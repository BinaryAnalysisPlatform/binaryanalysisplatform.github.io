<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Graphlib.Std.Solution.html">
<link rel="Up" href="Graphlib.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Graphlib.Std.Graphlib</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Graphlib.Std.Solution.html" title="Graphlib.Std.Solution">Previous</a>
&nbsp;<a class="up" href="Graphlib.Std.html" title="Graphlib.Std">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Graphlib.Std.Graphlib.html">Graphlib.Std.Graphlib</a></h1>

<pre><span class="keyword">module</span> Graphlib: <code class="code"><span class="keyword">sig</span></code> <a href="Graphlib.Std.Graphlib.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Generic Graph Library<br>
</div>
<hr width="100%">

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.Make.html">Make</a> <code class="code">(</code><code class="code"><span class="constructor">Node</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Regular.Std.Opaque.S.html">Std.Opaque.S</a></code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">Edge</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type">Std.T</code><code class="code">)&nbsp;</code>: <code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="type"> 
      with type node = Node.t
       and type Node.label = Node.t
       and type Edge.label = Edge.t</code></pre><div class="info">
<code class="code"><span class="constructor">Make</span>(<span class="constructor">Node</span>)(<span class="constructor">Edge</span>)</code> creates a module that implements <code class="code"><span class="constructor">Graph</span></code>
        interface and has unlabeled nodes of type <code class="code"><span class="constructor">Node</span>.t</code> and edges
        labeled with <code class="code"><span class="constructor">Edge</span>.t</code>
</div>

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.Labeled.html">Labeled</a> <code class="code">(</code><code class="code"><span class="constructor">Node</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Regular.Std.Opaque.S.html">Std.Opaque.S</a></code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">NL</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type">Std.T</code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">EL</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type">Std.T</code><code class="code">)&nbsp;</code>: <code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="type"> 
      with type node = (Node.t, NL.t) labeled
       and type Node.label = (Node.t, NL.t) labeled
       and type Edge.label = EL.t</code></pre><div class="info">
<code class="code"><span class="constructor">Labeled</span>(<span class="constructor">Node</span>)(<span class="constructor">Node_label</span>)(<span class="constructor">Edge_label</span>)</code> creates a graph
        structure with both nodes and edges labeled with abitrary
        types.
</div>

<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">(module Graphlib.Std.Graph with type t = 'c and type Edge.label = 'b and type Node.label = 'a) -><br>       ?nodes:'a list -> ?edges:('a * 'a * 'b) list -> unit -> 'c</code></pre><div class="info ">
<code class="code">create&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~nodes&nbsp;~edges&nbsp;()</code> creates a graph using
        implementation provided by <code class="code"><span class="keyword">module</span>&nbsp;<span class="constructor">G</span></code>.
        Example:
        <pre class="codepre"><code class="code">          <span class="keyword">module</span> <span class="constructor">G</span> = <span class="constructor">Graphlib</span>.<span class="constructor">String</span>.<span class="constructor">Bool</span>;;
          <span class="keyword">let</span> g = <span class="constructor">Graphlib</span>.create (<span class="keyword">module</span> <span class="constructor">G</span>) ~edges:[
              <span class="string">"entry"</span>, <span class="string">"loop"</span>, <span class="keyword">true</span>;
              <span class="string">"loop"</span>, <span class="string">"exit"</span>, <span class="keyword">false</span>;
              <span class="string">"loop"</span>, <span class="string">"loop"</span>, <span class="keyword">true</span>] ()
        </code></pre><br>
</div>

<pre><span id="VALunion"><span class="keyword">val</span> union</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       'c -> 'c -> 'c</code></pre><div class="info ">
<code class="code">union&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;g1&nbsp;g2</code> returns a graph <code class="code">g</code> that is a union
        of graphs <code class="code">g1</code> and <code class="code">g2</code>, i.e., contains all nodes and edges
        from this graphs.
<p>

        Postcondition: <pre class="verbatim">          - N(g) = N(g1) ∪ N(g2).
          - E(g) = E(g1) ∪ E(g2).
       </pre><br>
</div>

<pre><span id="VALinter"><span class="keyword">val</span> inter</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       'c -> 'c -> 'c</code></pre><div class="info ">
<code class="code">inter&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;g1&nbsp;g2</code> returns a graph <code class="code">g</code> that is an
        intersection of graphs <code class="code">g1</code> and <code class="code">g2</code>, i.e., it contain
        and edges from this graphs.
<p>

        Postcondition: <pre class="verbatim">          - N(g) = N(g1) ∩ N(g2).
          - E(g) = E(g1) ∩ E(g2).
       </pre><br>
</div>

<pre><span id="VALto_dot"><span class="keyword">val</span> to_dot</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?graph_attrs:('c -> <a href="Graphlib.Std.html#TYPEgraph_attr">Std.graph_attr</a> list) -><br>       ?node_attrs:('n -> <a href="Graphlib.Std.html#TYPEnode_attr">Std.node_attr</a> list) -><br>       ?edge_attrs:('e -> <a href="Graphlib.Std.html#TYPEedge_attr">Std.edge_attr</a> list) -><br>       ?string_of_node:('n -> string) -><br>       ?string_of_edge:('e -> string) -><br>       ?channel:Std.Out_channel.t -><br>       ?formatter:Format.formatter -> ?filename:string -> 'c -> unit</code></pre><div class="info ">
<code class="code">to_dot&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~filename:<span class="string">"graph.dot"</span>&nbsp;g</code> dumps graph <code class="code">g</code>
        using <code class="code">dot</code> format. This is a customizable version of printing
        function. For most cases it will be enough to use <code class="code"><span class="constructor">G</span>.pp</code> or
        <code class="code"><span class="constructor">G</span>.to_string</code> function. Use this function, if you really need
        to customize your output.<br>
</div>
<div class="param_info"><code class="code">graph_attrs</code> : a list of global graph attributes;</div>
<div class="param_info"><code class="code">node_attrs</code> : a list of node specific attributes;</div>
<div class="param_info"><code class="code">edge_attrs</code> : a list of edge specific attributes;</div>
<div class="param_info"><code class="code">string_of_node</code> : used to print nodes;</div>
<div class="param_info"><code class="code">string_of_edge</code> : used to print edges;</div>
<div class="param_info"><code class="code">channel</code> : where to output the graph;</div>
<div class="param_info"><code class="code">formatter</code> : where to output the graph;</div>
<div class="param_info"><code class="code">filename</code> : where to output the graph;
<p>

        Note: if no output parameter is provided, the graph will not be
        outputted. More than one output targets is OK. For example,
        <code class="code">to_dot&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~filename:<span class="string">"graph.dot"</span>&nbsp;~channel:stdout&nbsp;g</code> will
        output graph <code class="code">g</code> into both file named <code class="code"><span class="string">"graph.dot"</span></code> and
        standard output.
<p>

        Note: if <code class="code">string_of_node</code> function is not provided, then graph
        nodes will be labeled with the reverse post order number.</div>

<pre><span id="VALdepth_first_search"><span class="keyword">val</span> depth_first_search</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -><br>       ?start:'n -><br>       ?start_tree:('n -> 's -> 's) -><br>       ?enter_node:(int -> 'n -> 's -> 's) -><br>       ?leave_node:(int -> 'n -> 's -> 's) -><br>       ?enter_edge:(<a href="Graphlib.Std.html#TYPEedge_kind">Std.edge_kind</a> -> 'e -> 's -> 's) -><br>       ?leave_edge:(<a href="Graphlib.Std.html#TYPEedge_kind">Std.edge_kind</a> -> 'e -> 's -> 's) -> 'c -> init:'s -> 's</code></pre><div class="info ">
<code class="code">depth_first_search&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~init&nbsp;g</code>.  It is the most
        important algorithm of the Graphlib. It builds a forest of
        spanning trees of a graph, classifies graph edges and numbers
        nodes. It is a Swiss-army knife, that is very useful in
        implementing many other algorithms. You can think of this
        function as <code class="code">fold</code> on steroids. But unlike <code class="code">fold</code>, that
        accepts only one function, the <code class="code">depth_first_search</code> accepts 5
        different functions, that will be called on different
        situations, allowing you to «fill in the blanks» of your
        algorithm.
<p>

        Although <code class="code">depth_first_search</code> doesn't allow you to drive the
        walk itself, there're still ways to do this, using <a href="Graphlib.Std.Graphlib.html#VALfiltered"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Graphlib</span>.filtered</code></a>
        function. That allows you to hide nodes or edges from the
        walker, thus effectively erasing them from a graph, without
        even touching it.<br>
</div>
<div class="param_info"><code class="code">rev</code> : if true, then the graph <code class="code">g</code> is traversed in a
        reverse direction. This is essentially the same, as reversing
        the graph, but make sure, that you've adjusted the start
        node.</div>
<div class="param_info"><code class="code">start</code> : if specified, then the traverse will be started
        from the node that is equal to node <code class="code">start</code>. Otherwise the
        traverse is started from the first node of a graph as returned
        by <code class="code"><span class="constructor">G</span>.nodes</code>, i.e., usually it is an arbitrary node.</div>
<div class="param_info"><code class="code">start_tree</code> : <code class="code">node</code> <code class="code">state</code> is called on each new spanning
        tree started by the algorithm. If all nodes are reachable from
        the start node, then this function will be called only
        once. If all nodes of a graph are connected, then this
        function, will be called only once.</div>
<div class="param_info"><code class="code">enter_node</code> : <code class="code">pre</code> <code class="code">node</code> <code class="code">state</code> is called when a node
        is first discovered by the traversal. The number is a preorder
        number, also known as depth-first number or <code class="code">dfnum</code>. All nodes
        are entered in a pre-order.</div>
<div class="param_info"><code class="code">leave_node</code> : <code class="code">rpost</code> <code class="code">node</code> <code class="code">state</code> is called when all
        successors of a <code class="code">node</code> are left (finished). The provided
        number is a reverse post order number, that also defines a
        topological sorting order of a graph. All nodes, are left in
        a post order.</div>
<div class="param_info"><code class="code">enter_edge</code> : <code class="code">kind</code> <code class="code">edge</code> <code class="code">state</code> is called when and
        <code class="code">edge</code> is first discovered. Edge kinds are described below.
        The destination of the edge may not be discovered (i.e.,
        entered) yet. But the source is already entered (but not
        finished).</div>
<div class="param_info"><code class="code">leave_edge</code> : <code class="code">kind</code> <code class="code">edge</code> <code class="code">state</code> is called when the
        edge destination is at least started.
<p>

        <h2 id="2_Edgesclassification">Edges classification</h2>
<p>

        An edge in a spanning tree, produced by a depth first walk,
        can belong to one of the following category (kind):<ul>
<li>Tree edges constitutes a spanning tree <code class="code"><span class="constructor">T</span></code> of a graph;</li>
<li>Forward edges go from an ancestor to a descendants in
          a tree <code class="code"><span class="constructor">T</span></code>;</li>
<li>Back edges go from descendants to ancestors in <code class="code"><span class="constructor">T</span></code>,
          including node itself (they are also known as cycle
          edges).</li>
<li>Cross edges - all other edges, i.e., such edges for
          which doesn't go from ancestors to descendants or vice
          verse. They are possible since, tree defines only partial
          ordering.</li>
</ul>

        With respect to a pre-order and reverse post-ordering
        numbering the source <code class="code">x</code> and a destination <code class="code">y</code> of an edge with
        a given <code class="code">kind</code> satisfy to the following inequalities:
<p>

        <pre class="verbatim">            +---------+-----------------+---------------------+
            | Tree    | pre[x] &lt; pre[y] | rpost[x] &lt; rpost[y] |
            | Forward | pre[x] &lt; pre[y] | rpost[x] &lt; rpost[y] |
            | Back    | pre[x] ≥ pre[y] | rpost[x] ≥ rpost[y] |
            | Cross   | pre[x] &gt; pre[y] | rpost[x] &lt; rpost[y] |
            +---------+-----------------+---------------------+
         </pre>
<p>

        Note: since there can be more than one valid order of
        traversal of the same graph, (and thus more than one valid
        spanning tree), depending on a traversal the same edges can be
        classified differently. With the only exception, that a back
        edge will be always a back edge, disregarding the particular
        order.
<p>

        <h3 id="3_Complexity">Complexity</h3>
<p>

        The algorithm is linear in time. It uses constant stack
        space. In fact, for small graphs it uses stack, but for large
        graphs dynamically switches to a heap storage. The space
        complexity is bounded by linear function of the graph depth.</div>

<pre><span id="VALdepth_first_visit"><span class="keyword">val</span> depth_first_visit</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -><br>       ?start:'n -> 'c -> init:'s -> ('n, 'e, 's) <a href="Graphlib.Std.dfs_visitor-c.html">Std.dfs_visitor</a> -> 's</code></pre><div class="info ">
<code class="code">depth_first_visit&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~init&nbsp;visitor&nbsp;g</code> allows to
        specify visiting functions using object. That opens space for
        re-usability and using open recursion.<br>
</div>

<pre><span name="TYPEdfs_identity_visitor"><span class="keyword">class</span> <code class="type">[['n, 'e, 's]]</code> <a href="Graphlib.Std.Graphlib.dfs_identity_visitor-c.html">dfs_identity_visitor</a></span> : <code class="type"></code><code class="type">[['n, 'e, 's]]</code> <code class="type"><a href="Graphlib.Std.dfs_visitor-c.html">Std.dfs_visitor</a></code></pre><div class="info">
base class with all methods defaults to nothing.
</div>

<pre><span id="VALreverse_postorder_traverse"><span class="keyword">val</span> reverse_postorder_traverse</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -> ?start:'n -> 'c -> 'n <a href="Regular.Std.html#TYPEseq">Std.seq</a></code></pre><div class="info ">
returns a sequence of nodes in reverse post order.<br>
</div>

<pre><span id="VALpostorder_traverse"><span class="keyword">val</span> postorder_traverse</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -> ?start:'n -> 'c -> 'n <a href="Regular.Std.html#TYPEseq">Std.seq</a></code></pre><div class="info ">
returns a sequence of nodes in post order<br>
</div>

<pre><span id="VALdominators"><span class="keyword">val</span> dominators</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -> 'c -> 'n -> 'n <a href="Graphlib.Std.html#TYPEtree">Std.tree</a></code></pre><div class="info ">
<code class="code">dominators&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;g&nbsp;entry</code> builds a dominators tree for
        a given graph.
<p>

        Definition: a <b>walk</b> is a sequence of alternating nodes and
        edges, where each edge's endpoints are the preceding and
        following nodes in the sequence.
<p>

        Definition: a node <code class="code">v</code> is <b>reachable</b> if there exists a walk
        starting from <code class="code">entry</code> and ending with <code class="code">v</code>.
<p>

        Definition: node <code class="code">u</code> <b>dominates</b> <code class="code">v</code> if <code class="code">u&nbsp;=&nbsp;v</code> or if all walks
        from <code class="code">entry</code> to <code class="code">v</code> contains <code class="code">u</code>.
<p>

        Definition: node <code class="code">u</code> <b>strictly dominates</b> <code class="code">v</code> if it dominates
        <code class="code">v</code> and <code class="code">u&nbsp;&lt;&gt;&nbsp;v</code>.
<p>

        Definition: node <code class="code">u</code> <b>immediately dominates</b> <code class="code">v</code> if it
        strictly dominates <code class="code">v</code> and there is no other node that
        strictly dominates <code class="code">v</code> and is dominated by <code class="code">u</code>.
<p>

        Algorithm computes a dominator tree <code class="code">t</code> that has the following
        properties:<OL>
<li>Sets of graph nodes and tree nodes are equal;</li>
<li>if node <code class="code">u</code> is a parent of node <code class="code">v</code>, then node <code class="code">u</code>
           immediately dominates node <code class="code">v</code>;</li>
<li>if node <code class="code">u</code> is an ancestors of node <code class="code">v</code>, then node <code class="code">u</code>
           strictly dominates node <code class="code">v</code>;</li>
<li>if node <code class="code">v</code> is a child of node <code class="code">u</code>, then node <code class="code">u</code>
           immediately dominates node <code class="code">v</code>;</li>
<li>if node <code class="code">v</code> is a descendant of node <code class="code">u</code>, then node <code class="code">u</code>
           strictly dominates node <code class="code">v</code>.</li>
</OL>

        If every node of graph <code class="code">g</code> is reachable from a provided
        <code class="code">entry</code> node, then properties (2) - (5) are reversible, i.e.,
        an <code class="code"><span class="keyword">if</span></code> statement can be read as <code class="code">iff</code>, and the tree is
        unique.
<p>

        <b>Lemma</b>: Everything dominates unreachable block.
<p>

        <b>Proof</b>: (by contradiction) suppose there exists a node <code class="code">u</code> that
        doesn't dominate unreachable block <code class="code">v</code>. That means, that there
        exists a path from <code class="code">entry</code> to <code class="code">v</code> that doesn't contain
        <code class="code">u</code>. But that means, at least, that <code class="code">v</code> is reachable. This  is
        a contradiction with the original statement that <code class="code">v</code> is
        unreachable. <b>Qed.</b>
<p>

        If some nodes of graph <code class="code">g</code> are unreachable from the provided
        <code class="code">entry</code> node, then they are dominated by all other nodes of a
        graph. It means that the provided system is under constrained
        and has more then one solution (i.e., there exists more than
        one tree, that satisfies properties (1) - (5). In a current
        implementation each unreachable node is immediately dominated
        by the <code class="code">entry</code>, if the <code class="code">entry</code> is in graph.
<p>

        To get a post-dominator tree, reverse the graph by passing
        <code class="code"><span class="keyword">true</span></code> to <code class="code">rev</code> and pass exit node as a starting node.
<p>

        Note: although it is not imposed by the algotihm, but it is a
        good idea to have an entry node, that doesn't have any
        predecessors. Usually, this is what is silently assumed in
        many program analysis textbooks, but is not true in general
        for control-flow graphs that are reconstructed from binaries<br>
</div>

<pre><span id="VALdom_frontier"><span class="keyword">val</span> dom_frontier</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -> 'c -> 'n <a href="Graphlib.Std.html#TYPEtree">Std.tree</a> -> 'n <a href="Graphlib.Std.html#TYPEfrontier">Std.frontier</a></code></pre><div class="info ">
<code class="code">dom_frontier&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;g&nbsp;dom_tree</code> calculates dominance
        frontiers for all nodes in a graph <code class="code">g</code>.
<p>

        The dominance frontier of a node <code class="code">d</code> is the set of all nodes <code class="code">n</code>
        such that <code class="code">d</code> dominates an immediate predecessor of <code class="code">n</code>, but <code class="code">d</code> does
        not strictly dominate <code class="code">n</code>. It is the set of nodes where <code class="code">d</code>'s
        dominance stops.<br>
</div>

<pre><span id="VALstrong_components"><span class="keyword">val</span> strong_components</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       'c -> 'n <a href="Graphlib.Std.html#TYPEpartition">Std.partition</a></code></pre><div class="info ">
<code class="code">strong_components&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;g</code> partition graph into strongly
        connected components. The top of each component is a root
        node, i.e., a node that has the least pre-order number.<br>
</div>

<pre><span id="VALshortest_path"><span class="keyword">val</span> shortest_path</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?weight:('e -> int) -><br>       ?rev:bool -> 'c -> 'n -> 'n -> 'e <a href="Graphlib.Std.html#TYPEpath">Std.path</a> option</code></pre><div class="info ">
<code class="code">shortest_path&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;?weight&nbsp;?rev&nbsp;g&nbsp;u&nbsp;v</code>
        Find a shortest path from node <code class="code">u</code> to node <code class="code">v</code>.<br>
</div>
<div class="param_info"><code class="code">weight</code> : defines a weight of each edge. It defaults to 1.</div>
<div class="param_info"><code class="code">rev</code> : allows to reverse graph.</div>

<pre><span id="VALis_reachable"><span class="keyword">val</span> is_reachable</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -> 'c -> 'n -> 'n -> bool</code></pre><div class="info ">
<code class="code">is_reachable&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;?rev&nbsp;g&nbsp;u&nbsp;v</code> is true if node <code class="code">v</code> is
        reachable from node <code class="code">u</code> in graph <code class="code">g</code>. If rev is true, then it
        will solve the same problem but on a reversed graph.<br>
</div>

<pre><span id="VALfold_reachable"><span class="keyword">val</span> fold_reachable</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?rev:bool -> init:'a -> f:('a -> 'n -> 'a) -> 'c -> 'n -> 'a</code></pre><div class="info ">
<code class="code">fold_reachable&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;?rev&nbsp;~init&nbsp;~f&nbsp;g&nbsp;n</code> applies function
        <code class="code">f</code> to all nodes reachable from node <code class="code">g</code> in graph <code class="code">g</code>. If
        <code class="code">rev</code> is true, then the graph is reversed.
<p>

        For example, the following will build a set of reachable nodes:
        <code class="code">fold_reachable&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~init:<span class="constructor">G</span>.<span class="constructor">Node</span>.<span class="constructor">Set</span>.empty&nbsp;~f:<span class="constructor">Set</span>.add</code><br>
</div>

<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type">(module Graphlib.Std.Graph with type node = 'n and type t = 'a) -><br>       (module Graphlib.Std.Graph with type node = 'n and type t = 'b) -><br>       'a -> 'b -> int</code></pre><div class="info ">
<code class="code">compare&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G1</span>)&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G2</span>)&nbsp;g1&nbsp;g2</code> compares two graphs,
        with different implementation but the same node type.<br>
</div>

<pre><span id="VALfiltered"><span class="keyword">val</span> filtered</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c) -><br>       ?skip_node:('n -> bool) -><br>       ?skip_edge:('e -> bool) -><br>       unit -><br>       (module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c)</code></pre><div class="info ">
<code class="code"><span class="keyword">let</span>&nbsp;<span class="keyword">module</span>&nbsp;<span class="constructor">G'</span>&nbsp;=&nbsp;filtered&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;?skip_node&nbsp;?skip_edge&nbsp;()</code>
        creates a new module <code class="code"><span class="constructor">G'</span></code> that can be used at any place
        instead of <code class="code"><span class="constructor">G</span></code>, but that will hide nodes and edges, for which
        functions <code class="code">skip_node</code> and <code class="code">skip_edge</code> return true.
<p>

        Example:
        <pre class="codepre"><code class="code">          <span class="keyword">let</span> killed_edges = <span class="constructor">G</span>.<span class="constructor">Edge</span>.<span class="constructor">Hash_set</span>.create () <span class="keyword">in</span>
          <span class="keyword">let</span> <span class="keyword">module</span> <span class="constructor">G</span> = <span class="constructor">Graphlib</span>.filtered (<span class="keyword">module</span> <span class="constructor">G</span>)
              ~skip_edge:(<span class="constructor">Hash_set</span>.mem killed_edges) () <span class="keyword">in</span>
          <span class="keyword">let</span> <span class="keyword">rec</span> loop g () =
            <span class="comment">(* use (module G) as normal *)</span>
            <span class="constructor">Hash_set</span>.add killed_edges some_edge;
            <span class="comment">(* all edges added to [killed_edges] will no be visible *)</span>
        </code></pre><br>
</div>

<pre><span id="VALview"><span class="keyword">val</span> view</span> : <code class="type">(module Graphlib.Std.Graph with type edge = 'e and type node = 'n and type t = 'c and type Edge.label = 'b and type Node.label = 'a) -><br>       node:('n -> 'f) * ('f -> 'n) -><br>       edge:('e -> 'd) * ('d -> 'e) -><br>       node_label:('a -> 'p) * ('p -> 'a) -><br>       edge_label:('b -> 'r) * ('r -> 'b) -><br>       (module Graphlib.Std.Graph with type edge = 'd and type node = 'f and type t = 'c and type Edge.label = 'r and type Node.label = 'p)</code></pre><div class="info ">
<code class="code">view&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~node&nbsp;~edge&nbsp;~node_label&nbsp;~edge_label</code>
        creates a proxy module, that will transform back and
        forward elements of graph, using corresponding functions.<br>
</div>

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.To_ocamlgraph.html">To_ocamlgraph</a> <code class="code">(</code><code class="code"><span class="constructor">G</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="code">)&nbsp;</code>: <code class="type">Graph.Sig.P</code><code class="type">  with type t = G.t
                   and type V.t = G.node
                   and type E.t = G.edge
                   and type V.label = G.Node.label
                   and type E.label = G.Edge.label</code></pre><div class="info">
<code class="code"><span class="constructor">To_ocamlgraph</span>(<span class="constructor">G</span>)</code> returns a module that implements
        OCamlGraph interface for a persistent graph.
</div>

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.Of_ocamlgraph.html">Of_ocamlgraph</a> <code class="code">(</code><code class="code"><span class="constructor">G</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type">Graph.Sig.P</code><code class="code">)&nbsp;</code>: <code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="type">  with type t = G.t
             and type node = G.V.t
             and type edge = G.E.t
             and type Node.label = G.V.label
             and type Edge.label = G.E.label</code></pre><div class="info">
<code class="code"><span class="constructor">Of_ocamlgraph</span>(<span class="constructor">O</span>)</code> creates an adapter module, that implements
        <code class="code"><span class="constructor">Graphlib</span></code> interface on top of the module implementing
        <code class="code"><span class="constructor">OCamlGraph</span></code> interface.
</div>

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.Filtered.html">Filtered</a> <code class="code">(</code><code class="code"><span class="constructor">G</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">P</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Predicate.html">Std.Predicate</a></code><code class="type">  with type node = G.node
                        and type edge = G.edge</code><code class="code">)&nbsp;</code>: <code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="type">  with type t = G.t
             and type node = G.node
             and type edge = G.edge
             and module Node = G.Node
             and module Edge = G.Edge</code></pre><div class="info">
functorized version of a <code class="code">filter</code> function.
</div>

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.Mapper.html">Mapper</a> <code class="code">(</code><code class="code"><span class="constructor">G</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">N</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Isomorphism.html">Std.Isomorphism</a></code><code class="type">  with type s = G.node</code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">E</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Isomorphism.html">Std.Isomorphism</a></code><code class="type">  with type s = G.edge</code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">NL</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Isomorphism.html">Std.Isomorphism</a></code><code class="type">  with type s = G.Node.label</code><code class="code">)&nbsp;</code> <code class="code">(</code><code class="code"><span class="constructor">EL</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Graphlib.Std.Isomorphism.html">Std.Isomorphism</a></code><code class="type">  with type s = G.Edge.label</code><code class="code">)&nbsp;</code>: <code class="type"><a href="Graphlib.Std.Graph.html">Std.Graph</a></code><code class="type">  with type t = G.t
             and type node = N.t
             and type edge = E.t
             and type Node.label = NL.t
             and type Edge.label = EL.t</code></pre><div class="info">
functorized version of <a href="Graphlib.Std.Graphlib.html#VALview"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Graphlib</span>.view</code></a> function.
</div>

<pre><span id="VALfixpoint"><span class="keyword">val</span> fixpoint</span> : <code class="type">(module Graphlib.Std.Graph with type node = 'n and type t = 'c) -><br>       ?steps:int -><br>       ?start:'n -><br>       ?rev:bool -><br>       ?step:(int -> 'n -> 'd -> 'd -> 'd) -><br>       init:('n, 'd) <a href="Graphlib.Std.Solution.html#TYPEt">Std.Solution.t</a> -><br>       equal:('d -> 'd -> bool) -><br>       merge:('d -> 'd -> 'd) -><br>       f:('n -> 'd -> 'd) -> 'c -> ('n, 'd) <a href="Graphlib.Std.Solution.html#TYPEt">Std.Solution.t</a></code></pre><div class="info ">
<code class="code">fixpoint&nbsp;~equal&nbsp;~init&nbsp;~merge&nbsp;~f&nbsp;g</code> computes a solution for a
        system of equations denoted by graph <code class="code">g</code>, using the inital
        approximation <code class="code">init</code> (obtained either with <code class="code"><span class="constructor">Solution</span>.create</code> or
        from the previous calls to <code class="code">fixpoint</code>).
<p>

        The general representation of the fixpoint equations is
<p>

        <pre class="verbatim">          x(i) = f(i) (a(i,1) x(1) %  ... % a(i,j) x(j)),
       </pre>
<p>

        where<ul>
<li><code class="code">x(i)</code> is the value of the <code class="code">i</code>'th variable (node);</li>
<li><code class="code">a(i,j)</code> is <code class="code">1</code> if there is an edge from the node
          <code class="code">i</code> to the node <code class="code">j</code> and <code class="code">0</code> otherwise;</li>
<li><code class="code">%</code> the merge operator;</li>
<li><code class="code">f(i)</code> is the transfer function for the node <code class="code">i</code>;</li>
<li><code class="code">=</code> is the equivalence operation.</li>
</ul>

        A solution is obtained through a series of iterations until
        the fixpoint is reached, i.e., until the system
        stabilizes. The total number of iterations could be bound by
        an arbitrary number. If the maximum number of iterations is
        reached before the system stabilizes then the solution is not
        complete. An incomplete solution could be resumed later, or
        used as it is (for example, in case of ascending chain the
        solution is always a lower approximation of a real solution,
        so it is always safe to use it).<br>
</div>
<div class="param_info"><code class="code">start</code> : the entry node of the graph</div>
<div class="param_info"><code class="code">rev</code> : if <code class="code"><span class="keyword">true</span></code> then graph is visited in the reverse order,
        defaults to <code class="code"><span class="keyword">false</span></code>.</div>
<div class="param_info"><code class="code">step</code> : a function that is called every time a new value
        of a variable is obtained (an extension point for
        narrowing/widening).</div>
<div class="param_info"><code class="code">init</code> : initial approximation</div>
<div class="param_info"><code class="code">equal</code> : compares two approximations for equivalence</div>
<div class="param_info"><code class="code">merge</code> : the operator for path merging
        (usually meet/join depending on a starting point).</div>
<div class="param_info"><code class="code">f</code> : the transfer function
<p>

        <h3 id="3_DataFlowAnalysisandAbstractInterpretation">Data Flow Analysis and Abstract Interpretation</h3>
<p>

        The <code class="code">fixpoint</code> function implements a general fixed pointed
        iterative solver, that is suitable for implementing data-flow
        analysis or abstract interpreters. This section will provide
        some insight on how a particular choice of parameters affects
        the result of computation. We will start with a small
        introduction to the theory of Data Flow Analysis and Abstract
        Interpretation, with respect to the solution of a system of
        fixed point equations.
<p>

        <h4 id="4_Introduction">Introduction</h4>
<p>

        The data domain is a set of values equiped with a partial
        ordering operation <code class="code">(<span class="constructor">L</span>,&lt;=)</code>, also know as a lattice or a
        poset. We assume, that the lattice is complete, i.e., there
        are two special elements of a set that are called <code class="code">top</code> and
        <code class="code">bot</code> (the bottom value). The top element is the greatest
        element of the set L, i.e., for all <code class="code">x</code> in <code class="code"><span class="constructor">L</span></code>, <code class="code">x&nbsp;&lt;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top</code>. Correspondingly, the bottom element is the least element
        of the set <code class="code"><span class="constructor">L</span></code>, i.e., for all <code class="code">x</code> in <code class="code"><span class="constructor">L</span></code>, <code class="code">bot&nbsp;&lt;=&nbsp;x</code>. It is not
        required by the framework that the lattice has both or any of
        them, however their presence makes the explanation easier, and
        since any lattice could be artificially extended with these
        two elements, their introduction will not introduce a loss of
        generality. Since values of the lattice <code class="code"><span class="constructor">L</span></code> represent
        information, the partial ordering between two pieces of
        information <code class="code">a</code> and <code class="code">b</code>, e.g., <code class="code">a&nbsp;&lt;=&nbsp;b</code>, tells us that <code class="code">a</code>
        contains no more information than <code class="code">b</code>. Therefore the <code class="code">top</code>
        value contans all the information, representable in the
        lattice, correspondingly the <code class="code">bot</code> value represents an absence
        of information. Thus, we will consider the bottom value as an
        over approximation (or a lower approximation in terms of the
        lattice ordering relation), as an absence of information
        cannot contain false statements (vacuous truth). Assuming,
        that there is some value <code class="code">t</code>, <code class="code">bot&nbsp;&lt;=&nbsp;t&nbsp;&lt;=&nbsp;top</code> that represents
        a ground truth (that is usually unobtainable), we say that all
        values that are less than or equal <code class="code">t</code> are over-approximations
        of the truth, and the rest of the values, are
        under-approximations. Under-approximations under estimate a
        behavior of a system, and usually represent information about
        a system that is not true, hence an under approximate solution,
        is usually unsafe to use. In general, our task is to find an
        over approximation that is as close as possible to the ground
        truth <code class="code">t</code>.
<p>

        A solution to a fixed point equation (i.e., an equation of the
        form <code class="code">x&nbsp;=&nbsp;f(x)</code>) could be obtainted by starting from some
        initial approximation <code class="code">x0</code> and repeatedly applying <code class="code">f</code> to it,
        until the solution is found, i.e., <code class="code">x&nbsp;=&nbsp;f(...&nbsp;f(f(x0))&nbsp;...)</code>.
        In general, a function may have multiple (or no at all) fixed
        points. If a function has several fixed points, then we can
        distinguish two extremums - the least fixed point <code class="code">lfp</code> and
        the greatest fixed point <code class="code">gfp</code> w.r.t the ordering of lattice
        <code class="code"><span class="constructor">L</span></code>. Assuming that function <code class="code">f</code> is positive monotonic function
        (i.e., <code class="code">x&nbsp;&lt;=&nbsp;y</code> implies that <code class="code">f(x)&nbsp;&lt;=&nbsp;f(y)</code>), thechoice of the
        initial value <code class="code">x0</code> denotes which of the two fixed points is
        computed. When we start with the bot value, we are ascending
        from it until the least fixed point is obtained. Dually, if we
        will start with the top value, we will descend until the
        maximal fixpoint is reached. Assuming that both fixpoints are
        lower approximations of the ground truth, we can easily see,
        that the maximal fixpoint solution is more attractive, as it
        bears more information than the minimal (unless both are the
        same). However, the ascending search, bears a nice property,
        that any intermediate solution is an over-approximation of the
        ground truth (i.e., we are monotonically aggregating facts).
<p>

        In general, a function may not have a solution at all, or the
        solution may not be computable in practice, i.e., when the chain
        of function applications <code class="code">x&nbsp;=&nbsp;f(...&nbsp;f(x0)&nbsp;...)</code> is either
        infinite or effectively infinite (e.g., 2^64 applications). The
        Tarksi theorem states that if <code class="code"><span class="constructor">L</span></code> is complete and <code class="code">f</code> is
        monotone, then it has a fixed point. If a lattice has a
        limited height (maximum length of chain of elements, such that
        x0 &lt; x1 &lt; .. &lt; xM) then we will obtain a solution in no more
        than <code class="code"><span class="constructor">M</span></code> steps. However, if <code class="code"><span class="constructor">M</span></code> is very big, or infinite, then
        the solution won't be find in general, and the computation may
        not terminate.
<p>

        This brings us to the main distinction between Abstract
        Interpretation and Data Flow Analysis. The latter usually
        deals with lattice that have finite heights, while the former
        deals with very big and infinite lattices. To accelerate the
        convergence of a chain of approximations, a special technique
        called <code class="code">widening</code> is used. Widening can be seen as an
        operation that jumps over several applications of the function
        <code class="code">f</code>, hence it actually accelerates the convergence. Given,
        that widening jumps forward in the chain, it is possible to
        overshoot the fixed point solution. This can potential involve
        a lossage of precision (in case of the descending chain) or to
        an incorrect solution (in case of the ascending chain).
<p>

        So far, we were considering only one equation. However, we
        need to solve a system of equations, denoted by a graph (as
        graph denotes a boolean adjacency matrix <code class="code"><span class="constructor">A</span>&nbsp;=&nbsp;{a(i,j)}</code>, such that
        <code class="code">a(i,j)</code> is <code class="code">1</code> if there is an edge from <code class="code">i</code> to <code class="code">j</code>, and <code class="code">0</code>
        otherwise). To solve the system of equations, we need to find
        such vector <code class="code">x1,..,xM</code> that solves all equations. In general,
        a system may not have a solution (an over-constrainted system),
        may have one solution, and may have many solutions (under
        constrained system). In our case, the system is not linear, as
        each equation is function of type <code class="code"><span class="constructor">L</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">L</span></code> not <code class="code"><span class="constructor">L</span>^<span class="constructor">M</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">N</span></code>, since
        all input variables are merged with some operator, usually
        <code class="code">meet</code> or <code class="code">join</code>. A correct choice of the merge opeator ensures
        correctness and convergence of the solution.
<p>

        The <code class="code">meet</code> operator is a commutative, associative, and
        idempotent operator, such that if <code class="code">z&nbsp;=&nbsp;meet&nbsp;x&nbsp;y</code>, then <code class="code">z&nbsp;&lt;=&nbsp;x<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;z&nbsp;&lt;=&nbsp;y</code> and for all <code class="code">w</code> in <code class="code"><span class="constructor">L</span></code>, <code class="code">w&nbsp;&lt;=&nbsp;x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;w&nbsp;&lt;=&nbsp;y</code> implies <code class="code">w&nbsp;&lt;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z</code>. The <code class="code">z</code> value is called the greatest lower bound (<code class="code">glb</code>, or
        <code class="code">inf</code>) of <code class="code">x</code> and <code class="code">y</code>. Intuitively, the <code class="code">meet</code> operator takes
        two pieces of information and removes all contradictions. Thus
        <code class="code">z</code> is the maximal consensus between <code class="code">x</code> and <code class="code">y</code>. The <code class="code">top</code>
        element is the neutral element with respect to the <code class="code">meet</code>
        operation, e.g., <code class="code">meet&nbsp;x&nbsp;top&nbsp;=&nbsp;x</code>. A consequent application of
        the <code class="code">meet</code> operation builds a <i>descending chain</i> of
        approximations, i.e., the amount of information is reduced on
        each step.
<p>

        The <code class="code">join</code> operator is dual to <code class="code">meet</code> and is defined
        correspondingly (with the flipped order). A join of <code class="code">x</code> and
        <code class="code">y</code> is called the least upper bound (<code class="code">lub</code>, <code class="code">sup</code>) of <code class="code">x</code> and
        <code class="code">y</code>. Intuitively, the <code class="code">join</code> operator takes two
        non-contradictory pieces information and returns their
        concatenation. The <code class="code">bot</code> element is the neutral element with
        respect to the <code class="code">join</code> operation, e.g., <code class="code">join&nbsp;x&nbsp;bot&nbsp;=&nbsp;x</code>. A
        consequent application of the <code class="code">join</code> operation builds an
        ascending chain of approximations, i.e., the amount of
        information is increased on each step.
<p>

        <h4 id="4_Usingthefixpointfunction">Using the <code class="code">fixpoint</code> function</h4>
<p>

        The <code class="code">fixpoint</code> interface is trying to be as general as
        possible, but at the same time easy to use. The interface,
        allows a user to choose the direction of approximation
        (ascending vs. descending) and how to accelerate the
        convergence in case of tall lattices by applying narrowing and
        widening. The implentation fixes the iteration strategy (by
        always using the topological ordering). In case if you need a
        fixed point solver, that allows you to use different iteration
        strategies, the <code class="code">fixpoint</code><code class="code">1</code> library provides a descent
        alternative.
<p>

        <code class="code">1</code>: http://pop-art.inrialpes.fr/people/bjeannet/bjeannet-forge/fixpoint/
<p>

        <h5 id="5_UsingfixpointforClassicalDataFlowanalysis">Using <code class="code">fixpoint</code> for Classical Data Flow analysis</h5>
<p>

        The classical Data Flow analysis uses the descending chain of
        approximations in a complete lattice with finite (usually very
        small) height. Thus, the <code class="code">fixpoint</code> solution is the greatest
        (maximal) fixed point (a maximal set of facts on which all
        equations agree). If the transfer function <code class="code">f</code> is monotone and
        distributive, then it is the meet-over-paths (mop) solution,
        in a more general case <code class="code">gfp&nbsp;&lt;=&nbsp;mop</code> and <code class="code">mop&nbsp;&lt;=&nbsp;t</code> (where <code class="code">t</code> is
        the ground truth). (Note, <code class="code">gfp</code> is of course the best solution
        to the system of equations, as it is the maximal of all
        solutions. Both <code class="code">mop</code> and <code class="code">t</code> are not solutions to the given
        system, but define the true properties of a system under test,
        that we are trying to model with the system of fixed point
        equations. The fact that <code class="code">gfp</code> is smaller, indicates that our
        model looses the precision (i.e., it is overconstrained). For
        example, the meet-over-path solution is a meet of all possible
        paths, even those that are infeasible, thus the system is
        overconstrained as we are taking into account system
        behaviors that will never happen, this is however safe, to
        overconstraint a system, as it will give us an
        over-approximation of a real system behavior).
<p>

        The <code class="code">fixpoint</code> function could be easily applied to both
        forward and backward data flow problem, as backward problem
        could be seen as a forward problem on a reversed graph. To
        effectively reverse a graph, set the <code class="code">rev</code> flag to <code class="code"><span class="keyword">true</span></code> and
        set the <code class="code">enter</code> parameter to the <code class="code">exit</code> node.
<p>

        <h5 id="5_UsingfixpointforAbstractInterpretation">Using <code class="code">fixpoint</code> for Abstract Interpretation</h5>
<p>

        Abstract Interpretation usually deals with complex and large
        lattices, and applies different heuristics to ensure
        termination with the minimum loss of precision. This usually
        ends up in applying widening and narrowing operations. Since
        widening accelerates by jumping forward in the chain of
        approximations, it can easily overshoot a fixed point, and in
        case of the ascending chain this may lead to a solution that
        is an under approximation of the ground truth. Thus, abstract
        interpretation is usually applied in the descending order. In
        this case the <code class="code">widen</code> operation may still overshot the maximal
        fixpoint, that will lead to an over-approximation of the
        ground truth, that is safe, but still looses
        precision. Therefore, it is necessary to apply widening as
        rarely as possible. Unfortunatelly, a question where and when
        to apply widening is undecidable by itself, that's why
        heuristics are used. The <code class="code">fixpoint</code> function, provides a
        limited capabilities to control widening via the <code class="code">step&nbsp;i&nbsp;n&nbsp;x<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x'</code> function that is called every time a new <code class="code">i</code>'th
        approximation <code class="code">x'</code> for variable <code class="code">n</code> is computed. The <code class="code">step</code>
        function must return an upper bound (not necessary the least
        one) of the previous approximation <code class="code">x</code> and the new
        approximation <code class="code">x'</code>. The default, implementation just returns
        <code class="code">x'</code>. An alternative implementation may widen <code class="code">x'</code> if the
        number of steps <code class="code">i</code> in the chain is higher than some
        threshold, and/or if <code class="code">x</code> is a widening point (e.g., the loop
        header).
<p>

        Note: terms widening and narrowing comes from the interval
        analysis where they were first introduced, and correspond to
        the widening of an interval (usually up to infinitiy) and
        narrowing a widened interval based on some heurisitic.
<p>

        <h6 id="6_Usingfixpointforgeneraliterativeapproximation">Using <code class="code">fixpoint</code> for general iterative approximation</h6>
<p>

        In a general case, the <code class="code">fixpoint</code> function could be used to
        compute successive approximations of a solution to a system of
        (in)equations, even if <code class="code">f</code> is not monotone, and the lattice is not
        finite. The termination could be guaranteed by limiting the
        maximum number of iterations. And the correctness could be
        ensured by starting from the bottom element, and using the
        ascending chain of approximations. In that case, even a
        partially complete solution would be an over-approximation of
        a real solution. The obtained partial solution could be later
        resumed (and possibly extended with newly obtained facts).
<p>

        <h4 id="4_Implementation">Implementation</h4>
<p>

        The <code class="code">fixpoint</code> uses the Kildall iterative algorithm. And
        applies equations in reverse postorder (topological
        order). The solution is represented as an abstract finite
        mapping, that is also used to specify the initial set of
        constraints and the initial value of unconstrained
        variables. It is possible to specify more than one constraint
        to the system of equation (as opposed to the classical
        approach where the constraint denotes only the input for the
        entry node).</div>

<pre><span id="TYPEscheme"><span class="keyword">type</span> <code class="type"></code>scheme</span> </pre>
<div class="info ">
name generation scheme<br>
</div>


<pre><span id="TYPEsymbolizer"><span class="keyword">type</span> <code class="type">'a</code> symbolizer</span> = <code class="type">'a -> string</code> </pre>
<div class="info ">
a function that gives a name for a value of type <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="VALcreate_scheme"><span class="keyword">val</span> create_scheme</span> : <code class="type">next:(string -> string) -> string -> <a href="Graphlib.Std.Graphlib.html#TYPEscheme">scheme</a></code></pre><div class="info ">
<code class="code">create_scheme&nbsp;~next&nbsp;init</code> create a name generator, that will
        start with <code class="code">init</code> and apply <code class="code">next</code> on it infinitly.<br>
</div>

<pre><span id="VALsymbols"><span class="keyword">val</span> symbols</span> : <code class="type"><a href="Graphlib.Std.Graphlib.html#TYPEscheme">scheme</a></code></pre><div class="info ">
lower case symbols, starting from 'a' and moving up to 'z'.
        As 'z' is reached, all foregoing symbols will have a form
        of 'node_N' where 'N' is an increasing natural number.<br>
</div>

<pre><span id="VALnumbers"><span class="keyword">val</span> numbers</span> : <code class="type"><a href="Graphlib.Std.Graphlib.html#TYPEscheme">scheme</a></code></pre><div class="info ">
numbers from zero to inifinity (<code class="code"><span class="constructor">Sys</span>.max_int</code> in fact)
<p>
empty string<br>
</div>

<pre><span class="keyword">module</span> <a href="Graphlib.Std.Graphlib.Dot.html">Dot</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Graphlib.Std.Graphlib.Dot.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Generic dot printer.
</div>
</body></html>