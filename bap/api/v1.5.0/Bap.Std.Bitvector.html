<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Size.html">
<link rel="next" href="Bap.Std.Word.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Constructors" rel="Section" href="#2_Constructors">
<link title="Some predefined constant constructors " rel="Section" href="#2_Somepredefinedconstantconstructors">
<link title="Helpful shortcuts " rel="Section" href="#2_Helpfulshortcuts">
<link title="Conversions to OCaml built in integer types " rel="Section" href="#2_ConversionstoOCamlbuiltinintegertypes">
<link title="Iteration over bitvector components " rel="Section" href="#2_Iterationoverbitvectorcomponents">
<link title="Comparison with zero" rel="Subsection" href="#3_Comparisonwithzero">
<title>BAR: BAP Annotated Reference : Bap.Std.Bitvector</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Size.html" title="Bap.Std.Size">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Word.html" title="Bap.Std.Word">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Bitvector.html">Bap.Std.Bitvector</a></h1>

<pre><span class="keyword">module</span> Bitvector: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Bitvector -- an integer with modular arithmentics.
<p>

      <h2 id="2_Overview">Overview </h2>
<p>

      A numeric value with the 2-complement binary representation. It
      is good for representing addresses, offsets and other arithmetic
      values.
<p>

      Each value is attributed by a bitwidth and signedness. All
      arithmetic operations over values are done modulo their
      widths. It is an error to apply arithmetic operation to values
      with different widths. Default implementations will raise a an
      exception, however there exists a family of modules that provide
      arithmetic operations lifted to an <code class="code"><span class="constructor">Or_error</span>.t</code> monad. It is
      suggested to use them, if you know what kind of operands you're
      expecting.
<p>

      <h2 id="2_Clarificationonsizemorphism">Clarification on size-morphism </h2>
<p>

      Size-monomorphic operations (as opposed to size-polymorphic
      comparison) doesn't allow to compare two operands with different
      sizes, and either raise an exception or return <code class="code"><span class="constructor">Error</span></code>. If we would
      have a type safe interface, with type <code class="code">t</code> defined as <code class="code"><span class="keyword">type</span>&nbsp;<span class="keywordsign">'</span>a&nbsp;t</code>,
      where <code class="code"><span class="keywordsign">'</span>a</code> stands for size, then size-monomorphic operations will
      have type <code class="code"><span class="keywordsign">'</span>a&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keywordsign">'</span>a&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;_</code>, and size-polymorphic <code class="code"><span class="keywordsign">'</span>a&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keywordsign">'</span>b&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;_</code>.
<p>

      By default, size-polymorphic comparison is used. To understand
      the ordering relation one can think that a lexical ordering is
      specified on a tuple <code class="code">(x,n)</code>, where <code class="code">x</code> is the number and <code class="code">n</code> is
      the size. For example, the following sequence is in an ascending
      order:
<p>

      <pre class="codepre"><code class="code"> 0x0:1, 0x0:32, 0x0:64, 0x1:1, 0x1:32, 0xD:4, 0xDEADBEEF:32</code></pre>.
<p>

      A size-monomorphic interfaced is exposed in a <code class="code"><span class="constructor">Mono</span></code> submodule. So
      if you want a monomorphic map, then just use <code class="code"><span class="constructor">Mono</span>.<span class="constructor">Map</span></code> module.
      Note, <code class="code"><span class="constructor">Mono</span></code> submodule doesn't provide <code class="code"><span class="constructor">Table</span></code>, since we cannot
      guarantee that all keys in a hash-table have equal size.
<p>

      <h2 id="2_Clarificationonsigns">Clarification on signs</h2>
<p>

      By default all numbers represented by a bitvector are considered
      unsigned. This includes comparisons, e.g., <code class="code">of_int&nbsp;(-1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~width:32</code> is greater than zero. If you need to perform a signed
      operation, you can use the <code class="code">signed</code> operator to temporary cast
      your value to the signed kind.  We use word "temporary" to
      emphasize that, the signedness property won't propagate to the
      result of the operation, e.g. result of the following
      expression: <code class="code"><span class="constructor">Int_exn</span>.(signed&nbsp;x&nbsp;/&nbsp;y)</code> will not be signed. In other
      words each new value is created unsigned.
<p>

      If any operand of a binary operation is signed, then a signed
      version of an operation is used, i.e., the other operand is
      upcasted to the signed kind.
<p>

      Remember to use explicit casts, whenever you really need a signed
      representation. Examples:
      <pre class="codepre"><code class="code">        <span class="keyword">let</span> x = of_int <span class="keywordsign">~-</span>6 ~width:8
        <span class="keyword">let</span> y = to_int x          <span class="comment">(* y = 250 *)</span>
        <span class="keyword">let</span> z = to_int (signed x) <span class="comment">(* z = ~-6 *)</span>
        <span class="keyword">let</span> zero = of_int 0 ~width:8
        <span class="keyword">let</span> p = x &lt; zero          <span class="comment">(* p = false *)</span>
        <span class="keyword">let</span> q = signed x &lt; zero   <span class="comment">(* p = true *)</span>
      </code></pre>
<p>

      <h2 id="bv_string">Clarification on string representation </h2>
<p>

      As a part of <code class="code"><span class="constructor">Identifiable</span></code> interface bitvector provides a pair of
      complement functions: <code class="code">to_string</code> and <code class="code">of_string</code>, that provides
      facilities to store bitvector as a human readable string, and to
      restore it from string. The format of the representation is the
      following (in EBNF):
      <pre class="codepre"><code class="code">        repr  = [sign], [base], digit, {digit}, <span class="string">":"</span>, size, [kind]
          sign  = <span class="string">"+"</span> <span class="keywordsign">|</span> <span class="string">"-"</span>;
        base  = <span class="string">"0x"</span> <span class="keywordsign">|</span> <span class="string">"0b"</span> <span class="keywordsign">|</span> <span class="string">"0o"</span>;
        size  = dec, {dec};
        digit = dec <span class="keywordsign">|</span> oct <span class="keywordsign">|</span> hex;
        dec   = ?decimal digit?;
        oct   = ?octal digit?;
        hex   = ?hexadecimal digit?;
        kind  = u <span class="keywordsign">|</span> s
      </code></pre>
<p>

      Examples:
      <code class="code">0x5D:32s,&nbsp;0b0101:16u,&nbsp;5:64,&nbsp;+5:8,&nbsp;+0x5D:16</code>.
<p>

      If <code class="code">base</code> is omitted base-10 is assumed. If the kind is ommited,
      then the usigned kind is assumed. The output format is always in
      a hex representation with a full prefix.  .<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Bap.Std.html#TYPEword">Std.word</a></code> </pre>
<div class="info ">
<code class="code">word</code> is an abbreviation to <code class="code"><span class="constructor">Bitvector</span>.t</code><br>
</div>


<pre><span class="keyword">include</span> Regular.S</pre>
<div class="info ">
<h2 id="2_CommonInterfaces">Common Interfaces</h2>
<p>

        A bitvector is a value, first of all, so it supports a common
        set of a value interface: it can be stored, compared, it can
        be a key in a dictionary, etc. Moreover, being a number it can
        be compared with zero and applied to a common set of integer
        operations.<br>
</div>

<pre><span class="keyword">include</span> <a href="Bap.Std.Integer.S.html">Bap.Std.Integer.S</a></pre>
<div class="info ">
Bitvector implements a common set of operations that are
        expected from integral values.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.Mono.html">Mono</a>: <code class="type">Comparable</code><code class="type">  with type t := t</code></pre><div class="info">
A comparable interface with size-monomorphic comparison.
</div>

<pre><code><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
least significant byte comes first<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>

</tr></table>

<div class="info ">
Specifies the order of bytes in a word.<br>
</div>



<br>
<h2 id="2_Constructors">Constructors</h2><br>

<pre><span id="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">string -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_string&nbsp;s</code> parses a bitvector from a string representation
        defined in section <code class="code">bv_string</code>.<br>
</div>

<pre><span id="VALof_bool"><span class="keyword">val</span> of_bool</span> : <code class="type">bool -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_bool&nbsp;x</code> is a bitvector with length <code class="code">1</code> and value <code class="code">b0</code> if
        <code class="code">x</code> is false and <code class="code">b1</code> otherwise.<br>
</div>

<pre><span id="VALof_int"><span class="keyword">val</span> of_int</span> : <code class="type">width:int -> int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_int&nbsp;~width&nbsp;n</code> creates a bitvector of the specified
        bit-<code class="code">width</code> with the value equal to <code class="code">n</code>. If bits of the <code class="code">n</code>
        that doesn't fit into <code class="code">width</code> are ignored.<br>
</div>

<pre><span id="VALof_int32"><span class="keyword">val</span> of_int32</span> : <code class="type">?width:int -> int32 -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_int32&nbsp;?width&nbsp;n</code> creates a bitvector of the specified
        bit-<code class="code">width</code> with the value equal to <code class="code">n</code>. If bits of the <code class="code">n</code>
        that doesn't fit into <code class="code">width</code> are ignored. Parameter <code class="code">width</code>
        defaults to <code class="code">32</code>.<br>
</div>

<pre><span id="VALof_int64"><span class="keyword">val</span> of_int64</span> : <code class="type">?width:int -> int64 -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_int32&nbsp;?width&nbsp;n</code> creates a bitvector of the specified
        bit-<code class="code">width</code> with the value equal to <code class="code">n</code>. If bits of the <code class="code">n</code>
        that doesn't fit into <code class="code">width</code> are ignored. Parameter <code class="code">width</code>
        defaults to <code class="code">32</code>.<br>
</div>
<br>
<h2 id="2_Somepredefinedconstantconstructors">Some predefined constant constructors </h2><br>

<pre><span id="VALb0"><span class="keyword">val</span> b0</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">b0&nbsp;=&nbsp;of_bool&nbsp;<span class="keyword">false</span></code><br>
</div>

<pre><span id="VALb1"><span class="keyword">val</span> b1</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">b1&nbsp;=&nbsp;of_bool&nbsp;<span class="keyword">true</span></code><br>
</div>
<br>
<h2 id="2_Helpfulshortcuts">Helpful shortcuts </h2><br>

<pre><span id="VALone"><span class="keyword">val</span> one</span> : <code class="type">int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">one&nbsp;width</code> number one with a specified <code class="code">width</code>, is a shortcut for
        <code class="code">of_int&nbsp;1&nbsp;~width</code><br>
</div>

<pre><span id="VALzero"><span class="keyword">val</span> zero</span> : <code class="type">int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">zero&nbsp;width</code> zero with a specified <code class="code">width</code>, is a shortcut for
        <code class="code">of_int&nbsp;0&nbsp;~width</code><br>
</div>

<pre><span id="VALones"><span class="keyword">val</span> ones</span> : <code class="type">int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">ones&nbsp;width</code> is a number with a specified <code class="code">width</code>, and all bits
        set to 1. It is a shortcut for <code class="code">lnot&nbsp;(zero&nbsp;width)</code><br>
</div>

<pre><span id="VALof_binary"><span class="keyword">val</span> of_binary</span> : <code class="type">?width:int -> <a href="Bap.Std.Bitvector.html#TYPEendian">endian</a> -> string -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_binary&nbsp;?width&nbsp;endian&nbsp;num</code> creates a bitvector from a string
        interpreted as a sequence of bytes in a specified order.
<p>

        The result is always positive and unsigned. The <code class="code">num</code> argument is
        not shared. <code class="code">width</code> defaults to the length of <code class="code">num</code> in bits,
        i.e. <code class="code">8&nbsp;*&nbsp;<span class="constructor">String</span>.length&nbsp;num</code>.<br>
</div>
<br>
<h2 id="2_ConversionstoOCamlbuiltinintegertypes">Conversions to OCaml built in integer types </h2><br>

<pre><span id="VALto_int"><span class="keyword">val</span> to_int</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int Std.Or_error.t</code></pre><div class="info ">
<code class="code">to_int&nbsp;x</code> projects <code class="code">x</code> in to OCaml <code class="code">int</code>.<br>
</div>

<pre><span id="VALto_int32"><span class="keyword">val</span> to_int32</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int32 Std.Or_error.t</code></pre><div class="info ">
<code class="code">to_int32&nbsp;x</code> projects <code class="code">x</code> in to <code class="code">int32</code><br>
</div>

<pre><span id="VALto_int64"><span class="keyword">val</span> to_int64</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int64 Std.Or_error.t</code></pre><div class="info ">
<code class="code">to_int64&nbsp;x</code> projects <code class="code">x</code> in to <code class="code">int64</code><br>
</div>

<pre><span id="VALto_int_exn"><span class="keyword">val</span> to_int_exn</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">to_int_exn&nbsp;x</code> projects <code class="code">x</code> in to OCaml <code class="code">int</code>.<br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALto_int32_exn"><span class="keyword">val</span> to_int32_exn</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int32</code></pre><div class="info ">
<code class="code">to_int32_exn&nbsp;x</code> projects <code class="code">x</code> in to <code class="code">int32</code><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALto_int64_exn"><span class="keyword">val</span> to_int64_exn</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int64</code></pre><div class="info ">
<code class="code">to_int64_exn&nbsp;x</code> projects <code class="code">x</code> in to <code class="code">int64</code><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp"><span class="keyword">val</span> pp</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp&nbsp;x</code> prints <code class="code">x</code> into a formatter. This is
        a default printer, controlled by
        <code class="code">set_default_printer</code>. Multiple formats are available, see the
        <code class="code">available_writers</code> for the actual list of formats and
        a format description. Out of box it defaults to <code class="code">pp_hex_full</code>.
        Note, the <code class="code">printf</code> function from examples refers to the
        <code class="code"><span class="constructor">Format</span>.printf</code>, thus it is assumed that the <code class="code"><span class="constructor">Format</span></code> module
        is open in the scope.<br>
</div>

<pre><span id="VALpp_hex"><span class="keyword">val</span> pp_hex</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_hex&nbsp;x</code> prints <code class="code">x</code> in the hexadecimal format omitting
        suffixes, and the prefix if it is not necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_hex (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0xDEADBEEF
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_hex (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_dec"><span class="keyword">val</span> pp_dec</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_dec&nbsp;x</code> prints <code class="code">x</code> in the decimal format omitting
        suffixes and prefixes.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_dec (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          3735928559
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_dec (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_oct"><span class="keyword">val</span> pp_oct</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_oct&nbsp;x</code> prints <code class="code">x</code> in the octal format omitting
        suffixes, and the prefix if it is not necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_oct (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0o33653337357
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_oct (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
</div>

<pre><span id="VALpp_bin"><span class="keyword">val</span> pp_bin</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_bin&nbsp;x</code> prints <code class="code">x</code> in the binary (0 and 1) format omitting
        suffixes, and the prefix if it is not necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_bin (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0b11011110101011011011111011101111
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_bin (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_hex"><span class="keyword">val</span> pp_hex</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_hex&nbsp;x</code> prints <code class="code">x</code> in the hexadecimal format omitting
        suffixes, and the prefix if it is not necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_hex (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0xDEADBEEF
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_hex (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
</div>

<pre><span id="VALpp_dec"><span class="keyword">val</span> pp_dec</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_dec&nbsp;x</code> prints <code class="code">x</code> in the decimal format omitting
        suffixes and prefixes.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_dec (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          3735928559
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_dec (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_oct"><span class="keyword">val</span> pp_oct</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_oct&nbsp;x</code> prints <code class="code">x</code> in the octal format omitting
        suffixes, and the prefix if it is not necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_oct (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0o33653337357
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_oct (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_bin"><span class="keyword">val</span> pp_bin</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_bin&nbsp;x</code> prints <code class="code">x</code> in the binary (0 and 1)
        format omitting suffixes, and the prefix if it is not necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_bin (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0b11011110101011011011111011101111
          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_bin (<span class="constructor">Word</span>.of_int32 0x1);;
          1
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_hex_full"><span class="keyword">val</span> pp_hex_full</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_hex_full&nbsp;x</code> prints <code class="code">x</code> in the hexadecimal format with
        suffixes, and the prefix if it is necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_hex_full (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0xDEADBEEF:32u
                       <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_hex_full (<span class="constructor">Word</span>.of_int32 0x1);;
          1:32u
        </code></pre><br>
</div>

<pre><span id="VALpp_dec_full"><span class="keyword">val</span> pp_dec_full</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_dec_full&nbsp;x</code> prints <code class="code">x</code> in the decimal format with
        suffixes and prefixes.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_dec_full (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          3735928559:32u
                       <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_dec_full (<span class="constructor">Word</span>.of_int32 0x1);;
          1:32u
        </code></pre><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALpp_oct_full"><span class="keyword">val</span> pp_oct_full</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_oct_full&nbsp;x</code> prints <code class="code">x</code> in the octal format with
        suffixes, and the prefix if it is necessary.
        Example,
<p>

        <pre class="codepre"><code class="code">          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_oct_full (<span class="constructor">Word</span>.of_int32 0xDEADBEEFl);;
          0o33653337357:32u
                          <span class="keywordsign">#</span> printf <span class="string">"%a\n"</span> pp_oct_full (<span class="constructor">Word</span>.of_int32 0x1);;
          1:32u
        </code></pre><br>
</div>

<pre><span id="VALpp_bin_full"><span class="keyword">val</span> pp_bin_full</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_bin_full&nbsp;x</code> prints <code class="code">x</code> in the binary (0 and 1)
        format omitting suffixes, and the prefix if it is necessary.
        Example,
<p>

        <pre class="verbatim">          # printf "%a\n" pp_bin_full (Word.of_int32 0xDEADBEEFl);;
          0b11011110101011011011111011101111:32u
          # printf "%a\n" pp_bin_full (Word.of_int32 0x1);;
          1:32u
       </pre><br>
</div>

<pre><span id="VALpp_generic"><span class="keyword">val</span> pp_generic</span> : <code class="type">?case:[ `lower | `upper ] -><br>       ?prefix:[ `auto | `base | `none | `this of string ] -><br>       ?suffix:[ `full | `none | `size ] -><br>       ?format:[ `bin | `dec | `hex | `oct ] -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">pp_generic&nbsp;?case&nbsp;?prefix&nbsp;?suffix&nbsp;?format&nbsp;ppf&nbsp;x</code> - a printer
        to suit all tastes.
<p>

        Note: this is a generic printer factory that should be used if
        none of the nine preinstantiated suits you.<br>
</div>
<div class="param_info"><code class="code">case</code> : defines the case of hexadecimal letters</div>
<div class="param_info"><code class="code">prefix</code> : defines whether or not a number is prefixed:<ul>
<li><code class="code"><span class="keywordsign">`</span>auto</code> (default) - a prefix that corresponds to the chosen
            format is printed if it is necessary to disambiguate a
            number from a decimal representation;</li>
<li><code class="code"><span class="keywordsign">`</span>base</code> - a corresponding prefix is always printed;</li>
<li><code class="code"><span class="keywordsign">`</span>none</code> - the prefix is never printed;</li>
<li><code class="code"><span class="keywordsign">`</span>this&nbsp;p</code> - the user specified prefix <code class="code">p</code> is always
            printed;</li>
</ul>
</div>
<div class="param_info"><code class="code">suffix</code> : defines how the suffix should be printed:<ul>
<li><code class="code"><span class="keywordsign">`</span>none</code> (default) - the suffix is never printed;</li>
<li><code class="code"><span class="keywordsign">`</span>full</code> - a full suffix that denotes size and signedness
            is printed, e.g., <code class="code">0xDE:32s</code> is a signed integer modulo <code class="code">32</code>.</li>
<li><code class="code"><span class="keywordsign">`</span>size</code> - only the modulo is printed, e.g., <code class="code">0xDE:32s</code> is
            printed as <code class="code">0xDE:32</code></li>
</ul>
</div>
<div class="param_info"><code class="code">format</code> : defines the textual representation format:<ul>
<li><code class="code">hex</code> (default) - hexadecimal</li>
<li><code class="code">dec</code> - decimal</li>
<li><code class="code">oct</code> - octal</li>
<li><code class="code">bin</code> - binary (0 and 1).</li>
</ul>
</div>

<pre><span id="VALstring_of_value"><span class="keyword">val</span> string_of_value</span> : <code class="type">?hex:bool -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<code class="code">string_of_value&nbsp;?hex&nbsp;x</code> returns a textual representation of
        the <code class="code">x</code> value, i.e., ignores size and signedness.  If <code class="code">hex</code> is
        <code class="code"><span class="keyword">true</span></code> (default), then it is in the hexadecimal
        representation, otherwise the decimal representation is
        used. The returned value is not prefixed.  No leading zeros are
        printed. If a value is signed and negative, then a leading
        negative sign is printed. Hexadecimal letter literals are
        printed in a lowercase format.<br>
</div>

<pre><span id="VALsigned"><span class="keyword">val</span> signed</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">signed&nbsp;t</code> casts t to a signed type, so that any operations
        applied on <code class="code">t</code> will be signed.<br>
</div>

<pre><span id="VALunsigned"><span class="keyword">val</span> unsigned</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">unsigned&nbsp;t</code> casts <code class="code">t</code> to an unsigned type, so that any
        operations applied to it will interpret <code class="code">t</code> as an unsigned
        word.<br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALis_zero"><span class="keyword">val</span> is_zero</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_zero&nbsp;bv</code> is true iff all bits are set to zero.<br>
</div>

<pre><span id="VALis_one"><span class="keyword">val</span> is_one</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_ones&nbsp;bv</code> is true if the least significant bit is equal to one<br>
</div>

<pre><span id="VALbitwidth"><span class="keyword">val</span> bitwidth</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">bitwidth&nbsp;bv</code> return a bit-width, i.e., the amount of bits<br>
</div>

<pre><span id="VALextract"><span class="keyword">val</span> extract</span> : <code class="type">?hi:int -><br>       ?lo:int -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">extract&nbsp;bv&nbsp;~hi&nbsp;~lo</code> extracts a subvector from <code class="code">bv</code>, starting
        from bit <code class="code">hi</code> and ending with <code class="code">lo</code>. Bits are enumerated from
        right to left (from least significant to most), starting from
        zero. <code class="code">hi</code> maybe greater than <code class="code">size</code>.
<p>

        <code class="code">hi</code> defaults to <code class="code">width&nbsp;bv&nbsp;-&nbsp;1</code>
        <code class="code">lo</code> defaults to <code class="code">0</code>.
<p>

        Example:
<p>

        <code class="code">extract&nbsp;(of_int&nbsp;17&nbsp;~width:8)&nbsp;~hi:4&nbsp;~lo:3</code>
        will result in a two bit vector consisting of the forth and
        third bits, i.e., equal to a number <code class="code">2</code>.
<p>

        <code class="code">lo</code> and <code class="code">hi</code> should be non-negative numbers. <code class="code">lo</code> must be less
        then a <code class="code">width&nbsp;bv</code> and <code class="code">hi&nbsp;&gt;=&nbsp;lo</code>.<br>
</div>

<pre><span id="VALextract_exn"><span class="keyword">val</span> extract_exn</span> : <code class="type">?hi:int -> ?lo:int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">extract_exn&nbsp;bv&nbsp;~hi&nbsp;~lo</code> is the same as <code class="code">extract</code>, but will raise
        an exception on error.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">concat&nbsp;b1&nbsp;b2</code> concatenates two bitvectors<br>
</div>

<pre><span id="VAL(@.)"><span class="keyword">val</span> (@.)</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">b1&nbsp;@.&nbsp;b2</code> is <code class="code">concat&nbsp;b1&nbsp;b2</code><br>
</div>

<pre><span id="VALsucc"><span class="keyword">val</span> succ</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">succ&nbsp;n</code> returns next value after <code class="code">n</code>. It is not guaranteed that
        <code class="code">signed&nbsp;(succ&nbsp;n)&nbsp;&gt;&nbsp;signed&nbsp;n</code><br>
</div>

<pre><span id="VALpred"><span class="keyword">val</span> pred</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">pred&nbsp;n</code> returns a value preceding <code class="code">n</code>.<br>
</div>

<pre><span id="VALnsucc"><span class="keyword">val</span> nsucc</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">nsucc&nbsp;m&nbsp;n</code> is <code class="code"><span class="constructor">Fn</span>.apply_n_times&nbsp;~n&nbsp;succ&nbsp;m</code>, but more
        efficient.<br>
</div>

<pre><span id="VALnpred"><span class="keyword">val</span> npred</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">npred&nbsp;m&nbsp;n</code> is <code class="code"><span class="constructor">Fn</span>.apply_n_times&nbsp;~n&nbsp;pred&nbsp;addr</code>, but more
        efficient.<br>
</div>

<pre><span id="VAL(++)"><span class="keyword">val</span> (++)</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">a&nbsp;++&nbsp;n</code> is <code class="code">nsucc&nbsp;a&nbsp;n</code><br>
</div>

<pre><span id="VAL(--)"><span class="keyword">val</span> (--)</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> int -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">a&nbsp;--&nbsp;n</code> is <code class="code">npred&nbsp;a&nbsp;n</code><br>
</div>

<pre><span id="VALgcd"><span class="keyword">val</span> gcd</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">gcd&nbsp;x&nbsp;y</code> is the greatest common divisor of <code class="code">x</code> and <code class="code">y</code>
        in the integers. Note that this is not always the greatest
        common divisor in the bitvectors of fixed length. For example,
        in the 32-bit unsigned integers, <code class="code">2&nbsp;=&nbsp;2&nbsp;+&nbsp;2^32&nbsp;=&nbsp;2(1&nbsp;+&nbsp;2^31)</code>.
        Thus, <code class="code">1&nbsp;+&nbsp;2^31</code> is a divisor of <code class="code">2</code>, even though <code class="code">gcd&nbsp;2&nbsp;2&nbsp;=&nbsp;2</code>.
        Two properties that still hold are:
        1. Both <code class="code">x</code> and <code class="code">y</code> are multiples of <code class="code">gcd&nbsp;x&nbsp;y</code>, and
        2. <code class="code">gcd&nbsp;x&nbsp;y&nbsp;&lt;=&nbsp;min&nbsp;(abs&nbsp;x)&nbsp;(abs&nbsp;y)</code><br>
</div>

<pre><span id="VALlcm"><span class="keyword">val</span> lcm</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">lcm&nbsp;x&nbsp;y</code> is the least common multiple of <code class="code">x</code> and <code class="code">y</code>
        in the integers. Note that, like <code class="code">gcd&nbsp;x&nbsp;y</code>, this is not
        always the least common multiple of <code class="code">x</code> and <code class="code">y</code> in the fixed-
        length bitvectors. See the <code class="code">gcd</code> documentation for an example.
        The result of this function will always be some common multiple
        of the inputs, even in the fixed-width bitvectors.<br>
</div>

<pre><span id="VALgcdext"><span class="keyword">val</span> gcdext</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       (<a href="Bap.Std.Bitvector.html#TYPEt">t</a> * <a href="Bap.Std.Bitvector.html#TYPEt">t</a> * <a href="Bap.Std.Bitvector.html#TYPEt">t</a>)<br>       Std.Or_error.t</code></pre><div class="info ">
<code class="code">gcdext&nbsp;x&nbsp;y</code> returns <code class="code">(g,&nbsp;s,&nbsp;t)</code> where <code class="code">g&nbsp;=&nbsp;gcd&nbsp;x&nbsp;y</code> and
        <code class="code">g&nbsp;=&nbsp;s*x&nbsp;+&nbsp;t*y</code>. See the documentation for <code class="code">gcd&nbsp;x&nbsp;y</code> for
        why this function is tricky to use.<br>
</div>

<pre><span id="VALgcd_exn"><span class="keyword">val</span> gcd_exn</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">gcd_exn&nbsp;x&nbsp;y</code> is the same as <code class="code">gcd</code>, but will raise
        an exception on error.<br>
</div>

<pre><span id="VALlcm_exn"><span class="keyword">val</span> lcm_exn</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">lcm_exn&nbsp;x&nbsp;y</code> is the same as <code class="code">lcm</code>, but will raise
        an exception on error.<br>
</div>

<pre><span id="VALgcdext_exn"><span class="keyword">val</span> gcdext_exn</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Bitvector.html#TYPEt">t</a> * <a href="Bap.Std.Bitvector.html#TYPEt">t</a> * <a href="Bap.Std.Bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">gcdext_exn&nbsp;x&nbsp;y</code> is the same as <code class="code">gcdext</code>, but will raise
        an exception on error.<br>
</div>
<br>
<h2 id="2_Iterationoverbitvectorcomponents">Iteration over bitvector components </h2><br>

<pre><span id="VALenum_bytes"><span class="keyword">val</span> enum_bytes</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Bitvector.html#TYPEendian">endian</a> -> <a href="Bap.Std.Bitvector.html#TYPEt">t</a> <a href="Bap.Std.html#TYPEseq">Std.seq</a></code></pre><div class="info ">
<code class="code">enum_bytes&nbsp;x&nbsp;order</code> returns a sequence of bytes of <code class="code">x</code> in a
        specified <code class="code">order</code>.  Each byte is represented as a <code class="code">bitvector</code>
        itself.<br>
</div>

<pre><span id="VALenum_chars"><span class="keyword">val</span> enum_chars</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEendian">endian</a> -> char <a href="Bap.Std.html#TYPEseq">Std.seq</a></code></pre><div class="info ">
<code class="code">enum_bytes&nbsp;x&nbsp;order</code> returns bytes of <code class="code">x</code> in a specified <code class="code">order</code>,
        with bytes represented by <code class="code">char</code> type<br>
</div>

<pre><span id="VALenum_bits"><span class="keyword">val</span> enum_bits</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> <a href="Bap.Std.Bitvector.html#TYPEendian">endian</a> -> bool <a href="Bap.Std.html#TYPEseq">Std.seq</a></code></pre><div class="info ">
<code class="code">enum_bits&nbsp;x&nbsp;order</code> returns bits of <code class="code">x</code> in a specified <code class="code">order</code>.
        <code class="code">order</code> defines only the ordering of words in a bitvector, bits
        will always be in MSB first order. The length of the sequence
        is always a power of <code class="code">8</code>.<br>
</div>
<br>
<h3 id="3_Comparisonwithzero">Comparison with zero</h3>
<p>

        Note, we're not including <code class="code"><span class="constructor">With_zero</span></code> interface, since
        it refers to the `Sign` module, that is available only
        in core_kernel &gt;= 113.33.00.<br>

<pre><span id="VALvalidate_positive"><span class="keyword">val</span> validate_positive</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Validate.check</code></pre><div class="info ">
<code class="code">validate_positive</code> validates that a value is positive.<br>
</div>

<pre><span id="VALvalidate_non_negative"><span class="keyword">val</span> validate_non_negative</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Validate.check</code></pre><div class="info ">
<code class="code">validate_non_negative</code> validates that a value is non negative.<br>
</div>

<pre><span id="VALvalidate_negative"><span class="keyword">val</span> validate_negative</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Validate.check</code></pre><div class="info ">
<code class="code">validate_negative</code> validates that a value is negative.<br>
</div>

<pre><span id="VALvalidate_non_positive"><span class="keyword">val</span> validate_non_positive</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> Std.Validate.check</code></pre><div class="info ">
<code class="code">validate_non_positive</code> validates that a value is not positive.<br>
</div>

<pre><span id="VALis_positive"><span class="keyword">val</span> is_positive</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_positive&nbsp;x</code> is true if <code class="code">x</code> is greater than zero. Always
        true if <code class="code">x</code> is unsigned.<br>
</div>

<pre><span id="VALis_non_negative"><span class="keyword">val</span> is_non_negative</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_non_negative&nbsp;x</code> is true if <code class="code">x</code> is greater than or equal to
        zero. Tautology if <code class="code">x</code> is unsigned.<br>
</div>

<pre><span id="VALis_negative"><span class="keyword">val</span> is_negative</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_negative&nbsp;x</code> is true if <code class="code">x</code> is strictly less than zero. It
        is a contradiction if <code class="code">x</code> is not signed.<br>
</div>

<pre><span id="VALis_non_positive"><span class="keyword">val</span> is_non_positive</span> : <code class="type"><a href="Bap.Std.Bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_non_positive&nbsp;x</code> is true if <code class="code">x</code> is less than zero. It is a
        contradiction if <code class="code">x</code> is not signed.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.Int_err.html">Int_err</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.Int_err.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Arithmetic raised into <code class="code"><span class="constructor">Or_error</span></code> monad 
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.Int_exn.html">Int_exn</a>: <code class="type"><a href="Bap.Std.Integer.S.html">Std.Integer.S</a></code><code class="type">  with type t = t</code></pre><div class="info">
Arithmetic that raises exceptions.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.Unsafe.html">Unsafe</a>: <code class="type"><a href="Bap.Std.Integer.S.html">Std.Integer.S</a></code><code class="type">  with type t = t</code></pre><div class="info">
Arithmentic operations that doesn't check the widths.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.Stable.html">Stable</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.Stable.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Stable marshaling interface.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.Trie.html">Trie</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Prefix trees for bitvectors.
</div>
</body></html>