<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Addr.html">
<link rel="next" href="Bap.Std.Type.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Functional constructors" rel="Section" href="#2_Functionalconstructors">
<link title="BIL Helper functions" rel="Section" href="#bil_helpers">
<title>BAR: BAP Annotated Reference : Bap.Std.Bil</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Addr.html" title="Bap.Std.Addr">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Type.html" title="Bap.Std.Type">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Bil.html">Bap.Std.Bil</a></h1>

<pre><span class="keyword">module</span> Bil: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Main BIL module.
<p>

      The module specifies Binary Instruction Language (BIL). A language to
      define a semantics of instructions. The semantics of the BIL
      language is defined at <code class="code">[1]</code>.
<p>

      The language is defined using algebraic types. For each BIL
      constructor a smart constructor is defined with the same (if
      syntax allows) name. This allows to use BIL as a DSL embedded
      into OCaml:
<p>

      <pre class="codepre"><code class="code"><span class="constructor">Bil</span>.([
          v := src <span class="keyword">lsr</span> i32 1;
          r := src;
          s := i32 31;
          while_ (var v &lt;&gt; i32 0) [
            r := var r <span class="keyword">lsl</span> i32 1;
            r := var r <span class="keyword">lor</span> (var v <span class="keyword">land</span> i32 1);
            v := var v <span class="keyword">lsr</span> i32 1;
            s := var s - i32 1;
          ];
          dst := var r <span class="keyword">lsl</span> var s;
        ])</code></pre>
<p>

      where <code class="code">i32</code> is defined as
      <code class="code"><span class="keyword">let</span>&nbsp;i32&nbsp;x&nbsp;=&nbsp;<span class="constructor">Bil</span>.int&nbsp;(<span class="constructor">Word</span>.of_int&nbsp;~width:32&nbsp;x)</code>
      and <code class="code">v,r,s</code> are some variables of type <code class="code">var</code>; and
      <code class="code">src,&nbsp;dst</code> are expressions of type <code class="code">exp</code>.<br>
<b>See also</b> <a href="https://github.com/BinaryAnalysisPlatform/bil/releases/download/v0.1/bil.pdf"><code class="code">[1]</code>: BIL Semantics.</a><br>
</div>
<hr width="100%">

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Types.html">Types</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Types.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
include all constructors into Bil namespace<br>

<pre><span class="keyword">include</span> <a href="Bap.Std.Bil.Types.html">Bap.Std.Bil.Types</a></pre>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type">stmt list</code> </pre>




<pre><span id="TYPEvar_compare"><span class="keyword">type</span> <code class="type"></code>var_compare</span> </pre>


<pre><span id="TYPEvars"><span class="keyword">type</span> <code class="type"></code>vars</span> = <code class="type">(var, <a href="Bap.Std.Bil.html#TYPEvar_compare">var_compare</a>) Std.Set.t</code> </pre>


<pre><span class="keyword">include</span> Printable.S</pre>

<pre><span class="keyword">include</span> Data.S</pre>

<pre><span id="VALpp_binop"><span class="keyword">val</span> pp_binop</span> : <code class="type">binop <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_binop&nbsp;op</code> prints a binary operation <code class="code">op</code>.<br>
</div>

<pre><span id="VALpp_unop"><span class="keyword">val</span> pp_unop</span> : <code class="type">unop <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_unop&nbsp;op</code> prints an unary operation <code class="code">op</code><br>
</div>

<pre><span id="VALpp_cast"><span class="keyword">val</span> pp_cast</span> : <code class="type">cast <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<code class="code">printf&nbsp;<span class="string">"%a"</span>&nbsp;pp_cast&nbsp;t</code> prints a cast type <code class="code">t</code><br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALstring_of_binop"><span class="keyword">val</span> string_of_binop</span> : <code class="type">binop -> string</code></pre><div class="info ">
<code class="code">string_of_binop&nbsp;op</code> is a textual representation of <code class="code">op</code>.<br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALstring_of_unop"><span class="keyword">val</span> string_of_unop</span> : <code class="type">unop -> string</code></pre><div class="info ">
<code class="code">string_of_unop&nbsp;op</code> is a textual representation of <code class="code">op</code>.<br>
<b>Since</b> 1.3<br>
</div>

<pre><span id="VALstring_of_cast"><span class="keyword">val</span> string_of_cast</span> : <code class="type">cast -> string</code></pre><div class="info ">
<code class="code">string_of_cast&nbsp;t</code> is a textual representation of a cast type<br>
<b>Since</b> 1.3<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Infix.html">Infix</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Infix.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Infix operators
</div>

<pre><span class="keyword">include</span> <a href="Bap.Std.Bil.Infix.html">Bap.Std.Bil.Infix</a></pre>
<div class="info ">
Brings infix operations into scope of the <code class="code"><span class="constructor">Bil</span></code> module.<br>
</div>
<br>
<h2 id="2_Functionalconstructors">Functional constructors</h2><br>

<pre><span id="VALmove"><span class="keyword">val</span> move</span> : <code class="type">var -> exp -> stmt</code></pre><div class="info ">
<code class="code">move&nbsp;v&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Move</span>&nbsp;(v,x)</code><br>
</div>

<pre><span id="VALjmp"><span class="keyword">val</span> jmp</span> : <code class="type">exp -> stmt</code></pre><div class="info ">
<code class="code">jmp&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Jmp</span>&nbsp;x</code><br>
</div>

<pre><span id="VALspecial"><span class="keyword">val</span> special</span> : <code class="type">string -> stmt</code></pre><div class="info ">
<code class="code">special&nbsp;msg&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Special</span>&nbsp;msg</code><br>
</div>

<pre><span id="VALwhile_"><span class="keyword">val</span> while_</span> : <code class="type">exp -> stmt list -> stmt</code></pre><div class="info ">
<code class="code">while_&nbsp;cond&nbsp;stmts&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">While</span>&nbsp;(cond,stmts)</code><br>
</div>

<pre><span id="VALif_"><span class="keyword">val</span> if_</span> : <code class="type">exp -> stmt list -> stmt list -> stmt</code></pre><div class="info ">
<code class="code">if_&nbsp;cond&nbsp;s1&nbsp;s2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">If</span>(cond,s1,s2)</code><br>
</div>

<pre><span id="VALcpuexn"><span class="keyword">val</span> cpuexn</span> : <code class="type">int -> stmt</code></pre><div class="info ">
<code class="code">cpuexn&nbsp;number&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">CpuExn</span>&nbsp;number</code><br>
</div>

<pre><span id="VALunsigned"><span class="keyword">val</span> unsigned</span> : <code class="type">cast</code></pre><div class="info ">
<code class="code">unsigned&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">UNSIGNED</span></code><br>
</div>

<pre><span id="VALsigned"><span class="keyword">val</span> signed</span> : <code class="type">cast</code></pre><div class="info ">
<code class="code">signed&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SIGNED</span></code><br>
</div>

<pre><span id="VALhigh"><span class="keyword">val</span> high</span> : <code class="type">cast</code></pre><div class="info ">
<code class="code">high&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">HIGH</span></code><br>
</div>

<pre><span id="VALlow"><span class="keyword">val</span> low</span> : <code class="type">cast</code></pre><div class="info ">
<code class="code">low&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">LOW</span></code><br>
</div>

<pre><span id="VALplus"><span class="keyword">val</span> plus</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">plus&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">PLUS</span></code><br>
</div>

<pre><span id="VALminus"><span class="keyword">val</span> minus</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">minus&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">MINUS</span></code><br>
</div>

<pre><span id="VALtimes"><span class="keyword">val</span> times</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">times&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">TIMES</span></code><br>
</div>

<pre><span id="VALdivide"><span class="keyword">val</span> divide</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">divide&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">DIVIDE</span></code><br>
</div>

<pre><span id="VALsdivide"><span class="keyword">val</span> sdivide</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">sdivide&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SDIVIDE</span></code><br>
</div>

<pre><span id="VALmodulo"><span class="keyword">val</span> modulo</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">modulo&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">MOD</span></code><br>
</div>

<pre><span id="VALsmodulo"><span class="keyword">val</span> smodulo</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">smodulo&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SMOD</span></code><br>
</div>

<pre><span id="VALlshift"><span class="keyword">val</span> lshift</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">lshift&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">LSHIFT</span></code><br>
</div>

<pre><span id="VALrshift"><span class="keyword">val</span> rshift</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">rshift&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">RSHIFT</span></code><br>
</div>

<pre><span id="VALarshift"><span class="keyword">val</span> arshift</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">arshift&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">ARSHIFT</span></code><br>
</div>

<pre><span id="VALbit_and"><span class="keyword">val</span> bit_and</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">bit_and&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">AND</span></code><br>
</div>

<pre><span id="VALbit_or"><span class="keyword">val</span> bit_or</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">bit_or&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">OR</span></code><br>
</div>

<pre><span id="VALbit_xor"><span class="keyword">val</span> bit_xor</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">bit_xor&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">XOR</span></code><br>
</div>

<pre><span id="VALeq"><span class="keyword">val</span> eq</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">eq&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">EQ</span></code><br>
</div>

<pre><span id="VALneq"><span class="keyword">val</span> neq</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">neq&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">NEQ</span></code><br>
</div>

<pre><span id="VALlt"><span class="keyword">val</span> lt</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">lt&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">LT</span></code><br>
</div>

<pre><span id="VALle"><span class="keyword">val</span> le</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">le&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">LE</span></code><br>
</div>

<pre><span id="VALslt"><span class="keyword">val</span> slt</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">slt&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SLT</span></code><br>
</div>

<pre><span id="VALsle"><span class="keyword">val</span> sle</span> : <code class="type">binop</code></pre><div class="info ">
<code class="code">sle&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SLE</span></code><br>
</div>

<pre><span id="VALneg"><span class="keyword">val</span> neg</span> : <code class="type">unop</code></pre><div class="info ">
<code class="code">neg&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">NEG</span></code><br>
</div>

<pre><span id="VALnot"><span class="keyword">val</span> not</span> : <code class="type">unop</code></pre><div class="info ">
<code class="code">not&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">NOT</span></code><br>
</div>

<pre><span id="VALload"><span class="keyword">val</span> load</span> : <code class="type">mem:exp -> addr:exp -> <a href="Bap.Std.html#TYPEendian">Std.endian</a> -> <a href="Bap.Std.html#TYPEsize">Std.size</a> -> exp</code></pre><div class="info ">
<code class="code">load&nbsp;~mem&nbsp;~addr&nbsp;endian&nbsp;size&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Load</span>&nbsp;(mem,addr,endian,size)</code><br>
</div>

<pre><span id="VALstore"><span class="keyword">val</span> store</span> : <code class="type">mem:exp -> addr:exp -> exp -> <a href="Bap.Std.html#TYPEendian">Std.endian</a> -> <a href="Bap.Std.html#TYPEsize">Std.size</a> -> exp</code></pre><div class="info ">
<code class="code">store&nbsp;~mem&nbsp;~addr&nbsp;exp&nbsp;endian&nbsp;size&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Store</span>(mem,addr,endian,size)</code><br>
</div>

<pre><span id="VALbinop"><span class="keyword">val</span> binop</span> : <code class="type">binop -> exp -> exp -> exp</code></pre><div class="info ">
<code class="code">binop&nbsp;op&nbsp;x&nbsp;y&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">BinOp</span>(op,x,y)</code><br>
</div>

<pre><span id="VALunop"><span class="keyword">val</span> unop</span> : <code class="type">unop -> exp -> exp</code></pre><div class="info ">
<code class="code">unop&nbsp;op&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">UnOp</span>(op,x)</code><br>
</div>

<pre><span id="VALvar"><span class="keyword">val</span> var</span> : <code class="type">var -> exp</code></pre><div class="info ">
<code class="code">var&nbsp;v&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Var</span>&nbsp;v</code><br>
</div>

<pre><span id="VALint"><span class="keyword">val</span> int</span> : <code class="type"><a href="Bap.Std.html#TYPEword">Std.word</a> -> exp</code></pre><div class="info ">
<code class="code">int&nbsp;w&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Int</span>&nbsp;w</code><br>
</div>

<pre><span id="VALcast"><span class="keyword">val</span> cast</span> : <code class="type">cast -> int -> exp -> exp</code></pre><div class="info ">
<code class="code">cast&nbsp;t&nbsp;w&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Cast</span>&nbsp;(t,w,x)</code><br>
</div>

<pre><span id="VALlet_"><span class="keyword">val</span> let_</span> : <code class="type">var -> exp -> exp -> exp</code></pre><div class="info ">
<code class="code">let_&nbsp;var&nbsp;value&nbsp;expr&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Let</span>(var,value,expr)</code><br>
</div>

<pre><span id="VALunknown"><span class="keyword">val</span> unknown</span> : <code class="type">string -> typ -> exp</code></pre><div class="info ">
<code class="code">unknown&nbsp;msg&nbsp;typ&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Unknown</span>(msg,typ)</code><br>
</div>

<pre><span id="VALite"><span class="keyword">val</span> ite</span> : <code class="type">if_:exp -> then_:exp -> else_:exp -> exp</code></pre><div class="info ">
<code class="code">ite&nbsp;~if_:cond&nbsp;~then_:e1&nbsp;~else_:e2&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Ite</span>&nbsp;(cond,e1,e2)</code><br>
</div>

<pre><span id="VALextract"><span class="keyword">val</span> extract</span> : <code class="type">hi:int -> lo:int -> exp -> exp</code></pre><div class="info ">
<code class="code">extract&nbsp;~hi&nbsp;~lo&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Extract</span>&nbsp;(hi,lo,x)</code><br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type">exp -> exp -> exp</code></pre><div class="info ">
<code class="code">concat&nbsp;x&nbsp;y&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Concat</span>&nbsp;(x,y)</code><br>
</div>
<br>
<h2 id="bil_helpers">BIL Helper functions</h2><br>

<pre><span id="VALis_referenced"><span class="keyword">val</span> is_referenced</span> : <code class="type">var -> stmt list -> bool</code></pre><div class="info ">
<code class="code">is_referenced&nbsp;x&nbsp;p</code> is <code class="code"><span class="keyword">true</span></code> if <code class="code">x</code> is referenced in some
        expression or statement in program <code class="code">p</code>, before it is
        assigned.<br>
</div>

<pre><span id="VALis_assigned"><span class="keyword">val</span> is_assigned</span> : <code class="type">?strict:bool -> var -> stmt list -> bool</code></pre><div class="info ">
<code class="code">is_assigned&nbsp;x&nbsp;p</code> is <code class="code"><span class="keyword">true</span></code> if there exists such <code class="code"><span class="constructor">Move</span></code>
        statement, that <code class="code">x</code> occures on the left side of it. If
        <code class="code">strict</code> is true, then only unconditional assignments are
        accounted. By default, <code class="code">strict</code> is <code class="code"><span class="keyword">false</span></code><br>
</div>

<pre><span id="VALprune_unreferenced"><span class="keyword">val</span> prune_unreferenced</span> : <code class="type">?such_that:(var -> bool) -><br>       ?physicals:bool -> ?virtuals:bool -> stmt list -> stmt list</code></pre><div class="info ">
<code class="code">prune_unreferenced&nbsp;?physicals&nbsp;?virtuals&nbsp;?such_that&nbsp;p</code> remove
        all assignments to variables that are not used in the program
        <code class="code">p</code>. This is a local optimization.  The variable is
        unreferenced if it is not referenced in its lexical scope, or if
        it is referenced after the assignment. A variable is pruned
        only if it matches to one of the user specified kind,
        described below (no variable matches the default values, so
        by default nothing is pruned):
<p>

        <code class="code">such_that</code> matches a variable <code class="code">v</code> for which <code class="code">such_that&nbsp;v</code> is
        <code class="code"><span class="keyword">true</span></code>;
<p>

        <code class="code">physicals</code> matches all physical variables (i.e., registers
        and memory locations). See <a href="Bap.Std.Var.html#VALis_physical"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Var</span>.is_physical</code></a> for more
        information. Note: passing <code class="code"><span class="keyword">true</span></code> to this option is in general
        unsound, unless you're absolutely sure, that physical
        variables will not live out program <code class="code">p</code>;
<p>

        <code class="code">virtuals</code> matches all virtual variables (i.e., such variables
        that were added to a program artificially and are not
        represented physically in a program). See <a href="Bap.Std.Var.html#VALis_virtual"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Var</span>.is_virtual</code></a>
        for more information on virtual variables.<br>
</div>

<pre><span id="VALnormalize_negatives"><span class="keyword">val</span> normalize_negatives</span> : <code class="type">stmt list -> stmt list</code></pre><div class="info ">
<code class="code">normalize_negatives&nbsp;p</code> transform <code class="code">x&nbsp;+&nbsp;y</code> to <code class="code">x&nbsp;-&nbsp;abs(y)</code> if <code class="code">y&nbsp;&lt;&nbsp;0</code><br>
</div>

<pre><span id="VALsubstitute"><span class="keyword">val</span> substitute</span> : <code class="type">exp -> exp -> stmt list -> stmt list</code></pre><div class="info ">
<code class="code">substitute&nbsp;x&nbsp;y&nbsp;p</code> substitutes each occurrence of expression <code class="code">x</code> by
        expression <code class="code">y</code> in program <code class="code">p</code>. The mnemonic to remember the
        order is to recall the sed's <code class="code">s/<span class="keyword">in</span>/out</code> syntax.<br>
</div>

<pre><span id="VALsubstitute_var"><span class="keyword">val</span> substitute_var</span> : <code class="type">var -> exp -> stmt list -> stmt list</code></pre><div class="info ">
<code class="code">substitute_var&nbsp;x&nbsp;y&nbsp;p</code> substitutes all free occurences of
        variable <code class="code">x</code> in program <code class="code">p</code> by expression <code class="code">y</code>. A variable is
        free if it is not bounded in a preceding statement or not bound
        with let expression.<br>
</div>

<pre><span id="VALfree_vars"><span class="keyword">val</span> free_vars</span> : <code class="type">stmt list -> <a href="Bap.Std.Bil.html#TYPEvars">vars</a></code></pre><div class="info ">
<code class="code">free_vars&nbsp;bil</code> returns a set of free variables in program
        <code class="code">bil</code>. Variable is considered free if it is not bound in a
        preceding statement or is not bound with <code class="code"><span class="keyword">let</span></code> expression<br>
</div>

<pre><span id="VALfold_consts"><span class="keyword">val</span> fold_consts</span> : <code class="type">stmt list -> stmt list</code></pre><div class="info ">
<code class="code">fold_consts</code> evaluates constant expressions and statements.<br>
</div>

<pre><span id="VALfixpoint"><span class="keyword">val</span> fixpoint</span> : <code class="type">(stmt list -> stmt list) -> stmt list -> stmt list</code></pre><div class="info ">
<code class="code">fixpoint&nbsp;f</code> applies transformation <code class="code">f</code> until fixpoint is
        reached. If the transformation orbit contains non-trivial cycles,
        then the transformation will stop at an arbitrary point of a
        cycle.<br>
</div>

<pre><span id="VALpropagate_consts"><span class="keyword">val</span> propagate_consts</span> : <code class="type">stmt list -> stmt list</code></pre><div class="info ">
<code class="code">propagate_consts&nbsp;bil</code> propagates consts from their reaching definitions.
        The implementation computes reaching definition using inference style analysis,
        overapproximates while cycles (doesn't compute the meet-over-paths solution),
        and ignores memory locations.<br>
<b>Since</b> 1.5<br>
</div>

<pre><span id="VALprune_dead_virtuals"><span class="keyword">val</span> prune_dead_virtuals</span> : <code class="type">stmt list -> stmt list</code></pre><div class="info ">
<code class="code">prune_dead_virtuals&nbsp;bil</code> removes definitions of virtual variables that are
        not live in the provided <code class="code">bil</code> program. We assume that virtual variables are used
        to represent temporaries, thus their removal is safe. The analysis over-approximates
        the while loops, and won't remove any definition that occurs in a while loop body,
        or which depends on it. The analysis doesn't track memory locations.<br>
<b>Since</b> 1.5<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Apply.html">Apply</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Apply.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Maps BIL operators to bitvectors.
</div>

<pre><span id="TYPEresult"><span class="keyword">type</span> <code class="type"></code>result</span> </pre>
<div class="info ">
<span class="warning">Deprecated.</span>Use the Primus Framework.<br>
Result of a computation.<br>
</div>


<pre><span id="TYPEstorage"><span class="keyword">class type</span> <a href="Bap.Std.Bil.storage-c.html">storage</a></span> = <code class="code"><span class="keyword">object</span></code> <a href="Bap.Std.Bil.storage-c.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<span class="deprecated">An interface to a memory storage.
</span></div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Storage.html">Storage</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Storage.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<span class="deprecated">Predefined storage classes
</span></div>

<pre><code><span id="TYPEvalue"><span class="keyword">type</span> <code class="type"></code>value</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvalue.Imm"><span class="constructor">Imm</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEword">Std.word</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
immediate value<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvalue.Mem"><span class="constructor">Mem</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.Bil.storage-c.html">storage</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
memory storage<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTvalue.Bot"><span class="constructor">Bot</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
undefined value<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<span class="warning">Deprecated.</span>Use the Primus Framework<br>
Value of a result.
        We slightly diverge from an operational semantics by allowing
        a user to provide its own storage implementation.
<p>

        In operational semantics a storage is represented
        syntactically as
        <pre class="verbatim">            v1 with [v2,ed] : nat &lt;- v3,
     </pre>
        where v1 may be either a <code class="code"><span class="constructor">Bot</span></code> value, representing an empty
        memory (or an absence of knowledge), or another storage. So a
        well typed memory object is defined inductively as:
<p>

        <pre class="verbatim">          Inductive memory :=
           | bot : memory
           | store : (mem : memory) (addr : value) (data : value).
     </pre>
<p>

        That is equivalent to an assoc list. Although we provide an
        assoc list as storage variant (see <a href="Bap.Std.Bil.Storage.linear-c.html"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Bil</span>.<span class="constructor">Storage</span>.linear</code></a>), the
        default storage is implemented slightly more effective, and
        uses linear space and provides $log(N)$ lookup and update
        methods. Users are encouraged to provide more efficient
        storage implementations, for interpreters that rely heave on
        memory throughput.<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Result.html">Result</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Result.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Trie.html">Trie</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Tries on BIL.
</div>

<pre><span id="TYPEpass"><span class="keyword">type</span> <code class="type"></code>pass</span> </pre>


<pre><span id="VALregister_pass"><span class="keyword">val</span> register_pass</span> : <code class="type">?desc:string -><br>       string -> (<a href="Bap.Std.Bil.html#TYPEt">t</a> -> <a href="Bap.Std.Bil.html#TYPEt">t</a>) -> <a href="Bap.Std.Bil.html#TYPEpass">pass</a></code></pre><div class="info ">
<code class="code">register_pass&nbsp;~desc&nbsp;name&nbsp;pass</code> provides a pass to the BIL transformation pipeline.
        The BIL transformation pipeline is applied after the lifting procedure,
        i.e., it is embedded into each <code class="code">lift</code> function of all Target modules.
        (You can selectively register passes based on architecture by subscribing
        to the <code class="code"><span class="constructor">Project</span>.<span class="constructor">Info</span>.arch</code> variable). All passes that  were in the selection
        provided to the <code class="code">select_passes</code> are applied in the order of the selection
        until the fixed point is reached or a loop is detected. By default, no passes
        are selected. The <code class="code">bil</code> plugin provides a user interface for passes selection,
        as well as some useful passes.<br>
<b>Since</b> 1.5<br>
</div>

<pre><span id="VALselect_passes"><span class="keyword">val</span> select_passes</span> : <code class="type"><a href="Bap.Std.Bil.html#TYPEpass">pass</a> list -> unit</code></pre><div class="info ">
<code class="code">select_passes&nbsp;passes</code> select the <code class="code">passes</code> for the BIL transformation pipeline.
        See <a href="Bap.Std.Bil.html#VALregister_pass"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Bil</span>.register_pass</code></a> for more information about the BIL transformation pipeline.<br>
<b>Since</b> 1.5<br>
</div>

<pre><span id="VALpasses"><span class="keyword">val</span> passes</span> : <code class="type">unit -> <a href="Bap.Std.Bil.html#TYPEpass">pass</a> list</code></pre><div class="info ">
<code class="code">passes&nbsp;()</code> returns all currently registered passes.<br>
<b>Since</b> 1.5<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.Pass.html">Pass</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.Pass.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A BIL analysis pass
</div>
</body></html>