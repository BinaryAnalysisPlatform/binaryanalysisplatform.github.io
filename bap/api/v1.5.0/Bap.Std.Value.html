<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Arch.html">
<link rel="next" href="Bap.Std.Dict.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Bap.Std.Value</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Arch.html" title="Bap.Std.Arch">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Dict.html" title="Bap.Std.Dict">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Value.html">Bap.Std.Value</a></h1>

<pre><span class="keyword">module</span> Value: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Universal Values.
<p>

      This module creates an extensible variant type, that resembles
      extensible variant types, introduced in 4.02, but even more safe
      and more extensible, and, what really matters,
      serializable. Basically you should think of <code class="code"><span class="constructor">Value</span>.t</code> as a union
      type, aka sum type, that can be extended in any place, including
      your plugin code. Where extending is adding new constructor. To
      add new constructor, you need to register it, e.g.,
<p>

      <pre class="codepre"><code class="code">        <span class="keyword">let</span> function_signature = <span class="constructor">Value</span>.<span class="constructor">Tag</span>.register (<span class="keyword">module</span> <span class="constructor">String</span>)
            ~name:<span class="string">"function_signature"</span>
            ~uuid:<span class="string">"2175c28c-08ca-4052-8385-3a01e1c6ab6f"</span>
      </code></pre>
<p>

      This is merely equivalent to adding a branch
<p>

      <pre class="codepre"><code class="code">        <span class="keywordsign">|</span> <span class="constructor">Function_signature</span> <span class="keyword">of</span> string
      </code></pre>
<p>

      to existing union type. The main difference is that the <code class="code">name</code>
      shouldn't be unique (in fact <code class="code">name</code> doesn't bear any semantic
      meaning, it basically for pretty-printing). On the other hand
      the <code class="code">uuid</code> parameter must be unique across the universe, space
      and time. To get the UUID with such properties, you can use
      <code class="code">uuidgen</code> program that is usually available on Linux and Mac OS.
<p>

      <code class="code">name</code> and <code class="code">uuid</code> must be strings, known at compile time, in
      other words it must be string literal, not just an arbitrary
      string, created dynamically. This is made intentionally, in
      order to prevent the abuse of the system.
<p>

      The <code class="code">(<span class="keyword">module</span>&nbsp;<span class="constructor">String</span>)</code> syntax creates a value from the module
      <code class="code"><span class="constructor">String</span></code>, (so called first-class module). The module should
      implement <code class="code"><span class="constructor">Value</span>.<span class="constructor">S</span></code> signature, that requires pretty-printing,
      comparison function and serialization.
<p>

      <pre class="codepre"><code class="code">        <span class="keyword">module</span> <span class="keyword">type</span> <span class="constructor">S</span> = <span class="keyword">sig</span>
          <span class="keyword">type</span> t <span class="keyword">with</span> bin_io, compare, sexp

          <span class="keyword">val</span> pp : <span class="constructor">Format</span>.formatter <span class="keywordsign">-&gt;</span> t <span class="keywordsign">-&gt;</span> unit
        <span class="keyword">end</span>
      </code></pre>
<p>

      The good news is that, most of the types in <code class="code"><span class="constructor">Core</span></code> and <code class="code"><span class="constructor">Bap</span></code> do
      conform with the requirements. Usually, one can implement the
      requirements very easily by using type-driven syntax extensions
      (although, you still need to implement pretty-printing function
      yourself):
<p>

      <pre class="codepre"><code class="code">        <span class="keyword">module</span> <span class="constructor">Loc</span> = <span class="keyword">struct</span>
          <span class="keyword">type</span> t = string * int * int
          <span class="keyword">with</span> bin_io, compare, sexp

          <span class="keyword">let</span> pp ppf (file,line,col) =
            <span class="constructor">Format</span>.fprintf ppf <span class="string">"%s:%d:%d"</span> file line col
        <span class="keyword">end</span>

        <span class="keyword">let</span> loc = <span class="constructor">Value</span>.<span class="constructor">Tag</span>.register (<span class="keyword">module</span> <span class="constructor">Loc</span>)
            ~name:<span class="string">"loc"</span>
            ~uuid:<span class="string">"400e190e-ce21-488d-87b1-c101709621a8"</span>
      </code></pre>
<p>

      The returned value, is a tag that can be used to constructed
      values of that branch, and to deconstruct (extract) them. You
      may think of it as a cipher key, that is used to package data
      into the value container, and later to unpack it:
<p>

      <pre class="codepre"><code class="code">        <span class="keywordsign">#</span> <span class="keyword">let</span> main_pos = <span class="constructor">Value</span>.create loc (<span class="string">"test.c"</span>, 20, 2);;
        <span class="keyword">val</span> main_pos : value = test.c:20:2
      </code></pre>
<p>

      You may see, that OCaml pretty-prints the value. That's neat!
      Also, you may see, that the returned expression has type
      <code class="code">value</code>. That means that it can be used uniformly with other
      values, for example, you can put them in one container, e.g.,
<p>

      <pre class="codepre"><code class="code">        <span class="keywordsign">#</span> <span class="keyword">let</span> main_t = <span class="constructor">Value</span>.create function_signature
              <span class="string">"void main(int argc, const char *argv[])"</span>;;
        <span class="keyword">val</span> main_t : value = void main(int argc, const char *argv[])
      </code></pre>
<p>

      <pre class="codepre"><code class="code">        <span class="keywordsign">#</span> <span class="keyword">let</span> main = [main_pos; main_t];;
        <span class="keyword">val</span> main : value list = [
            test.c:20:2;
            void main(int argc, const char *argv[])
          ]
      </code></pre>
<p>

      To extract value you can use <code class="code"><span class="constructor">Value</span>.get</code> function:
<p>

      <pre class="codepre"><code class="code">        <span class="keywordsign">#</span> <span class="constructor">Value</span>.get loc main_pos;;
        - : <span class="constructor">Loc</span>.t option = <span class="constructor">Some</span> (<span class="string">"test.c"</span>, 20, 2)
      </code></pre>
<p>

      This will require an extra allocation of an <code class="code">option</code> container,
      and in a performance critical context it may be unacceptable.
      For this special case you can use a more efficient:
<p>

      <pre class="codepre"><code class="code"><span class="keyword">if</span> <span class="constructor">Value</span>.is loc <span class="keyword">then</span> <span class="constructor">Value</span>.get_exn loc main_pos</code></pre>.
<p>

      Underneath the hood, the values of type <code class="code">value</code> is just a pair
      of an original value and runtime type information.
<p>

      The comparison of two values of type <code class="code">value</code> is actually a
      multi-method, as it has the following behavior:
<p>

      1. If both values has the same type, then use <code class="code">compare</code>
       function, that was provided for this type.
      2. If values are of different types, that are known to
       the type system, then compare them using RTTI, and ignore the
       value.
      3. If at least one of the values is of the unknown type,
       (i.e., type wasn't registered in the type system), then
       use polymorphic compare on a tuple of UUID and binary
       representation of the values.
<p>

      The rules above guarantee, that values with different RTTI id
      are never equal. It also guarantees that the ordering will be
      preserved between different builds of a program, and even
      between different versions of the compiler.
<p>

      <h2 id="2_Threadsafety">Thread safety</h2>
<p>

      The only thread unsafe function is <code class="code">register</code>, that should be
      called in the module initialization time. In general programs
      modules are initialized in a single thread, so this shouldn't be
      an issue.  The implementation by itself doesn't call <code class="code">register</code>.<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Bap.Std.html#TYPEvalue">Std.value</a></code> </pre>
<div class="info ">
a universal value<br>
</div>




<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type">'a</code> tag</span> </pre>
<div class="info ">
Tag constructor of type <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Value.S.html">S</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.S.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A required interface for the type to be lifted to value.
</div>

<pre><span id="TYPEvoid"><span class="keyword">type</span> <code class="type"></code>void</span> </pre>
<div class="info ">
uninhabited type<br>
</div>


<pre><span id="TYPEliteral"><span class="keyword">type</span> <code class="type"></code>literal</span> = <code class="type">(<a href="Bap.Std.Value.html#TYPEvoid">void</a>, <a href="Bap.Std.Value.html#TYPEvoid">void</a>, <a href="Bap.Std.Value.html#TYPEvoid">void</a>)<br>       Std.format</code> </pre>
<div class="info ">
literal string. Don't look at the right hand side of a type
        equation, this is just a way to say that a string should be a
        literal not a value. Compiler will automatically coerce your
        string literals to this type.<br>
</div>


<pre><span id="TYPEtypeid"><span class="keyword">type</span> <code class="type"></code>typeid</span> </pre>
<div class="info ">
persistent type identifier<br>
</div>




<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">tag</a> -> 'a -> <a href="Bap.Std.Value.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">create&nbsp;cons&nbsp;x</code> creates a value using constructor <code class="code">cons</code> and
        argument <code class="code">x</code><br>
</div>

<pre><span id="VALis"><span class="keyword">val</span> is</span> : <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">tag</a> -> <a href="Bap.Std.Value.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is&nbsp;cons&nbsp;v</code> true if value <code class="code">v</code> was constructed with constructor
        <code class="code">cons</code>, i.e., it is true only when <code class="code">is_cons&nbsp;t&nbsp;(create&nbsp;t&nbsp;x)</code><br>
</div>

<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">tag</a> -> <a href="Bap.Std.Value.html#TYPEt">t</a> -> 'a option</code></pre><div class="info ">
<code class="code">get&nbsp;cons</code> extracts a value associated with a constructor <code class="code">cons</code>
        (Essentially, performs a pattern match on the specified variant
        branch)<br>
</div>

<pre><span id="VALget_exn"><span class="keyword">val</span> get_exn</span> : <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">tag</a> -> <a href="Bap.Std.Value.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<code class="code">get_exn&nbsp;t&nbsp;v</code> extracts value created with <code class="code">t</code> from the
        variant. Raises unspecified exception if variant <code class="code">v</code> wasn't
        created with <code class="code">t</code>.<br>
</div>

<pre><span id="VALtagname"><span class="keyword">val</span> tagname</span> : <code class="type"><a href="Bap.Std.Value.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<code class="code">tagname&nbsp;value</code> returns a constructor name of the <code class="code">value</code><br>
</div>

<pre><span id="VALtypeid"><span class="keyword">val</span> typeid</span> : <code class="type"><a href="Bap.Std.Value.html#TYPEt">t</a> -> <a href="Bap.Std.Value.html#TYPEtypeid">typeid</a></code></pre><div class="info ">
<code class="code">typeid&nbsp;value</code> returns a type identifier of the <code class="code">value</code><br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Value.Tag.html">Tag</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.Tag.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Variants of values.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Value.Match.html">Match</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.Match.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Runtime parallel match.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Value.Typeid.html">Typeid</a>: <code class="type">Identifiable</code><code class="type">  with type t = typeid</code></pre><div class="info">
Persistent type identifiers.
</div>

<pre><span class="keyword">include</span> Regular.S</pre>
<div class="info ">
Although values of type <code class="code">value</code> implements regular interface
        it is recommended to used <code class="code">dict</code> data structure instead of
        those, that are provided by <code class="code"><span class="constructor">Regular</span></code> interface.x<br>
</div>
</body></html>