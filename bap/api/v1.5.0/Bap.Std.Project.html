<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Event.html">
<link rel="next" href="Bap.Std.Self.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Extensible record" rel="Section" href="#3_Extensiblerecord">
<link title="Registering passes" rel="Section" href="#3_Registeringpasses">
<title>BAR: BAP Annotated Reference : Bap.Std.Project</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Event.html" title="Bap.Std.Event">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Self.html" title="Bap.Std.Self">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Project.html">Bap.Std.Project</a></h1>

<pre><span class="keyword">module</span> Project: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Disassembled program.
<p>

      Project contains data that we were able to reconstruct during
      the disassembly, semantic analysis, and other arbitrary amount of
      analyses.
<p>

      Actually, project allows to associate arbitrary data with memory
      regions, program terms, and even attach them globally to
      itself. So it can be seen as a knowledge base of deeply
      interconnected facts.
<p>

      Other than delivering information, from the bap to a passes, it
      can be also used as a communication media between different
      passes, (see <a href="Bap.Std.html#project"><i>Working with project</i></a>).<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Bap.Std.html#TYPEproject">Std.project</a></code> </pre>


<pre><span id="TYPEinput"><span class="keyword">type</span> <code class="type"></code>input</span> </pre>


<pre><span class="keyword">include</span> Data.S</pre>
<div class="info ">
IO interface to a project data structure.<br>
</div>

<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?disassembler:string -><br>       ?brancher:<a href="Bap.Std.html#TYPEbrancher">Std.brancher</a> <a href="Bap.Std.html#TYPEsource">Std.source</a> -><br>       ?symbolizer:<a href="Bap.Std.html#TYPEsymbolizer">Std.symbolizer</a> <a href="Bap.Std.html#TYPEsource">Std.source</a> -><br>       ?rooter:<a href="Bap.Std.html#TYPErooter">Std.rooter</a> <a href="Bap.Std.html#TYPEsource">Std.source</a> -><br>       ?reconstructor:<a href="Bap.Std.html#TYPEreconstructor">Std.reconstructor</a> <a href="Bap.Std.html#TYPEsource">Std.source</a> -><br>       <a href="Bap.Std.Project.html#TYPEinput">input</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">from_file&nbsp;filename</code> creates a project from a provided input
        source. The reconstruction is a multi-pass process driven by
        the following input variables, provided by a user:
<p>
<ul>
<li><code class="code">brancher</code> decides instruction successors;</li>
<li><code class="code">rooter</code> decides function starts;</li>
<li><code class="code">symbolizer</code> decides function names;</li>
<li><code class="code">reconstructor</code> provides algorithm for symtab reconstruction;</li>
</ul>

        The project is built incrementally and iteratively until a
        fixpoint is reached. The fixpoint is reached when an
        information stops to flow from the input variables.
<p>

        The overall algorithm of can depicted with the following
        diargram, where boxes denote data and ovals denote processes:
<p>

        <pre class="verbatim">               +---------+   +---------+   +---------+
               | brancher|   |code/data|   |  rooter |
               +----+----+   +----+----+   +----+----+
                    |             |             |
                    |             v             |
                    |        -----------        |
                    +------&gt;(   disasm  )&lt;------+
                             -----+-----
                                  |
                                  v
              +----------+   +---------+   +----------+
              |symbolizer|   |   CFG   |   | reconstr +
              +-----+----+   +----+----+   +----+-----+
                    |             |             |
                    |             v             |
                    |        -----------        |
                    +------&gt;(  reconstr )&lt;------+
                             -----+-----
                                  |
                                  v
                             +---------+
                             |  symtab |
                             +----+----+
                                  |
                                  v
                             -----------
                            (  lift IR  )
                             -----+-----
                                  |
                                  v
                             +---------+
                             | program |
                             +---------+

      </pre>
<p>

        The input variables, are represented with stream of
        values. Basically, they can be viewed as cells, that depends
        on some input. When input changes, the value is recomputed and
        passed to the stream. Circular dependencies are allowed, so a
        rooter may actually depend on the <code class="code">program</code> term. In case of
        circular dependencies, the above algorithm will be run
        iteratively, until a fixpoint is reached. A criterium for the
        fixpoint, is when no data need to be recomputed. And the data
        must be recomputed when its input is changed or needs to be
        recomputed.
<p>

        User provided input can depend on any information, but a good
        start is the information provided by the <a href="Bap.Std.Project.Info.html"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Project</span>.<span class="constructor">Info</span></code></a> module. It
        contains several variables, that are guaranteed to be defined
        in the process of reconstruction.
<p>

        For example, let's assume, that a <code class="code">create_source</code> function
        actually requires a filename as its input, to create a source
        <code class="code">t</code>, then it can be created as easily as:
<p>

        <code class="code"><span class="constructor">Stream</span>.map&nbsp;<span class="constructor">Input</span>.file&nbsp;~f:create_source</code>
<p>

        As a more complex, example let's assume, that a source now
        requires that both <code class="code">arch</code> and <code class="code">file</code> are known. We can combine
        two different streams of information with a <code class="code">merge</code> function:
<p>

        <code class="code"><span class="constructor">Stream</span>.merge&nbsp;<span class="constructor">Input</span>.file&nbsp;<span class="constructor">Input</span>.arch&nbsp;~f:create_source</code>, where
        <code class="code">create_source</code> is a function of type: <code class="code">string&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;arch&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t</code>.
<p>

        If the source requires more than two arguments, then a
        <code class="code"><span class="constructor">Stream</span>.<span class="constructor">Variadic</span></code>, that is a generalization of a merge
        function can be used. Suppose, that a source of information
        requires three inputs: filename, architecture and compiler
        name. Then we first define a list of arguments,
<p>

        <code class="code"><span class="keyword">let</span>&nbsp;args&nbsp;=&nbsp;<span class="constructor">Stream</span>.<span class="constructor">Variadic</span>.(args&nbsp;<span class="constructor">Input</span>.arch&nbsp;$<span class="constructor">Input</span>.file&nbsp;$<span class="constructor">Compiler</span>.name)</code>
<p>

        and apply them to our function <code class="code">create_source</code>:
<p>

        <code class="code"><span class="constructor">Stream</span>.<span class="constructor">Variadic</span>.(apply&nbsp;~f:create_source&nbsp;args</code>.
<p>

        Sources, specified in the examples above, will call a <code class="code">create_source</code>
        when all arguments changes. This is an expected behavior for
        the <code class="code">arch</code> and <code class="code">file</code> variables, since the do not change during
        the program computation. Mixing constant and non-constant
        (with respect to a computation) variables is not that easy, but
        still can be achieved using <code class="code">either</code> and <code class="code">parse</code> combinators.
        For example, let's assume, that a <code class="code">source</code> requires <code class="code">arch</code> and
        <code class="code">cfg</code> as its input:
<p>

        <pre class="codepre"><code class="code">          <span class="constructor">Stream</span>.either <span class="constructor">Input</span>.arch <span class="constructor">Input</span>.cfg |&gt;
          <span class="constructor">Stream</span>.parse inputs ~init:nil ~f:(<span class="keyword">fun</span> create <span class="keywordsign">-&gt;</span> <span class="keyword">function</span>
              <span class="keywordsign">|</span> <span class="constructor">First</span> arch <span class="keywordsign">-&gt;</span> <span class="constructor">None</span>, create_source arch
              <span class="keywordsign">|</span> <span class="constructor">Second</span> cfg <span class="keywordsign">-&gt;</span> <span class="constructor">Some</span> (create cfg), create)
        </code></pre>
<p>

        In the example, we parse the stream that contains either
        architectures or control flow graphs with a state of type,
        <code class="code">cfg&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;t&nbsp;<span class="constructor">Or_error</span>.t</code>. Every time an architecture is changed,
        (i.e., a new project is started), we recreate a our state,
        by calling the <code class="code">create_source</code> function. Since, we can't
        proof, that architecture will be decided before the <code class="code">cfg</code>, or
        decided at all we need to provide an initial <code class="code">nil</code> function.
        It can return either a bottom value, e.g.,
        <code class="code"><span class="keyword">let</span>&nbsp;nil&nbsp;_&nbsp;=&nbsp;<span class="constructor">Or_error</span>.of_string&nbsp;<span class="string">"expected&nbsp;arch"</span></code>
<p>

        or it can just provide an empty information.<br>
</div>

<pre><span id="VALarch"><span class="keyword">val</span> arch</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEarch">Std.arch</a></code></pre><div class="info ">
<code class="code">arch&nbsp;project</code> reveals the architecture of a loaded file<br>
</div>

<pre><span id="VALdisasm"><span class="keyword">val</span> disasm</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEdisasm">Std.disasm</a></code></pre><div class="info ">
<code class="code">disasm&nbsp;project</code> returns results of disassembling<br>
</div>

<pre><span id="VALprogram"><span class="keyword">val</span> program</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEprogram">Std.program</a> <a href="Bap.Std.html#TYPEterm">Std.term</a></code></pre><div class="info ">
<code class="code">program&nbsp;project</code> returns a program lifted into <a href="Bap.Std.html#sema">IR</a><br>
</div>

<pre><span id="VALwith_program"><span class="keyword">val</span> with_program</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEprogram">Std.program</a> <a href="Bap.Std.html#TYPEterm">Std.term</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">with_program&nbsp;project&nbsp;program</code> updates a project program<br>
</div>

<pre><span id="VALsymbols"><span class="keyword">val</span> symbols</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEsymtab">Std.symtab</a></code></pre><div class="info ">
<code class="code">symbols&nbsp;t</code> returns reconstructed symbol table<br>
</div>

<pre><span id="VALwith_symbols"><span class="keyword">val</span> with_symbols</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEsymtab">Std.symtab</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">with_symbols&nbsp;project&nbsp;symbols</code> updates <code class="code">project</code> symbols<br>
</div>

<pre><span id="VALstorage"><span class="keyword">val</span> storage</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEdict">Std.dict</a></code></pre><div class="info ">
returns an attribute storage of the project<br>
</div>

<pre><span id="VALwith_storage"><span class="keyword">val</span> with_storage</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEdict">Std.dict</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
updates the attribute storage<br>
</div>

<pre><span id="VALmemory"><span class="keyword">val</span> memory</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEvalue">Std.value</a> <a href="Bap.Std.html#TYPEmemmap">Std.memmap</a></code></pre><div class="info ">
<code class="code">memory&nbsp;t</code> returns the memory as an interval tree marked with
        arbitrary values.<br>
</div>

<pre><span id="VALtag_memory"><span class="keyword">val</span> tag_memory</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a <a href="Bap.Std.html#TYPEtag">Std.tag</a> -> 'a -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">tag_memory&nbsp;project&nbsp;region&nbsp;tag&nbsp;value</code> tags a given <code class="code">region</code> of
        memory in <code class="code">project</code> with a given <code class="code">tag</code> and <code class="code">value</code>. Example:
        <code class="code"><span class="constructor">Project</span>.tag_memory&nbsp;project&nbsp;tained&nbsp;color&nbsp;red</code><br>
</div>

<pre><span id="VALsubstitute"><span class="keyword">val</span> substitute</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -><br>       <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> string <a href="Bap.Std.html#TYPEtag">Std.tag</a> -> string -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">substitute&nbsp;p&nbsp;region&nbsp;tag&nbsp;value</code> is like
        <a href="Bap.Std.Project.html#VALtag_memory">tag_memory</a>, but it will also apply
        substitutions in the provided string value, as per OCaml
        standard library's <code class="code"><span class="constructor">Buffer</span>.add_substitute</code> function.
<p>

        Example: <pre class="codepre"><code class="code">          <span class="constructor">Project</span>.substitute project comment <span class="string">"$symbol starts at $symbol_addr"</span>
        </code></pre>
<p>

        The following substitutions are supported:
<p>
<ul>
<li><code class="code">$section{_name,_addr,_min_addr,_max_addr}</code> - name of region of file
        to which it belongs. For example, in ELF this name will
        correspond to the section name</li>
</ul>
<ul>
<li><code class="code">$symbol{_name,_addr,_min_addr,_max_addr}</code> - name or address
        of the symbol to which this memory belongs</li>
</ul>
<ul>
<li><code class="code">$asm</code> - assembler listing of the memory region</li>
</ul>
<ul>
<li><code class="code">$bil</code> - BIL code of the tagged memory region</li>
</ul>
<ul>
<li><code class="code">$block{_name,_addr,_min_addr,_max_addr}</code> - name or address of a basic
        block to which this region belongs</li>
</ul>
<ul>
<li><code class="code">$min_addr,&nbsp;$addr</code> - starting address of a memory region</li>
</ul>
<ul>
<li><code class="code">$max_addr</code> - address of the last byte of a memory region.</li>
</ul>
<br>
</div>

<pre><span id="VALwith_memory"><span class="keyword">val</span> with_memory</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEvalue">Std.value</a> <a href="Bap.Std.html#TYPEmemmap">Std.memmap</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">with_memory&nbsp;project</code> updates project memory. It is
          recommended to use <a href="Bap.Std.Project.html#VALtag_memory"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Project</span>.tag_memory</code></a> and <a href="Bap.Std.Project.html#VALsubstitute"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Project</span>.substitute</code></a> instead of this
        function, if possible.<br>
</div>
<br>
<h3 id="3_Extensiblerecord">Extensible record</h3>
<p>

        Project can also be viewed as an extensible record, where one
        can store arbitrary values. Example,
        <pre class="codepre"><code class="code">          <span class="keyword">let</span> p = <span class="constructor">Project</span>.set project color <span class="keywordsign">`</span>green
        </code></pre>
        This will set field <code class="code">color</code> to a value <code class="code"><span class="keywordsign">`</span>green</code>.<br>

<pre><span id="VALset"><span class="keyword">val</span> set</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> 'a <a href="Bap.Std.html#TYPEtag">Std.tag</a> -> 'a -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">set&nbsp;project&nbsp;field&nbsp;value</code> sets a <code class="code">field</code> to a give value. If
        <code class="code">field</code> was already set, then new value overrides the old
        one. Otherwise the field is added.<br>
</div>

<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> 'a <a href="Bap.Std.html#TYPEtag">Std.tag</a> -> 'a option</code></pre><div class="info ">
<code class="code">get&nbsp;project&nbsp;field</code> returns the value of the <code class="code">field</code> if it
        exists<br>
</div>

<pre><span id="VALhas"><span class="keyword">val</span> has</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> 'a <a href="Bap.Std.html#TYPEtag">Std.tag</a> -> bool</code></pre><div class="info ">
<code class="code">has&nbsp;project&nbsp;field</code> checks whether field exists or not. Useful
        for fields of type unit, that actually isomorphic to bool fields,
        e.g., <code class="code"><span class="keyword">if</span>&nbsp;<span class="constructor">Project</span>.has&nbsp;project&nbsp;mark</code><br>
</div>

<pre><span id="VALdel"><span class="keyword">val</span> del</span> : <code class="type"><a href="Bap.Std.Project.html#TYPEt">t</a> -> 'a <a href="Bap.Std.html#TYPEtag">Std.tag</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">del&nbsp;project&nbsp;attr</code> removes an attribute from a project<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Project.Info.html">Info</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.Info.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Information obtained during project reconstruction.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Project.Input.html">Input</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.Input.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Input information.
</div>
<br>
<h3 id="3_Registeringpasses">Registering passes</h3>
<p>

        To add new pass one of the following <code class="code">register_*</code> functions
        should be called.<br>

<pre><span id="TYPEpass"><span class="keyword">type</span> <code class="type"></code>pass</span> </pre>


<pre><span id="VALregister_pass"><span class="keyword">val</span> register_pass</span> : <code class="type">?autorun:bool -><br>       ?runonce:bool -><br>       ?deps:string list -><br>       ?name:string -> (<a href="Bap.Std.Project.html#TYPEt">t</a> -> <a href="Bap.Std.Project.html#TYPEt">t</a>) -> unit</code></pre><div class="info ">
<code class="code">register_pass&nbsp;?autorun&nbsp;?runonce&nbsp;?deps&nbsp;?name&nbsp;pass</code> registers a
        <code class="code">pass</code> over a project.
<p>

        If <code class="code">autorun</code> is <code class="code"><span class="keyword">true</span></code>, then the host program will run this
        pass automatically. If <code class="code">runonce</code> is true, then for a given
        project the pass will be run only once. Each repeating
        attempts to run the pass will be ignored. The <code class="code">runonce</code>
        parameter defaults to <code class="code"><span class="keyword">false</span></code> when <code class="code">autorun</code> is <code class="code"><span class="keyword">false</span></code>, and
        to <code class="code"><span class="keyword">true</span></code> otherwise.
<p>

        Parameter <code class="code">deps</code> is list of dependencies. Each dependency is a
        name of a pass, that should be run before the <code class="code">pass</code>. The
        dependencies will be run in a specified order every time the
        <code class="code">pass</code> is run.
<p>

        To get access to command line arguments use <code class="code"><span class="constructor">Plugin</span>.argv</code><br>
</div>

<pre><span id="VALregister_pass'"><span class="keyword">val</span> register_pass'</span> : <code class="type">?autorun:bool -><br>       ?runonce:bool -><br>       ?deps:string list -> ?name:string -> (<a href="Bap.Std.Project.html#TYPEt">t</a> -> unit) -> unit</code></pre><div class="info ">
<code class="code">register_pass'&nbsp;pass</code> registers <code class="code">pass</code> that doesn't modify
        the project effect and is run only for side effect.
        (See <a href="Bap.Std.Project.html#VALregister_pass"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Project</span>.register_pass</code></a>)<br>
</div>

<pre><span id="VALpasses"><span class="keyword">val</span> passes</span> : <code class="type">unit -> <a href="Bap.Std.Project.html#TYPEpass">pass</a> list</code></pre><div class="info ">
<code class="code">passes&nbsp;()</code> returns all currently registered passes.<br>
</div>

<pre><span id="VALfind_pass"><span class="keyword">val</span> find_pass</span> : <code class="type">string -> <a href="Bap.Std.Project.html#TYPEpass">pass</a> option</code></pre><div class="info ">
<code class="code">find_pass&nbsp;name</code> returns a pass with the given name.<br>
</div>

<pre><span id="TYPEsecond"><span class="keyword">type</span> <code class="type"></code>second</span> = <code class="type">float</code> </pre>
<div class="info ">
time duration in seconds<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Project.Pass.html">Pass</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.Pass.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A program analysis pass.
</div>
</body></html>