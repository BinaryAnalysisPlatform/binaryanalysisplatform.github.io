<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="Bap.Std.Expi.S.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Error conditions" rel="Section" href="#2_Errorconditions">
<title>BAR: BAP Annotated Reference : Bap.Std.Expi.S.t</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Bap.Std.Expi.S.html" title="Bap.Std.Expi.S">Up</a>
&nbsp;</div>
<h1>Class <a href="type_Bap.Std.Expi.S.t.html">Bap.Std.Expi.S.t</a></h1>

<pre><span name="TYPEt"><span class="keyword">class</span> <code class="type">[#<a href="Bap.Std.Expi.context-c.html">Std.Expi.context</a>]</code> t</span> : <code class="type"></code><code class="code"><span class="keyword">object</span></code> <a href="Bap.Std.Expi.S.t-c.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info class top">
Expression interpreter.
<p>

          Expi is a base class for all other interpreters (see <a href="Bap.Std.bili-c.html"><code class="code"><span class="constructor">Std</span>.bili</code></a>
          and <a href="Bap.Std.biri-c.html"><code class="code"><span class="constructor">Std</span>.biri</code></a>, that do all the hard work. Expi recognizes a
          language defined by <code class="code">exp</code> type. It evaluates arbitrary
          expressions under provided <a href="Bap.Std.Context.html">context</a>.
<p>

          To create new interpreter use operator <code class="code"><span class="keyword">new</span></code>:
<p>

          <pre class="verbatim">        let expi = new expi;;
        val expi : _#Expi.context expi = &lt;obj&gt;
       </pre>
<p>

          Note: The type <code class="code">_<span class="keywordsign">#</span><span class="constructor">Expi</span>.context</code> is weakly polymorphic subtype of
          <code class="code"><span class="constructor">Expi</span>.context</code><code class="code">1</code>. Basically, this means, that the type is not
          generalized and will be instantiated when used and fixed
          afterwards.
<p>

          <pre class="verbatim">        let r = expi#eval_exp Bil.(int Word.b0 lor int Word.b1);;
        val r : _#Expi.context Bil.Result.r = &lt;abstr&gt;
       </pre>
<p>

          The returned value is a state monad parametrized by a subtype
          of class <code class="code"><span class="constructor">Expi</span>.context</code>. The state monad is a chain of
          computations, where each computation is merely a function from
          state to a state paired with the result of computation. The
          state is accessible inside the computation and can be
          changed.
<p>

          To run the computation use <code class="code"><span class="constructor">Monad</span>.<span class="constructor">State</span>.eval</code> function, that
          accepts a state monad and an initial value. Here we can
          provide any subtype of <code class="code"><span class="constructor">Expi</span>.context</code> as an initial
          value. Let start with a <code class="code"><span class="constructor">Expi</span>.context</code> as a first approximation:
<p>

          <pre class="verbatim">        let x = Monad.State.eval r (new Expi.context);;
        val x : Bil.result = [0x3] true
       </pre>
<p>

          The expression evaluates to <code class="code"><span class="keyword">true</span></code>, and the result is tagged
          with an identifier <code class="code">[0x3]</code>. The <code class="code"><span class="constructor">Exp</span>.context</code> assigns a unique
          identifier for each freshly created result. Tag <code class="code">[0x3]</code> means
          that this was the third value created under provided context.
<p>

          If the only thing, that you need is just to evaluate an
          expression, then you can just use <code class="code"><span class="constructor">Exp</span>.eval</code> function:
<p>

          <pre class="verbatim">        Exp.eval Bil.(int Word.b0 lor int Word.b1);;
        - : Bil.value = true
       </pre>
<p>

          The main strength of <code class="code">expi</code> is its extensibility. Let's write
          a expression evaluator that will record a trace of evaluation:
<p>

          <pre class="codepre"><code class="code">            <span class="keyword">class</span> context = <span class="keyword">object</span>
              <span class="keyword">inherit</span> <span class="constructor">Expi</span>.context
              <span class="keyword">val</span> events : (exp * <span class="constructor">Bil</span>.result) list = []
              <span class="keyword">method</span> add_event exp res = {&lt; events = (exp,res) :: events &gt;}
              <span class="keyword">method</span> show_events = <span class="constructor">List</span>.rev events
            <span class="keyword">end</span>
          </code></pre>
<p>

          <pre class="codepre"><code class="code">            <span class="keyword">class</span> [<span class="keywordsign">'</span>a] exp_tracer = <span class="keyword">object</span>
              <span class="keyword">constraint</span> <span class="keywordsign">'</span>a = <span class="keywordsign">#</span>context
              <span class="keyword">inherit</span> [<span class="keywordsign">'</span>a] expi <span class="keyword">as</span> super
              <span class="keyword">method</span>! eval_exp e =
                <span class="keyword">let</span> <span class="keyword">open</span> <span class="constructor">Monad</span>.<span class="constructor">State</span> <span class="keyword">in</span>
                super<span class="keywordsign">#</span>eval_exp e &gt;&gt;= <span class="keyword">fun</span> r <span class="keywordsign">-&gt;</span>
                get () &gt;&gt;= <span class="keyword">fun</span> ctxt <span class="keywordsign">-&gt;</span>
                put (ctxt<span class="keywordsign">#</span>add_event e r) &gt;&gt;= <span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span>
                return r
            <span class="keyword">end</span>;;
          </code></pre>
<p>

          Note : We made our <code class="code">exp_tracer</code> class polymorphic as a
          courtesy to our fellow programmer, that may want to reuse it.
          We can define it by inheriting from <code class="code">expi</code> parametrized with
          our context type, like this: <code class="code"><span class="keyword">inherit</span>&nbsp;[context]&nbsp;expi</code>
<p>

          Also, there is no need to write a <code class="code"><span class="keyword">constraint</span></code>, as it will be
          inferred automatically.
<p>

          Now, let's try to use our tracer. We will use
          <code class="code"><span class="constructor">Monad</span>.<span class="constructor">State</span>.run</code> function, that returns both, the evaluated
          value and the context. (We can also use <code class="code"><span class="constructor">Monad</span>.<span class="constructor">State</span>.exec</code>, if
          we're not interested in value at all):
<p>

          <pre class="verbatim">        let expi = new exp_tracer;;
        val expi : _#context exp_tracer = &lt;obj&gt;
        # let r = expi#eval_exp Bil.(int Word.b0 lor int Word.b1);;
        val r : _#context Bil.Result.r = &lt;abstr&gt;
        # let r,ctxt = Monad.State.run r (new context) ;;
        val r : Bil.result = [0x3] true
        val ctxt : context = &lt;obj&gt;
        ctxt#events;;
        - : (exp * Bil.result) list =
        [(false, [0x1] false); (true, [0x2] true); (false | true, [0x3] true)]
       </pre>
<p>

          <code class="code">1</code>: The weakness of the type variable is introduced by
          a value restriction and can't be relaxed since it is invariant
          in state monad.<br>
</div>
<b>Inherits</b><ul>
<li><code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span>.<span class="constructor">Expi</span>.<span class="constructor">S</span>.<span class="constructor">Eval</span>.semantics</code>    <h2 id="2_Interactionwithenvironment">Interaction with environment</h2></li>
</ul>
<hr width="100%">

<pre><span id="METHODempty"><span class="keyword">method</span> empty</span> : <code class="type"><a href="Bap.Std.Bil.storage-c.html">Std.Bil.storage</a></code></pre><div class="info ">
creates an empty storage. If you want to provide
            your own implementation of storage, then it is definitely
            the right place.<br>
</div>

<pre><span id="METHODlookup"><span class="keyword">method</span> lookup</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">Std.var</a> -> (#<a href="Bap.Std.Expi.context-c.html">Std.Expi.context</a> as 'a) <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
a variable is looked up in a context<br>
</div>

<pre><span id="METHODupdate"><span class="keyword">method</span> update</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">Std.var</a> -> <a href="Bap.Std.Bil.html#TYPEresult">Std.Bil.result</a> -> 'a <a href="Bap.Std.Expi.S.html#TYPEu">u</a></code></pre><div class="info ">
a variable is bind to a value.<br>
</div>

<pre><span id="METHODload"><span class="keyword">method</span> load</span> : <code class="type"><a href="Bap.Std.Bil.storage-c.html">Std.Bil.storage</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> 'a <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
a byte is loaded from a given address<br>
</div>

<pre><span id="METHODstore"><span class="keyword">method</span> store</span> : <code class="type"><a href="Bap.Std.Bil.storage-c.html">Std.Bil.storage</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> <a href="Bap.Std.html#TYPEword">Std.word</a> -> 'a <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
a byte is stored to a a given address<br>
</div>
<h2 id="2_Errorconditions">Error conditions</h2>
<pre><span id="METHODtype_error"><span class="keyword">method</span> type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">Std.type_error</a> -> 'a <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
a given typing error has occured<br>
</div>

<pre><span id="METHODdivision_by_zero"><span class="keyword">method</span> division_by_zero</span> : <code class="type">unit -> 'a <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
we can't do this!<br>
</div>

<pre><span id="METHODundefined_addr"><span class="keyword">method</span> undefined_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> 'a <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
called when storage doesn't contain the addr<br>
</div>

<pre><span id="METHODundefined_var"><span class="keyword">method</span> undefined_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">Std.var</a> -> 'a <a href="Bap.Std.Expi.S.html#TYPEr">r</a></code></pre><div class="info ">
called when context doesn't know the variable<br>
</div>
</body></html>