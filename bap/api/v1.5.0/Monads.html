<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Regular.html">
<link rel="next" href="Ogre.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Monads</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Regular.html" title="Regular">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Ogre.html" title="Ogre">Next</a>
</div>
<h1>Module <a href="type_Monads.html">Monads</a></h1>

<pre><span class="keyword">module</span> Monads: <code class="code"><span class="keyword">sig</span></code> <a href="Monads.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Monad Transformer Library.
<p>

    <h2 id="abstract">Abstract</h2>
<p>

    A monad is an abstraction that can be used to parametrize code
    with the way how computations are sequenced. A monad can also be
    seen as design pattern, that sometimes makes your code more
    readable (and, more often, less readable).  A monad transformer of
    a monad <code class="code"><span class="constructor">M</span></code> is a functor that takes another monad <code class="code"><span class="constructor">M'</span></code> and
    enriches <code class="code"><span class="constructor">M</span></code> with the behavior of <code class="code"><span class="constructor">M'</span></code>. In other terms a
    transformer is a monad composition operator.  This library
    provides the monad abstraction and implementations of commonly
    known monads. Each implementation provides the transformer as
    well.
<p>

    <h2 id="2_TableofContents">Table of Contents</h2><ul>
<li>Abstract</li>
<li>Introduction</li>
<li>Conventions</li>
<li><a href="Monads.Std.Monoid.html">Monoid</a> a set with an associative operation</li>
<li><a href="Monads.Std.Monad.html">Monad</a> a basic monad interface
    <ul>
<li>Monad Interfaces
        <ul>
<li><a href="Monads.Std.Monad.S.html">Monad.S</a> the unary monad</li>
<li><a href="Monads.Std.Monad.S2.html">Monad.S2</a> the binary monad</li>
<li><a href="Monads.Std.Monad.Minimal.html">Monad.Minimal</a> the minimal interface</li>
<li><a href="Monads.Std.Monad.Minimal.html">Monad.Minimal2</a> the minimal interface</li>
<li><a href="Monads.Std.Monad.Core.html">Monad.Core</a> the core interface</li>
<li><a href="Monads.Std.Monad.Core.html">Monad.Core2</a> the core interface</li>
<li><a href="Monads.Std.Monad.Plus.html">Monad.Plus</a> a monad over a monoid interface</li>
<li><a href="Monads.Std.Monad.Fail.html">Monad.Fail</a> a failure monad interface</li>
<li><a href="Monads.Std.Monad.Choice.html">Monad.Choice</a> a choice monad interface</li>
<li><a href="Monads.Std.Monad.Trans.html">Monad.Trans</a> a monad transformer interface</li>
</ul>

      </li>
<li><a href="Monads.Std.Monad.Collection.html">Monad.Collection</a> a container of monads</li>
<li><a href="Monads.Std.Monad.Syntax.html">Monad.Syntax</a> monad operators</li>
<li>Monad Constructors
        <ul>
<li><a href="Monads.Std.Monad.Make.html">Make</a></li>
<li><a href="Monads.Std.Monad.Make2.html">Make2</a></li>
<li><a href="Monads.Std.Monad.Core.html">Core</a></li>
<li><a href="Monads.Std.Monad.Core2.html">Core2</a></li>
<li><a href="Monads.Std.Monad.Minimal.html">Minimal</a></li>
<li><a href="Monads.Std.Monad.Minimal2.html">Minimal2</a></li>
</ul>

      </li>
<li><a href="Monads.Std.Monad.Ident.html">Monad.Ident</a> the do-nothing monad</li>
<li><a href="Monads.Std.Monad.Option.html">Monad.Option</a> a non-total monad</li>
<li><a href="Monads.Std.Monad.Result.html">Monad.Result</a> a non-total monad</li>
<li><a href="Monads.Std.Monad.Result.Error.html">Monad.Result.Error</a> a non-total monad</li>
<li><a href="Monads.Std.Monad.Result.Exception.html">Monad.Result.Exception</a> a non-total monad</li>
<li><a href="Monads.Std.Monad.List.html">Monad.List</a> a non-deterministic monad</li>
<li><a href="Monads.Std.Monad.Seq.html">Monad.Seq</a> a non-deterministic monad</li>
<li><a href="Monads.Std.Monad.Writer.html">Monad.Writer</a> a computation with a writable state</li>
<li><a href="Monads.Std.Monad.Reader.html">Monad.Reader</a> a computation with a readable state</li>
<li><a href="Monads.Std.Monad.State.html">Monad.State</a> a computation with a state</li>
<li><a href="Monads.Std.Monad.State.html">Monad.State.Multi</a> a computation with a non-deterministic state</li>
<li><a href="Monads.Std.Monad.Cont.html">Monad.Cont</a> a call/cc monad</li>
</ul>
</li>
</ul>

    <h2 id="intro">Introduction</h2>
<p>

    In this section we will provide a small introduction into the
    Monad Concept. If you feel yourself comfortable with the idea of
    Monad you may skip to the next section.
<p>

    Monad by itself is a concept or an abstraction. Abstractions come
    into play when there is a need to write a generic implementation
    of some algorithm. There are different mechanisms for
    parametrization an algorithm, but all of them require defining
    some kind of abstraction, that are usually denoted in a
    programming language with a type or a module type. In simple
    cases, an algorithm is parametrized by scalar, e.g.,
<p>

    <pre class="verbatim">      algorithm a b ::=
         x := f a;
         y := f b;
         return (x + y);
   </pre>
<p>

    In a more general case, we may parametrize an algorithm with
    transformations, i.e., with functions:
<p>

    <pre class="verbatim">      algorithm ((_ + _), (f _)) a b ::=
         x := f a;
         y := f b;
         return (x + y);
   </pre>
<p>

    However, we have one more generalization opportunity. The
    semicolon is a sequencing operator that has semantics that is
    usually defined by a programming language, and, typically, in
    regular deterministic languages <code class="code">x&nbsp;:=&nbsp;f&nbsp;a;&nbsp;y&nbsp;:=&nbsp;f&nbsp;b</code> means: first
    compute <code class="code">f&nbsp;a</code> and assign the result to <code class="code">x</code>, then compute <code class="code">f&nbsp;b</code> and
    assign the result to <code class="code">y</code>. However, what if we would like to
    parametrize our algorithm with a behavior of the semicolon
    and operators:
<p>

    <pre class="verbatim">      algorithm ((return _), (_ := _ ; _)) ((_ + _), (f _)) a b ::=
         x := f a;
         y := f b;
         return (x + y);
   </pre>
<p>

    A pair of operators <code class="code">(return&nbsp;_)</code> and <code class="code">(_&nbsp;:=&nbsp;_&nbsp;;&nbsp;_)</code> form the monad
    signature. Since a host language no longer defines semantics of
    the assignment and semicolon, the monad actually operates with
    computations rather than with values. I.e., it is the monad
    implementation that now defines how computations produce values,
    the order of evaluation, etc. The <code class="code">return&nbsp;x</code> lifts a value into
    the computation, i.e., it constructs a trivial computation from a
    constant.  The <code class="code">v&nbsp;:=&nbsp;y;&nbsp;z</code> operator, also called <code class="code">bind</code>, gives the
    general semantics of a program, i.e., how the result of computation
    <code class="code">y</code> is propagated to the computation <code class="code">z</code> (if propagated), it also
    defines the semantics of the semicolon, i.e., whether <code class="code">z</code> is
    performed after <code class="code">y</code>, etc. In general, the semantics may be
    arbitrary, but let's show few examples.
<p>

    1. Partiality: a computation may diverge into a bottom value,
       i.e., if <code class="code">y</code> diverges, then <code class="code">z</code> is not called and the bottom
       value becomes the result of the whole
       computation. <a href="Monads.Std.Monad.Option.html">Monad.Option</a> and
       <a href="Monads.Std.Monad.Result.html">Monad.Result</a> provide a notion of partial
       computation with different representations of the bottom value.
<p>

    2. Nondeterminism: a computation may produce more than one value,
       in that case <code class="code">v</code> will be bound several times, and <code class="code">z</code> will be
       called for each possible value of
       <code class="code">v</code>. <a href="Monads.Std.Monad.List.html">Monad.List</a> and
       <a href="Monads.Std.Monad.Seq.html">Monad.Seq</a> provide implementations of the
       nondeterministic monad with different representations of a
       sequence of values.
<p>

    3. Side-effects: <code class="code">x</code> may produce an effect that changes the
       computation environment. We can subdivide effectful computation
       into more precise categories:<ul>
<li>effect only -- computations do depend on the effects produced
           by other computations, see <a href="Monads.Std.Monad.Writer.html">Monad.Writer</a>;</li>
<li>coeffect only -- computations can't produce effects, though
           they depend on the computation environment,
           see <a href="Monads.Std.Monad.Reader.html">Monad.Reader</a>;</li>
<li>full effect -- computations may change the environment and
           may depend on effects produced by other computations, see
           see <a href="Monads.Std.Monad.State.html">Monad.State</a>.
       The effect itself may also be non-deterministic, e.g., <code class="code">z</code> is
       computed for each possible effect produced by <code class="code">y</code>, see
       <a href="Monads.Std.Monad.State.Multi.html">Monad.State.Multi</a></li>
</ul>

    4. Continuation: <code class="code">x</code> defines a continuation of <code class="code">z</code>, i.e., akin to
       the effect notion, in which a program state is passed from one
       computation to another, the continuation notion reifes the
       control flow of a computation and passes it to the consequent
       continuation as a state. See <a href="Monads.Std.Monad.Cont.html">Monad.Cont</a>.
<p>

    <h3 id="3_TheOCamlrepresentationofthemonadsignature">The OCaml representation of the monad signature</h3>
<p>

    The monad signature <code class="code">(return&nbsp;_),&nbsp;(_&nbsp;:=&nbsp;_&nbsp;;&nbsp;_)</code> is represented with
    the following OCaml signature:
<p>

    <pre class="codepre"><code class="code">      <span class="keyword">module</span> <span class="keyword">type</span> <span class="constructor">Monad</span> = <span class="keyword">sig</span>
        <span class="keyword">type</span> <span class="keywordsign">'</span>a t
        <span class="keyword">val</span> return : <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t
        <span class="keyword">val</span> bind : <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> (<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b t) <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b t
      <span class="keyword">end</span>
    </code></pre>
<p>

    We also use <code class="code">&gt;&gt;=</code> operator as an alias to the <code class="code">bind</code>
    function. Thus <code class="code">v&nbsp;:=&nbsp;x;&nbsp;z</code> is represented in OCaml as
    <code class="code">x&nbsp;&gt;&gt;=&nbsp;<span class="keyword">fun</span>&nbsp;v&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;z</code>. We use functors to parametrize algorithms with
    signatures, e.g.,
<p>

    <pre class="codepre"><code class="code">      <span class="keyword">module</span> <span class="constructor">Algorithm</span>(<span class="constructor">M</span> : <span class="constructor">Monad</span>) = <span class="keyword">struct</span>
        <span class="keyword">open</span> <span class="constructor">R</span> <span class="keyword">open</span> <span class="constructor">M</span>

        <span class="keyword">let</span> run a b =
          f a &gt;&gt;= <span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span>
          f b &gt;&gt;= <span class="keyword">fun</span> y <span class="keywordsign">-&gt;</span>
          return (x + y)
      <span class="keyword">end</span>
    </code></pre>
<p>

    Basically, whenever you see <code class="code">c1&nbsp;&gt;&gt;=&nbsp;<span class="keyword">fun</span>&nbsp;v&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;c2</code> you should
    understand it as <code class="code">v&nbsp;:=&nbsp;c1;&nbsp;c2</code> with a parametrized semicolon, and
    when you see <code class="code">c1&nbsp;&gt;&gt;=&nbsp;<span class="keyword">fun</span>&nbsp;()&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;c2</code> you should understand it as <code class="code">c1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;c2</code>.  Once you will develop a habit of using monadic semicolon it
    will become much easier to you to understand the monadic
    code. Alternatively, you may try one of the syntax preprocessors
    that will introduce the so called do-notation, with the actual
    semicolon being overloaded.
<p>

    <h2 id="conv">Conventions</h2>
<p>

    To use the library add <code class="code"><span class="keyword">open</span>&nbsp;<span class="constructor">Monads</span>.<span class="constructor">Std</span></code> to your program. It will
    bring <code class="code"><span class="constructor">Monoid</span></code> and <code class="code"><span class="constructor">Monad</span></code> modules to your scope. A conventional
    way of writing a computation in a monad <code class="code"><span class="constructor">M</span></code>, is to open its syntax
    with <code class="code"><span class="keyword">open</span>&nbsp;<span class="constructor">M</span>.<span class="constructor">Syntax</span></code>.
<p>

    Given that monad is a concept that goes beyond OCaml language,
    i.e., it is more a design pattern rather than just a module type
    signature, we follow few conventions to make it easier to work
    with different monads.
<p>

    First of all we have two monad signatures, <code class="code"><span class="constructor">S</span></code> and <code class="code"><span class="constructor">S2</span></code>. The <code class="code"><span class="constructor">S</span></code>
    signature defines monad interface for an unary type constructor <code class="code"><span class="keywordsign">'</span>a<br>
&nbsp;&nbsp;&nbsp;&nbsp;t</code> and <code class="code"><span class="constructor">S2</span></code> defines the monad interface for a type parametrized
    with two type parameters, i.e., <code class="code">(<span class="keywordsign">'</span>a,<span class="keywordsign">'</span>b)&nbsp;t</code>. Correspondingly,
    functors named <code class="code"><span class="constructor">Make</span></code> generate modules of type <code class="code"><span class="constructor">S</span></code> and modules
    named <code class="code"><span class="constructor">Make2</span></code> produce modules of type <code class="code"><span class="constructor">S2</span></code>.
<p>

    Every monad <code class="code"><span class="constructor">M</span></code> provides two transformers <code class="code"><span class="constructor">M</span>.<span class="constructor">Make</span></code> and <code class="code"><span class="constructor">M</span>.<span class="constructor">Make2</span></code>
    that transforms <code class="code"><span class="constructor">M</span></code> into another monad. The <code class="code"><span class="constructor">M</span></code> itself provides an
    implementation of <code class="code"><span class="constructor">M</span>.<span class="constructor">S</span></code> or <code class="code"><span class="constructor">M</span>.<span class="constructor">S2</span></code> (depending on a particular kind
    of monad).
<p>

    If a monad type is parametrized by two parameters, then the first
    parameter holds the type of a value, and the second type holds the
    type of an extra information (usually the type of the context).
<p>

    Each monad transformer creates a module that has functions <code class="code">lift</code>
    and <code class="code">run</code>. The <code class="code">lift</code> function lifts original computation into the
    transformed one, and <code class="code">run</code> will run the computation.<br>
</div>
<hr width="100%">

<pre><span class="keyword">module</span> <a href="Monads.Std.html">Std</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Monads.Std.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Monad Transformer Library.
</div>
</body></html>