<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Biri.html">
<link rel="next" href="Bap.Std.Table.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Interfacing with C" rel="Section" href="#2_InterfacingwithC">
<title>BAR: BAP Annotated Reference : Bap.Std.Memory</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Biri.html" title="Bap.Std.Biri">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Table.html" title="Bap.Std.Table">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Memory.html">Bap.Std.Memory</a></h1>

<pre><span class="keyword">module</span> Memory: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Memory region<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Bap.Std.html#TYPEmem">Std.mem</a></code> </pre>




<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?pos:int -><br>       ?len:int -><br>       <a href="Bap.Std.html#TYPEendian">Std.endian</a> -><br>       <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -><br>       Std.Bigstring.t -> <a href="Bap.Std.Memory.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">create&nbsp;?pos&nbsp;?len&nbsp;endian&nbsp;start&nbsp;data</code> creates a memory region.
<p>

        Creates a memory view of the provided <code class="code">data</code> using the
        specified byte order <code class="code">endian</code> and mapping the first (<code class="code">pos</code>)
        byte to the <code class="code">start</code> address. The <code class="code">pos</code> and <code class="code">len</code> parameters
        can be used to narrow down the view, and default to <code class="code">0</code> and
        the length of the provided string, correspondingly.
<p>

        The <code class="code">data</code> may not be copied and the returned memory view may
        reference the same bigstring object.<br>
</div>

<pre><span id="VALof_file"><span class="keyword">val</span> of_file</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">Std.endian</a> -><br>       <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> string -> <a href="Bap.Std.Memory.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">of_file&nbsp;endian&nbsp;start&nbsp;name</code> creates a memory region from file.
        Takes data stored in a file with the given <code class="code">name</code> and maps it
        to the memory region with the specified starting address <code class="code">start</code>
        and using the <code class="code">endian</code> for storing and reading words.<br>
</div>

<pre><span id="VALview"><span class="keyword">val</span> view</span> : <code class="type">?word_size:<a href="Bap.Std.html#TYPEsize">Std.size</a> -><br>       ?from:<a href="Bap.Std.html#TYPEaddr">Std.addr</a> -><br>       ?words:int -> <a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.Memory.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">view&nbsp;word_size&nbsp;~from&nbsp;~words&nbsp;mem</code> returns a new memory
        that represents the specified region of memory <code class="code">mem</code>. <code class="code">copy</code>
        function performs deep copy.<br>
</div>
<div class="param_info"><code class="code">words</code> : defaults to the end of the memory region.</div>

<pre><span id="VALrange"><span class="keyword">val</span> range</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -><br>       <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> <a href="Bap.Std.Memory.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">range&nbsp;mem&nbsp;a0&nbsp;a1</code> returns a view on <code class="code">mem</code> starting from
        address <code class="code">a0</code> and ending at <code class="code">a1</code>, bounds inclusive<br>
</div>

<pre><span id="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -><br>       <a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.Memory.html#TYPEt">t</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">merge&nbsp;m1&nbsp;m2</code> takes two memory regions, that either intersects or
        share edges (i.e., difference between <code class="code">min_addr</code> of one of the
        blocks and <code class="code">max_addr</code> of another is less then or equal to one, and
        returns memory blocks that spans memory starting from the address
        <pre class="codepre"><code class="code">min (min_addr m1) (min_addr m2)</code></pre> and ending with address
        <pre class="codepre"><code class="code">max (max_addr m1) (max_addr m2)</code></pre>.
<p>

        Will return an error, if either the above state precondition
        doesn't hold, or if this two memory blocks doesn't share the same
        underlying memory (i.e., bases), or if they have different
        endianness.<br>
</div>

<pre><span id="VALfirst_byte"><span class="keyword">val</span> first_byte</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.Memory.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">first_byte&nbsp;m</code> returns first byte of <code class="code">m</code> as a memory<br>
</div>

<pre><span id="VALlast_byte"><span class="keyword">val</span> last_byte</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.Memory.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">last_byte&nbsp;m</code> returns last byte of <code class="code">m</code> as a memory<br>
</div>

<pre><span id="VALendian"><span class="keyword">val</span> endian</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEendian">Std.endian</a></code></pre><div class="info ">
returns the order of bytes in a word<br>
</div>

<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type">?disp:int -><br>       ?index:int -><br>       ?scale:<a href="Bap.Std.html#TYPEsize">Std.size</a> -><br>       ?addr:<a href="Bap.Std.html#TYPEaddr">Std.addr</a> -><br>       <a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEword">Std.word</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">get&nbsp;word_size&nbsp;mem&nbsp;addr</code> reads memory value from the specified
        address. <code class="code">word_size</code> default to <code class="code"><span class="keywordsign">`</span>r8</code><br>
</div>

<pre><span id="VAL(^)"><span class="keyword">val</span> (^)</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> <a href="Bap.Std.html#TYPEword">Std.word</a> Std.Or_error.t</code></pre><div class="info ">
<code class="code">m^n</code> dereferences a byte at address <code class="code">n</code><br>
</div>

<pre><span id="VAL(^!)"><span class="keyword">val</span> (^!)</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> <a href="Bap.Std.html#TYPEword">Std.word</a></code></pre><div class="info ">
<code class="code">m^.n</code> dereferences a byte at address <code class="code">n</code><br>
</div>

<pre><span id="VALmax_addr"><span class="keyword">val</span> max_addr</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a></code></pre><div class="info ">
<code class="code">max_addr&nbsp;m</code> is an address of the last byte of <code class="code">m</code><br>
</div>

<pre><span id="VALmin_addr"><span class="keyword">val</span> min_addr</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a></code></pre><div class="info ">
<code class="code">min_addr&nbsp;m</code> is an address of the first byte of <code class="code">m</code><br>
</div>

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">length&nbsp;m</code> returns a number of bytes in m<br>
</div>

<pre><span id="VALcontains"><span class="keyword">val</span> contains</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> bool</code></pre><div class="info ">
<code class="code">contains&nbsp;mem&nbsp;addr</code> returns true if <code class="code">mem</code> contains address <code class="code">addr</code><br>
</div>

<pre><span id="VALcompare_with"><span class="keyword">val</span> compare_with</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -><br>       <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> [ `addr_is_above | `addr_is_below | `addr_is_inside ]</code></pre><div class="info ">
<code class="code">compare_with&nbsp;mem&nbsp;addr</code> compares memory with <code class="code">addr</code><br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.Input.html">Input</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory.Input.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A set of low level input operations.
</div>

<pre><span class="keyword">include</span> Printable.S</pre>
<div class="info ">
<h2 id="2_Printingandoutputing">Printing and outputing</h2><br>
</div>

<pre><span id="VALhexdump"><span class="keyword">val</span> hexdump</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<code class="code">hexdump&nbsp;t&nbsp;out</code> outputs hexdump (as per <code class="code">hexdump&nbsp;-<span class="constructor">C</span></code>) of the
        memory to formatter <code class="code">out</code><br>
</div>

<pre><span class="keyword">include</span> <a href="Bap.Std.Memory_iterators.html">Bap.Std.Memory_iterators</a></pre>
<div class="info ">
a set of iterators, with identity monad.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.With_error.html">With_error</a>: <code class="type"><a href="Bap.Std.Memory_iterators.html">Std.Memory_iterators</a></code><code class="type">  with type t := t
                                          and type 'a m = 'a Or_error.t</code></pre><div class="info">
iterators lifter to the Or_error monad
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.Make_iterators.html">Make_iterators</a> <code class="code">(</code><code class="code"><span class="constructor">M</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type">Std.Legacy.Monad.S</code><code class="code">)&nbsp;</code>: <code class="type"><a href="Bap.Std.Memory_iterators.html">Std.Memory_iterators</a></code><code class="type">  with type t := t
                          and type 'a m = 'a M.t</code></pre><div class="info">
lifts iterators to monad <code class="code"><span class="constructor">M</span></code>
</div>
<br>
<h2 id="2_InterfacingwithC">Interfacing with C</h2>
<p>

        The following interfaces is supposed to be used only for the
        purposes of exposing memory to c programs.<br>

<pre><span id="VALto_buffer"><span class="keyword">val</span> to_buffer</span> : <code class="type"><a href="Bap.Std.Memory.html#TYPEt">t</a> -> Std.Bigsubstring.t</code></pre><div class="info ">
<code class="code">to_buffers&nbsp;mem</code> creates a buffer representing the memory <code class="code">mem</code>.
        It is not specified whether the returned buffer has some sharing
        with underlying implementation. In other words the returned buffer
        shouldn't be modified.
<p>

        Since it is not guaranteed that memory is contiguous, a sequence of
        buffers is returned, with each buffer representing a contiguous
        part of memory.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.Trie.html">Trie</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Tries over memory
</div>
</body></html>