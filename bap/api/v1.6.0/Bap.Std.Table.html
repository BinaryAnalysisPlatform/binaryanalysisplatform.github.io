<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Memory.html">
<link rel="next" href="Bap.Std.Location.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Table relations" rel="Section" href="#2_Tablerelations">
<link title="Examples" rel="Subsection" href="#3_Examples">
<title>BAR: BAP Annotated Reference : Bap.Std.Table</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Memory.html" title="Bap.Std.Memory">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Location.html" title="Bap.Std.Location">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Table.html">Bap.Std.Table</a></h1>

<pre><span id="MODULETable"><span class="keyword">module</span> Table</span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Table.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<div class="info-desc">
<p>Table.</p>

<p>Tables are used to partition memory region into a set of
      non-intersecting areas. Each area is assosiated with arbitrary
      value of type <code class="code"><span class="keywordsign">'</span>a</code> bound to the type of the table.</p>

<p>All operations over tables are purely applicative, i.e. there is
      no observable side-effects. Although, they employ some kind of
      caching underneath the hood, so that they perform better if
      they're  build once and used many times.</p>

<p>Tables can be also linked. For example, if you have two tables
      mapping the same memory region to a different sets of values, you
      can create a mapping from one set of values to another. See <code class="code">link</code>
      function for mode details.</p>
</div>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">'a <a href="Bap.Std.html#TYPEtable">Std.table</a></code> </pre>




<pre><span id="TYPEhashable"><span class="keyword">type</span> <code class="type">'a</code> hashable</span> = <code class="type">'a Hashtbl.Hashable.t</code> </pre>


<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>creates an empty table</p>
</div>
</div>

<pre><span id="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type"><a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'a <a href="Bap.Std.Table.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>creates a table containing one bindins</p>
</div>
</div>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -><br>       <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'a <a href="Bap.Std.Table.html#TYPEt">t</a> Or_error.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">add&nbsp;table&nbsp;mem&nbsp;v</code> returns a new table with added mapping from a
        mem region <code class="code">mem</code> to a data value <code class="code">v</code></p>
</div>
</div>

<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a <a href="Bap.Std.Table.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>returns a new table with all mappings from the mem region
        <code class="code">mem</code> removed</p>
</div>
</div>

<pre><span id="VALchange"><span class="keyword">val</span> change</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -><br>       <a href="Bap.Std.html#TYPEmem">Std.mem</a> -><br>       f:((<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) <a href="Bap.Std.html#TYPEseq">Std.seq</a> -><br>          [ `ignore<br>          | `rebind of <a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a<br>          | `remove<br>          | `update of <a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a -> 'a ]) -><br>       'a <a href="Bap.Std.Table.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">change&nbsp;tab&nbsp;mem&nbsp;~f</code> function <code class="code">f</code> is applied to a set of all memory
        regions that intersects with <code class="code">mem</code>. If function <code class="code">f</code> evaluates to
        <code class="code"><span class="keywordsign">`</span>remap&nbsp;(new_mem,y)</code> then all memory regions that have had
        intersections with <code class="code">mem</code> will be removed from the new map and
        memory region <code class="code">new_mem</code> will be mapped to <code class="code">y</code>. If <code class="code">f</code> evaluates to
        <code class="code"><span class="keywordsign">`</span>remove</code>, then the regions will be removed, and nothing will be
        added. If it evaluates to <code class="code"><span class="keywordsign">`</span>skip</code> then the table will be returned
        unchanged.  Intersections are passed sorted in an ascending order.</p>
</div>
</div>

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">length&nbsp;table</code> returns a number of entries in the table</p>
</div>
</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a option</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">find&nbsp;table&nbsp;mem</code> finds an element mapped to the memory region <code class="code">mem</code></p>
</div>
</div>

<pre><span id="VALfind_addr"><span class="keyword">val</span> find_addr</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEaddr">Std.addr</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) option</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">find_addr&nbsp;tab&nbsp;addr</code> finds a memory region that contains a
        specified <code class="code">addr</code></p>
</div>
</div>

<pre><span id="VALintersections"><span class="keyword">val</span> intersections</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) <a href="Bap.Std.html#TYPEseq">Std.seq</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">intersections&nbsp;table&nbsp;mem</code> returns all mappings in a <code class="code">table</code> that
        have intersections with <code class="code">mem</code></p>
</div>
</div>

<pre><span id="VALfold_intersections"><span class="keyword">val</span> fold_intersections</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -><br>       <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> init:'b -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'b -> 'b) -> 'b</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fold_intersections&nbsp;table&nbsp;mem</code> folds over all regions
        intersecting with <code class="code">mem</code></p>
</div>
</div>

<pre><span id="VALhas_intersections"><span class="keyword">val</span> has_intersections</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">has_intersections&nbsp;tab&nbsp;mem</code> is true iff some portion of <code class="code">mem</code> is
        is already mapped in <code class="code">tab</code>.</p>
</div>
</div>

<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">mem&nbsp;table&nbsp;mem</code> is true if table contains mem region <code class="code">mem</code></p>
</div>
</div>

<pre><span id="VALnext"><span class="keyword">val</span> next</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) option</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">next&nbsp;table&nbsp;elt</code> returns element next to <code class="code">elt</code>, if any</p>
</div>
</div>

<pre><span id="VALprev"><span class="keyword">val</span> prev</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) option</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">next&nbsp;table&nbsp;elt</code> returns element preceding to <code class="code">elt</code>, if any</p>
</div>
</div>

<pre><span id="VALmin"><span class="keyword">val</span> min</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) option</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">min&nbsp;tab</code> return the lowest binding</p>
</div>
</div>

<pre><span id="VALmax"><span class="keyword">val</span> max</span> : <code class="type">'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) option</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">max&nbsp;tab</code> return the highest binding</p>
</div>
</div>

<pre><span id="TYPEr"><span class="keyword">type</span> <code class="type">('a, 'm)</code> r</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Relation multiplicity.
        For a given type <code class="code"><span class="keywordsign">'</span>a</code> creates type <code class="code"><span class="keywordsign">'</span>m</code></p>
</div>
</div>

<h3 id="2_Tablerelations">Table relations</h3>
<pre><span id="VALmany"><span class="keyword">val</span> many</span> : <code class="type">('a, 'a <a href="Bap.Std.html#TYPEseq">Std.seq</a>) <a href="Bap.Std.Table.html#TYPEr">r</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">0..*</code></p>
</div>
</div>

<pre><span id="VALone"><span class="keyword">val</span> one</span> : <code class="type">('a, 'a) <a href="Bap.Std.Table.html#TYPEr">r</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">1..1</code></p>
</div>
</div>

<pre><span id="VALmaybe_one"><span class="keyword">val</span> maybe_one</span> : <code class="type">('a, 'a option) <a href="Bap.Std.Table.html#TYPEr">r</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">0..1</code></p>
</div>
</div>
<p><code class="code">link&nbsp;relation&nbsp;t&nbsp;t1&nbsp;t2</code> takes two tables and returns a mapping
        from elements of one table to elements of other table.</p>

<p>Parameter <code class="code">t</code> specifies a <code class="code">hashable</code> typeclass of the type <code class="code"><span class="keywordsign">'</span>a</code>. If
        type <code class="code"><span class="keywordsign">'</span>a</code> implements <code class="code"><span class="constructor">Hashable</span></code> interface, then you can obtain it
        with <code class="code">hashable</code> function, e.g. <code class="code"><span class="constructor">Int</span>.hashable</code> with return the
        appropriate type class. If <code class="code"><span class="keywordsign">'</span>a</code> doesn't implement <code class="code"><span class="constructor">Hashable</span></code>, then
        it can be implemented manually.</p>

<p>Relation specifies the multiplicity of the relation between
        entities from table <code class="code">t1</code> to entities from table <code class="code">t2</code>, and is
        summarized below:</p>

<ul>
<li><code class="code">one_to_many</code> means that a particular region from table <code class="code">t1</code> can
        span several memory regions from table <code class="code">t2</code>. Example: segments
        to symbols relation.</li>
</ul>
<ul>
<li><code class="code">one_to_one</code> means that for each value of type <code class="code"><span class="keywordsign">'</span>a</code> there is
        exactly one value of type <code class="code"><span class="keywordsign">'</span>b</code>. This relation should be used with
        caution, since it is quantified over _all_ values of type
        <code class="code"><span class="keywordsign">'</span>a</code>. Indeed, it should be used only for cases, when it can be
        guaranteed, that it is impossible to create such value of type
        <code class="code"><span class="keywordsign">'</span>b</code>, that has no correspondence in table <code class="code">t2</code>. Otherwise,
        <code class="code">one_to_maybe_one</code> relation should be used. Example: llvm
        machine code to assembly string relation.</li>
</ul>
<ul>
<li><code class="code">one_to_maybe_one</code> means that for each value in table <code class="code">t1</code> there
        exists at most one value in table <code class="code">t2</code>. Example: function to
        symbol relation.</li>
</ul>
<h4 id="3_Examples">Examples</h4>
<pre class="codepre"><code class="code">          <span class="keyword">let</span> mc_of_insn  = link one_to:one <span class="constructor">Insn</span>.hashable insns mcs
          <span class="keyword">let</span> syms_of_sec = link one_to:many <span class="constructor">Sec</span>.hashable  secs syms
        </code></pre>
<pre><span id="VALrev_map"><span class="keyword">val</span> rev_map</span> : <code class="type">one_to:(<a href="Bap.Std.html#TYPEmem">Std.mem</a>, 'r) <a href="Bap.Std.Table.html#TYPEr">r</a> -><br>       'a <a href="Bap.Std.Table.html#TYPEhashable">hashable</a> -><br>       'a <a href="Bap.Std.Table.html#TYPEt">t</a> -> ('a -> 'r) Or_error.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">rev_map&nbsp;arity&nbsp;t&nbsp;tab</code> creates a reverse mapping from values of
        typeclass <code class="code">t</code> stored in table <code class="code">tab</code> to memory regions.</p>

<p>Note. not every mapping is reversable, for example, trying to obtain
        a reverse of surjective mapping as a one-to-one mapping will
        result in an error. But surjective mappings can be reversed
        using <code class="code">~one_to:many</code> mapping. A particular example of surjective
        mapping is <code class="code">symbol</code> tables, in a case when functions can occupy
        several non-contiguous regions of memory.</p>

<p>For example, to create a mapping from a function symbol to
        sequence of memory regions with it code:</p>

<pre class="codepre"><code class="code">rev_map one_to:many <span class="constructor">Sym</span>.hashable tab</code></pre></div>
</div>

<pre><span id="TYPEranged"><span class="keyword">type</span> <code class="type">'a</code> ranged</span> = <code class="type">?start:<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> ?until:<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a</code> </pre>
<div class="info ">
<div class="info-desc">
<h3 id="2_Iterators">Iterators</h3>
<p>This section provides a common set of iterators. Note: name
        iterator is used in a functional meaning, i.e., an iterator is a
        function that takes a data structure and another function, and
        applies it to all elements in some manner.</p>

<p>All iterators share some common part of interface that was lifted
        to a <code class="code"><span class="keywordsign">'</span>a&nbsp;ranged</code> type. When you see</p>

<p><code class="code">(<span class="keywordsign">'</span>a&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;f:(<span class="keywordsign">'</span>a&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;bool)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;bool)&nbsp;ranged</code></p>

<p>just mentally substitute it with:</p>

<p><code class="code">?start&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;?until&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keywordsign">'</span>a&nbsp;t&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;f:(<span class="keywordsign">'</span>a&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;bool)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;bool</code>.</p>

<p>In other words <code class="code"><span class="keywordsign">'</span>f&nbsp;ranged</code> just prepends <code class="code">?start&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;?until&nbsp;<span class="keywordsign">-&gt;</span></code> to
        function with type <code class="code"><span class="keywordsign">'</span>f</code> (do not forget that <code class="code"><span class="keywordsign">'</span>f</code> can be an arrow
        type).</p>

<p><code class="code">start</code> and <code class="code">until</code> parameters narrows iteration to some
        subset of table. If they are unspecified then iteration would
        be performed on all table entries in an ascending order of
        addresses. If they are specified, then if <code class="code">start&nbsp;&lt;=&nbsp;until</code>,
        then iteration will be performed in the same order but on a
        specified subset. In the case, when <code class="code">start&nbsp;&gt;&nbsp;until</code>, iteration
        will be performed in a decreasing order.</p>
</div>
</div>


<pre><span id="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> bool) -> bool) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">exists&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> checks if at least one
        element of <code class="code">table</code> satisfies the predicate <code class="code">f</code>.</p>
</div>
</div>

<pre><span id="VALfor_all"><span class="keyword">val</span> for_all</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> bool) -> bool) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">for_all&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> checks if all elements
        of <code class="code">table</code> satisfies the predicate <code class="code">f</code>.</p>
</div>
</div>

<pre><span id="VALexistsi"><span class="keyword">val</span> existsi</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> bool) -> bool)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">existsi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALexists"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.exists</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALfor_alli"><span class="keyword">val</span> for_alli</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> bool) -> bool)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">for_alli&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALfor_all"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.for_all</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALcount"><span class="keyword">val</span> count</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> bool) -> int) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">count&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> returns the number of elements
        <code class="code">table</code> that satisfy the predicate <code class="code">p</code></p>
</div>
</div>

<pre><span id="VALfind_if"><span class="keyword">val</span> find_if</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> bool) -> 'a option) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">find_if&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> returns the first element of
        <code class="code">table</code> that satisfies the predicate <code class="code">p</code> or None if no elements
        satisfied</p>
</div>
</div>

<pre><span id="VALfind_map"><span class="keyword">val</span> find_map</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> 'b option) -> 'b option) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">find_map&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> returns the first evaluation
        of <code class="code">f</code> that returns <code class="code"><span class="constructor">Some</span></code> or None if <code class="code">f</code> always returns <code class="code"><span class="constructor">None</span></code></p>
</div>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> init:'b -> f:('a -> 'b -> 'b) -> 'b)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fold&nbsp;~start&nbsp;~until&nbsp;~init&nbsp;~f&nbsp;table</code> returns a fold over
        <code class="code">table</code> in form <code class="code">f&nbsp;elt_n&nbsp;(&nbsp;...&nbsp;(f&nbsp;elt_2&nbsp;(f&nbsp;(elt_1&nbsp;acc)))&nbsp;...&nbsp;)</code></p>
</div>
</div>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> unit) -> unit) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">iter&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> applies function <code class="code">f</code> in turn to
        elements of <code class="code">table</code></p>
</div>
</div>

<pre><span id="VALfind_mapi"><span class="keyword">val</span> find_mapi</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'b option) -> 'b option)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">find_mapi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALfind_map"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.find_map</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALfoldi"><span class="keyword">val</span> foldi</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> init:'b -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'b -> 'b) -> 'b)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">foldi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALfold"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.fold</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> unit) -> unit)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">ieri&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALiter"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.iter</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> 'b) -> 'b <a href="Bap.Std.Table.html#TYPEt">t</a>)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">map&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> applies <code class="code">f</code> to elements of
        <code class="code">table</code> and builds new table with results returned by <code class="code">f</code></p>
</div>
</div>

<pre><span id="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'b) -> 'b <a href="Bap.Std.Table.html#TYPEt">t</a>)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">mapi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALmap"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.map</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> bool) -> 'a <a href="Bap.Std.Table.html#TYPEt">t</a>)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">filter&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> removes all mappings from
        <code class="code">table</code> that doesn't satisfies the predicate <code class="code">f</code></p>
</div>
</div>

<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:('a -> 'b option) -> 'b <a href="Bap.Std.Table.html#TYPEt">t</a>)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">filter_map&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> return a subtable of
        <code class="code">table</code> containing only elements for which <code class="code">f</code> returns
        <code class="code"><span class="constructor">Some</span></code></p>
</div>
</div>

<pre><span id="VALfilteri"><span class="keyword">val</span> filteri</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> bool) -> 'a <a href="Bap.Std.Table.html#TYPEt">t</a>)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">filteri&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALfilter"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.filter</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALfilter_mapi"><span class="keyword">val</span> filter_mapi</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -><br>        f:(<a href="Bap.Std.html#TYPEmem">Std.mem</a> -> 'a -> 'b option) -> 'b <a href="Bap.Std.Table.html#TYPEt">t</a>)<br>       <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">filter_mapi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href="Bap.Std.Table.html#VALfilter_map"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Table</span>.filter_map</code></a>, but
        also passes the memory as an argument.</p>
</div>
</div>

<pre><span id="VALto_sequence"><span class="keyword">val</span> to_sequence</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> (<a href="Bap.Std.html#TYPEmem">Std.mem</a> * 'a) <a href="Bap.Std.html#TYPEseq">Std.seq</a>) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">to_sequence&nbsp;~start&nbsp;~until&nbsp;table</code> converts the <code class="code">table</code> to a
        sequence of key-value pairs.</p>
</div>
</div>

<pre><span id="VALregions"><span class="keyword">val</span> regions</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> <a href="Bap.Std.html#TYPEmem">Std.mem</a> <a href="Bap.Std.html#TYPEseq">Std.seq</a>) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">regions&nbsp;table</code> returns in an ascending order of addresses all
        memory regions mapped in a <code class="code">table</code></p>
</div>
</div>

<pre><span id="VALelements"><span class="keyword">val</span> elements</span> : <code class="type">('a <a href="Bap.Std.Table.html#TYPEt">t</a> -> 'a <a href="Bap.Std.html#TYPEseq">Std.seq</a>) <a href="Bap.Std.Table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">elements&nbsp;table</code> returns in an ascending order of addresses all
        elements mapped in a <code class="code">table</code></p>
</div>
</div>

<pre><span id="VALpp"><span class="keyword">val</span> pp</span> : <code class="type">'a <a href="Regular.Std.html#TYPEprinter">Std.printer</a> -> 'a <a href="Bap.Std.Table.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEprinter">Std.printer</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">pp&nbsp;printer</code> - creates a printer for table from value printer</p>
</div>
</div>
</body></html>
