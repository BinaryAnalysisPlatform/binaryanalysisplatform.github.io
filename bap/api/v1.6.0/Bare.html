<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap_primus.html">
<link rel="next" href="Arm_insn.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Example" rel="Section" href="#2_Example">
<link title="Syntax" rel="Section" href="#2_Syntax">
<link title="Semantics" rel="Section" href="#2_Semantics">
<link title="Concrete Syntax" rel="Subsection" href="#3_ConcreteSyntax">
<link title="Abstract Syntax" rel="Subsection" href="#3_AbstractSyntax">
<title>BAR: BAP Annotated Reference : Bare</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap_primus.html" title="Bap_primus">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Arm_insn.html" title="Arm_insn">Next</a>
</div>
<h1>Module <a href="type_Bare.html">Bare</a></h1>

<pre><span class="keyword">module</span> Bare: <code class="code"><span class="keyword">sig</span></code> <a href="Bare.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Binary Analysis Rule Engine (BARE).
<p>

    The Binary Analysis Rule Engine is a production system (a forward
    chaining rule system) that is used in the Binary Analysis
    Platform, and features non-linear pattern matching and a stream
    based approach to the state of the world.
<p>

    BARE defines the syntax and semantics of a rule specification
    language, and provides a simple pattern matching engine. The
    semantics of facts, as well as the semantics of the evaluation
    loop are left to concrete implementations of interpreters.
<p>

    A BARE specification consists of a sequence of rules. Each rule is
    a pair. The first element, called the left hand side, is a list of
    tuples that represents patterns that should be matched with
    facts. The second element, called the right hand side, is a list
    of tuples that represents the list of facts that should be
    produced once all patterns on the left hand side match with the
    provided facts. A rule is applied to a stream of facts, if all
    patterns in a rule matches with some facts, then a rule is
    triggered and produces facts from the right hand side. A rule may
    have variables on the left hand side, that will bind to elements
    of a fact tuple that matched with a pattern. The same variable may
    occur in different patterns of the same rule, i.e., a pattern is not
    required to be linear. When the same variable occurs in two
    patterns of the same rule, then a constraint is imposed that this
    variable should be bound to the same term in both patterns. The
    order of the patterns in the left hand side doesn't matter, thus
    the semantics of rule doesn't change with the permutation of its
    patterns. The order of facts may matter, depending on a concrete
    interpretation of fact. If a rule is applied to different
    permutations of a list of facts it may produce different sequences
    of facts, though all derivable facts will be produced.
<p>

    BARE represents tuples with S-expressions and variables with atoms
    that start with the question mark (?). A single question mark
    character represents a wild card variable that matches with
    everything but cannot be used on the right hand side of a
    rule. Since the right hand side of a rule may contain more than
    one pattern the engine will perform the join operation on a stream
    of events. Given that any join operation generates a number of
    matches that is in general a polynomial function of the number of
    patterns, a caution should be used by an expert who builds a
    system with complex rules that contains many patterns in the same
    rule. BARE can't apply any query optimization techniques on a
    rule, given the open and extensible notion of a fact. Thus BARE
    should be considered as a base representation for the
    pattern/action forward chanining systems, that shall perform all
    the necessary optimizations on their level.
<p>

    <h2 id="2_Example">Example</h2>
<p>

    Suppose we want to process a stream of events that represent the
    behavior of some memory allocator. We expect the following kinds
    of events:
<p>
<ul>
<li><code class="code">(acquire&nbsp;<span class="constructor">SITE</span>&nbsp;<span class="constructor">PTR</span>&nbsp;<span class="constructor">LEN</span>)</code> represents an allocation event, where
       SITE is an allocation site (i.e., an address of a program
       instruction that perfroms an allocation), <code class="code"><span class="constructor">PTR</span></code> is a pointer to
       the allocated data, and <code class="code"><span class="constructor">LEN</span></code> is the data size;</li>
</ul>
<ul>
<li><code class="code">(release&nbsp;<span class="constructor">SITE</span>&nbsp;<span class="constructor">PTR</span>&nbsp;<span class="constructor">LEN</span>)</code> represents a memory deallocation
       event;</li>
</ul>
<ul>
<li><code class="code">(violate&nbsp;<span class="constructor">SITE</span>&nbsp;<span class="constructor">PTR</span>&nbsp;<span class="constructor">KIND</span>)</code> represents a violation of a memory
       allocator invariants of the specified KIND.</li>
</ul>

     Suppose we want to build a rule, that will report each violation
     as a tuple that contains a kind of the violation and all three
     sites, that are involved in the incident.
<p>

    <pre class="verbatim">    (((acquire ?asite ?ptr ?)
      (release ?rsite ?ptr ?)
      (violate ?vsite ?ptr ?kind)

     ((?kind ?asite ?rsite ?vsite)))
   </pre>
<p>

    This rule can be read as, for all acquire, release, and violate
    events that have the same <code class="code"><span class="constructor">PTR</span></code> produce a fact of a violation of
    the specified kind that contains the program locations of these
    three events. For example, given the following sequence of events:
<p>

    <pre class="verbatim">      (acquire L10 0xBAD 10)
      (release L20 0XBAD 10)
      (violate L30 0XBAD use-after-free)
      (violate L40 0xBAD double-free)
      (violate L50 0XBAD use-after-free)
   </pre>
<p>

    The following facts will be produced if the rule is sequentially
    applied to the above sequence:
<p>

    <pre class="verbatim">      (use-after-free L10 L20 L30)
      (double-free L10 L20 L40)
      (use-after-free L10 L20 L50)
   </pre>
<p>

    <h2 id="2_Syntax">Syntax</h2>
<p>

    <h3 id="3_ConcreteSyntax">Concrete Syntax</h3>
<p>

    A tuple is represented by an arbitrary S-expression. A variable is
    an atom that starts with the question mark. A special variable <code class="code">?</code>
    (one question mark symbol) may occur on the left hand side of a
    rule, and represents a freshly created variable. Every occurence
    of the <code class="code">?</code> symbol represents a different variable. Both sides of a
    rule may be empty (represented by the 0-tuple <code class="code">()</code>).
<p>

    <pre class="verbatim">    rule,r  ::= ((p1 .. pM) (f1 .. fN))
    sexp,s  ::= atom | (s1 .. sM)
    patt,p  ::= sexp
    fact,f  ::= sexp
    atom,a  ::= ?sequence-of-chars?
   </pre>
<p>

    Example:
    <pre class="verbatim">    (((duck ?name) (does ?action)) ((looks like ?name did ?action)))
   </pre>
<p>

    This rule contains two patterns <code class="code">(duck&nbsp;?name)</code> and <code class="code">(does&nbsp;?action)</code>
    and one production fact <code class="code">(looks&nbsp;like&nbsp;?name&nbsp;did&nbsp;?action)</code>.
<p>

    <h3 id="3_AbstractSyntax">Abstract Syntax</h3>
<p>

    A rule r is a tuple (P,F) where P is a sequence of patterns
    p1,...,pM, F is a sequence of facts f1,...,fN, and M,N are
    non-negative numbers. A pattern p and fact f are arbitrary
    n-tuples (terms) t, that contain atoms, other tuples, and free
    variables.
<p>

    <pre class="verbatim">    rule,r ::= (B,P,F)
    P ::= p1,...
    F ::= f1,...
    B ::= v1-&gt;f,...
    V ::= v1,...
    T ::= t1,...
    term,p,f,s,t ::= v | a | (t,..,tM)
    atom,x,y,z ::= ?atom?
    v ::= ?variable?
   </pre>
<p>

    <h2 id="2_Semantics">Semantics</h2>
<p>

    We use a regular sequent calculus (with all structural rules) to
    represent semantics. A rule with a sequence of patterns P matches
    with a sequence of facts with the given valuations, denoted as
    <code class="code"><span class="constructor">B</span>,<span class="constructor">T</span>&nbsp;|-&nbsp;<span class="constructor">P</span></code>, if it can be proved using the rules below (plus
    regular rules of the sequent calculus). The (match-rule) rule,
    expands rules (eliminating tuples on the top level). The
    (match-tuple) rule further expands patterns until each pattern is
    either an atom, in that case it is proved by the axiom of
    identity, or to a variable, in that case a match can be proved with
    the (match-var) rule, that says that a variable matches a
    term only if it is bound to that term.
<p>

    Note, that exchange and weakening rules of sequent calculus allows
    us to drop and rearrange facts. The latter makes the order of
    rules irrelevant. If for a sequence of facts, there are several
    valuations of variables that will lead to a match, then all these
    matches are provided. In other words, the engine will generate all
    derivable facts in an unspecified but consistent order.
<p>

    <pre class="verbatim">
     B,T |- p1 .. B,T |- pM
     ----------------------- (match-rule)
     B,T |- (p1,..,pM)


     B,t1,T |- s1 .. B,tM,T |- sM
     ---------------------------- (match-tuple)
     B,(t1,..,tM),T |- (s1,..,sM)


     B,T |- v-&gt;t
     ---------- (match-var)
     B,t,T |- v

   </pre><br>
</div>
<hr width="100%">
<br>
Binary Analysis Rule Engine (BARE).
<p>

    The Binary Analysis Rule Engine is a production system (a forward
    chaining rule system) that is used in the Binary Analysis
    Platform, and features non-linear pattern matching and a stream
    based approach to the state of the world.
<p>

    BARE defines the syntax and semantics of a rule specification
    language, and provides a simple pattern matching engine. The
    semantics of facts, as well as the semantics of the evaluation
    loop are left to concrete implementations of interpreters.
<p>

    A BARE specification consists of a sequence of rules. Each rule is
    a pair. The first element, called the left hand side, is a list of
    tuples that represents patterns that should be matched with
    facts. The second element, called the right hand side, is a list
    of tuples that represents the list of facts that should be
    produced once all patterns on the left hand side match with the
    provided facts. A rule is applied to a stream of facts, if all
    patterns in a rule matches with some facts, then a rule is
    triggered and produces facts from the right hand side. A rule may
    have variables on the left hand side, that will bind to elements
    of a fact tuple that matched with a pattern. The same variable may
    occur in different patterns of the same rule, i.e., a pattern is not
    required to be linear. When the same variable occurs in two
    patterns of the same rule, then a constraint is imposed that this
    variable should be bound to the same term in both patterns. The
    order of the patterns in the left hand side doesn't matter, thus
    the semantics of rule doesn't change with the permutation of its
    patterns. The order of facts may matter, depending on a concrete
    interpretation of fact. If a rule is applied to different
    permutations of a list of facts it may produce different sequences
    of facts, though all derivable facts will be produced.
<p>

    BARE represents tuples with S-expressions and variables with atoms
    that start with the question mark (?). A single question mark
    character represents a wild card variable that matches with
    everything but cannot be used on the right hand side of a
    rule. Since the right hand side of a rule may contain more than
    one pattern the engine will perform the join operation on a stream
    of events. Given that any join operation generates a number of
    matches that is in general a polynomial function of the number of
    patterns, a caution should be used by an expert who builds a
    system with complex rules that contains many patterns in the same
    rule. BARE can't apply any query optimization techniques on a
    rule, given the open and extensible notion of a fact. Thus BARE
    should be considered as a base representation for the
    pattern/action forward chanining systems, that shall perform all
    the necessary optimizations on their level.
<p>

    <h2 id="2_Example">Example</h2>
<p>

    Suppose we want to process a stream of events that represent the
    behavior of some memory allocator. We expect the following kinds
    of events:
<p>
<ul>
<li><code class="code">(acquire&nbsp;<span class="constructor">SITE</span>&nbsp;<span class="constructor">PTR</span>&nbsp;<span class="constructor">LEN</span>)</code> represents an allocation event, where
       SITE is an allocation site (i.e., an address of a program
       instruction that perfroms an allocation), <code class="code"><span class="constructor">PTR</span></code> is a pointer to
       the allocated data, and <code class="code"><span class="constructor">LEN</span></code> is the data size;</li>
</ul>
<ul>
<li><code class="code">(release&nbsp;<span class="constructor">SITE</span>&nbsp;<span class="constructor">PTR</span>&nbsp;<span class="constructor">LEN</span>)</code> represents a memory deallocation
       event;</li>
</ul>
<ul>
<li><code class="code">(violate&nbsp;<span class="constructor">SITE</span>&nbsp;<span class="constructor">PTR</span>&nbsp;<span class="constructor">KIND</span>)</code> represents a violation of a memory
       allocator invariants of the specified KIND.</li>
</ul>

     Suppose we want to build a rule, that will report each violation
     as a tuple that contains a kind of the violation and all three
     sites, that are involved in the incident.
<p>

    <pre class="verbatim">    (((acquire ?asite ?ptr ?)
      (release ?rsite ?ptr ?)
      (violate ?vsite ?ptr ?kind)

     ((?kind ?asite ?rsite ?vsite)))
   </pre>
<p>

    This rule can be read as, for all acquire, release, and violate
    events that have the same <code class="code"><span class="constructor">PTR</span></code> produce a fact of a violation of
    the specified kind that contains the program locations of these
    three events. For example, given the following sequence of events:
<p>

    <pre class="verbatim">      (acquire L10 0xBAD 10)
      (release L20 0XBAD 10)
      (violate L30 0XBAD use-after-free)
      (violate L40 0xBAD double-free)
      (violate L50 0XBAD use-after-free)
   </pre>
<p>

    The following facts will be produced if the rule is sequentially
    applied to the above sequence:
<p>

    <pre class="verbatim">      (use-after-free L10 L20 L30)
      (double-free L10 L20 L40)
      (use-after-free L10 L20 L50)
   </pre>
<p>

    <h2 id="2_Syntax">Syntax</h2>
<p>

    <h3 id="3_ConcreteSyntax">Concrete Syntax</h3>
<p>

    A tuple is represented by an arbitrary S-expression. A variable is
    an atom that starts with the question mark. A special variable <code class="code">?</code>
    (one question mark symbol) may occur on the left hand side of a
    rule, and represents a freshly created variable. Every occurence
    of the <code class="code">?</code> symbol represents a different variable. Both sides of a
    rule may be empty (represented by the 0-tuple <code class="code">()</code>).
<p>

    <pre class="verbatim">    rule,r  ::= ((p1 .. pM) (f1 .. fN))
    sexp,s  ::= atom | (s1 .. sM)
    patt,p  ::= sexp
    fact,f  ::= sexp
    atom,a  ::= ?sequence-of-chars?
   </pre>
<p>

    Example:
    <pre class="verbatim">    (((duck ?name) (does ?action)) ((looks like ?name did ?action)))
   </pre>
<p>

    This rule contains two patterns <code class="code">(duck&nbsp;?name)</code> and <code class="code">(does&nbsp;?action)</code>
    and one production fact <code class="code">(looks&nbsp;like&nbsp;?name&nbsp;did&nbsp;?action)</code>.
<p>

    <h3 id="3_AbstractSyntax">Abstract Syntax</h3>
<p>

    A rule r is a tuple (P,F) where P is a sequence of patterns
    p1,...,pM, F is a sequence of facts f1,...,fN, and M,N are
    non-negative numbers. A pattern p and fact f are arbitrary
    n-tuples (terms) t, that contain atoms, other tuples, and free
    variables.
<p>

    <pre class="verbatim">    rule,r ::= (B,P,F)
    P ::= p1,...
    F ::= f1,...
    B ::= v1-&gt;f,...
    V ::= v1,...
    T ::= t1,...
    term,p,f,s,t ::= v | a | (t,..,tM)
    atom,x,y,z ::= ?atom?
    v ::= ?variable?
   </pre>
<p>

    <h2 id="2_Semantics">Semantics</h2>
<p>

    We use a regular sequent calculus (with all structural rules) to
    represent semantics. A rule with a sequence of patterns P matches
    with a sequence of facts with the given valuations, denoted as
    <code class="code"><span class="constructor">B</span>,<span class="constructor">T</span>&nbsp;|-&nbsp;<span class="constructor">P</span></code>, if it can be proved using the rules below (plus
    regular rules of the sequent calculus). The (match-rule) rule,
    expands rules (eliminating tuples on the top level). The
    (match-tuple) rule further expands patterns until each pattern is
    either an atom, in that case it is proved by the axiom of
    identity, or to a variable, in that case a match can be proved with
    the (match-var) rule, that says that a variable matches a
    term only if it is bound to that term.
<p>

    Note, that exchange and weakening rules of sequent calculus allows
    us to drop and rearrange facts. The latter makes the order of
    rules irrelevant. If for a sequence of facts, there are several
    valuations of variables that will lead to a match, then all these
    matches are provided. In other words, the engine will generate all
    derivable facts in an unspecified but consistent order.
<p>

    <pre class="verbatim">
     B,T |- p1 .. B,T |- pM
     ----------------------- (match-rule)
     B,T |- (p1,..,pM)


     B,t1,T |- s1 .. B,tM,T |- sM
     ---------------------------- (match-tuple)
     B,(t1,..,tM),T |- (s1,..,sM)


     B,T |- v-&gt;t
     ---------- (match-var)
     B,t,T |- v

   </pre><br>

<pre><span id="TYPEtuple"><span class="keyword">type</span> <code class="type"></code>tuple</span> = <code class="type">Sexp.t</code> </pre>
<div class="info ">
representation of a tuple<br>
</div>


<pre><span id="TYPEfact"><span class="keyword">type</span> <code class="type"></code>fact</span> = <code class="type"><a href="Bare.html#TYPEtuple">tuple</a></code> </pre>
<div class="info ">
representation of a fact<br>
</div>


<pre><span class="keyword">module</span> <a href="Bare.Rule.html">Rule</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bare.Rule.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Matching rule specification.
</div>
</body></html>