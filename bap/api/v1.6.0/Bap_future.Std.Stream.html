<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap_future.Std.Promise.html">
<link rel="next" href="Bap_future.Std.Signal.html">
<link rel="Up" href="Bap_future.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Subscriber interface" rel="Section" href="#2_Subscriberinterface">
<link title="Publisher interface" rel="Section" href="#2_Publisherinterface">
<link title="Combinators" rel="Section" href="#2_Combinators">
<title>BAR: BAP Annotated Reference : Bap_future.Std.Stream</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap_future.Std.Promise.html" title="Bap_future.Std.Promise">Previous</a>
&nbsp;<a class="up" href="Bap_future.Std.html" title="Bap_future.Std">Up</a>
&nbsp;<a class="post" href="Bap_future.Std.Signal.html" title="Bap_future.Std.Signal">Next</a>
</div>
<h1>Module <a href="type_Bap_future.Std.Stream.html">Bap_future.Std.Stream</a></h1>

<pre><span class="keyword">module</span> Stream: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_future.Std.Stream.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
A stream of elements.
<p>

      A stream is an infinite sequence of elements. Since the stream
      is defined coinductively it can be processed only
      corecursively. That means that in general, one cannot aggregate
      a stream into normal (inductive) data. But it is still possible
      to get an aggregate snapshot of some intermediate state in the
      form of futures.
<p>

      Streams can be observed and combined. There is no built in
      notion of the end of stream and all streams are considered
      infinite. It is still possible to simulate an end of stream, by
      using futures, that designates the end of stream condition.
<p>

      Streams can be made lazy in the sense that if no one is watching
      a stream, then no work should be performed to feed the
      stream. This requires some cooperation from the feeder, as it
      should use <code class="code">on_subscribe</code> and <code class="code">on_unsubscribe</code> functions, to
      react on user's subsriptions. The <code class="code">has_subscribers</code> is also
      useful.
<p>

      Streams also provide some mechanism for a pushback, that allows
      a cooperative sink to limit his rate. The pushback interface
      consists of two functions:
<p>
<ul>
<li><code class="code">wait</code> that should be called by a consumer, when it wants to ask
      a producer to wait for a moment;</li>
</ul>
<ul>
<li><code class="code">on_wait</code> that is called when any consumer requested for a
      pause.</li>
</ul>

      The pushback interface is not mandatory.<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">'a <a href="Bap_future.Std.html#TYPEstream">Bap_future.Std.stream</a></code> </pre>


<pre><span id="TYPEid"><span class="keyword">type</span> <code class="type"></code>id</span> </pre>


<pre><span class="keyword">module</span> <a href="Bap_future.Std.Stream.Variadic.html">Variadic</a>: <code class="type"><a href="Bap_future.Std.Variadic.S.html">Bap_future.Std.Variadic.S</a></code><code class="type">  with type 'a arg = 'a t</code></pre>
<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">unit -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * 'a <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a></code></pre><div class="info ">
<code class="code">create&nbsp;()</code> retuns a stream and a signal handler that is used
        to feed the stream. Every time a value is signaled, it will
        occur in the stream.<br>
</div>

<pre><span id="VALfrom"><span class="keyword">val</span> from</span> : <code class="type">(unit -> 'a) -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a></code></pre><div class="info ">
<code class="code">from&nbsp;f</code> returns a stream that is generated from successive
        applications of a function <code class="code">f</code>. A new value is produced by a
        stream, every time it is signaled with associated signal
        handler.<br>
</div>

<pre><span id="VALunfold"><span class="keyword">val</span> unfold</span> : <code class="type">init:'b -><br>       f:('b -> 'a * 'b) -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a></code></pre><div class="info ">
<code class="code">unfold&nbsp;~init&nbsp;~f</code> a more general than <code class="code">from</code> way of building a
        stream, that allows to pass state between consecutive
        invocations of the generator function.  A new value is
        produced by a stream, every time it is signaled with an
        associated signal handler.<br>
</div>

<pre><span id="VALunfold_until"><span class="keyword">val</span> unfold_until</span> : <code class="type">init:'b -><br>       f:('b -> ('a * 'b) option) -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a> *<br>       unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">unfold_until&nbsp;~init&nbsp;~f</code> returns <code class="code">(stream,signal,future)</code> is the
        same as <code class="code">unfold</code>, except that function <code class="code">f</code> is called until it
        returns a <code class="code"><span class="constructor">None</span></code> value. Once this happens, the <code class="code">future</code>
        becomes determined.<br>
</div>

<pre><span id="VALunfold'"><span class="keyword">val</span> unfold'</span> : <code class="type">init:'b -><br>       f:('b -> 'a Queue.t * 'b) -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a></code></pre><div class="info ">
<code class="code">unfold'&nbsp;~init&nbsp;~f</code> is a batched version of the <code class="code">unfold</code>
        function. A new value is produced by a stream, every time it
        is signaled with associated signal handler.<br>
</div>

<pre><span id="VALrepeat"><span class="keyword">val</span> repeat</span> : <code class="type">'a -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a></code></pre><div class="info ">
<code class="code">repeat&nbsp;x</code> returns a stream <code class="code">xs</code> and a signal <code class="code">s</code>. Every time
        <code class="code">s</code> is signaled stream <code class="code">xs</code> will produce a value <code class="code">x</code><br>
</div>

<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type">'a list -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a> *<br>       unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">of_list&nbsp;xs</code> returns a stream <code class="code">ss</code>, a signal <code class="code">s</code> and a future
        <code class="code">es</code>. Stream will produce consequently elements of <code class="code">xs</code> every
        time the signal <code class="code">s</code> is sent. Once all elements are produced
        the future <code class="code">es</code> will occur signifying the end of the
        underlying sequence. All consecutive signals from <code class="code">es</code> are
        ignored.<br>
</div>

<pre><span id="VALof_array"><span class="keyword">val</span> of_array</span> : <code class="type">'a array -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a> *<br>       unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">of_array&nbsp;xs</code> returns a stream <code class="code">ss</code>, a signal <code class="code">s</code> and a future
        <code class="code">es</code>. Stream will produce consequently elements of <code class="code">xs</code> every
        time the signal <code class="code">s</code> is sent. Once all elements are produced
        the future <code class="code">es</code> will occur signifying the end of the
        underlying sequence. All consecutive signals from <code class="code">es</code> are
        ignored.<br>
</div>

<pre><span id="VALof_sequence"><span class="keyword">val</span> of_sequence</span> : <code class="type">'a Sequence.t -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * unit <a href="Bap_future.Std.html#TYPEsignal">Bap_future.Std.signal</a> *<br>       unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">of_seq&nbsp;xs</code> returns a stream <code class="code">ss</code>, a signal <code class="code">s</code> and a future
        <code class="code">es</code>. Stream will produce consequently elements of <code class="code">xs</code> every
        time the signal <code class="code">s</code> is sent. Once all elements are produced
        the future <code class="code">es</code> will occur signifying the end of the
        underlying sequence. All consecutive signals from <code class="code">es</code> are
        ignored.<br>
</div>
<br>
<h2 id="2_Subscriberinterface">Subscriber interface</h2>
<p>

        In order to start to monitor a stream, a user should subscribe
        to the stream using one of the subscription functions:
        <code class="code">watch</code>, <code class="code">observe</code>, <code class="code">subscribe</code>.
<p>

        The subscription can be canceled by using an <code class="code">unsubscribe</code>
        function, or by throwing an exception from the callback
        function. The latter plays well with `with_return` function.<br>

<pre><span id="VALwatch"><span class="keyword">val</span> watch</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       (<a href="Bap_future.Std.Stream.html#TYPEid">id</a> -> 'a -> unit) -> unit</code></pre><div class="info ">
<code class="code">watch&nbsp;s&nbsp;f</code> watches a stream <code class="code">s</code> with a function <code class="code">f</code>.  A
        subscription identifier is passed to the function, so it can
        be used to unsubscribe from the stream directly from the
        function.<br>
</div>

<pre><span id="VALobserve"><span class="keyword">val</span> observe</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> ('a -> unit) -> unit</code></pre><div class="info ">
<code class="code">observe&nbsp;s&nbsp;f</code> is like <code class="code">watch</code> but a subscription identifier is
        not passed to the function <code class="code">f</code>.<br>
</div>

<pre><span id="VALsubscribe"><span class="keyword">val</span> subscribe</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> ('a -> unit) -> <a href="Bap_future.Std.Stream.html#TYPEid">id</a></code></pre><div class="info ">
<code class="code">subscribe&nbsp;s&nbsp;f</code> subscribe to a stream <code class="code">s</code> with a function
        <code class="code">f</code>. A subscription identifier is returned.<br>
</div>

<pre><span id="VALunsubscribe"><span class="keyword">val</span> unsubscribe</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> <a href="Bap_future.Std.Stream.html#TYPEid">id</a> -> unit</code></pre><div class="info ">
<code class="code">unsubscribe&nbsp;s&nbsp;id</code> stop calling a function that was has a
        provided identifier <code class="code">id</code><br>
</div>

<pre><span id="VALwait"><span class="keyword">val</span> wait</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
<code class="code">wait&nbsp;xs</code> a polite way to notify a producer to slow down.
        Note: producer is not required to obey.<br>
</div>
<br>
<h2 id="2_Publisherinterface">Publisher interface</h2><br>

<pre><span id="VALhas_subscribers"><span class="keyword">val</span> has_subscribers</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">has_subscribers&nbsp;s</code> is true if someone is watching for the stream<br>
</div>

<pre><span id="VALon_subscribe"><span class="keyword">val</span> on_subscribe</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> (<a href="Bap_future.Std.Stream.html#TYPEid">id</a> -> unit) -> unit</code></pre><div class="info ">
<code class="code">on_subscribe&nbsp;s&nbsp;f</code> will call a function <code class="code">f</code> every time someone
        is subscribed to a stream <code class="code">s</code><br>
</div>

<pre><span id="VALon_unsubscribe"><span class="keyword">val</span> on_unsubscribe</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> (<a href="Bap_future.Std.Stream.html#TYPEid">id</a> -> unit) -> unit</code></pre><div class="info ">
<code class="code">on_unsubscribe&nbsp;s&nbsp;f</code> will call a function <code class="code">f</code> every time
        someone has canceled subscription to a stream <code class="code">s</code><br>
</div>

<pre><span id="VALon_wait"><span class="keyword">val</span> on_wait</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> (unit -> unit) -> unit</code></pre><div class="info ">
<code class="code">on_wait&nbsp;s&nbsp;f</code> will be called every time someone, watching a
        stream <code class="code">s</code>, will call <code class="code">wait&nbsp;s</code> to ask a producer to slow down.<br>
</div>
<br>
<h2 id="2_Combinators">Combinators</h2><br>

<pre><span id="VALmap'"><span class="keyword">val</span> map'</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       f:('a -> 'b Queue.t) -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">s'&nbsp;=&nbsp;map'&nbsp;s&nbsp;~f</code> apply function <code class="code">f</code> for each value of a
        stream <code class="code">s</code> and push values from a resulting queue into the
        stream <code class="code">s'</code>.
        Example:
        <pre class="codepre"><code class="code">          <span class="keyword">let</span> q,p = of_list [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>, <span class="string">'.'</span>]
          <span class="keyword">let</span> q' = map q ~f:(<span class="keyword">function</span>
              <span class="keywordsign">|</span> <span class="string">'a'</span>..<span class="string">'z'</span> <span class="keyword">as</span> c <span class="keywordsign">-&gt;</span>
                <span class="constructor">Queue</span>.of_list <span class="constructor">Char</span>.[uppercase c; lowercase c]
              <span class="keywordsign">|</span> c <span class="keywordsign">-&gt;</span> <span class="constructor">Queue</span>.singleton c
        </code></pre>
<p>

        Will produce:
<p>

        <code class="code">&lt;<span class="constructor">A</span>;&nbsp;a;&nbsp;<span class="constructor">B</span>;&nbsp;b;&nbsp;<span class="constructor">C</span>;&nbsp;c;&nbsp;.&gt;</code><br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> f:('a -> 'b) -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">map&nbsp;ss&nbsp;~f</code> returns new stream, that is build by application
        of a function <code class="code">f</code> to each element of the stream <code class="code">ss</code><br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       f:('a -> 'b option) -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">filter_map&nbsp;s&nbsp;~f</code> for each value <code class="code">x</code> in stream <code class="code">s</code>, produce
        <code class="code">y</code> if <code class="code">f&nbsp;x</code> is <code class="code"><span class="constructor">Some</span>&nbsp;y</code>, otherwise ignore <code class="code">x</code><br>
</div>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> f:('a -> bool) -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">filter&nbsp;s&nbsp;f</code> produce a stream that contains the elements of
        stream <code class="code">s</code>, for which <code class="code">f</code> evaluates to true.<br>
</div>

<pre><span id="VALeither"><span class="keyword">val</span> either</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       ('a, 'b) Either.t <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">either&nbsp;xs&nbsp;ys</code> is a discriminated union of two streams.<br>
</div>

<pre><span id="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       f:('a -> 'b -> 'c) -> 'c <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">merge&nbsp;xs&nbsp;ys&nbsp;f</code> merges streams <code class="code">xs</code> and <code class="code">ys</code> using function
        <code class="code">f</code>.<br>
</div>

<pre><span id="VALapply"><span class="keyword">val</span> apply</span> : <code class="type">('a -> 'b) <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">apply&nbsp;fs&nbsp;xs</code> apply stream of functions <code class="code">fs</code> to a stream of
        values xs, producing a stream of results.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> list -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">concat&nbsp;ss</code> returns a stream that will produce elements from 
        the input list of streams <code class="code">ss</code>. The ordering of the elements
        of different streams is unspecified, though it is guaranteed
        that elements of the same stream will preserve their ordering.<br>
</div>

<pre><span id="VALconcat_merge"><span class="keyword">val</span> concat_merge</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> list -><br>       f:('a -> 'a -> 'a) -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">concat_merge&nbsp;xs&nbsp;~f</code> builds a stream, that will 
        produce elements from the input list and applies <code class="code">f</code> to all 
        consecutive elements. The ordering of the input list does not 
        mandate the ordering of elemenets in the output stream, and is
        undefined. See <code class="code">concat</code> for more information.<br>
</div>

<pre><span id="VALsplit"><span class="keyword">val</span> split</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       f:('a -> 'b * 'c) -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * 'c <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">split&nbsp;xs&nbsp;~f</code> returns a pair of streams, where the first stream 
        contains <code class="code">fst&nbsp;(f&nbsp;x)</code> for each <code class="code">x</code> in <code class="code">xs</code> and the second stream
        contains <code class="code">snd&nbsp;(f&nbsp;x)</code> for each <code class="code">x</code> in <code class="code">xs</code>.<br>
</div>

<pre><span id="VALzip"><span class="keyword">val</span> zip</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> ('a * 'b) <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">zip&nbsp;xs&nbsp;ys</code> creates a steam that will produce an element <code class="code">(x,y)</code> 
        every time both <code class="code">xs</code> and <code class="code">ys</code> produce elements <code class="code">x</code> and <code class="code">y</code> respectively<br>
</div>

<pre><span id="VALunzip"><span class="keyword">val</span> unzip</span> : <code class="type">('a * 'b) <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> * 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">unzip&nbsp;xs</code> creates a pair of streams, where the first stream contains
        <code class="code">fst&nbsp;x</code> for each <code class="code">x</code> in <code class="code">xs</code> and the second stream contains <code class="code">snd&nbsp;x</code> for
        each <code class="code">x</code> in <code class="code">xs</code>. Essentially, the same as <code class="code">split&nbsp;~f:ident</code><br>
</div>

<pre><span id="VALonce"><span class="keyword">val</span> once</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">once&nbsp;xs</code> creates a stream that will at most contain the next value 
        produced by <code class="code">xs</code> and nothing more.<br>
</div>

<pre><span id="VALparse"><span class="keyword">val</span> parse</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       init:'b -> f:('b -> 'a -> 'c option * 'b) -> 'c <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">parse&nbsp;ss&nbsp;~init&nbsp;~f</code> parses stream <code class="code">ss</code> and builds new stream
        <code class="code">ss'</code>. Function <code class="code">f</code> is applied to each consecutive element of
        the stream <code class="code">ss</code> with a state <code class="code">s</code>. If function <code class="code">f</code> returns
        <code class="code"><span class="constructor">None</span>,s'</code>, then no value is produced in the output state and
        state <code class="code">s'</code> is passed to the next invocation of function
        <code class="code">f</code>. If it returns <code class="code"><span class="constructor">Some</span>&nbsp;x,&nbsp;s'</code>, then value <code class="code">x</code> is produced by
        the output stream and state <code class="code">s'</code> is passed to a consecutive
        invocation of <code class="code">f</code>. If it state type <code class="code"><span class="keywordsign">'</span>b</code> is an instance of a
        list type, then parse will be a push down automaton. With
        arbitrary type of state it is possible to build automatons
        that falls between PDA and Turing Machine (not including the
        latter).<br>
</div>

<pre><span id="VALfoldw"><span class="keyword">val</span> foldw</span> : <code class="type">?stride:int -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       int -> init:'b -> f:('b -> 'a -> 'b) -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">foldw&nbsp;ss&nbsp;n&nbsp;~init&nbsp;~f</code> performs a windowed fold of the stream.
        A function <code class="code">f</code> is folded over <code class="code">n</code> consecutive elements of <code class="code">ss</code>,
        then the result is produced into the output stream, the window
        is shifted by <code class="code">stride</code> (defaults to one) and function <code class="code">f</code>
        applied to the next <code class="code">n</code> elements. For example, if stream <code class="code">ss</code>
        produced the following sequence of elements:
<p>

        <pre class="codepre"><code class="code">1,2,3,4,5,6,7,8</code></pre>
<p>

        and windows length <code class="code">n</code> is equal to <code class="code">3</code>, then the function <code class="code">f</code>
        will be applied to a sequences:
        <pre class="codepre"><code class="code">[1,2,3], [2,3,4], [3,4,5], [4,5,6], [5,6,7], [6,7,8]</code></pre>.
<p>

        Example, a moving average filter implemented with <code class="code">foldw</code>:
<p>

        <pre class="codepre"><code class="code">          <span class="keyword">let</span> moving_average ss n =
            <span class="constructor">Float</span>.(foldw ss n ~init:zero ~f:(+) &gt;&gt;| <span class="keyword">fun</span> s / of_int n)

        </code></pre><br>
</div>

<pre><span id="VALframe"><span class="keyword">val</span> frame</span> : <code class="type">clk:unit <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       init:'b -> f:('b -> 'a -> 'b) -> 'b <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">frame&nbsp;~clk&nbsp;s&nbsp;~init&nbsp;~f</code> will gather elements of <code class="code">s</code> into frames,
        where the start of the new frame is signaled by a stream <code class="code">clk</code>.
        The function is very similar to <code class="code">foldw</code> except, that the window
        is determined dynamically by a <code class="code">clk</code> stream. This function is
        useful to build custom time scales.
<p>

        The semantics of the function can be clarified with the
        following description:
        1. Every time a stream <code class="code">s</code> produces a value it is buffered
        2. Every time a stream <code class="code">clk</code> produces a value, a function <code class="code">f</code>
           is folded over all buffered value, and the result is put
           into the output stream. The internal buffer is cleared
           afterwards.
<p>

        Example
        -------
<p>

        Consider the following timing diagram, where each row
        represents a stream, and columns represent time. Elements of
        the <code class="code">clk</code> stream are depicted with a <code class="code"><span class="constructor">T</span></code> symbol.
<p>

        <pre class="verbatim">          clk:    T         T        T  T      T     T
           ss: 123 56 123 12  1234 4      1234  1
       </pre>
<p>

        will be framed in the following way:
<p>

        <code class="code">[123],&nbsp;[5612312],&nbsp;[12344],&nbsp;[],&nbsp;[1234],&nbsp;[1]</code>
<p>

        Note: since all streams should be serialized it is impossible,
        that two events occur at the same time. So at the same column
        of the timing diagram there can be only one event.<br>
</div>

<pre><span id="VALsample"><span class="keyword">val</span> sample</span> : <code class="type">clk:unit <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'a option <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">sample&nbsp;~clk&nbsp;ss</code> is semantically the same as
        <code class="code">frame&nbsp;~clk&nbsp;ss&nbsp;&gt;&gt;|&nbsp;fst</code><br>
</div>

<pre><span id="VALhd"><span class="keyword">val</span> hd</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'a <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">hd&nbsp;s</code> returns a <code class="code">future</code> that will occur as soon, as stream
        <code class="code">s</code> will produce a value.
        Note: if <code class="code">hd</code> is called on a stream, that already produced
        some values, the returned future will still be fulfilled on
        the first value, that will be put into the stream after the
        future is created.<br>
</div>

<pre><span id="VALtl"><span class="keyword">val</span> tl</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">tl&nbsp;s</code> ignores the next occurrence in the stream <code class="code">s</code><br>
</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> f:('a -> bool) -> 'a <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">find&nbsp;xs&nbsp;f</code> returns a future that will be fulfilled with a
        first value for which a function <code class="code">f</code> is <code class="code"><span class="keyword">true</span></code>.<br>
</div>

<pre><span id="VALfind_map"><span class="keyword">val</span> find_map</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> f:('a -> 'b option) -> 'b <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">find_map&nbsp;xs&nbsp;f</code> returns a future that will be fulfilled by a
        result of a first invocation of <code class="code">f</code> to an element of the stream,
        that evaluated to <code class="code"><span class="constructor">Some</span></code> value<br>
</div>

<pre><span id="VALtake"><span class="keyword">val</span> take</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> int -> 'a list <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">take&nbsp;xs&nbsp;n</code> returns a future that will evaluate to <code class="code">n</code> values
        of the stream <code class="code">xs</code> that has occurred after the future was
        created.<br>
</div>

<pre><span id="VALnth"><span class="keyword">val</span> nth</span> : <code class="type">'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> int -> 'a <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">nth&nbsp;xs&nbsp;n</code> returns <code class="code">n</code>'th element of the stream <code class="code">xs</code>. The
        element is <code class="code">n</code>'th with respect to the future <code class="code">f</code>, if was <code class="code">n</code>'th
        element of the stream after the creation of the stream.<br>
</div>

<pre><span id="VALupon"><span class="keyword">val</span> upon</span> : <code class="type">unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'a <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">upon&nbsp;e&nbsp;xs</code> returns a future that will be fulfilled with a
        last value of a stream <code class="code">xs</code> before an event <code class="code">e</code> has
        occurred. If at the time when the event <code class="code">e</code> occurs, the stream
        <code class="code">xs</code> didn't produce any elements, then the future will not be
        fulfilled.<br>
</div>

<pre><span id="VALbefore"><span class="keyword">val</span> before</span> : <code class="type">unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> 'a list <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">before&nbsp;e&nbsp;xs</code> returns a list that contains elements of
        the stream <code class="code">xs</code> that occurred before the event <code class="code">e</code><br>
</div>

<pre><span id="VALlast_before"><span class="keyword">val</span> last_before</span> : <code class="type">unit <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a> -><br>       'a <a href="Bap_future.Std.Stream.html#TYPEt">t</a> -> int -> 'a list <a href="Bap_future.Std.html#TYPEfuture">Bap_future.Std.future</a></code></pre><div class="info ">
<code class="code">last_before&nbsp;e&nbsp;xs&nbsp;n</code> returns a list of length up to <code class="code">n</code>, that
        contains last elements of the stream <code class="code">xs</code> that occurred before the
        event <code class="code">e</code><br>
</div>
</body></html>