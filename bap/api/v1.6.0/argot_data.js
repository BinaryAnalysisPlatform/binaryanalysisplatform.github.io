add_ocaml_element("int", "int", "type", "int", "", "built-in", []);
add_ocaml_element("char", "char", "type", "char", "", "built-in", []);
add_ocaml_element("string", "string", "type", "string", "", "built-in", []);
add_ocaml_element("float", "float", "type", "float", "", "built-in", []);
add_ocaml_element("bool", "bool", "type", "bool", "", "built-in", []);
add_ocaml_element("unit", "unit", "type", "unit", "", "built-in", []);
add_ocaml_element("exn", "exn", "type", "exn", "", "built-in", []);
add_ocaml_element("array", "array", "type", "array", "", "built-in", []);
add_ocaml_element("list", "list", "type", "list", "", "built-in", []);
add_ocaml_element("option", "option", "type", "option", "", "built-in", []);
add_ocaml_element("int32", "int32", "type", "int32", "", "built-in", []);
add_ocaml_element("int64", "int64", "type", "int64", "", "built-in", []);
add_ocaml_element("nativeint", "nativeint", "type", "nativeint", "", "built-in", []);
add_ocaml_element("format4", "format4", "type", "format4", "", "built-in", []);
add_ocaml_element("lazy_t", "lazy_t", "type", "lazy_t", "", "built-in", []);
add_ocaml_element("Match_failure", "Match_failure", "exception", "string * int * int", "", "built-in", []);
add_ocaml_element("Assert_failure", "Assert_failure", "exception", "string * int * int", "", "built-in", []);
add_ocaml_element("Invalid_argument", "Invalid_argument", "exception", "string", "", "built-in", []);
add_ocaml_element("Failure", "Failure", "exception", "string", "", "built-in", []);
add_ocaml_element("Not_found", "Not_found", "exception", "", "", "built-in", []);
add_ocaml_element("Out_of_memory", "Out_of_memory", "exception", "", "", "built-in", []);
add_ocaml_element("Stack_overflow", "Stack_overflow", "exception", "", "", "built-in", []);
add_ocaml_element("Sys_error", "Sys_error", "exception", "string", "", "built-in", []);
add_ocaml_element("End_of_file", "End_of_file", "exception", "", "", "built-in", []);
add_ocaml_element("Division_by_zero", "Division_by_zero", "exception", "", "", "built-in", []);
add_ocaml_element("Sys_blocked_io", "Sys_blocked_io", "exception", "", "", "built-in", []);
add_ocaml_element("Undefined_recursive_module", "Undefined_recursive_module", "exception", "string * int * int", "", "built-in", []);
add_ocaml_element("Some", "Some", "constructor", "option", "", "built-in", []);
add_ocaml_element("None", "None", "constructor", "option", "", "built-in", []);
add_manifest("'a181 Std.Seq.t", "'a181 Std.Seq.t", "Std.seq");
add_manifest("'a181 Std.seq", "'a181 Std.seq", "Std.seq");
add_manifest("'a235 Std.Seq.t", "'a235 Std.Seq.t", "Std.seq");
add_manifest("'a235 Std.seq", "'a235 Std.seq", "Std.seq");
add_manifest("Std.Bitvector.Stable.V1.t", "Std.Bitvector.Stable.V1.t", "Std.word");
add_manifest("Std.Bitvector.Stable.V2.t", "Std.Bitvector.Stable.V2.t", "Std.word");
add_manifest("Std.Bitvector.t", "Std.Bitvector.t", "Std.word");
add_manifest("Std.addr", "Std.addr", "Std.word");
add_manifest("Std.Size.all Std.Size.p", "Std.Size.all Std.Size.p", "Std.size");
add_manifest("Std.Size.t", "Std.Size.t", "Std.size");
add_manifest("Std.addr_size", "Std.addr_size", "[ `r32 | `r64 ] Std.Size.p");
add_manifest("Std.Bil.typ", "Std.Bil.typ", "Std.typ");
add_manifest("Std.Bil.var", "Std.Bil.var", "Std.var");
add_manifest("Std.Var.t", "Std.Var.t", "Std.var");
add_manifest("Std.Bil.t", "Std.Bil.t", "stmt list");
add_manifest("Std.bil", "Std.bil", "stmt list");
add_manifest("Std.Bil.binop", "Std.Bil.binop", "Std.binop");
add_manifest("Std.Bil.cast", "Std.Bil.cast", "X86_types.cast_type");
add_manifest("Std.cast", "Std.cast", "X86_types.cast_type");
add_manifest("Std.Bil.exp", "Std.Bil.exp", "Std.exp");
add_manifest("Std.Exp.t", "Std.Exp.t", "Std.exp");
add_manifest("Std.Bil.stmt", "Std.Bil.stmt", "Std.stmt");
add_manifest("Std.Stmt.t", "Std.Stmt.t", "Std.stmt");
add_manifest("Std.Bil.unop", "Std.Bil.unop", "Std.unop");
add_manifest("Std.Type_error.t", "Std.Type_error.t", "Std.type_error");
add_manifest("Std.Arch.t", "Std.Arch.t", "[ `aarch64\n  | `aarch64_be\n  | `armv4\n  | `armv4eb\n  | `armv5\n  | `armv5eb\n  | `armv6\n  | `armv6eb\n  | `armv7\n  | `armv7eb\n  | `hexagon\n  | `mips\n  | `mips64\n  | `mips64el\n  | `mipsel\n  | `nvptx\n  | `nvptx64\n  | `ppc\n  | `ppc64\n  | `ppc64le\n  | `r600\n  | `sparc\n  | `sparcv9\n  | `systemz\n  | `thumbv4\n  | `thumbv4eb\n  | `thumbv5\n  | `thumbv5eb\n  | `thumbv6\n  | `thumbv6eb\n  | `thumbv7\n  | `thumbv7eb\n  | `x86\n  | `x86_64\n  | `xcore ]");
add_manifest("Std.arch", "Std.arch", "[ `aarch64\n  | `aarch64_be\n  | `armv4\n  | `armv4eb\n  | `armv5\n  | `armv5eb\n  | `armv6\n  | `armv6eb\n  | `armv7\n  | `armv7eb\n  | `hexagon\n  | `mips\n  | `mips64\n  | `mips64el\n  | `mipsel\n  | `nvptx\n  | `nvptx64\n  | `ppc\n  | `ppc64\n  | `ppc64le\n  | `r600\n  | `sparc\n  | `sparcv9\n  | `systemz\n  | `thumbv4\n  | `thumbv4eb\n  | `thumbv5\n  | `thumbv5eb\n  | `thumbv6\n  | `thumbv6eb\n  | `thumbv7\n  | `thumbv7eb\n  | `x86\n  | `x86_64\n  | `xcore ]");
add_manifest("'a234 Std.Value.tag", "'a234 Std.Value.tag", "Std.tag");
add_manifest("'a234 Std.tag", "'a234 Std.tag", "Std.tag");
add_manifest("Std.color", "Std.color", "[ `black\n  | `blue\n  | `cyan\n  | `gray\n  | `green\n  | `magenta\n  | `red\n  | `white\n  | `yellow ]");
add_manifest("(Std.addr) * (int)", "(Std.addr) * (int)", "Std.location");
add_manifest("Std.Location.t", "Std.Location.t", "Std.location");
add_manifest("Std.jump", "Std.jump", "[ `Cond | `Jump ]");
add_manifest("Std.edge", "Std.edge", "[ `Cond | `Fall | `Jump ]");
add_manifest("Std.Kind.t", "Std.Kind.t", "[ `Barrier\n  | `Call\n  | `Conditional_branch\n  | `Indirect_branch\n  | `May_affect_control_flow\n  | `May_load\n  | `May_store\n  | `Return\n  | `Terminator\n  | `Unconditional_branch ]");
add_manifest("Std.kind", "Std.kind", "[ `Barrier\n  | `Call\n  | `Conditional_branch\n  | `Indirect_branch\n  | `May_affect_control_flow\n  | `May_load\n  | `May_store\n  | `Return\n  | `Terminator\n  | `Unconditional_branch ]");
add_manifest("Std.Op.t", "Std.Op.t", "Std.op");
add_manifest("Std.lifter", "Std.lifter", "Std.mem ->\n  Std.Disasm_expert.Basic.full_insn -> Std.bil Or_error.t");
add_manifest("'a228 Std.Source.t", "'a228 Std.Source.t", "Std.source");
add_manifest("'a228 Std.source", "'a228 Std.source", "Std.source");
add_manifest("Std.Size.all", "Std.Size.all", "[ `r128 | `r16 | `r256 | `r32 | `r64 | `r8 ]");
add_manifest("Std.Size.p", "Std.Size.p", "[< Std.Size.all ] as 'p");
add_manifest("[< Std.Size.all ] Std.Size.p", "[< Std.Size.all ] Std.Size.p", "[< Std.Size.all ] as 'p");
add_manifest("(var, Std.Bil.var_compare) Set.t", "(var, Std.Bil.var_compare) Set.t", "Std.Bil.vars");
add_manifest("Std.Bil.Result.t", "Std.Bil.Result.t", "Std.Bil.result");
add_manifest("'a224 Std.Bil.Result.r", "'a224 Std.Bil.Result.r", "Std.Bil.Result.r");
add_manifest("(Std.Bil.result, 'a224) Std.Monad.State.t", "(Std.Bil.result, 'a224) Std.Monad.State.t", "Std.Bil.Result.r");
add_manifest("'a223 Std.Bil.Result.u", "'a223 Std.Bil.Result.u", "Std.Bil.Result.u");
add_manifest("(unit, 'a223) Std.Monad.State.t", "(unit, 'a223) Std.Monad.State.t", "Std.Bil.Result.u");
add_manifest("Std.Type.Error.t", "Std.Type.Error.t", "Std.Type.error");
add_manifest("'a222 M.t", "'a222 M.t", "Std.Eval.T1.m");
add_manifest("'a222 Std.Eval.T1.m", "'a222 Std.Eval.T1.m", "Std.Eval.T1.m");
add_manifest("('a221, 'e49) M.t", "('a221, 'e49) M.t", "Std.Eval.T2.m");
add_manifest("('a221, 'e49) Std.Eval.T2.m", "('a221, 'e49) Std.Eval.T2.m", "Std.Eval.T2.m");
add_manifest("'a217 Std.Expi.S.u", "'a217 Std.Expi.S.u", "Std.Expi.S.u");
add_manifest("(unit, 'a217) Std.Expi.S.state", "(unit, 'a217) Std.Expi.S.state", "Std.Expi.S.u");
add_manifest("'a216 Std.Expi.S.r", "'a216 Std.Expi.S.r", "Std.Expi.S.r");
add_manifest("(Std.Bil.result, 'a216) Std.Expi.S.state", "(Std.Bil.result, 'a216) Std.Expi.S.state", "Std.Expi.S.r");
add_manifest("'a214 Std.Bili.S.u", "'a214 Std.Bili.S.u", "Std.Bili.S.u");
add_manifest("(unit, 'a214) Std.Bili.S.state", "(unit, 'a214) Std.Bili.S.state", "Std.Bili.S.u");
add_manifest("'a213 Std.Bili.S.r", "'a213 Std.Bili.S.r", "Std.Bili.S.r");
add_manifest("(Std.Bil.result, 'a213) Std.Bili.S.state", "(Std.Bil.result, 'a213) Std.Bili.S.state", "Std.Bili.S.r");
add_manifest("Std.Arch.x86", "Std.Arch.x86", "[ `x86 | `x86_64 ]");
add_manifest("Std.Arch.arm", "Std.Arch.arm", "[ `armv4 | `armv5 | `armv6 | `armv7 ]");
add_manifest("Std.Arch.armeb", "Std.Arch.armeb", "[ `armv4eb | `armv5eb | `armv6eb | `armv7eb ]");
add_manifest("Std.Arch.thumb", "Std.Arch.thumb", "[ `thumbv4 | `thumbv5 | `thumbv6 | `thumbv7 ]");
add_manifest("Std.Arch.thumbeb", "Std.Arch.thumbeb", "[ `thumbv4eb | `thumbv5eb | `thumbv6eb | `thumbv7eb ]");
add_manifest("Std.Arch.aarch64", "Std.Arch.aarch64", "[ `aarch64 | `aarch64_be ]");
add_manifest("Std.Arch.ppc", "Std.Arch.ppc", "[ `ppc | `ppc64 | `ppc64le ]");
add_manifest("Std.Arch.mips", "Std.Arch.mips", "[ `mips | `mips64 | `mips64el | `mipsel ]");
add_manifest("Std.Arch.sparc", "Std.Arch.sparc", "[ `sparc | `sparcv9 ]");
add_manifest("Std.Arch.nvptx", "Std.Arch.nvptx", "[ `nvptx | `nvptx64 ]");
add_manifest("Std.Arch.hexagon", "Std.Arch.hexagon", "[ `hexagon ]");
add_manifest("Std.Arch.r600", "Std.Arch.r600", "[ `r600 ]");
add_manifest("Std.Arch.systemz", "Std.Arch.systemz", "[ `systemz ]");
add_manifest("Std.Arch.xcore", "Std.Arch.xcore", "[ `xcore ]");
add_manifest("Bap_traces.Std.Trace.event", "Bap_traces.Std.Trace.event", "Std.value");
add_manifest("Std.Value.t", "Std.Value.t", "Std.value");
add_manifest("(Std.Value.void, Std.Value.void, Std.Value.void)\n  format", "(Std.Value.void, Std.Value.void, Std.Value.void)\n  format", "Std.Value.literal");
add_manifest("'a211 Std.Value.Tag.t", "'a211 Std.Value.Tag.t", "Std.Value.Tag.t");
add_manifest("'a211 Std.Value.tag", "'a211 Std.Value.tag", "Std.Value.Tag.t");
add_manifest("Std.Dict.t", "Std.Dict.t", "Std.dict");
add_manifest("'a209 Std.Vector.t", "'a209 Std.Vector.t", "Std.Vector.t");
add_manifest("'a209 Std.vector", "'a209 Std.vector", "Std.Vector.t");
add_manifest("'a207 Std.Biri.S.u", "'a207 Std.Biri.S.u", "Std.Biri.S.u");
add_manifest("(unit, 'a207) Std.Biri.S.state", "(unit, 'a207) Std.Biri.S.state", "Std.Biri.S.u");
add_manifest("'a206 Std.Biri.S.r", "'a206 Std.Biri.S.r", "Std.Biri.S.r");
add_manifest("(Std.Bil.result, 'a206) Std.Biri.S.state", "(Std.Bil.result, 'a206) Std.Biri.S.state", "Std.Biri.S.r");
add_manifest("Std.Memory.t", "Std.Memory.t", "Std.mem");
add_manifest("'a205 Std.Memory.Input.reader", "'a205 Std.Memory.Input.reader", "Std.Memory.t ->\n  pos_ref:Std.addr ref -> 'a205 Or_error.t");
add_manifest("Std.Memory.Input.reader", "Std.Memory.Input.reader", "Std.Memory.t ->\n  pos_ref:Std.addr ref -> 'a205 Or_error.t");
add_manifest("'a203 Std.Table.t", "'a203 Std.Table.t", "Std.Table.t");
add_manifest("'a203 Std.table", "'a203 Std.table", "Std.Table.t");
add_manifest("'a202 Hashtbl.Hashable.t", "'a202 Hashtbl.Hashable.t", "Std.Table.hashable");
add_manifest("'a202 Std.Table.hashable", "'a202 Std.Table.hashable", "Std.Table.hashable");
add_manifest("'a200 Std.Table.ranged", "'a200 Std.Table.ranged", "Std.Table.ranged");
add_manifest("?start:Std.mem -> ?until:Std.mem -> 'a200", "?start:Std.mem -> ?until:Std.mem -> 'a200", "Std.Table.ranged");
add_manifest("Bigstring.t -> Std.Backend.Img.t option", "Bigstring.t -> Std.Backend.Img.t option", "Std.Backend.t");
add_manifest("(string) * (Std.Backend.perm) * (int) * (Std.location)", "(string) * (Std.Backend.perm) * (int) * (Std.location)", "Std.Backend.Segment.t");
add_manifest("(string) * (bool) * (bool) * (Std.location * Std.location list)", "(string) * (bool) * (bool) * (Std.location * Std.location list)", "Std.Backend.Symbol.t");
add_manifest("(string) * (Std.location)", "(string) * (Std.location)", "Std.Backend.Section.t");
add_manifest("(Std.arch) * (Std.addr) * (Std.Backend.Segment.t * Std.Backend.Segment.t list) * (Std.Backend.Symbol.t list) * (Std.Backend.Section.t list)", "(Std.arch) * (Std.addr) * (Std.Backend.Segment.t * Std.Backend.Segment.t list) * (Std.Backend.Symbol.t list) * (Std.Backend.Section.t list)", "Std.Backend.Img.t");
add_manifest("Std.Image.t", "Std.Image.t", "Std.image");
add_manifest("Bap_api.api", "Bap_api.api", "string");
add_manifest("Bap_api.filename", "Bap_api.filename", "string");
add_manifest("Std.Image.path", "Std.Image.path", "string");
add_manifest("Text_tags.mode", "Text_tags.mode", "string");
add_manifest("(Std.Image.t * Error.t list) Or_error.t", "(Std.Image.t * Error.t list) Or_error.t", "Std.Image.result");
add_manifest("Std.Image.Segment.t", "Std.Image.Segment.t", "Std.Image.segment");
add_manifest("Std.Image.Symbol.t", "Std.Image.Symbol.t", "Std.Image.symbol");
add_manifest("Std.Image.Scheme.addr", "Std.Image.Scheme.addr", "int64");
add_manifest("Std.Image.Scheme.off", "Std.Image.Scheme.off", "int64");
add_manifest("Std.Image.Scheme.size", "Std.Image.Scheme.size", "int64");
add_manifest("'a199 Std.Image.Scheme.region", "'a199 Std.Image.Scheme.region", "Std.Image.Scheme.region");
add_manifest("(Std.Image.Scheme.addr) * (Std.Image.Scheme.size) * ('a199)", "(Std.Image.Scheme.addr) * (Std.Image.Scheme.size) * ('a199)", "Std.Image.Scheme.region");
add_manifest("'a198 Std.Memmap.t", "'a198 Std.Memmap.t", "Std.Memmap.t");
add_manifest("'a198 Std.memmap", "'a198 Std.memmap", "Std.Memmap.t");
add_manifest("Std.Kind.branch", "Std.Kind.branch", "[ `Conditional_branch | `Indirect_branch | `Unconditional_branch ]");
add_manifest("Std.Kind.affecting_control", "Std.Kind.affecting_control", "[ `Barrier\n  | `Call\n  | `Conditional_branch\n  | `Indirect_branch\n  | `May_affect_control_flow\n  | `Return\n  | `Terminator\n  | `Unconditional_branch ]");
add_manifest("Std.Kind.having_side_effect", "Std.Kind.having_side_effect", "[ `May_load | `May_store ]");
add_manifest("Std.Reg.t", "Std.Reg.t", "Std.reg");
add_manifest("Std.Imm.t", "Std.Imm.t", "Std.imm");
add_manifest("Std.Fmm.t", "Std.Fmm.t", "Std.fmm");
add_manifest("Std.Disasm_expert.Basic.pred", "Std.Disasm_expert.Basic.pred", "[ `Barrier\n  | `Call\n  | `Conditional_branch\n  | `Indirect_branch\n  | `May_affect_control_flow\n  | `May_load\n  | `May_store\n  | `Return\n  | `Terminator\n  | `Unconditional_branch\n  | `Valid ]");
add_manifest("('a196, 'k3) Std.Disasm_expert.Basic.insns", "('a196, 'k3) Std.Disasm_expert.Basic.insns", "Std.Disasm_expert.Basic.insns");
add_manifest("(Std.mem * ('a196, 'k3) Std.Disasm_expert.Basic.insn option) list", "(Std.mem * ('a196, 'k3) Std.Disasm_expert.Basic.insn option) list", "Std.Disasm_expert.Basic.insns");
add_manifest("(Std.Disasm_expert.Basic.asm, Std.Disasm_expert.Basic.kinds)\n  Std.Disasm_expert.Basic.insn", "(Std.Disasm_expert.Basic.asm, Std.Disasm_expert.Basic.kinds)\n  Std.Disasm_expert.Basic.insn", "Std.Disasm_expert.Basic.full_insn");
add_manifest("('a193, 'k0) Std.Disasm_expert.Basic.Insn.t", "('a193, 'k0) Std.Disasm_expert.Basic.Insn.t", "Std.Disasm_expert.Basic.Insn.t");
add_manifest("('a193, 'k0) Std.Disasm_expert.Basic.insn", "('a193, 'k0) Std.Disasm_expert.Basic.insn", "Std.Disasm_expert.Basic.Insn.t");
add_manifest("(Std.mem * Std.insn option) list", "(Std.mem * Std.insn option) list", "Std.Disasm_expert.Linear.t");
add_manifest("Std.Disasm_expert.Recursive.error", "Std.Disasm_expert.Recursive.error", "[ `Failed_to_disasm of Std.mem\n  | `Failed_to_lift of\n      Std.mem * Std.Disasm_expert.Basic.full_insn * Error.t ]");
add_manifest("Std.Insn.t", "Std.Insn.t", "Std.insn");
add_manifest("Std.Block.t", "Std.Block.t", "Std.block");
add_manifest("Std.Disasm.t", "Std.Disasm.t", "Std.disasm");
add_manifest("Std.Symtab.t", "Std.Symtab.t", "Std.symtab");
add_manifest("Std.Symtab.fn", "Std.Symtab.fn", "string * Std.block * Std.cfg");
add_manifest("Std.Taint.t", "Std.Taint.t", "Std.tid");
add_manifest("Std.Tid.t", "Std.Tid.t", "Std.tid");
add_manifest("'a191 Std.Term.t", "'a191 Std.Term.t", "Std.Term.t");
add_manifest("'a191 Std.term", "'a191 Std.term", "Std.Term.t");
add_manifest("Std.Program.t", "Std.Program.t", "Std.program Std.term");
add_manifest("Std.Sub.t", "Std.Sub.t", "Std.sub Std.term");
add_manifest("Std.Blk.t", "Std.Blk.t", "Std.blk Std.term");
add_manifest("Std.Blk.elt", "Std.Blk.elt", "[ `Def of Std.def Std.term\n  | `Jmp of Std.jmp Std.term\n  | `Phi of Std.phi Std.term ]");
add_manifest("Std.Def.t", "Std.Def.t", "Std.def Std.term");
add_manifest("Std.Jmp.t", "Std.Jmp.t", "Std.jmp Std.term");
add_manifest("Std.Phi.t", "Std.Phi.t", "Std.phi Std.term");
add_manifest("Std.Arg.t", "Std.Arg.t", "Std.arg Std.term");
add_manifest("Std.Call.t", "Std.Call.t", "Std.call");
add_manifest("Std.Label.t", "Std.Label.t", "Std.label");
add_manifest("'a190 Or_error.t Bap_future.Std.stream", "'a190 Or_error.t Bap_future.Std.stream", "Std.Source.t");
add_manifest("'a190 Std.Source.t", "'a190 Std.Source.t", "Std.Source.t");
add_manifest("'a189 Std.Source.source", "'a189 Std.Source.source", "Std.Source.source");
add_manifest("'a189 Std.Source.t", "'a189 Std.Source.t", "Std.Source.source");
add_manifest("Std.Taint.set", "Std.Taint.set", "Std.Tid.Set.t");
add_manifest("Std.Taint.map", "Std.Taint.map", "Std.Taint.set Std.Var.Map.t");
add_manifest("'a37 -> string", "'a37 -> string", "Std.symbolizer");
add_manifest("'a37 Std.symbolizer", "'a37 Std.symbolizer", "Std.symbolizer");
add_manifest("Std.Symbolizer.t", "Std.Symbolizer.t", "Std.symbolizer");
add_manifest("Std.Rooter.t", "Std.Rooter.t", "Std.rooter");
add_manifest("Std.Brancher.t", "Std.Brancher.t", "Std.brancher");
add_manifest("Std.Brancher.dest", "Std.Brancher.dest", "Std.addr option * Std.edge");
add_manifest("Std.Brancher.dest list", "Std.Brancher.dest list", "Std.Brancher.dests");
add_manifest("Std.Reconstructor.t", "Std.Reconstructor.t", "Std.reconstructor");
add_manifest("(Std.Event.Log.level) * (string) * (string)", "(Std.Event.Log.level) * (string) * (string)", "Std.Event.Log.info");
add_manifest("Std.Project.t", "Std.Project.t", "Std.project");
add_manifest("Std.Project.second", "Std.Project.second", "float");
add_manifest("Std.Project.Input.t", "Std.Project.Input.t", "Std.Project.input");
add_manifest("Std.Project.Pass.t", "Std.Project.Pass.t", "Std.Project.pass");
add_manifest("'a186 Std.Self.Config.parser", "'a186 Std.Self.Config.parser", "string -> [ `Error of string | `Ok of 'a186 ]");
add_manifest("Std.Self.Config.parser", "Std.Self.Config.parser", "string -> [ `Error of string | `Ok of 'a186 ]");
add_manifest("('a185. 'a185 Std.Self.Config.param -> 'a185)", "('a185. 'a185 Std.Self.Config.param -> 'a185)", "Std.Self.Config.reader");
add_manifest("Std.Self.Config.manpage_block", "Std.Self.Config.manpage_block", "[ `I of string * string\n  | `Noblank\n  | `P of string\n  | `Pre of string\n  | `S of string ]");
add_manifest("(string) * (string) * (string) * (string) * (string) * (float) * (string list) * (string list) * (string option) * (string option) * (string option) * (string list) * (string list)", "(string) * (string) * (string) * (string) * (string) * (float) * (string list) * (string list) * (string option) * (string option) * (string option) * (string list) * (string list)", "Bap_bundle.Std.manifest");
add_manifest("Bap_bundle.Std.Manifest.t", "Bap_bundle.Std.Manifest.t", "Bap_bundle.Std.manifest");
add_manifest("Bap_bundle.Std.Bundle.t", "Bap_bundle.Std.Bundle.t", "Bap_bundle.Std.bundle");
add_manifest("Bap_plugins.Std.Plugin.t", "Bap_plugins.Std.Plugin.t", "Bap_plugins.Std.plugin");
add_manifest("Bap_plugins.Std.Plugins.event", "Bap_plugins.Std.Plugins.event", "[ `Errored of string * Error.t\n  | `Linking of string\n  | `Loaded of Bap_plugins.Std.plugin\n  | `Loading of Bap_plugins.Std.plugin\n  | `Opening of string ]");
add_manifest("Bytes.t", "Bytes.t", "Std.bytes");
add_manifest("Std.Bytes.t", "Std.Bytes.t", "Std.bytes");
add_manifest("'a182 Std.printer", "'a182 Std.printer", "Stdlib.Format.formatter -> 'a182 -> unit");
add_manifest("Std.printer", "Std.printer", "Stdlib.Format.formatter -> 'a182 -> unit");
add_manifest("'a180 Sequence.t", "'a180 Sequence.t", "Std.Seq.t");
add_manifest("'a180 Std.Seq.t", "'a180 Std.Seq.t", "Std.Seq.t");
add_manifest("'b5 -> 'a179 -> int -> unit", "'b5 -> 'a179 -> int -> unit", "Std.Data.copy");
add_manifest("('a179, 'b5) Std.Data.copy", "('a179, 'b5) Std.Data.copy", "Std.Data.copy");
add_manifest("'b4 -> 'a178 -> unit", "'b4 -> 'a178 -> unit", "Std.Data.dump");
add_manifest("('a178, 'b4) Std.Data.dump", "('a178, 'b4) Std.Data.dump", "Std.Data.dump");
add_manifest("Std.Data.lexbuf", "Std.Data.lexbuf", "Stdlib.Lexing.lexbuf");
add_manifest("Std.Data.scanbuf", "Std.Data.scanbuf", "Stdlib.Scanf.Scanning.scanbuf");
add_manifest("Std.Data.S.info", "Std.Data.S.info", "string * [ `Ver of string ] * string option");
add_manifest("'a177 Std.Data.Read.t", "'a177 Std.Data.Read.t", "Std.Data.Read.t");
add_manifest("'a177 Std.reader", "'a177 Std.reader", "Std.Data.Read.t");
add_manifest("'a176 Std.Data.Write.t", "'a176 Std.Data.Write.t", "Std.Data.Write.t");
add_manifest("'a176 Std.writer", "'a176 Std.writer", "Std.Data.Write.t");
add_manifest("('a175.\n    'a175 Std.reader ->\n    'a175 Std.writer -> 'a175 Std.Data.Cache.t)", "('a175.\n    'a175 Std.reader ->\n    'a175 Std.writer -> 'a175 Std.Data.Cache.t)", "Std.Data.Cache.service");
add_manifest("Std.Monoid.TList.t", "Std.Monoid.TList.t", "T.t list");
add_manifest("'a146 Std.Monad.Option.T1.t", "'a146 Std.Monad.Option.T1.t", "Std.Monad.Option.T1.t");
add_manifest("'a146 option M.t", "'a146 option M.t", "Std.Monad.Option.T1.t");
add_manifest("'a145 M.t", "'a145 M.t", "Std.Monad.Option.T1.m");
add_manifest("'a145 Std.Monad.Option.T1.m", "'a145 Std.Monad.Option.T1.m", "Std.Monad.Option.T1.m");
add_manifest("'a144 Std.Monad.Option.T1.e", "'a144 Std.Monad.Option.T1.e", "Std.Monad.Option.T1.e");
add_manifest("'a144 Std.Monad.Option.T1.t", "'a144 Std.Monad.Option.T1.t", "Std.Monad.Option.T1.e");
add_manifest("('a143 option, 'e31) M.t", "('a143 option, 'e31) M.t", "Std.Monad.Option.T2.t");
add_manifest("('a143, 'e31) Std.Monad.Option.T2.t", "('a143, 'e31) Std.Monad.Option.T2.t", "Std.Monad.Option.T2.t");
add_manifest("('a142, 'e30) M.t", "('a142, 'e30) M.t", "Std.Monad.Option.T2.m");
add_manifest("('a142, 'e30) Std.Monad.Option.T2.m", "('a142, 'e30) Std.Monad.Option.T2.m", "Std.Monad.Option.T2.m");
add_manifest("('a141, 'e29) Std.Monad.Option.T2.e", "('a141, 'e29) Std.Monad.Option.T2.e", "Std.Monad.Option.T2.e");
add_manifest("('a141, 'e29) Std.Monad.Option.T2.t", "('a141, 'e29) Std.Monad.Option.T2.t", "Std.Monad.Option.T2.e");
add_manifest("Std.Monad.Cont.T1.r", "Std.Monad.Cont.T1.r", "T.t");
add_manifest("Std.Monad.Reader.T1.env", "Std.Monad.Reader.T1.env", "T.t");
add_manifest("Std.Monad.Result.T1.error", "Std.Monad.Result.T1.error", "T.t");
add_manifest("Std.Monad.State.Multi.T1.env", "Std.Monad.State.Multi.T1.env", "T.t");
add_manifest("Std.Monad.State.T1.env", "Std.Monad.State.T1.env", "T.t");
add_manifest("Std.Monad.Writer.T1.state", "Std.Monad.Writer.T1.state", "T.t");
add_manifest("'a139 M.t", "'a139 M.t", "Std.Monad.Result.T1.m");
add_manifest("'a139 Std.Monad.Result.T1.m", "'a139 Std.Monad.Result.T1.m", "Std.Monad.Result.T1.m");
add_manifest("'a138 Std.Monad.Result.T1.t", "'a138 Std.Monad.Result.T1.t", "Std.Monad.Result.T1.t");
add_manifest("('a138, Std.Monad.Result.T1.error) Std.Monad.Result.result\n  Std.Monad.Result.T1.m", "('a138, Std.Monad.Result.T1.error) Std.Monad.Result.result\n  Std.Monad.Result.T1.m", "Std.Monad.Result.T1.t");
add_manifest("'a137 Std.Monad.Result.T1.e", "'a137 Std.Monad.Result.T1.e", "Std.Monad.Result.T1.e");
add_manifest("('a137, Std.Monad.Result.T1.error) Std.Monad.Result.result\n  Std.Monad.Result.T1.m", "('a137, Std.Monad.Result.T1.error) Std.Monad.Result.result\n  Std.Monad.Result.T1.m", "Std.Monad.Result.T1.e");
add_manifest("'a136 M.t", "'a136 M.t", "Std.Monad.Result.T2.m");
add_manifest("'a136 Std.Monad.Result.T2.m", "'a136 Std.Monad.Result.T2.m", "Std.Monad.Result.T2.m");
add_manifest("('a135, 'e27) Std.Monad.Result.T2.t", "('a135, 'e27) Std.Monad.Result.T2.t", "Std.Monad.Result.T2.t");
add_manifest("('a135, 'e27) Std.Monad.Result.result Std.Monad.Result.T2.m", "('a135, 'e27) Std.Monad.Result.result Std.Monad.Result.T2.m", "Std.Monad.Result.T2.t");
add_manifest("('a134, 'e26) Std.Monad.Result.T2.e", "('a134, 'e26) Std.Monad.Result.T2.e", "Std.Monad.Result.T2.e");
add_manifest("('a134, 'e26) Std.Monad.Result.result Std.Monad.Result.T2.m", "('a134, 'e26) Std.Monad.Result.result Std.Monad.Result.T2.m", "Std.Monad.Result.T2.e");
add_manifest("'a133 M.t", "'a133 M.t", "Std.Monad.Result.Error.T.m");
add_manifest("'a133 Std.Monad.Result.Error.T.m", "'a133 Std.Monad.Result.Error.T.m", "Std.Monad.Result.Error.T.m");
add_manifest("'a132 Or_error.t Std.Monad.Result.Error.T.m", "'a132 Or_error.t Std.Monad.Result.Error.T.m", "Std.Monad.Result.Error.T.t");
add_manifest("'a132 Std.Monad.Result.Error.T.t", "'a132 Std.Monad.Result.Error.T.t", "Std.Monad.Result.Error.T.t");
add_manifest("'a131 Or_error.t Std.Monad.Result.Error.T.m", "'a131 Or_error.t Std.Monad.Result.Error.T.m", "Std.Monad.Result.Error.T.e");
add_manifest("'a131 Std.Monad.Result.Error.T.e", "'a131 Std.Monad.Result.Error.T.e", "Std.Monad.Result.Error.T.e");
add_manifest("'a130 M.t", "'a130 M.t", "Std.Monad.Result.Exception.T.m");
add_manifest("'a130 Std.Monad.Result.Exception.T.m", "'a130 Std.Monad.Result.Exception.T.m", "Std.Monad.Result.Exception.T.m");
add_manifest("'a129 Std.Monad.Result.Exception.T.t", "'a129 Std.Monad.Result.Exception.T.t", "Std.Monad.Result.Exception.T.t");
add_manifest("('a129, exn) Result.t Std.Monad.Result.Exception.T.m", "('a129, exn) Result.t Std.Monad.Result.Exception.T.m", "Std.Monad.Result.Exception.T.t");
add_manifest("'a128 Std.Monad.Result.Exception.T.e", "'a128 Std.Monad.Result.Exception.T.e", "Std.Monad.Result.Exception.T.e");
add_manifest("('a128, exn) Result.t Std.Monad.Result.Exception.T.m", "('a128, exn) Result.t Std.Monad.Result.Exception.T.m", "Std.Monad.Result.Exception.T.e");
add_manifest("'a127 Std.Monad.List.T1.t", "'a127 Std.Monad.List.T1.t", "Std.Monad.List.T1.t");
add_manifest("'a127 list M.t", "'a127 list M.t", "Std.Monad.List.T1.t");
add_manifest("'a126 M.t", "'a126 M.t", "Std.Monad.List.T1.m");
add_manifest("'a126 Std.Monad.List.T1.m", "'a126 Std.Monad.List.T1.m", "Std.Monad.List.T1.m");
add_manifest("'a125 Std.Monad.List.T1.e", "'a125 Std.Monad.List.T1.e", "Std.Monad.List.T1.e");
add_manifest("'a125 Std.Monad.List.T1.t", "'a125 Std.Monad.List.T1.t", "Std.Monad.List.T1.e");
add_manifest("('a124 list, 'e25) M.t", "('a124 list, 'e25) M.t", "Std.Monad.List.T2.t");
add_manifest("('a124, 'e25) Std.Monad.List.T2.t", "('a124, 'e25) Std.Monad.List.T2.t", "Std.Monad.List.T2.t");
add_manifest("('a123, 'e24) M.t", "('a123, 'e24) M.t", "Std.Monad.List.T2.m");
add_manifest("('a123, 'e24) Std.Monad.List.T2.m", "('a123, 'e24) Std.Monad.List.T2.m", "Std.Monad.List.T2.m");
add_manifest("('a122, 'e23) Std.Monad.List.T2.e", "('a122, 'e23) Std.Monad.List.T2.e", "Std.Monad.List.T2.e");
add_manifest("('a122, 'e23) Std.Monad.List.T2.t", "('a122, 'e23) Std.Monad.List.T2.t", "Std.Monad.List.T2.e");
add_manifest("'a121 Sequence.t M.t", "'a121 Sequence.t M.t", "Std.Monad.Seq.T1.t");
add_manifest("'a121 Std.Monad.Seq.T1.t", "'a121 Std.Monad.Seq.T1.t", "Std.Monad.Seq.T1.t");
add_manifest("'a120 M.t", "'a120 M.t", "Std.Monad.Seq.T1.m");
add_manifest("'a120 Std.Monad.Seq.T1.m", "'a120 Std.Monad.Seq.T1.m", "Std.Monad.Seq.T1.m");
add_manifest("'a119 Std.Monad.Seq.T1.e", "'a119 Std.Monad.Seq.T1.e", "Std.Monad.Seq.T1.e");
add_manifest("'a119 Std.Monad.Seq.T1.t", "'a119 Std.Monad.Seq.T1.t", "Std.Monad.Seq.T1.e");
add_manifest("('a118 Sequence.t, 'e22) M.t", "('a118 Sequence.t, 'e22) M.t", "Std.Monad.Seq.T2.t");
add_manifest("('a118, 'e22) Std.Monad.Seq.T2.t", "('a118, 'e22) Std.Monad.Seq.T2.t", "Std.Monad.Seq.T2.t");
add_manifest("('a117, 'e21) M.t", "('a117, 'e21) M.t", "Std.Monad.Seq.T2.m");
add_manifest("('a117, 'e21) Std.Monad.Seq.T2.m", "('a117, 'e21) Std.Monad.Seq.T2.m", "Std.Monad.Seq.T2.m");
add_manifest("('a116, 'e20) Std.Monad.Seq.T2.e", "('a116, 'e20) Std.Monad.Seq.T2.e", "Std.Monad.Seq.T2.e");
add_manifest("('a116, 'e20) Std.Monad.Seq.T2.t", "('a116, 'e20) Std.Monad.Seq.T2.t", "Std.Monad.Seq.T2.e");
add_manifest("'a114 M.t", "'a114 M.t", "Std.Monad.Writer.T1.m");
add_manifest("'a114 Std.Monad.Writer.T1.m", "'a114 Std.Monad.Writer.T1.m", "Std.Monad.Writer.T1.m");
add_manifest("'a113 Std.Monad.Writer.T1.t", "'a113 Std.Monad.Writer.T1.t", "Std.Monad.Writer.T1.t");
add_manifest("('a113, Std.Monad.Writer.T1.state) Std.Monad.Writer.writer\n  Std.Monad.Writer.T1.m", "('a113, Std.Monad.Writer.T1.state) Std.Monad.Writer.writer\n  Std.Monad.Writer.T1.m", "Std.Monad.Writer.T1.t");
add_manifest("'a112 Std.Monad.Writer.T1.e", "'a112 Std.Monad.Writer.T1.e", "Std.Monad.Writer.T1.e");
add_manifest("('a112 * Std.Monad.Writer.T1.state) Std.Monad.Writer.T1.m", "('a112 * Std.Monad.Writer.T1.state) Std.Monad.Writer.T1.m", "Std.Monad.Writer.T1.e");
add_manifest("'a110 M.t", "'a110 M.t", "Std.Monad.Reader.T1.m");
add_manifest("'a110 Std.Monad.Reader.T1.m", "'a110 Std.Monad.Reader.T1.m", "Std.Monad.Reader.T1.m");
add_manifest("'a109 Std.Monad.Reader.T1.t", "'a109 Std.Monad.Reader.T1.t", "Std.Monad.Reader.T1.t");
add_manifest("('a109 Std.Monad.Reader.T1.m, Std.Monad.Reader.T1.env)\n  Std.Monad.Reader.reader", "('a109 Std.Monad.Reader.T1.m, Std.Monad.Reader.T1.env)\n  Std.Monad.Reader.reader", "Std.Monad.Reader.T1.t");
add_manifest("'a108 Std.Monad.Reader.T1.e", "'a108 Std.Monad.Reader.T1.e", "Std.Monad.Reader.T1.env -> 'a108 Std.Monad.Reader.T1.m");
add_manifest("Std.Monad.Reader.T1.e", "Std.Monad.Reader.T1.e", "Std.Monad.Reader.T1.env -> 'a108 Std.Monad.Reader.T1.m");
add_manifest("'a107 M.t", "'a107 M.t", "Std.Monad.Reader.T2.m");
add_manifest("'a107 Std.Monad.Reader.T2.m", "'a107 Std.Monad.Reader.T2.m", "Std.Monad.Reader.T2.m");
add_manifest("('a106 Std.Monad.Reader.T2.m, 'e19) Std.Monad.Reader.reader", "('a106 Std.Monad.Reader.T2.m, 'e19) Std.Monad.Reader.reader", "Std.Monad.Reader.T2.t");
add_manifest("('a106, 'e19) Std.Monad.Reader.T2.t", "('a106, 'e19) Std.Monad.Reader.T2.t", "Std.Monad.Reader.T2.t");
add_manifest("'e18 -> 'a105 Std.Monad.Reader.T2.m", "'e18 -> 'a105 Std.Monad.Reader.T2.m", "Std.Monad.Reader.T2.e");
add_manifest("('a105, 'e18) Std.Monad.Reader.T2.e", "('a105, 'e18) Std.Monad.Reader.T2.e", "Std.Monad.Reader.T2.e");
add_manifest("Std.Monad.State.Multi.status", "Std.Monad.State.Multi.status", "[ `Current | `Dead | `Live ]");
add_manifest("'a101 M.t", "'a101 M.t", "Std.Monad.State.Multi.T1.m");
add_manifest("'a101 Std.Monad.State.Multi.T1.m", "'a101 Std.Monad.State.Multi.T1.m", "Std.Monad.State.Multi.T1.m");
add_manifest("'a100 Std.Monad.State.Multi.T1.t", "'a100 Std.Monad.State.Multi.T1.t", "Std.Monad.State.Multi.T1.t");
add_manifest("(('a100,\n    Std.Monad.State.Multi.T1.env Std.Monad.State.Multi.contexts)\n   Std.Monad.State.storage Std.Monad.State.Multi.T1.m,\n   Std.Monad.State.Multi.T1.env Std.Monad.State.Multi.contexts)\n  Std.Monad.State.state", "(('a100,\n    Std.Monad.State.Multi.T1.env Std.Monad.State.Multi.contexts)\n   Std.Monad.State.storage Std.Monad.State.Multi.T1.m,\n   Std.Monad.State.Multi.T1.env Std.Monad.State.Multi.contexts)\n  Std.Monad.State.state", "Std.Monad.State.Multi.T1.t");
add_manifest("'a99 Std.Monad.State.Multi.T1.e", "'a99 Std.Monad.State.Multi.T1.e", "Std.Monad.State.Multi.T1.env ->\n  ('a99 * Std.Monad.State.Multi.T1.env)\n  Std.Monad.State.Multi.T1.m");
add_manifest("Std.Monad.State.Multi.T1.e", "Std.Monad.State.Multi.T1.e", "Std.Monad.State.Multi.T1.env ->\n  ('a99 * Std.Monad.State.Multi.T1.env)\n  Std.Monad.State.Multi.T1.m");
add_manifest("'a98 M.t", "'a98 M.t", "Std.Monad.State.Multi.T2.m");
add_manifest("'a98 Std.Monad.State.Multi.T2.m", "'a98 Std.Monad.State.Multi.T2.m", "Std.Monad.State.Multi.T2.m");
add_manifest("('a97, 'e15) Std.Monad.State.Multi.T2.t", "('a97, 'e15) Std.Monad.State.Multi.T2.t", "Std.Monad.State.Multi.T2.t");
add_manifest("(('a97, 'e15 Std.Monad.State.Multi.contexts)\n   Std.Monad.State.storage Std.Monad.State.Multi.T2.m,\n   'e15 Std.Monad.State.Multi.contexts)\n  Std.Monad.State.state", "(('a97, 'e15 Std.Monad.State.Multi.contexts)\n   Std.Monad.State.storage Std.Monad.State.Multi.T2.m,\n   'e15 Std.Monad.State.Multi.contexts)\n  Std.Monad.State.state", "Std.Monad.State.Multi.T2.t");
add_manifest("'e14 -> ('a96 * 'e14) Std.Monad.State.Multi.T2.m", "'e14 -> ('a96 * 'e14) Std.Monad.State.Multi.T2.m", "Std.Monad.State.Multi.T2.e");
add_manifest("('a96, 'e14) Std.Monad.State.Multi.T2.e", "('a96, 'e14) Std.Monad.State.Multi.T2.e", "Std.Monad.State.Multi.T2.e");
add_manifest("'a95 M.t", "'a95 M.t", "Std.Monad.State.T1.m");
add_manifest("'a95 Std.Monad.State.T1.m", "'a95 Std.Monad.State.T1.m", "Std.Monad.State.T1.m");
add_manifest("'a94 Std.Monad.State.T1.t", "'a94 Std.Monad.State.T1.t", "Std.Monad.State.T1.t");
add_manifest("(('a94, Std.Monad.State.T1.env) Std.Monad.State.storage\n   Std.Monad.State.T1.m, Std.Monad.State.T1.env)\n  Std.Monad.State.state", "(('a94, Std.Monad.State.T1.env) Std.Monad.State.storage\n   Std.Monad.State.T1.m, Std.Monad.State.T1.env)\n  Std.Monad.State.state", "Std.Monad.State.T1.t");
add_manifest("'a93 Std.Monad.State.T1.e", "'a93 Std.Monad.State.T1.e", "Std.Monad.State.T1.env ->\n  ('a93 * Std.Monad.State.T1.env) Std.Monad.State.T1.m");
add_manifest("Std.Monad.State.T1.e", "Std.Monad.State.T1.e", "Std.Monad.State.T1.env ->\n  ('a93 * Std.Monad.State.T1.env) Std.Monad.State.T1.m");
add_manifest("'a92 M.t", "'a92 M.t", "Std.Monad.State.T2.m");
add_manifest("'a92 Std.Monad.State.T2.m", "'a92 Std.Monad.State.T2.m", "Std.Monad.State.T2.m");
add_manifest("('a91, 'e13) Std.Monad.State.T2.t", "('a91, 'e13) Std.Monad.State.T2.t", "Std.Monad.State.T2.t");
add_manifest("(('a91, 'e13) Std.Monad.State.storage Std.Monad.State.T2.m,\n   'e13)\n  Std.Monad.State.state", "(('a91, 'e13) Std.Monad.State.storage Std.Monad.State.T2.m,\n   'e13)\n  Std.Monad.State.state", "Std.Monad.State.T2.t");
add_manifest("'e12 -> ('a90 * 'e12) Std.Monad.State.T2.m", "'e12 -> ('a90 * 'e12) Std.Monad.State.T2.m", "Std.Monad.State.T2.e");
add_manifest("('a90, 'e12) Std.Monad.State.T2.e", "('a90, 'e12) Std.Monad.State.T2.e", "Std.Monad.State.T2.e");
add_manifest("'a88 M.t", "'a88 M.t", "Std.Monad.Fun.T1.m");
add_manifest("'a88 Std.Monad.Fun.T1.m", "'a88 Std.Monad.Fun.T1.m", "Std.Monad.Fun.T1.m");
add_manifest("'a87 Std.Monad.Fun.T1.m Std.Monad.Fun.thunk", "'a87 Std.Monad.Fun.T1.m Std.Monad.Fun.thunk", "Std.Monad.Fun.T1.t");
add_manifest("'a87 Std.Monad.Fun.T1.t", "'a87 Std.Monad.Fun.T1.t", "Std.Monad.Fun.T1.t");
add_manifest("'a86 Std.Monad.Fun.T1.e", "'a86 Std.Monad.Fun.T1.e", "Std.Monad.Fun.T1.e");
add_manifest("'a86 Std.Monad.Fun.T1.m", "'a86 Std.Monad.Fun.T1.m", "Std.Monad.Fun.T1.e");
add_manifest("('a85, 'e11) M.t", "('a85, 'e11) M.t", "Std.Monad.Fun.T2.m");
add_manifest("('a85, 'e11) Std.Monad.Fun.T2.m", "('a85, 'e11) Std.Monad.Fun.T2.m", "Std.Monad.Fun.T2.m");
add_manifest("('a84, 'e10) Std.Monad.Fun.T2.m Std.Monad.Fun.thunk", "('a84, 'e10) Std.Monad.Fun.T2.m Std.Monad.Fun.thunk", "Std.Monad.Fun.T2.t");
add_manifest("('a84, 'e10) Std.Monad.Fun.T2.t", "('a84, 'e10) Std.Monad.Fun.T2.t", "Std.Monad.Fun.T2.t");
add_manifest("('a83, 'e9) Std.Monad.Fun.T2.e", "('a83, 'e9) Std.Monad.Fun.T2.e", "Std.Monad.Fun.T2.e");
add_manifest("('a83, 'e9) Std.Monad.Fun.T2.m", "('a83, 'e9) Std.Monad.Fun.T2.m", "Std.Monad.Fun.T2.e");
add_manifest("'a82 M.t", "'a82 M.t", "Std.Monad.Lazy.T1.m");
add_manifest("'a82 Std.Monad.Lazy.T1.m", "'a82 Std.Monad.Lazy.T1.m", "Std.Monad.Lazy.T1.m");
add_manifest("'a81 Std.Monad.Lazy.T1.m Lazy.t", "'a81 Std.Monad.Lazy.T1.m Lazy.t", "Std.Monad.Lazy.T1.t");
add_manifest("'a81 Std.Monad.Lazy.T1.t", "'a81 Std.Monad.Lazy.T1.t", "Std.Monad.Lazy.T1.t");
add_manifest("'a80 Std.Monad.Lazy.T1.e", "'a80 Std.Monad.Lazy.T1.e", "Std.Monad.Lazy.T1.e");
add_manifest("'a80 Std.Monad.Lazy.T1.m", "'a80 Std.Monad.Lazy.T1.m", "Std.Monad.Lazy.T1.e");
add_manifest("('a79, 'e8) M.t", "('a79, 'e8) M.t", "Std.Monad.Lazy.T2.m");
add_manifest("('a79, 'e8) Std.Monad.Lazy.T2.m", "('a79, 'e8) Std.Monad.Lazy.T2.m", "Std.Monad.Lazy.T2.m");
add_manifest("('a78, 'e7) Std.Monad.Lazy.T2.m Lazy.t", "('a78, 'e7) Std.Monad.Lazy.T2.m Lazy.t", "Std.Monad.Lazy.T2.t");
add_manifest("('a78, 'e7) Std.Monad.Lazy.T2.t", "('a78, 'e7) Std.Monad.Lazy.T2.t", "Std.Monad.Lazy.T2.t");
add_manifest("('a77, 'e6) Std.Monad.Lazy.T2.e", "('a77, 'e6) Std.Monad.Lazy.T2.e", "Std.Monad.Lazy.T2.e");
add_manifest("('a77, 'e6) Std.Monad.Lazy.T2.m", "('a77, 'e6) Std.Monad.Lazy.T2.m", "Std.Monad.Lazy.T2.e");
add_manifest("'a75 M.t", "'a75 M.t", "Std.Monad.Cont.T1.m");
add_manifest("'a75 Std.Monad.Cont.T1.m", "'a75 Std.Monad.Cont.T1.m", "Std.Monad.Cont.T1.m");
add_manifest("'a74 Std.Monad.Cont.T1.t", "'a74 Std.Monad.Cont.T1.t", "Std.Monad.Cont.T1.t");
add_manifest("('a74, Std.Monad.Cont.T1.r Std.Monad.Cont.T1.m)\n  Std.Monad.Cont.cont", "('a74, Std.Monad.Cont.T1.r Std.Monad.Cont.T1.m)\n  Std.Monad.Cont.cont", "Std.Monad.Cont.T1.t");
add_manifest("'a73 Std.Monad.Cont.T1.e", "'a73 Std.Monad.Cont.T1.e", "Std.Monad.Cont.T1.e");
add_manifest("('a73 -> Std.Monad.Cont.T1.r Std.Monad.Cont.T1.m) ->\n  Std.Monad.Cont.T1.r Std.Monad.Cont.T1.m", "('a73 -> Std.Monad.Cont.T1.r Std.Monad.Cont.T1.m) ->\n  Std.Monad.Cont.T1.r Std.Monad.Cont.T1.m", "Std.Monad.Cont.T1.e");
add_manifest("'a72 M.t", "'a72 M.t", "Std.Monad.Cont.T2.m");
add_manifest("'a72 Std.Monad.Cont.T2.m", "'a72 Std.Monad.Cont.T2.m", "Std.Monad.Cont.T2.m");
add_manifest("('a71, 'e5 Std.Monad.Cont.T2.m) Std.Monad.Cont.cont", "('a71, 'e5 Std.Monad.Cont.T2.m) Std.Monad.Cont.cont", "Std.Monad.Cont.T2.t");
add_manifest("('a71, 'e5) Std.Monad.Cont.T2.t", "('a71, 'e5) Std.Monad.Cont.T2.t", "Std.Monad.Cont.T2.t");
add_manifest("('a70 -> 'e4 Std.Monad.Cont.T2.m) -> 'e4 Std.Monad.Cont.T2.m", "('a70 -> 'e4 Std.Monad.Cont.T2.m) -> 'e4 Std.Monad.Cont.T2.m", "Std.Monad.Cont.T2.e");
add_manifest("('a70, 'e4) Std.Monad.Cont.T2.e", "('a70, 'e4) Std.Monad.Cont.T2.e", "Std.Monad.Cont.T2.e");
add_manifest("('a64, 'k -> 'l) Ogre.attribute", "('a64, 'k -> 'l) Ogre.attribute", "unit -> ('a64, 'k -> 'l) Ogre.typeinfo");
add_manifest("Ogre.attribute", "Ogre.attribute", "unit -> ('a64, 'k -> 'l) Ogre.typeinfo");
add_manifest("'a61 Ogre.seq", "'a61 Ogre.seq", "Ogre.seq");
add_manifest("'a61 Sequence.t", "'a61 Sequence.t", "Ogre.seq");
add_manifest("'a59 Ogre.Query.t", "'a59 Ogre.Query.t", "Ogre.Query.t");
add_manifest("'a59 Ogre.query", "'a59 Ogre.query", "Ogre.Query.t");
add_manifest("Ogre.Doc.t", "Ogre.Doc.t", "Ogre.doc");
add_manifest("'a51 Bap_future.Std.future", "'a51 Bap_future.Std.future", "Bap_future.Std.t");
add_manifest("'a51 Bap_future.Std.t", "'a51 Bap_future.Std.t", "Bap_future.Std.t");
add_manifest("'a50 Bap_future.Std.Promise.t", "'a50 Bap_future.Std.Promise.t", "Bap_future.Std.Promise.t");
add_manifest("'a50 Bap_future.Std.promise", "'a50 Bap_future.Std.promise", "Bap_future.Std.Promise.t");
add_manifest("'a49 Bap_future.Std.Stream.t", "'a49 Bap_future.Std.Stream.t", "Bap_future.Std.Stream.t");
add_manifest("'a49 Bap_future.Std.stream", "'a49 Bap_future.Std.stream", "Bap_future.Std.Stream.t");
add_manifest("'a48 Bap_future.Std.Signal.t", "'a48 Bap_future.Std.Signal.t", "Bap_future.Std.Signal.t");
add_manifest("'a48 Bap_future.Std.signal", "'a48 Bap_future.Std.signal", "Bap_future.Std.Signal.t");
add_manifest("('c, 'n1, 'e1) Std.graph", "('c, 'n1, 'e1) Std.graph", "Std.graph");
add_manifest("(module Std.Graph with type edge = 'e1 and type node = 'n1 and type t = 'c)", "(module Std.Graph with type edge = 'e1 and type node = 'n1 and type t = 'c)", "Std.graph");
add_manifest("Std.edge_kind", "Std.edge_kind", "[ `Back | `Cross | `Forward | `Tree ]");
add_manifest("Graph.Graphviz.DotAttributes.vertex", "Graph.Graphviz.DotAttributes.vertex", "Std.node_attr");
add_manifest("Graph.Graphviz.DotAttributes.edge", "Graph.Graphviz.DotAttributes.edge", "Std.edge_attr");
add_manifest("Graph.Graphviz.DotAttributes.graph", "Graph.Graphviz.DotAttributes.graph", "Std.graph_attr");
add_manifest("('n0) * ('a42)", "('n0) * ('a42)", "Std.labeled");
add_manifest("('n0, 'a42) Std.labeled", "('n0, 'a42) Std.labeled", "Std.labeled");
add_manifest("'a41 Std.Tree.t", "'a41 Std.Tree.t", "Std.Tree.t");
add_manifest("'a41 Std.tree", "'a41 Std.tree", "Std.Tree.t");
add_manifest("'a40 Std.Frontier.t", "'a40 Std.Frontier.t", "Std.Frontier.t");
add_manifest("'a40 Std.frontier", "'a40 Std.frontier", "Std.Frontier.t");
add_manifest("'e0 Std.Path.t", "'e0 Std.Path.t", "Std.Path.t");
add_manifest("'e0 Std.path", "'e0 Std.path", "Std.Path.t");
add_manifest("'a39 Std.Partition.t", "'a39 Std.Partition.t", "Std.Partition.t");
add_manifest("'a39 Std.partition", "'a39 Std.partition", "Std.Partition.t");
add_manifest("'a38 Std.Group.t", "'a38 Std.Group.t", "Std.Group.t");
add_manifest("'a38 Std.group", "'a38 Std.group", "Std.Group.t");
add_manifest("Std.Equiv.t", "Std.Equiv.t", "Std.equiv");
add_manifest("Std.Primus.Pos.t", "Std.Primus.Pos.t", "Std.Primus.pos");
add_manifest("'a32 Std.Primus.Machine.state", "'a32 Std.Primus.Machine.state", "Std.Primus.state");
add_manifest("'a32 Std.Primus.state", "'a32 Std.Primus.state", "Std.Primus.state");
add_manifest("(module Std.Primus.Machine.Component)", "(module Std.Primus.Machine.Component)", "Std.Primus.component");
add_manifest("Std.Primus.Machine.component", "Std.Primus.Machine.component", "Std.Primus.component");
add_manifest("Std.Primus.Observation.Provider.t", "Std.Primus.Observation.Provider.t", "Std.Primus.Observation.provider");
add_manifest("Std.Primus.Pos.top", "Std.Primus.Pos.top", "Std.program");
add_manifest("('a31 Std.term) * ('b1)", "('a31 Std.term) * ('b1)", "Std.Primus.Pos.level");
add_manifest("('a31, 'b1) Std.Primus.Pos.level", "('a31, 'b1) Std.Primus.Pos.level", "Std.Primus.Pos.level");
add_manifest("(Std.Primus.Pos.top, Std.Primus.Pos.nil)\n  Std.Primus.Pos.level", "(Std.Primus.Pos.top, Std.Primus.Pos.nil)\n  Std.Primus.Pos.level", "Std.Primus.Pos.level3");
add_manifest("(Std.sub, Std.Primus.Pos.level3)\n  Std.Primus.Pos.level", "(Std.sub, Std.Primus.Pos.level3)\n  Std.Primus.Pos.level", "Std.Primus.Pos.level2");
add_manifest("'a30 Std.Primus.Pos.level1", "'a30 Std.Primus.Pos.level1", "Std.Primus.Pos.level1");
add_manifest("('a30, Std.Primus.Pos.level2) Std.Primus.Pos.level", "('a30, Std.Primus.Pos.level2) Std.Primus.Pos.level", "Std.Primus.Pos.level1");
add_manifest("'a29 Std.Primus.Pos.level0", "'a29 Std.Primus.Pos.level0", "Std.Primus.Pos.level0");
add_manifest("('a29, Std.blk Std.Primus.Pos.level1)\n  Std.Primus.Pos.level", "('a29, Std.blk Std.Primus.Pos.level1)\n  Std.Primus.Pos.level", "Std.Primus.Pos.level0");
add_manifest("Std.Monad.State.Multi.id", "Std.Monad.State.Multi.id", "Std.Primus.Machine.id");
add_manifest("'a28 Std.Primus.Machine.State.t", "'a28 Std.Primus.Machine.State.t", "Std.Primus.Machine.state");
add_manifest("'a28 Std.Primus.Machine.state", "'a28 Std.Primus.Machine.state", "Std.Primus.Machine.state");
add_manifest("'a26 Std.Primus.Machine.State.state", "'a26 Std.Primus.Machine.State.state", "Std.Primus.Machine.State.state");
add_manifest("'a26 Std.Primus.Machine.State.t", "'a26 Std.Primus.Machine.State.t", "Std.Primus.Machine.State.state");
add_manifest("(Std.Primus.Machine.State.void,\n   Std.Primus.Machine.State.void,\n   Std.Primus.Machine.State.void)\n  format", "(Std.Primus.Machine.State.void,\n   Std.Primus.Machine.State.void,\n   Std.Primus.Machine.State.void)\n  format", "Std.Primus.Machine.State.uuid");
add_manifest("Std.Primus.Value.Make.t", "Std.Primus.Value.Make.t", "Std.Primus.value");
add_manifest("Std.Primus.Value.t", "Std.Primus.Value.t", "Std.Primus.value");
add_manifest("'a22 Machine.t", "'a22 Machine.t", "Std.Primus.Value.Make.m");
add_manifest("'a22 Std.Primus.Value.Make.m", "'a22 Std.Primus.Value.Make.m", "Std.Primus.Value.Make.m");
add_manifest("'a21 Machine.t", "'a21 Machine.t", "Std.Primus.Interpreter.Make.m");
add_manifest("'a21 Std.Primus.Interpreter.Make.m", "'a21 Std.Primus.Interpreter.Make.m", "Std.Primus.Interpreter.Make.m");
add_manifest("Std.Primus.Linker.name", "Std.Primus.Linker.name", "[ `addr of Std.addr | `symbol of string | `tid of Std.tid ]");
add_manifest("(module Std.Primus.Linker.Code)", "(module Std.Primus.Linker.Code)", "Std.Primus.Linker.code");
add_manifest("'a20 Machine.t", "'a20 Machine.t", "Std.Primus.Linker.Make.m");
add_manifest("'a20 Std.Primus.Linker.Make.m", "'a20 Std.Primus.Linker.Make.m", "Std.Primus.Linker.Make.m");
add_manifest("Std.Primus.Generator.t", "Std.Primus.Generator.t", "Std.Primus.generator");
add_manifest("(module Std.Primus.Lisp.Closure)", "(module Std.Primus.Lisp.Closure)", "Std.Primus.Lisp.closure");
add_manifest("(module Std.Primus.Lisp.Primitives)", "(module Std.Primus.Lisp.Primitives)", "Std.Primus.Lisp.primitives");
add_manifest("(Category.t * (Name.t * Descr.t) list) list", "(Category.t * (Name.t * Descr.t) list) list", "Std.Primus.Lisp.Doc.index");
add_manifest("Std.Primus.Lisp.Type.parameters", "Std.Primus.Lisp.Type.parameters", "[ `All of Std.Primus.Lisp.Type.t\n  | `Gen of\n      Std.Primus.Lisp.Type.t list *\n      Std.Primus.Lisp.Type.t\n  | `Tuple of Std.Primus.Lisp.Type.t list ]");
add_manifest("Std.Primus.Lisp.Message.t", "Std.Primus.Lisp.Message.t", "Std.Primus.Lisp.message");
add_manifest("Bare.fact", "Bare.fact", "Sexp.t");
add_manifest("Bare.tuple", "Bare.tuple", "Sexp.t");
add_manifest("Arm_insn.t", "Arm_insn.t", "[ `ADCri\n  | `ADCrr\n  | `ADCrsi\n  | `ADCrsr\n  | `ADDri\n  | `ADDrr\n  | `ADDrsi\n  | `ADDrsr\n  | `ANDri\n  | `ANDrr\n  | `ANDrsi\n  | `ANDrsr\n  | `BFC\n  | `BFI\n  | `BICri\n  | `BICrr\n  | `BICrsi\n  | `BICrsr\n  | `BL\n  | `BLX\n  | `BLX_pred\n  | `BLXi\n  | `BL_pred\n  | `BX\n  | `BX_RET\n  | `BX_pred\n  | `Bcc\n  | `CLZ\n  | `CMNri\n  | `CMNzrr\n  | `CMNzrsi\n  | `CMNzrsr\n  | `CMPri\n  | `CMPrr\n  | `CMPrsi\n  | `CMPrsr\n  | `CPS2p\n  | `DMB\n  | `DSB\n  | `EORri\n  | `EORrr\n  | `EORrsi\n  | `EORrsr\n  | `HINT\n  | `LDMDA\n  | `LDMDA_UPD\n  | `LDMDB\n  | `LDMDB_UPD\n  | `LDMIA\n  | `LDMIA_UPD\n  | `LDMIB\n  | `LDMIB_UPD\n  | `LDRBT_POST_IMM\n  | `LDRBT_POST_REG\n  | `LDRB_POST_IMM\n  | `LDRB_POST_REG\n  | `LDRB_PRE_IMM\n  | `LDRB_PRE_REG\n  | `LDRBi12\n  | `LDRBrs\n  | `LDRD\n  | `LDRD_POST\n  | `LDRD_PRE\n  | `LDREX\n  | `LDREXB\n  | `LDREXD\n  | `LDREXH\n  | `LDRH\n  | `LDRHTr\n  | `LDRH_POST\n  | `LDRH_PRE\n  | `LDRSB\n  | `LDRSBTr\n  | `LDRSB_POST\n  | `LDRSB_PRE\n  | `LDRSH\n  | `LDRSHTi\n  | `LDRSHTr\n  | `LDRSH_POST\n  | `LDRSH_PRE\n  | `LDRT_POST_REG\n  | `LDR_POST_IMM\n  | `LDR_POST_REG\n  | `LDR_PRE_IMM\n  | `LDR_PRE_REG\n  | `LDRi12\n  | `LDRrs\n  | `MLA\n  | `MLS\n  | `MOVPCLR\n  | `MOVTi16\n  | `MOVi\n  | `MOVi16\n  | `MOVr\n  | `MOVsi\n  | `MOVsr\n  | `MRS\n  | `MSR\n  | `MUL\n  | `MVNi\n  | `MVNr\n  | `MVNsi\n  | `MVNsr\n  | `ORRri\n  | `ORRrr\n  | `ORRrsi\n  | `ORRrsr\n  | `PKHTB\n  | `PLDi12\n  | `RBIT\n  | `REV\n  | `REV16\n  | `RSBri\n  | `RSBrr\n  | `RSBrsi\n  | `RSBrsr\n  | `RSCri\n  | `RSCrr\n  | `RSCrsi\n  | `RSCrsr\n  | `SBCri\n  | `SBCrr\n  | `SBCrsi\n  | `SBCrsr\n  | `SBFX\n  | `SMLABB\n  | `SMLAD\n  | `SMLAL\n  | `SMLALBT\n  | `SMLAWB\n  | `SMUAD\n  | `SMULBB\n  | `SMULL\n  | `SMULTB\n  | `STMDA\n  | `STMDA_UPD\n  | `STMDB\n  | `STMDB_UPD\n  | `STMIA\n  | `STMIA_UPD\n  | `STMIB\n  | `STMIB_UPD\n  | `STRBT_POST_IMM\n  | `STRBT_POST_REG\n  | `STRB_POST_IMM\n  | `STRB_POST_REG\n  | `STRB_PRE_IMM\n  | `STRB_PRE_REG\n  | `STRBi12\n  | `STRBrs\n  | `STRD\n  | `STRD_POST\n  | `STRD_PRE\n  | `STREX\n  | `STREXB\n  | `STREXD\n  | `STREXH\n  | `STRH\n  | `STRHTr\n  | `STRH_POST\n  | `STRH_PRE\n  | `STRT_POST_REG\n  | `STR_POST_IMM\n  | `STR_POST_REG\n  | `STR_PRE_IMM\n  | `STR_PRE_REG\n  | `STRi12\n  | `STRrs\n  | `SUBri\n  | `SUBrr\n  | `SUBrsi\n  | `SUBrsr\n  | `SVC\n  | `SWPB\n  | `SXTAB\n  | `SXTAH\n  | `SXTB\n  | `SXTH\n  | `TEQri\n  | `TEQrr\n  | `TEQrsi\n  | `TEQrsr\n  | `TSTri\n  | `TSTrr\n  | `TSTrsi\n  | `TSTrsr\n  | `UBFX\n  | `UMLAL\n  | `UMULL\n  | `UXTAB\n  | `UXTAH\n  | `UXTB\n  | `UXTH ]");
add_manifest("Arm_types.insn", "Arm_types.insn", "[ `ADCri\n  | `ADCrr\n  | `ADCrsi\n  | `ADCrsr\n  | `ADDri\n  | `ADDrr\n  | `ADDrsi\n  | `ADDrsr\n  | `ANDri\n  | `ANDrr\n  | `ANDrsi\n  | `ANDrsr\n  | `BFC\n  | `BFI\n  | `BICri\n  | `BICrr\n  | `BICrsi\n  | `BICrsr\n  | `BL\n  | `BLX\n  | `BLX_pred\n  | `BLXi\n  | `BL_pred\n  | `BX\n  | `BX_RET\n  | `BX_pred\n  | `Bcc\n  | `CLZ\n  | `CMNri\n  | `CMNzrr\n  | `CMNzrsi\n  | `CMNzrsr\n  | `CMPri\n  | `CMPrr\n  | `CMPrsi\n  | `CMPrsr\n  | `CPS2p\n  | `DMB\n  | `DSB\n  | `EORri\n  | `EORrr\n  | `EORrsi\n  | `EORrsr\n  | `HINT\n  | `LDMDA\n  | `LDMDA_UPD\n  | `LDMDB\n  | `LDMDB_UPD\n  | `LDMIA\n  | `LDMIA_UPD\n  | `LDMIB\n  | `LDMIB_UPD\n  | `LDRBT_POST_IMM\n  | `LDRBT_POST_REG\n  | `LDRB_POST_IMM\n  | `LDRB_POST_REG\n  | `LDRB_PRE_IMM\n  | `LDRB_PRE_REG\n  | `LDRBi12\n  | `LDRBrs\n  | `LDRD\n  | `LDRD_POST\n  | `LDRD_PRE\n  | `LDREX\n  | `LDREXB\n  | `LDREXD\n  | `LDREXH\n  | `LDRH\n  | `LDRHTr\n  | `LDRH_POST\n  | `LDRH_PRE\n  | `LDRSB\n  | `LDRSBTr\n  | `LDRSB_POST\n  | `LDRSB_PRE\n  | `LDRSH\n  | `LDRSHTi\n  | `LDRSHTr\n  | `LDRSH_POST\n  | `LDRSH_PRE\n  | `LDRT_POST_REG\n  | `LDR_POST_IMM\n  | `LDR_POST_REG\n  | `LDR_PRE_IMM\n  | `LDR_PRE_REG\n  | `LDRi12\n  | `LDRrs\n  | `MLA\n  | `MLS\n  | `MOVPCLR\n  | `MOVTi16\n  | `MOVi\n  | `MOVi16\n  | `MOVr\n  | `MOVsi\n  | `MOVsr\n  | `MRS\n  | `MSR\n  | `MUL\n  | `MVNi\n  | `MVNr\n  | `MVNsi\n  | `MVNsr\n  | `ORRri\n  | `ORRrr\n  | `ORRrsi\n  | `ORRrsr\n  | `PKHTB\n  | `PLDi12\n  | `RBIT\n  | `REV\n  | `REV16\n  | `RSBri\n  | `RSBrr\n  | `RSBrsi\n  | `RSBrsr\n  | `RSCri\n  | `RSCrr\n  | `RSCrsi\n  | `RSCrsr\n  | `SBCri\n  | `SBCrr\n  | `SBCrsi\n  | `SBCrsr\n  | `SBFX\n  | `SMLABB\n  | `SMLAD\n  | `SMLAL\n  | `SMLALBT\n  | `SMLAWB\n  | `SMUAD\n  | `SMULBB\n  | `SMULL\n  | `SMULTB\n  | `STMDA\n  | `STMDA_UPD\n  | `STMDB\n  | `STMDB_UPD\n  | `STMIA\n  | `STMIA_UPD\n  | `STMIB\n  | `STMIB_UPD\n  | `STRBT_POST_IMM\n  | `STRBT_POST_REG\n  | `STRB_POST_IMM\n  | `STRB_POST_REG\n  | `STRB_PRE_IMM\n  | `STRB_PRE_REG\n  | `STRBi12\n  | `STRBrs\n  | `STRD\n  | `STRD_POST\n  | `STRD_PRE\n  | `STREX\n  | `STREXB\n  | `STREXD\n  | `STREXH\n  | `STRH\n  | `STRHTr\n  | `STRH_POST\n  | `STRH_PRE\n  | `STRT_POST_REG\n  | `STR_POST_IMM\n  | `STR_POST_REG\n  | `STR_PRE_IMM\n  | `STR_PRE_REG\n  | `STRi12\n  | `STRrs\n  | `SUBri\n  | `SUBrr\n  | `SUBrsi\n  | `SUBrsr\n  | `SVC\n  | `SWPB\n  | `SXTAB\n  | `SXTAH\n  | `SXTB\n  | `SXTH\n  | `TEQri\n  | `TEQrr\n  | `TEQrsi\n  | `TEQrsr\n  | `TSTri\n  | `TSTrr\n  | `TSTrsi\n  | `TSTrsr\n  | `UBFX\n  | `UMLAL\n  | `UMULL\n  | `UXTAB\n  | `UXTAH\n  | `UXTB\n  | `UXTH ]");
add_manifest("Arm_op.t", "Arm_op.t", "[ `Imm of Std.word | `Reg of Arm_types.reg ]");
add_manifest("Arm_types.op", "Arm_types.op", "[ `Imm of Std.word | `Reg of Arm_types.reg ]");
add_manifest("Arm_cond.t", "Arm_cond.t", "[ `AL\n  | `CC\n  | `CS\n  | `EQ\n  | `GE\n  | `GT\n  | `HI\n  | `LE\n  | `LS\n  | `LT\n  | `MI\n  | `NE\n  | `PL\n  | `VC\n  | `VS ]");
add_manifest("Arm_types.cond", "Arm_types.cond", "[ `AL\n  | `CC\n  | `CS\n  | `EQ\n  | `GE\n  | `GT\n  | `HI\n  | `LE\n  | `LS\n  | `LT\n  | `MI\n  | `NE\n  | `PL\n  | `VC\n  | `VS ]");
add_manifest("Arm_reg.t", "Arm_reg.t", "[ `CPSR\n  | `ITSTATE\n  | `LR\n  | `Nil\n  | `PC\n  | `R0\n  | `R1\n  | `R10\n  | `R11\n  | `R12\n  | `R2\n  | `R3\n  | `R4\n  | `R5\n  | `R6\n  | `R7\n  | `R8\n  | `R9\n  | `SP\n  | `SPSR ]");
add_manifest("Arm_types.reg", "Arm_types.reg", "[ `CPSR\n  | `ITSTATE\n  | `LR\n  | `Nil\n  | `PC\n  | `R0\n  | `R1\n  | `R10\n  | `R11\n  | `R12\n  | `R2\n  | `R3\n  | `R4\n  | `R5\n  | `R6\n  | `R7\n  | `R8\n  | `R9\n  | `SP\n  | `SPSR ]");
add_manifest("Arm_types.nil_reg", "Arm_types.nil_reg", "[ `Nil ]");
add_manifest("Arm_types.gpr_reg", "Arm_types.gpr_reg", "[ `LR\n  | `PC\n  | `R0\n  | `R1\n  | `R10\n  | `R11\n  | `R12\n  | `R2\n  | `R3\n  | `R4\n  | `R5\n  | `R6\n  | `R7\n  | `R8\n  | `R9\n  | `SP ]");
add_manifest("Arm_types.gpr_or_nil", "Arm_types.gpr_or_nil", "[ `LR\n  | `Nil\n  | `PC\n  | `R0\n  | `R1\n  | `R10\n  | `R11\n  | `R12\n  | `R2\n  | `R3\n  | `R4\n  | `R5\n  | `R6\n  | `R7\n  | `R8\n  | `R9\n  | `SP ]");
add_manifest("Arm_types.ccr_reg", "Arm_types.ccr_reg", "[ `CPSR | `ITSTATE | `SPSR ]");
add_manifest("Arm_types.ccr_or_nil", "Arm_types.ccr_or_nil", "[ `CPSR | `ITSTATE | `Nil | `SPSR ]");
add_manifest("Arm_types.non_nil_reg", "Arm_types.non_nil_reg", "[ `CPSR\n  | `ITSTATE\n  | `LR\n  | `PC\n  | `R0\n  | `R1\n  | `R10\n  | `R11\n  | `R12\n  | `R2\n  | `R3\n  | `R4\n  | `R5\n  | `R6\n  | `R7\n  | `R8\n  | `R9\n  | `SP\n  | `SPSR ]");
add_manifest("Arm_types.move_insn", "Arm_types.move_insn", "[ `ADCri\n  | `ADCrr\n  | `ADCrsi\n  | `ADCrsr\n  | `ADDri\n  | `ADDrr\n  | `ADDrsi\n  | `ADDrsr\n  | `ANDri\n  | `ANDrr\n  | `ANDrsi\n  | `ANDrsr\n  | `BICri\n  | `BICrr\n  | `BICrsi\n  | `BICrsr\n  | `CMNri\n  | `CMNzrr\n  | `CMNzrsi\n  | `CMNzrsr\n  | `CMPri\n  | `CMPrr\n  | `CMPrsi\n  | `CMPrsr\n  | `EORri\n  | `EORrr\n  | `EORrsi\n  | `EORrsr\n  | `MOVPCLR\n  | `MOVTi16\n  | `MOVi\n  | `MOVi16\n  | `MOVr\n  | `MOVsi\n  | `MOVsr\n  | `MVNi\n  | `MVNr\n  | `MVNsi\n  | `MVNsr\n  | `ORRri\n  | `ORRrr\n  | `ORRrsi\n  | `ORRrsr\n  | `RSBri\n  | `RSBrr\n  | `RSBrsi\n  | `RSBrsr\n  | `RSCri\n  | `RSCrr\n  | `RSCrsi\n  | `RSCrsr\n  | `SBCri\n  | `SBCrr\n  | `SBCrsi\n  | `SBCrsr\n  | `SUBri\n  | `SUBrr\n  | `SUBrsi\n  | `SUBrsr\n  | `TEQri\n  | `TEQrr\n  | `TEQrsi\n  | `TEQrsr\n  | `TSTri\n  | `TSTrr\n  | `TSTrsi\n  | `TSTrsr ]");
add_manifest("Arm_types.bits_insn", "Arm_types.bits_insn", "[ `BFC\n  | `BFI\n  | `CLZ\n  | `PKHTB\n  | `RBIT\n  | `REV\n  | `REV16\n  | `SBFX\n  | `SWPB\n  | `SXTAB\n  | `SXTAH\n  | `SXTB\n  | `SXTH\n  | `UBFX\n  | `UXTAB\n  | `UXTAH\n  | `UXTB\n  | `UXTH ]");
add_manifest("Arm_types.mult_insn", "Arm_types.mult_insn", "[ `MLA\n  | `MLS\n  | `MUL\n  | `SMLABB\n  | `SMLAD\n  | `SMLAL\n  | `SMLALBT\n  | `SMLAWB\n  | `SMUAD\n  | `SMULBB\n  | `SMULL\n  | `SMULTB\n  | `UMLAL\n  | `UMULL ]");
add_manifest("Arm_types.mem_multi_insn", "Arm_types.mem_multi_insn", "[ `LDMDA\n  | `LDMDA_UPD\n  | `LDMDB\n  | `LDMDB_UPD\n  | `LDMIA\n  | `LDMIA_UPD\n  | `LDMIB\n  | `LDMIB_UPD\n  | `STMDA\n  | `STMDA_UPD\n  | `STMDB\n  | `STMDB_UPD\n  | `STMIA\n  | `STMIA_UPD\n  | `STMIB\n  | `STMIB_UPD ]");
add_manifest("Arm_types.mem_insn", "Arm_types.mem_insn", "[ `LDMDA\n  | `LDMDA_UPD\n  | `LDMDB\n  | `LDMDB_UPD\n  | `LDMIA\n  | `LDMIA_UPD\n  | `LDMIB\n  | `LDMIB_UPD\n  | `LDRBT_POST_IMM\n  | `LDRBT_POST_REG\n  | `LDRB_POST_IMM\n  | `LDRB_POST_REG\n  | `LDRB_PRE_IMM\n  | `LDRB_PRE_REG\n  | `LDRBi12\n  | `LDRBrs\n  | `LDRD\n  | `LDRD_POST\n  | `LDRD_PRE\n  | `LDREX\n  | `LDREXB\n  | `LDREXD\n  | `LDREXH\n  | `LDRH\n  | `LDRHTr\n  | `LDRH_POST\n  | `LDRH_PRE\n  | `LDRSB\n  | `LDRSBTr\n  | `LDRSB_POST\n  | `LDRSB_PRE\n  | `LDRSH\n  | `LDRSHTi\n  | `LDRSHTr\n  | `LDRSH_POST\n  | `LDRSH_PRE\n  | `LDRT_POST_REG\n  | `LDR_POST_IMM\n  | `LDR_POST_REG\n  | `LDR_PRE_IMM\n  | `LDR_PRE_REG\n  | `LDRi12\n  | `LDRrs\n  | `STMDA\n  | `STMDA_UPD\n  | `STMDB\n  | `STMDB_UPD\n  | `STMIA\n  | `STMIA_UPD\n  | `STMIB\n  | `STMIB_UPD\n  | `STRBT_POST_IMM\n  | `STRBT_POST_REG\n  | `STRB_POST_IMM\n  | `STRB_POST_REG\n  | `STRB_PRE_IMM\n  | `STRB_PRE_REG\n  | `STRBi12\n  | `STRBrs\n  | `STRD\n  | `STRD_POST\n  | `STRD_PRE\n  | `STREX\n  | `STREXB\n  | `STREXD\n  | `STREXH\n  | `STRH\n  | `STRHTr\n  | `STRH_POST\n  | `STRH_PRE\n  | `STRT_POST_REG\n  | `STR_POST_IMM\n  | `STR_POST_REG\n  | `STR_PRE_IMM\n  | `STR_PRE_REG\n  | `STRi12\n  | `STRrs ]");
add_manifest("Arm_types.branch_insn", "Arm_types.branch_insn", "[ `BL | `BLX | `BLX_pred | `BLXi | `BL_pred | `BX | `BX_RET | `BX_pred | `Bcc ]");
add_manifest("Arm_types.special_insn", "Arm_types.special_insn", "[ `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ]");
add_manifest("Arm_types.arth", "Arm_types.arth", "[ `ADC | `ADD | `RSB | `RSC | `SBC | `SUB ]");
add_manifest("Arm_types.move", "Arm_types.move", "[ `AND | `BIC | `EOR | `MOV | `MVN | `ORR ]");
add_manifest("Arm_types.data_oper", "Arm_types.data_oper", "[ `ADC\n  | `ADD\n  | `AND\n  | `BIC\n  | `EOR\n  | `MOV\n  | `MVN\n  | `ORR\n  | `RSB\n  | `RSC\n  | `SBC\n  | `SUB ]");
add_manifest("Arm_types.repair", "Arm_types.repair", "[ `NEG | `POS ]");
add_manifest("Arm_types.shift", "Arm_types.shift", "[ `ASR | `LSL | `LSR | `ROR | `RRX ]");
add_manifest("Std.Exp.t -> Std.Exp.t -> Std.Exp.t", "Std.Exp.t -> Std.Exp.t -> Std.Exp.t", "X86_types.binopf");
add_manifest("(Std.typ) * (Std.typ) * (X86_types.operand) * (int) * (int)", "(Std.typ) * (Std.typ) * (X86_types.operand) * (int) * (int)", "X86_types.offsetinfo");
add_manifest("(bool) * (bool) * (bool) * (bool)", "(bool) * (bool) * (bool) * (bool)", "X86_types.rex");
add_manifest("(bool) * (bool) * (bool) * (int) * (bool) * (int) * (bool) * (int)", "(bool) * (bool) * (bool) * (int) * (bool) * (int) * (bool) * (int)", "X86_types.vex");
add_manifest("(Std.typ) * (Std.typ) * (Std.typ) * (Std.typ) * (bool) * (bool) * (bool) * (bool) * (X86_types.rex option) * (X86_types.vex option) * (int) * (int) * (int)", "(Std.typ) * (Std.typ) * (Std.typ) * (Std.typ) * (bool) * (bool) * (bool) * (bool) * (X86_types.rex option) * (X86_types.vex option) * (int) * (int) * (int)", "X86_types.prefix");
add_manifest("(X86_types.Pcmpstr.ssize) * (X86_types.Pcmpstr.ssign) * (X86_types.Pcmpstr.agg) * (bool) * (bool) * (X86_types.Pcmpstr.outselectsig) * (X86_types.Pcmpstr.outselectmask)", "(X86_types.Pcmpstr.ssize) * (X86_types.Pcmpstr.ssign) * (X86_types.Pcmpstr.agg) * (bool) * (bool) * (X86_types.Pcmpstr.outselectsig) * (X86_types.Pcmpstr.outselectmask)", "X86_types.Pcmpstr.imm8cb");
add_manifest("(X86_types.Pcmpstr.out) * (X86_types.Pcmpstr.len)", "(X86_types.Pcmpstr.out) * (X86_types.Pcmpstr.len)", "X86_types.Pcmpstr.pcmpinfo");
add_manifest("X86_asm.reg", "X86_asm.reg", "[ `AH\n  | `AL\n  | `AX\n  | `BH\n  | `BL\n  | `BP\n  | `BPL\n  | `BX\n  | `CH\n  | `CL\n  | `CS\n  | `CX\n  | `DH\n  | `DI\n  | `DIL\n  | `DL\n  | `DS\n  | `DX\n  | `EAX\n  | `EBP\n  | `EBX\n  | `ECX\n  | `EDI\n  | `EDX\n  | `ES\n  | `ESI\n  | `ESP\n  | `FS\n  | `FS_BASE\n  | `GS\n  | `GS_BASE\n  | `R10\n  | `R10B\n  | `R10D\n  | `R10W\n  | `R11\n  | `R11B\n  | `R11D\n  | `R11W\n  | `R12\n  | `R12B\n  | `R12D\n  | `R12W\n  | `R13\n  | `R13B\n  | `R13D\n  | `R13W\n  | `R14\n  | `R14B\n  | `R14D\n  | `R14W\n  | `R15\n  | `R15B\n  | `R15D\n  | `R15W\n  | `R8\n  | `R8B\n  | `R8D\n  | `R8W\n  | `R9\n  | `R9B\n  | `R9D\n  | `R9W\n  | `RAX\n  | `RBP\n  | `RBX\n  | `RCX\n  | `RDI\n  | `RDX\n  | `RSI\n  | `RSP\n  | `SI\n  | `SIL\n  | `SP\n  | `SPL\n  | `SS\n  | `XMM0\n  | `XMM1\n  | `XMM10\n  | `XMM11\n  | `XMM12\n  | `XMM13\n  | `XMM14\n  | `XMM15\n  | `XMM2\n  | `XMM3\n  | `XMM4\n  | `XMM5\n  | `XMM6\n  | `XMM7\n  | `XMM8\n  | `XMM9\n  | `YMM0\n  | `YMM1\n  | `YMM10\n  | `YMM11\n  | `YMM12\n  | `YMM13\n  | `YMM14\n  | `YMM15\n  | `YMM2\n  | `YMM3\n  | `YMM4\n  | `YMM5\n  | `YMM6\n  | `YMM7\n  | `YMM8\n  | `YMM9 ]");
add_manifest("X86_asm_reg_types.r8l", "X86_asm_reg_types.r8l", "[ `AL\n  | `BL\n  | `BPL\n  | `CL\n  | `DIL\n  | `DL\n  | `R10B\n  | `R11B\n  | `R12B\n  | `R13B\n  | `R14B\n  | `R15B\n  | `R8B\n  | `R9B\n  | `SIL\n  | `SPL ]");
add_manifest("X86_asm_reg_types.r8h", "X86_asm_reg_types.r8h", "[ `AH | `BH | `CH | `DH ]");
add_manifest("X86_asm_reg_types.r8", "X86_asm_reg_types.r8", "[ `AH\n  | `AL\n  | `BH\n  | `BL\n  | `BPL\n  | `CH\n  | `CL\n  | `DH\n  | `DIL\n  | `DL\n  | `R10B\n  | `R11B\n  | `R12B\n  | `R13B\n  | `R14B\n  | `R15B\n  | `R8B\n  | `R9B\n  | `SIL\n  | `SPL ]");
add_manifest("X86_asm_reg_types.r16", "X86_asm_reg_types.r16", "[ `AX\n  | `BP\n  | `BX\n  | `CX\n  | `DI\n  | `DX\n  | `R10W\n  | `R11W\n  | `R12W\n  | `R13W\n  | `R14W\n  | `R15W\n  | `R8W\n  | `R9W\n  | `SI\n  | `SP ]");
add_manifest("X86_asm_reg_types.r32", "X86_asm_reg_types.r32", "[ `EAX\n  | `EBP\n  | `EBX\n  | `ECX\n  | `EDI\n  | `EDX\n  | `ESI\n  | `ESP\n  | `R10D\n  | `R11D\n  | `R12D\n  | `R13D\n  | `R14D\n  | `R15D\n  | `R8D\n  | `R9D ]");
add_manifest("X86_asm_reg_types.r64", "X86_asm_reg_types.r64", "[ `R10\n  | `R11\n  | `R12\n  | `R13\n  | `R14\n  | `R15\n  | `R8\n  | `R9\n  | `RAX\n  | `RBP\n  | `RBX\n  | `RCX\n  | `RDI\n  | `RDX\n  | `RSI\n  | `RSP ]");
add_manifest("X86_asm_reg_types.r128", "X86_asm_reg_types.r128", "[ `XMM0\n  | `XMM1\n  | `XMM10\n  | `XMM11\n  | `XMM12\n  | `XMM13\n  | `XMM14\n  | `XMM15\n  | `XMM2\n  | `XMM3\n  | `XMM4\n  | `XMM5\n  | `XMM6\n  | `XMM7\n  | `XMM8\n  | `XMM9 ]");
add_manifest("X86_asm_reg_types.r256", "X86_asm_reg_types.r256", "[ `YMM0\n  | `YMM1\n  | `YMM10\n  | `YMM11\n  | `YMM12\n  | `YMM13\n  | `YMM14\n  | `YMM15\n  | `YMM2\n  | `YMM3\n  | `YMM4\n  | `YMM5\n  | `YMM6\n  | `YMM7\n  | `YMM8\n  | `YMM9 ]");
add_manifest("X86_asm_reg_types.ip", "X86_asm_reg_types.ip", "[ `EIP | `IP | `RIP ]");
add_manifest("X86_asm_reg_types.segment", "X86_asm_reg_types.segment", "[ `CS | `DS | `ES | `FS | `GS | `SS ]");
add_manifest("X86_asm_reg_types.segment_base", "X86_asm_reg_types.segment_base", "[ `FS_BASE | `GS_BASE ]");
add_manifest("X86_asm_reg_types.gpr", "X86_asm_reg_types.gpr", "[ `AH\n  | `AL\n  | `AX\n  | `BH\n  | `BL\n  | `BP\n  | `BPL\n  | `BX\n  | `CH\n  | `CL\n  | `CX\n  | `DH\n  | `DI\n  | `DIL\n  | `DL\n  | `DX\n  | `EAX\n  | `EBP\n  | `EBX\n  | `ECX\n  | `EDI\n  | `EDX\n  | `ESI\n  | `ESP\n  | `R10\n  | `R10B\n  | `R10D\n  | `R10W\n  | `R11\n  | `R11B\n  | `R11D\n  | `R11W\n  | `R12\n  | `R12B\n  | `R12D\n  | `R12W\n  | `R13\n  | `R13B\n  | `R13D\n  | `R13W\n  | `R14\n  | `R14B\n  | `R14D\n  | `R14W\n  | `R15\n  | `R15B\n  | `R15D\n  | `R15W\n  | `R8\n  | `R8B\n  | `R8D\n  | `R8W\n  | `R9\n  | `R9B\n  | `R9D\n  | `R9W\n  | `RAX\n  | `RBP\n  | `RBX\n  | `RCX\n  | `RDI\n  | `RDX\n  | `RSI\n  | `RSP\n  | `SI\n  | `SIL\n  | `SP\n  | `SPL\n  | `XMM0\n  | `XMM1\n  | `XMM10\n  | `XMM11\n  | `XMM12\n  | `XMM13\n  | `XMM14\n  | `XMM15\n  | `XMM2\n  | `XMM3\n  | `XMM4\n  | `XMM5\n  | `XMM6\n  | `XMM7\n  | `XMM8\n  | `XMM9\n  | `YMM0\n  | `YMM1\n  | `YMM10\n  | `YMM11\n  | `YMM12\n  | `YMM13\n  | `YMM14\n  | `YMM15\n  | `YMM2\n  | `YMM3\n  | `YMM4\n  | `YMM5\n  | `YMM6\n  | `YMM7\n  | `YMM8\n  | `YMM9 ]");
add_manifest("X86_asm_reg_types.t", "X86_asm_reg_types.t", "[ `AH\n  | `AL\n  | `AX\n  | `BH\n  | `BL\n  | `BP\n  | `BPL\n  | `BX\n  | `CH\n  | `CL\n  | `CS\n  | `CX\n  | `DH\n  | `DI\n  | `DIL\n  | `DL\n  | `DS\n  | `DX\n  | `EAX\n  | `EBP\n  | `EBX\n  | `ECX\n  | `EDI\n  | `EDX\n  | `EIP\n  | `ES\n  | `ESI\n  | `ESP\n  | `FS\n  | `FS_BASE\n  | `GS\n  | `GS_BASE\n  | `IP\n  | `R10\n  | `R10B\n  | `R10D\n  | `R10W\n  | `R11\n  | `R11B\n  | `R11D\n  | `R11W\n  | `R12\n  | `R12B\n  | `R12D\n  | `R12W\n  | `R13\n  | `R13B\n  | `R13D\n  | `R13W\n  | `R14\n  | `R14B\n  | `R14D\n  | `R14W\n  | `R15\n  | `R15B\n  | `R15D\n  | `R15W\n  | `R8\n  | `R8B\n  | `R8D\n  | `R8W\n  | `R9\n  | `R9B\n  | `R9D\n  | `R9W\n  | `RAX\n  | `RBP\n  | `RBX\n  | `RCX\n  | `RDI\n  | `RDX\n  | `RIP\n  | `RSI\n  | `RSP\n  | `SI\n  | `SIL\n  | `SP\n  | `SPL\n  | `SS\n  | `XMM0\n  | `XMM1\n  | `XMM10\n  | `XMM11\n  | `XMM12\n  | `XMM13\n  | `XMM14\n  | `XMM15\n  | `XMM2\n  | `XMM3\n  | `XMM4\n  | `XMM5\n  | `XMM6\n  | `XMM7\n  | `XMM8\n  | `XMM9\n  | `YMM0\n  | `YMM1\n  | `YMM10\n  | `YMM11\n  | `YMM12\n  | `YMM13\n  | `YMM14\n  | `YMM15\n  | `YMM2\n  | `YMM3\n  | `YMM4\n  | `YMM5\n  | `YMM6\n  | `YMM7\n  | `YMM8\n  | `YMM9 ]");
add_manifest("(module Bap_api.S)", "(module Bap_api.S)", "Bap_api.t");
add_manifest("Bap_c_type.char", "Bap_c_type.char", "[ `char | `schar | `uchar ]");
add_manifest("Bap_c_type.short", "Bap_c_type.short", "[ `sshort | `ushort ]");
add_manifest("Bap_c_type.cint", "Bap_c_type.cint", "[ `sint | `uint ]");
add_manifest("Bap_c_type.long", "Bap_c_type.long", "[ `slong | `ulong ]");
add_manifest("Bap_c_type.long_long", "Bap_c_type.long_long", "[ `slong_long | `ulong_long ]");
add_manifest("Bap_c_type.signed", "Bap_c_type.signed", "[ `schar | `sint | `slong | `slong_long | `sshort ]");
add_manifest("Bap_c_type.unsigned", "Bap_c_type.unsigned", "[ `uchar | `uint | `ulong | `ulong_long | `ushort ]");
add_manifest("Bap_c_type.enum", "Bap_c_type.enum", "[ `enum of (string * int64 option) list ]");
add_manifest("Bap_c_type.integer", "Bap_c_type.integer", "[ `char\n  | `enum of (string * int64 option) list\n  | `schar\n  | `sint\n  | `slong\n  | `slong_long\n  | `sshort\n  | `uchar\n  | `uint\n  | `ulong\n  | `ulong_long\n  | `ushort ]");
add_manifest("Bap_c_type.real", "Bap_c_type.real", "[ `double | `float | `long_double ]");
add_manifest("Bap_c_type.complex", "Bap_c_type.complex", "[ `cdouble | `cfloat | `clong_double ]");
add_manifest("Bap_c_type.floating", "Bap_c_type.floating", "[ `cdouble | `cfloat | `clong_double | `double | `float | `long_double ]");
add_manifest("Bap_c_type.basic", "Bap_c_type.basic", "[ `cdouble\n  | `cfloat\n  | `char\n  | `clong_double\n  | `double\n  | `enum of (string * int64 option) list\n  | `float\n  | `long_double\n  | `schar\n  | `sint\n  | `slong\n  | `slong_long\n  | `sshort\n  | `uchar\n  | `uint\n  | `ulong\n  | `ulong_long\n  | `ushort ]");
add_manifest("Bap_c_type.cv", "Bap_c_type.cv", "unit");
add_manifest("Bap_c_type.cvr", "Bap_c_type.cvr", "Bool.t");
add_manifest("'a18 Bap_c_type.Qualifier.t", "'a18 Bap_c_type.Qualifier.t", "Bap_c_type.qualifier");
add_manifest("'a18 Bap_c_type.qualifier", "'a18 Bap_c_type.qualifier", "Bap_c_type.qualifier");
add_manifest("(string) * (string sexp_list)", "(string) * (string sexp_list)", "Bap_c_type.attr");
add_manifest("Bap_c_type.Attr.t", "Bap_c_type.Attr.t", "Bap_c_type.attr");
add_manifest("('a17, 'b0) Bap_c_type.Spec.t", "('a17, 'b0) Bap_c_type.Spec.t", "Bap_c_type.spec");
add_manifest("('a17, 'b0) Bap_c_type.spec", "('a17, 'b0) Bap_c_type.spec", "Bap_c_type.spec");
add_manifest("Bap_c_type.no_qualifier", "Bap_c_type.no_qualifier", "[ `no_qualifier ]");
add_manifest("Bap_c_type.t", "Bap_c_type.t", "[ `Array of\n      (Bap_c_type.cvr Bap_c_type.qualifier, Bap_c_type.array) Bap_c_type.spec\n  | `Basic of\n      (Bap_c_type.cv Bap_c_type.qualifier, Bap_c_type.basic) Bap_c_type.spec\n  | `Function of (Bap_c_type.no_qualifier, Bap_c_type.proto) Bap_c_type.spec\n  | `Pointer of\n      (Bap_c_type.cvr Bap_c_type.qualifier, Bap_c_type.t) Bap_c_type.spec\n  | `Structure of\n      (Bap_c_type.no_qualifier, Bap_c_type.compound) Bap_c_type.spec\n  | `Union of (Bap_c_type.no_qualifier, Bap_c_type.compound) Bap_c_type.spec\n  | `Void ]");
add_manifest("Bap_c_type.proto", "Bap_c_type.proto", "Bap_c_type.t Bap_c_type.Proto.t");
add_manifest("Bap_c_type.compound", "Bap_c_type.compound", "Bap_c_type.t Bap_c_type.Compound.t");
add_manifest("Bap_c_type.array", "Bap_c_type.array", "Bap_c_type.t Bap_c_type.Array.t");
add_manifest("Bap_c_type.scalar", "Bap_c_type.scalar", "[ `Basic of\n      (Bap_c_type.cv Bap_c_type.qualifier, Bap_c_type.basic) Bap_c_type.spec\n  | `Pointer of\n      (Bap_c_type.cvr Bap_c_type.qualifier, Bap_c_type.t) Bap_c_type.spec ]");
add_manifest("Bap_c_type.aggregate", "Bap_c_type.aggregate", "[ `Array of (Bap_c_type.no_qualifier, Bap_c_type.t) Bap_c_type.spec\n  | `Structure of (Bap_c_type.no_qualifier, Bap_c_type.t list) Bap_c_type.spec ]");
add_manifest("'a16 Bap_c_type.Qualifier.t", "'a16 Bap_c_type.Qualifier.t", "Bap_c_type.Qualifier.t");
add_manifest("(Bool.t) * (Bool.t) * ('a16)", "(Bool.t) * (Bool.t) * ('a16)", "Bap_c_type.Qualifier.t");
add_manifest("('a15) * ('b) * (Bap_c_type.attr sexp_list)", "('a15) * ('b) * (Bap_c_type.attr sexp_list)", "Bap_c_type.Spec.t");
add_manifest("('a15, 'b) Bap_c_type.Spec.t", "('a15, 'b) Bap_c_type.Spec.t", "Bap_c_type.Spec.t");
add_manifest("'a14 Bap_c_type.Proto.t", "'a14 Bap_c_type.Proto.t", "Bap_c_type.Proto.t");
add_manifest("('a14) * ((string * 'a14) list) * (Bool.t)", "('a14) * ((string * 'a14) list) * (Bool.t)", "Bap_c_type.Proto.t");
add_manifest("'a13 Bap_c_type.Compound.t", "'a13 Bap_c_type.Compound.t", "Bap_c_type.Compound.t");
add_manifest("(string) * ((string * 'a13) list)", "(string) * ((string * 'a13) list)", "Bap_c_type.Compound.t");
add_manifest("'a12 Bap_c_type.Array.t", "'a12 Bap_c_type.Array.t", "Bap_c_type.Array.t");
add_manifest("('a12) * (Int.t option)", "('a12) * (Int.t option)", "Bap_c_type.Array.t");
add_manifest("Bap_c_data.model32", "Bap_c_data.model32", "[ `ILP32 | `LP32 ]");
add_manifest("Bap_c_data.model64", "Bap_c_data.model64", "[ `ILP64 | `LLP64 | `LP64 ]");
add_manifest("Bap_c_data.model", "Bap_c_data.model", "[ `ILP32 | `ILP64 | `LLP64 | `LP32 | `LP64 ]");
add_manifest("'a11 Bap_c_attr.pass", "'a11 Bap_c_attr.pass", "Bap_c_type.attr -> 'a11 Std.term -> 'a11 Std.term");
add_manifest("Bap_c_attr.pass", "Bap_c_attr.pass", "Bap_c_type.attr -> 'a11 Std.term -> 'a11 Std.term");
add_manifest("Bap_c_abi.param", "Bap_c_abi.param", "Bap_c_data.t * Std.exp");
add_manifest("(Bap_c_abi.param option) * ((Bap_c_type.t * Bap_c_abi.param) list) * (Bap_c_abi.param list)", "(Bap_c_abi.param option) * ((Bap_c_type.t * Bap_c_abi.param) list) * (Bap_c_abi.param list)", "Bap_c_abi.args");
add_manifest("(Std.sub Std.term ->\n  Bap_c_type.attr list -> Bap_c_type.proto -> Bap_c_abi.args option) * (Bap_c_type.attr list -> Std.sub Std.term -> Std.sub Std.term)", "(Std.sub Std.term ->\n  Bap_c_type.attr list -> Bap_c_type.proto -> Bap_c_abi.args option) * (Bap_c_type.attr list -> Std.sub Std.term -> Std.sub Std.term)", "Bap_c_abi.t");
add_manifest("Bap_c_size.bits", "Bap_c_size.bits", "Int.t");
add_manifest("(string * Bap_c_type.t) list", "(string * Bap_c_type.t) list", "Bap_c_parser.decls");
add_manifest("Bap_c_parser.parser", "Bap_c_parser.parser", "Bap_c_size.base -> string -> Bap_c_parser.decls Or_error.t");
add_manifest("Bap_byteweight_signatures.error", "Bap_byteweight_signatures.error", "[ `Corrupted of string\n  | `No_entry of string\n  | `No_signatures\n  | `Sys_error of string ]");
add_manifest("Bap_demangle.Std.Demangler.t", "Bap_demangle.Std.Demangler.t", "Bap_demangle.Std.demangler");
add_manifest("Bap_dwarf.Std.Dwarf.Tag.t", "Bap_dwarf.Std.Dwarf.Tag.t", "Bap_dwarf.Std.Dwarf.tag");
add_manifest("Bap_dwarf.Std.Dwarf.Attr.t", "Bap_dwarf.Std.Dwarf.Attr.t", "Bap_dwarf.Std.Dwarf.attr");
add_manifest("Bap_dwarf.Std.Dwarf.Form.t", "Bap_dwarf.Std.Dwarf.Form.t", "Bap_dwarf.Std.Dwarf.form");
add_manifest("Bap_dwarf.Std.Dwarf.Section.t", "Bap_dwarf.Std.Dwarf.Section.t", "Bap_dwarf.Std.Dwarf.section");
add_manifest("Bap_dwarf.Std.Dwarf.Fn.t", "Bap_dwarf.Std.Dwarf.Fn.t", "Bap_dwarf.Std.Dwarf.fn");
add_manifest("'a7 Bap_dwarf.Std.Dwarf.Buffer.t", "'a7 Bap_dwarf.Std.Dwarf.Buffer.t", "Bap_dwarf.Std.Dwarf.Data.buffer");
add_manifest("'a7 Bap_dwarf.Std.Dwarf.Data.buffer", "'a7 Bap_dwarf.Std.Dwarf.Data.buffer", "Bap_dwarf.Std.Dwarf.Data.buffer");
add_manifest("'a6 Bap_dwarf.Std.Leb128.encoder", "'a6 Bap_dwarf.Std.Leb128.encoder", "Bap_dwarf.Std.Leb128.encoder");
add_manifest("?signed:bool -> 'a6 -> Bap_dwarf.Std.Leb128.t", "?signed:bool -> 'a6 -> Bap_dwarf.Std.Leb128.t", "Bap_dwarf.Std.Leb128.encoder");
add_manifest("'a5 Bap_dwarf.Std.Leb128.decoder", "'a5 Bap_dwarf.Std.Leb128.decoder", "Bap_dwarf.Std.Leb128.t -> 'a5 Or_error.t");
add_manifest("Bap_dwarf.Std.Leb128.decoder", "Bap_dwarf.Std.Leb128.decoder", "Bap_dwarf.Std.Leb128.t -> 'a5 Or_error.t");
add_manifest("Bap_ida.Std.Ida.t", "Bap_ida.Std.Ida.t", "Bap_ida.Std.ida");
add_manifest("'a3 Bap_ida.Std.Command.t", "'a3 Bap_ida.Std.Command.t", "Bap_ida.Std.Command.t");
add_manifest("'a3 Bap_ida.Std.command", "'a3 Bap_ida.Std.command", "Bap_ida.Std.Command.t");
add_manifest("Bap_ida.Std.Command.language", "Bap_ida.Std.Command.language", "[ `idc | `python ]");
add_manifest("('a3. 'a3 Bap_ida.Std.command -> 'a3) * (unit -> unit)", "('a3. 'a3 Bap_ida.Std.command -> 'a3) * (unit -> unit)", "Bap_ida.Std.Service.t");
add_manifest("Bap_llvm.Std.x86_syntax", "Bap_llvm.Std.x86_syntax", "[ `att | `intel ]");
add_manifest("(string option) * (Std.addr)", "(string option) * (Std.addr)", "Bap_traces.Std.location");
add_manifest("Bap_traces.Std.Location.t", "Bap_traces.Std.Location.t", "Bap_traces.Std.location");
add_manifest("'a2 Bap_traces.Std.Move.t", "'a2 Bap_traces.Std.Move.t", "Bap_traces.Std.move");
add_manifest("'a2 Bap_traces.Std.move", "'a2 Bap_traces.Std.move", "Bap_traces.Std.move");
add_manifest("(Std.addr) * (string)", "(Std.addr) * (string)", "Bap_traces.Std.chunk");
add_manifest("Bap_traces.Std.Chunk.t", "Bap_traces.Std.Chunk.t", "Bap_traces.Std.chunk");
add_manifest("(int) * (Std.word array)", "(int) * (Std.word array)", "Bap_traces.Std.syscall");
add_manifest("Bap_traces.Std.Syscall.t", "Bap_traces.Std.Syscall.t", "Bap_traces.Std.syscall");
add_manifest("(int) * (Std.addr option) * (Std.addr option)", "(int) * (Std.addr option) * (Std.addr option)", "Bap_traces.Std.exn");
add_manifest("Bap_traces.Std.Exn.t", "Bap_traces.Std.Exn.t", "Bap_traces.Std.exn");
add_manifest("(Bap_traces.Std.location) * (Bap_traces.Std.location) * (Std.word array)", "(Bap_traces.Std.location) * (Bap_traces.Std.location) * (Std.word array)", "Bap_traces.Std.call");
add_manifest("Bap_traces.Std.Call.t", "Bap_traces.Std.Call.t", "Bap_traces.Std.call");
add_manifest("(string) * (string)", "(string) * (string)", "Bap_traces.Std.return");
add_manifest("Bap_traces.Std.Return.t", "Bap_traces.Std.Return.t", "Bap_traces.Std.return");
add_manifest("(string) * (Std.addr) * (Std.addr)", "(string) * (Std.addr) * (Std.addr)", "Bap_traces.Std.modload");
add_manifest("Bap_traces.Std.Modload.t", "Bap_traces.Std.Modload.t", "Bap_traces.Std.modload");
add_manifest("(string) * (string array) * (string array) * (string)", "(string) * (string array) * (string array) * (string)", "Bap_traces.Std.tracer");
add_manifest("Bap_traces.Std.Binary.t", "Bap_traces.Std.Binary.t", "Bap_traces.Std.tracer");
add_manifest("Bap_traces.Std.Tracer.t", "Bap_traces.Std.Tracer.t", "Bap_traces.Std.tracer");
add_manifest("Bap_traces.Std.binary", "Bap_traces.Std.binary", "Bap_traces.Std.tracer");
add_manifest("(int) * (float) * (float) * (float)", "(int) * (float) * (float) * (float)", "Bap_traces.Std.file_stats");
add_manifest("Bap_traces.Std.File_stats.t", "Bap_traces.Std.File_stats.t", "Bap_traces.Std.file_stats");
add_manifest("(string) * (string) * (float)", "(string) * (string) * (float)", "Bap_traces.Std.trace_stats");
add_manifest("Bap_traces.Std.Trace_stats.t", "Bap_traces.Std.Trace_stats.t", "Bap_traces.Std.trace_stats");
add_manifest("Bap_traces.Std.Trace.t", "Bap_traces.Std.Trace.t", "Bap_traces.Std.trace");
add_manifest("Bap_traces.Std.Trace.io_error", "Bap_traces.Std.Trace.io_error", "[ `Protocol_error of Error.t | `System_error of Unix.error ]");
add_manifest("Bap_traces.Std.Trace.error", "Bap_traces.Std.Trace.error", "[ `Ambiguous_uri\n  | `No_provider\n  | `Protocol_error of Error.t\n  | `System_error of Unix.error ]");
add_manifest("(Bap_traces.Std.Trace.tool) * (Std.dict) * (unit -> Bap_traces.Std.Trace.event Or_error.t option)", "(Bap_traces.Std.Trace.tool) * (Std.dict) * (unit -> Bap_traces.Std.Trace.event Or_error.t option)", "Bap_traces.Std.Trace.reader");
add_manifest("Bap_traces.Std.Trace.Reader.t", "Bap_traces.Std.Trace.Reader.t", "Bap_traces.Std.Trace.reader");
add_manifest("Bap_traces.Std.Trace.step", "Bap_traces.Std.Trace.step", "[ `Fail | `Make of Bap_traces.Std.Trace.event | `Skip | `Stop ]");
add_manifest("Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.monitor");
add_manifest("'a1 Bap_traces.Std.Move.t", "'a1 Bap_traces.Std.Move.t", "Bap_traces.Std.Move.t");
add_manifest("('a1) * (Std.word)", "('a1) * (Std.word)", "Bap_traces.Std.Move.t");
add_ocaml_element("print_colors", "Text_tags.Attr.print_colors", "value", "bool -> unit", "Text_tags.Attr.html#VALprint_colors", "<div class=\"info\">\n<p><code class=\"code\">print_colors&nbsp;yesno</code> enable/disable color submode.</p>\n\n</div>\n", ["COLOR", "DISABLE", "ENABLE", "PRINT_COLORS", "SUBMODE", "YESNO"]);
add_ocaml_element("hide", "Text_tags.Attr.hide", "value", "string -> unit", "Text_tags.Attr.html#VALhide", "<div class=\"info\">\n<p><code class=\"code\">hide&nbsp;name</code> disable attribute with the <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ATTRIBUTE", "DISABLE", "HIDE", "NAME", "THE", "WITH"]);
add_ocaml_element("show", "Text_tags.Attr.show", "value", "string -> unit", "Text_tags.Attr.html#VALshow", "<div class=\"info\">\n<p><code class=\"code\">show&nbsp;name</code> enable attribute with the <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ATTRIBUTE", "ENABLE", "NAME", "SHOW", "THE", "WITH"]);
add_ocaml_element("available_modes", "Text_tags.available_modes", "value", "unit -> Text_tags.mode list", "Text_tags.html#VALavailable_modes", "<div class=\"info\">\n<p><code class=\"code\">available_modes&nbsp;()</code> lists all currently installed modes.</p>\n\n</div>\n", ["ALL", "AVAILABLE_MODES", "CURRENTLY", "INSTALLED", "LISTS", "MODES"]);
add_ocaml_element("register_mode", "Text_tags.register_mode", "value", "Text_tags.mode -> (Stdlib.Format.formatter -> unit) -> unit", "Text_tags.html#VALregister_mode", "<div class=\"info\">\n<p><code class=\"code\">register_mode&nbsp;mode&nbsp;init</code> installs new mode.</p>\n\n</div>\n", ["ALL", "FORMAT", "FUNCTION", "HOOKS", "INIT", "INSTALL", "INSTALLS", "INTERFACE", "MODE", "MUST", "NEW", "REGISTER_MODE", "THE", "USING"]);
add_ocaml_element("with_mode", "Text_tags.with_mode", "value", "Stdlib.Format.formatter -> Text_tags.mode -> f:(unit -> 'a) -> 'a", "Text_tags.html#VALwith_mode", "<div class=\"info\">\n<p><code class=\"code\">with_mode&nbsp;ppf&nbsp;mode&nbsp;f</code> installs <code class=\"code\">mode</code>, calls <code class=\"code\">f</code>, and then\n    reinstalls the previous mode.</p>\n\n</div>\n", ["AND", "CALLS", "INSTALLS", "MODE", "PPF", "PREVIOUS", "REINSTALLS", "THE", "THEN", "WITH_MODE"]);
add_ocaml_element("install", "Text_tags.install", "value", "Stdlib.Format.formatter -> Text_tags.mode -> unit", "Text_tags.html#VALinstall", "<div class=\"info\">\n<p><code class=\"code\">install&nbsp;ppf&nbsp;mode</code> switch formatter <code class=\"code\">ppf</code> into a <code class=\"code\">mode</code>.</p>\n\n</div>\n", ["ACCORDING", "ALL", "ARE", "DEFAULT", "FORMATTER", "IGNORED", "INSTALL", "INSTALLED", "INTO", "MODE", "NAMED", "NONE", "ONCE", "PPF", "RENDERED", "SEMANTICS", "SWITCH", "TAGS", "THE", "WILL"]);
add_ocaml_element("is_buildable", "Bap_strings_unscrambler.Make.is_buildable", "value", "Bap_strings_unscrambler.Make.t -> string -> bool", "Bap_strings_unscrambler.Make.html#VALis_buildable", "<div class=\"info\">\n<p><code class=\"code\">is_buildable&nbsp;d&nbsp;chars</code> returns <code class=\"code\"><span class=\"keyword\">true</span></code> if in the dictionary <code class=\"code\">d</code>\n      exists a word that can be built from the given characters.</p>\n\n</div>\n", ["BUILT", "CAN", "CHARACTERS", "CHARS", "DICTIONARY", "EXISTS", "FROM", "GIVEN", "IS_BUILDABLE", "RETURNS", "THAT", "THE", "TRUE", "WORD"]);
add_ocaml_element("build", "Bap_strings_unscrambler.Make.build", "value", "Bap_strings_unscrambler.Make.t -> string -> string Sequence.t", "Bap_strings_unscrambler.Make.html#VALbuild", "<div class=\"info\">\n<p><code class=\"code\">build&nbsp;d&nbsp;chars</code> returns a sequence of all words in the\n      dictionary <code class=\"code\">d</code> that could be built from the sequence of characters <code class=\"code\">chars</code></p>\n\n</div>\n", ["ALL", "BUILD", "BUILT", "CHARACTERS", "CHARS", "COULD", "DICTIONARY", "FROM", "RETURNS", "SEQUENCE", "THAT", "THE", "WORDS"]);
add_ocaml_element("add_word", "Bap_strings_unscrambler.Make.add_word", "value", "Bap_strings_unscrambler.Make.t -> string -> Bap_strings_unscrambler.Make.t", "Bap_strings_unscrambler.Make.html#VALadd_word", "<div class=\"info\">\n<p><code class=\"code\">add_word&nbsp;d&nbsp;x</code> extends the dictionary <code class=\"code\">d</code> with the new word <code class=\"code\">x</code>.</p>\n\n</div>\n", ["ADD_WORD", "DICTIONARY", "EXTENDS", "NEW", "THE", "WITH", "WORD"]);
add_ocaml_element("of_files", "Bap_strings_unscrambler.Make.of_files", "value", "string list -> Bap_strings_unscrambler.Make.t", "Bap_strings_unscrambler.Make.html#VALof_files", "<div class=\"info\">\n<p><code class=\"code\">of_files&nbsp;names</code> reads the dictionary from all provided file\n      <code class=\"code\">names</code>, each file should be a sequence of newline separated\n      words.</p>\n\n</div>\n", ["ALL", "DICTIONARY", "EACH", "FILE", "FROM", "NAMES", "NEWLINE", "OF_FILES", "PROVIDED", "READS", "SEPARATED", "SEQUENCE", "SHOULD", "THE", "WORDS"]);
add_ocaml_element("of_file", "Bap_strings_unscrambler.Make.of_file", "value", "string -> Bap_strings_unscrambler.Make.t", "Bap_strings_unscrambler.Make.html#VALof_file", "<div class=\"info\">\n<p><code class=\"code\">of_file&nbsp;name</code> reads the dictionary from file <code class=\"code\">name</code>,\n      each word is on a separate line.</p>\n\n</div>\n", ["DICTIONARY", "EACH", "FILE", "FORMAT", "FROM", "LINE", "LINUX", "NAME", "OF_FILE", "READS", "SEPARATE", "STANDARD", "THE", "WORD"]);
add_ocaml_element("empty", "Bap_strings_unscrambler.Make.empty", "value", "Bap_strings_unscrambler.Make.t", "Bap_strings_unscrambler.Make.html#VALempty", "<div class=\"info\">\n<p>an empty unscrambler that doesn't know any words</p>\n\n</div>\n", ["ANY", "DOESN", "EMPTY", "KNOW", "THAT", "UNSCRAMBLER", "WORDS"]);
add_ocaml_element("index", "Bap_strings_unscrambler.Alphabet.index", "value", "char -> int", "Bap_strings_unscrambler.Alphabet.html#VALindex", "<div class=\"info\">\n<p><code class=\"code\">index&nbsp;x</code> maps <code class=\"code\">x</code> to the <code class=\"code\">n</code>'th symbol of an alphabet, if <code class=\"code\">x</code>\n      is a representation of that symbols, returns a number that is\n      outside of <code class=\"code\">[0,len-1]</code> interval if it is not.</p>\n\n</div>\n", ["ALPHABET", "INDEX", "INTERVAL", "LEN", "MAPS", "NOT", "NUMBER", "OUTSIDE", "REPRESENTATION", "RETURNS", "SYMBOL", "SYMBOLS", "THAT", "THE"]);
add_ocaml_element("length", "Bap_strings_unscrambler.Alphabet.length", "value", "int", "Bap_strings_unscrambler.Alphabet.html#VALlength", "<div class=\"info\">\n<p>total number of symbols in the alphabet</p>\n\n</div>\n", ["ALPHABET", "NUMBER", "SYMBOLS", "THE", "TOTAL"]);
add_ocaml_element("pp_stats", "Bap_strings_detector.pp_stats", "value", "Stdlib.Format.formatter -> 'a Bap_strings_detector.t -> unit", "Bap_strings_detector.html#VALpp_stats", "", []);
add_ocaml_element("pp_decision", "Bap_strings_detector.pp_decision", "value", "Stdlib.Format.formatter -> 'a Bap_strings_detector.decision -> unit", "Bap_strings_detector.html#VALpp_decision", "", []);
add_ocaml_element("pp", "Bap_strings_detector.pp", "value", "Stdlib.Format.formatter -> 'a Bap_strings_detector.t -> unit", "Bap_strings_detector.html#VALpp", "", []);
add_ocaml_element("data", "Bap_strings_detector.data", "value", "?rev:bool -> 'a Bap_strings_detector.decision -> 'a list", "Bap_strings_detector.html#VALdata", "", []);
add_ocaml_element("chars", "Bap_strings_detector.chars", "value", "'a Bap_strings_detector.decision -> string", "Bap_strings_detector.html#VALchars", "", []);
add_ocaml_element("result", "Bap_strings_detector.result", "value", "'a Bap_strings_detector.decision -> ('a * char) list", "Bap_strings_detector.html#VALresult", "", []);
add_ocaml_element("abort", "Bap_strings_detector.abort", "value", "'a Bap_strings_detector.t -> 'a Bap_strings_detector.decision option", "Bap_strings_detector.html#VALabort", "", []);
add_ocaml_element("when_decided", "Bap_strings_detector.when_decided", "value", "'a Bap_strings_detector.t ->\n  f:('a Bap_strings_detector.decision -> 'b) -> 'b -> 'b", "Bap_strings_detector.html#VALwhen_decided", "", []);
add_ocaml_element("decision", "Bap_strings_detector.decision", "value", "'a Bap_strings_detector.t -> 'a Bap_strings_detector.decision option", "Bap_strings_detector.html#VALdecision", "", []);
add_ocaml_element("step", "Bap_strings_detector.step", "value", "'a Bap_strings_detector.t -> 'a -> char -> 'a Bap_strings_detector.t", "Bap_strings_detector.html#VALstep", "<div class=\"info\">\n<p><code class=\"code\">step&nbsp;t&nbsp;data&nbsp;char</code> performs one observation.</p>\n\n</div>\n", ["CHAR", "DATA", "OBSERVATION", "ONE", "PERFORMS", "STEP"]);
add_ocaml_element("run", "Bap_strings_detector.run", "value", "'a Bap_strings_detector.t ->\n  ('a * char) Sequence.t ->\n  'a Bap_strings_detector.decision Sequence.t", "Bap_strings_detector.html#VALrun", "", []);
add_ocaml_element("create", "Bap_strings_detector.create", "value", "?alpha:float ->\n  ?beta:float ->\n  ?p1:float ->\n  ?ps:float ->\n  ?len_pdf:(float -> float) ->\n  Char.Set.t -> 'a Bap_strings_detector.t", "Bap_strings_detector.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;alphabet</code> creates a detector.</p>\n\n</div>\n", ["ALPHABET", "CREATE", "CREATES", "DETECTOR"]);
add_ocaml_element("run", "Bap_strings_scanner.run", "value", "?is_stop:(char -> bool) ->\n  read:(int -> char option) -> int -> (int * string) Sequence.t", "Bap_strings_scanner.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">scan&nbsp;~is_stop&nbsp;~read&nbsp;off</code> applies <code class=\"code\">next&nbsp;~is_stop&nbsp;~read</code> for all\n    offsets that are bigger than <code class=\"code\">off</code> until <code class=\"code\">read&nbsp;off</code> is not <code class=\"code\"><span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["ALL", "APPLIES", "ARE", "BIGGER", "CORRESPONDING", "DATA", "EMPTY", "FOR", "IS_STOP", "NEXT", "NON", "NONE", "NOT", "OFF", "OFFSETS", "PAIRED", "READ", "RETURNS", "SCAN", "SEQUENCE", "STRINGS", "THAN", "THAT", "THEIR", "UNTIL", "WITH"]);
add_ocaml_element("next", "Bap_strings_scanner.next", "value", "?is_stop:(char -> bool) -> read:(int -> char option) -> int -> string", "Bap_strings_scanner.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;~is_stop&nbsp;~read&nbsp;off</code> reads characters starting with the\n    offset <code class=\"code\">off</code>, using the <code class=\"code\">read</code> function to map offsets to\n    characters, until the <code class=\"code\">is_stop</code> character occurs, or the <code class=\"code\">read</code>\n    function returns <code class=\"code\"><span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["CHARACTER", "CHARACTERS", "FORALL", "FUNCTION", "IS_STOP", "MAP", "NEXT", "NONE", "NOT", "OCCURS", "OFF", "OFFSET", "OFFSETS", "POSTCONDITION", "READ", "READS", "RESULT", "RETURNS", "STARTING", "THE", "UNTIL", "USING", "WITH"]);
add_ocaml_element("succ", "Bap_strings_index.Key.succ", "value", "Bap_strings_index.Key.t -> Bap_strings_index.Key.t", "Bap_strings_index.Key.html#VALsucc", "", []);
add_ocaml_element("null", "Bap_strings_index.Key.null", "value", "Bap_strings_index.Key.t", "Bap_strings_index.Key.html#VALnull", "", []);
add_ocaml_element("compare", "Bap_strings_index.Key.compare", "value", "Bap_strings_index.Key.t -> Bap_strings_index.Key.t -> int", "Bap_strings_index.Key.html#VALcompare", "", []);
add_ocaml_element("registered", "Bap_strings_index.Persistent.S.registered", "value", "Bap_strings_index.Persistent.S.t -> string -> bool", "Bap_strings_index.Persistent.S.html#VALregistered", "<div class=\"info\">\n<p><code class=\"code\">registered&nbsp;idx&nbsp;data</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">data</code> was registered in\n        the index.</p>\n\n</div>\n", ["DATA", "IDX", "INDEX", "REGISTERED", "THE", "TRUE", "WAS"]);
add_ocaml_element("register", "Bap_strings_index.Persistent.S.register", "value", "Bap_strings_index.Persistent.S.t ->\n  string -> Bap_strings_index.Persistent.S.t", "Bap_strings_index.Persistent.S.html#VALregister", "<div class=\"info\">\n<p><code class=\"code\">register&nbsp;idx&nbsp;data</code> registers data in the index <code class=\"code\">idx</code>.</p>\n\n</div>\n", ["ALREADY", "ASSOCIATED", "DATA", "FRESH", "IDX", "INDEX", "KEY", "NEW", "OTHERWISE", "REGISTER", "REGISTERED", "REGISTERS", "RETURNED", "RETURNS", "THE", "THEN", "UNCHANGED", "WHERE", "WITH"]);
add_ocaml_element("key", "Bap_strings_index.Persistent.S.key", "value", "Bap_strings_index.Persistent.S.t ->\n  string -> Bap_strings_index.Persistent.S.key", "Bap_strings_index.Persistent.S.html#VALkey", "<div class=\"info\">\n<p><code class=\"code\">key&nbsp;idx&nbsp;data</code> returns the key associated with <code class=\"code\">data</code>, if no\n        key is associated then <code class=\"code\"><span class=\"constructor\">Key</span>.null</code> is returned</p>\n\n</div>\n", ["ASSOCIATED", "DATA", "IDX", "KEY", "NULL", "RETURNED", "RETURNS", "THE", "THEN", "WITH"]);
add_ocaml_element("string", "Bap_strings_index.Persistent.S.string", "value", "Bap_strings_index.Persistent.S.t ->\n  Bap_strings_index.Persistent.S.key -> string", "Bap_strings_index.Persistent.S.html#VALstring", "<div class=\"info\">\n<p><code class=\"code\">string&nbsp;idx&nbsp;key</code> returns data associated with the\n        provided <code class=\"code\">key</code>.</p>\n\n</div>\n", ["ARE", "ASSOCIATED", "DATA", "EMPTY", "IDX", "KEY", "PROVIDED", "RETURNS", "STRING", "THE", "THERE", "WITH"]);
add_ocaml_element("empty", "Bap_strings_index.Persistent.S.empty", "value", "Bap_strings_index.Persistent.S.t", "Bap_strings_index.Persistent.S.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty</code> an empty index</p>\n\n</div>\n", ["EMPTY", "INDEX"]);
add_ocaml_element("trace_stats", "Bap_traces.Std.Meta.trace_stats", "value", "Bap_traces.Std.trace_stats Std.tag", "Bap_traces.Std.Meta.html#VALtrace_stats", "<div class=\"info\">\n<p>generic information about the trace.</p>\n\n</div>\n", ["ABOUT", "GENERIC", "INFORMATION", "THE", "TRACE"]);
add_ocaml_element("binary_file_stats", "Bap_traces.Std.Meta.binary_file_stats", "value", "Bap_traces.Std.file_stats Std.tag", "Bap_traces.Std.Meta.html#VALbinary_file_stats", "<div class=\"info\">\n<p>file stats of the traced binary</p>\n\n</div>\n", ["BINARY", "FILE", "STATS", "THE", "TRACED"]);
add_ocaml_element("arch", "Bap_traces.Std.Meta.arch", "value", "Std.arch Std.tag", "Bap_traces.Std.Meta.html#VALarch", "<div class=\"info\">\n<p>description of binary architecture.</p>\n\n</div>\n", ["ARCHITECTURE", "BINARY", "DESCRIPTION"]);
add_ocaml_element("binary", "Bap_traces.Std.Meta.binary", "value", "Bap_traces.Std.binary Std.tag", "Bap_traces.Std.Meta.html#VALbinary", "<div class=\"info\">\n<p>description of a target binary (executable) that was traced.</p>\n\n</div>\n", ["BINARY", "DESCRIPTION", "EXECUTABLE", "TARGET", "THAT", "TRACED", "WAS"]);
add_ocaml_element("tracer", "Bap_traces.Std.Meta.tracer", "value", "Bap_traces.Std.tracer Std.tag", "Bap_traces.Std.Meta.html#VALtracer", "<div class=\"info\">\n<p>description of a tracer that was used to create the trace</p>\n\n</div>\n", ["CREATE", "DESCRIPTION", "THAT", "THE", "TRACE", "TRACER", "USED", "WAS"]);
add_ocaml_element("modload", "Bap_traces.Std.Event.modload", "value", "Bap_traces.Std.modload Std.tag", "Bap_traces.Std.Event.html#VALmodload", "<div class=\"info\">\n<p>a module (shared library) is dynamically linked into a host program.</p>\n\n</div>\n", ["DYNAMICALLY", "HOST", "INTO", "LIBRARY", "LINKED", "MODULE", "PROGRAM", "SHARED"]);
add_ocaml_element("return", "Bap_traces.Std.Event.return", "value", "Bap_traces.Std.return Std.tag", "Bap_traces.Std.Event.html#VALreturn", "<div class=\"info\">\n<p>a return from a call has occured</p>\n\n</div>\n", ["CALL", "FROM", "HAS", "OCCURED", "RETURN"]);
add_ocaml_element("call", "Bap_traces.Std.Event.call", "value", "Bap_traces.Std.call Std.tag", "Bap_traces.Std.Event.html#VALcall", "<div class=\"info\">\n<p>a control flow transfer from one procedure to another has occured</p>\n\n</div>\n", ["ANOTHER", "CONTROL", "FLOW", "FROM", "HAS", "OCCURED", "ONE", "PROCEDURE", "TRANSFER"]);
add_ocaml_element("exn", "Bap_traces.Std.Event.exn", "value", "Bap_traces.Std.exn Std.tag", "Bap_traces.Std.Event.html#VALexn", "<div class=\"info\">\n<p>a software exception has occured.</p>\n\n</div>\n", ["EXCEPTION", "HAS", "OCCURED", "SOFTWARE"]);
add_ocaml_element("syscall", "Bap_traces.Std.Event.syscall", "value", "Bap_traces.Std.syscall Std.tag", "Bap_traces.Std.Event.html#VALsyscall", "<div class=\"info\">\n<p>a system call has occured</p>\n\n</div>\n", ["CALL", "HAS", "OCCURED", "SYSTEM"]);
add_ocaml_element("context_switch", "Bap_traces.Std.Event.context_switch", "value", "int Std.tag", "Bap_traces.Std.Event.html#VALcontext_switch", "<div class=\"info\">\n<p>operating system has performed context switching to a provided\n        thread (process) id.</p>\n\n</div>\n", ["CONTEXT", "HAS", "OPERATING", "PERFORMED", "PROCESS", "PROVIDED", "SWITCHING", "SYSTEM", "THREAD"]);
add_ocaml_element("code_exec", "Bap_traces.Std.Event.code_exec", "value", "Bap_traces.Std.chunk Std.tag", "Bap_traces.Std.Event.html#VALcode_exec", "<div class=\"info\">\n<p>CPU loaded this memory chunk for execution.</p>\n\n</div>\n", ["AFTER", "ALL", "BEFORE", "CHUNK", "CODE", "CPU", "EFFECTS", "EVENT", "EXECUTION", "FOR", "JUST", "LOADED", "MEMORY", "OCCURS", "SIDE", "THE", "THIS"]);
add_ocaml_element("pc_update", "Bap_traces.Std.Event.pc_update", "value", "Std.addr Std.tag", "Bap_traces.Std.Event.html#VALpc_update", "<div class=\"info\">\n<p>CPU PC register changed its value</p>\n\n</div>\n", ["CHANGED", "CPU", "ITS", "REGISTER", "VALUE"]);
add_ocaml_element("timestamp", "Bap_traces.Std.Event.timestamp", "value", "int64 Std.tag", "Bap_traces.Std.Event.html#VALtimestamp", "<div class=\"info\">\n<p>this event can used to synchronize traces</p>\n\n</div>\n", ["CAN", "EVENT", "SYNCHRONIZE", "THIS", "TRACES", "USED"]);
add_ocaml_element("register_write", "Bap_traces.Std.Event.register_write", "value", "Std.var Bap_traces.Std.move Std.tag", "Bap_traces.Std.Event.html#VALregister_write", "<div class=\"info\">\n<p>a value is written to the specified register</p>\n\n</div>\n", ["REGISTER", "SPECIFIED", "THE", "VALUE", "WRITTEN"]);
add_ocaml_element("register_read", "Bap_traces.Std.Event.register_read", "value", "Std.var Bap_traces.Std.move Std.tag", "Bap_traces.Std.Event.html#VALregister_read", "<div class=\"info\">\n<p>a value was read from a given register</p>\n\n</div>\n", ["FROM", "GIVEN", "READ", "REGISTER", "VALUE", "WAS"]);
add_ocaml_element("memory_store", "Bap_traces.Std.Event.memory_store", "value", "Std.addr Bap_traces.Std.move Std.tag", "Bap_traces.Std.Event.html#VALmemory_store", "<div class=\"info\">\n<p>a write access to a memory cell</p>\n\n</div>\n", ["ACCESS", "CELL", "MEMORY", "WRITE"]);
add_ocaml_element("memory_load", "Bap_traces.Std.Event.memory_load", "value", "Std.addr Bap_traces.Std.move Std.tag", "Bap_traces.Std.Event.html#VALmemory_load", "<div class=\"info\">\n<p>an read access to a memory cell</p>\n\n</div>\n", ["ACCESS", "CELL", "MEMORY", "READ"]);
add_ocaml_element("remove", "Bap_traces.Std.Traces.remove", "value", "Bap_traces.Std.trace -> unit", "Bap_traces.Std.Traces.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;trace</code> removes a <code class=\"code\">trace</code> from the repository, do\n        nothing if it wasn't registered.</p>\n\n</div>\n", ["FROM", "NOTHING", "REGISTERED", "REMOVE", "REMOVES", "REPOSITORY", "THE", "TRACE", "WASN"]);
add_ocaml_element("add", "Bap_traces.Std.Traces.add", "value", "Bap_traces.Std.trace -> unit", "Bap_traces.Std.Traces.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;trace</code> registers a <code class=\"code\">trace</code> into the repository</p>\n\n</div>\n", ["ADD", "INTO", "REGISTERS", "REPOSITORY", "THE", "TRACE"]);
add_ocaml_element("enum", "Bap_traces.Std.Traces.enum", "value", "unit -> Bap_traces.Std.trace Std.seq", "Bap_traces.Std.Traces.html#VALenum", "<div class=\"info\">\n<p><code class=\"code\">enum&nbsp;()</code> enumerates all currently loaded traces</p>\n\n</div>\n", ["ALL", "CURRENTLY", "ENUM", "ENUMERATES", "LOADED", "TRACES"]);
add_ocaml_element("to_list", "Bap_traces.Std.Traces.to_list", "value", "unit -> Bap_traces.Std.trace list", "Bap_traces.Std.Traces.html#VALto_list", "<div class=\"info\">\n<p><code class=\"code\">to_list&nbsp;()</code> returns a list of currently loaded traces.</p>\n\n</div>\n", ["CURRENTLY", "LIST", "LOADED", "RETURNS", "TO_LIST", "TRACES"]);
add_ocaml_element("probe", "Bap_traces.Std.Trace.P.probe", "value", "Uri.t -> bool", "Bap_traces.Std.Trace.P.html#VALprobe", "", []);
add_ocaml_element("supports", "Bap_traces.Std.Trace.S.supports", "value", "'a Std.tag -> bool", "Bap_traces.Std.Trace.S.html#VALsupports", "", []);
add_ocaml_element("name", "Bap_traces.Std.Trace.S.name", "value", "string", "Bap_traces.Std.Trace.S.html#VALname", "", []);
add_ocaml_element("create", "Bap_traces.Std.Trace.Monitor.create", "value", "(Error.t -> Bap_traces.Std.Trace.step) ->\n  Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;filter</code> creates a user defined monitor from function\n          <code class=\"code\">filter</code> that is applied to a sequence of events or errors, and\n          returns a sequence of events.</p>\n\n</div>\n", ["AND", "APPLIED", "CREATE", "CREATES", "DEFINED", "ERRORS", "EVENTS", "FILTER", "FROM", "FUNCTION", "MONITOR", "RETURNS", "SEQUENCE", "THAT", "USER"]);
add_ocaml_element("pack_errors", "Bap_traces.Std.Trace.Monitor.pack_errors", "value", "(Error.t -> Bap_traces.Std.Trace.event) ->\n  Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.html#VALpack_errors", "<div class=\"info\">\n<p><code class=\"code\">pack_errors&nbsp;pack</code> will transform any occured error into event\n          using <code class=\"code\">pack</code> function.</p>\n\n</div>\n", ["ANY", "ERROR", "EVENT", "FUNCTION", "INTO", "OCCURED", "PACK", "PACK_ERRORS", "TRANSFORM", "USING", "WILL"]);
add_ocaml_element("stop_on_error", "Bap_traces.Std.Trace.Monitor.stop_on_error", "value", "Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.html#VALstop_on_error", "<div class=\"info\">\n<p><code class=\"code\">stop_on_error</code> will silently finish a stream in case of error.</p>\n\n</div>\n", ["CASE", "ERROR", "FINISH", "SILENTLY", "STOP_ON_ERROR", "STREAM", "WILL"]);
add_ocaml_element("fail_on_error", "Bap_traces.Std.Trace.Monitor.fail_on_error", "value", "Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.html#VALfail_on_error", "<div class=\"info\">\n<p><code class=\"code\">fail_on_error</code> will fail with an <code class=\"code\">error</code> <code class=\"code\"><span class=\"constructor\">Error</span>.raise&nbsp;error</code></p>\n\n</div>\n", ["ERROR", "FAIL", "FAIL_ON_ERROR", "RAISE", "WILL", "WITH"]);
add_ocaml_element("warn_on_error", "Bap_traces.Std.Trace.Monitor.warn_on_error", "value", "(Error.t -> unit) -> Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.html#VALwarn_on_error", "", []);
add_ocaml_element("ignore_errors", "Bap_traces.Std.Trace.Monitor.ignore_errors", "value", "Bap_traces.Std.Trace.Monitor.t", "Bap_traces.Std.Trace.Monitor.html#VALignore_errors", "<div class=\"info\">\n<p><code class=\"code\">ignore_errors</code> filters good events and silently drops error events</p>\n\n</div>\n", ["AND", "BUT", "CALLS", "DROPS", "ERROR", "EVENTS", "FILTERS", "FUNCTION", "GOOD", "HAS", "IGNORE_ERRORS", "OCCURED", "ON_ERROR", "SAME", "SILENTLY", "WARN_ON_ERROR", "WHEN"]);
add_ocaml_element("register_writer", "Bap_traces.Std.Trace.register_writer", "value", "Bap_traces.Std.Trace.proto ->\n  (Uri.t ->\n   Bap_traces.Std.Trace.t ->\n   (unit, Bap_traces.Std.Trace.io_error) Result.t) ->\n  unit", "Bap_traces.Std.Trace.html#VALregister_writer", "", []);
add_ocaml_element("register_reader", "Bap_traces.Std.Trace.register_reader", "value", "Bap_traces.Std.Trace.proto ->\n  (Uri.t ->\n   Bap_traces.Std.Trace.id ->\n   (Bap_traces.Std.Trace.reader, Bap_traces.Std.Trace.io_error)\n   Result.t) ->\n  unit", "Bap_traces.Std.Trace.html#VALregister_reader", "", []);
add_ocaml_element("register_proto", "Bap_traces.Std.Trace.register_proto", "value", "(module Bap_traces.Std.Trace.P) -> Bap_traces.Std.Trace.proto", "Bap_traces.Std.Trace.html#VALregister_proto", "", []);
add_ocaml_element("register_tool", "Bap_traces.Std.Trace.register_tool", "value", "(module Bap_traces.Std.Trace.S) -> Bap_traces.Std.Trace.tool", "Bap_traces.Std.Trace.html#VALregister_tool", "", []);
add_ocaml_element("filter_map", "Bap_traces.Std.Trace.filter_map", "value", "Bap_traces.Std.Trace.t ->\n  f:(Bap_traces.Std.Trace.event -> Bap_traces.Std.Trace.event option) ->\n  Bap_traces.Std.Trace.t", "Bap_traces.Std.Trace.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;t&nbsp;~f</code> will return a trace where all events a\n        filter-mapped with the provided function <code class=\"code\">f</code></p>\n\n</div>\n", ["ALL", "EVENTS", "FILTER", "FILTER_MAP", "FUNCTION", "MAPPED", "PROVIDED", "RETURN", "THE", "TRACE", "WHERE", "WILL", "WITH"]);
add_ocaml_element("next_matching", "Bap_traces.Std.Trace.next_matching", "value", "Bap_traces.Std.Trace.t -> 'a Std.Value.Match.t -> 'a option", "Bap_traces.Std.Trace.html#VALnext_matching", "<div class=\"info\">\n<p><code class=\"code\">next_matching&nbsp;trace&nbsp;matcher</code> reads and discards trace events\n        until an event matching with the <code class=\"code\">matcher</code> is found.</p>\n\n</div>\n", ["AND", "DISCARDS", "EVENT", "EVENTS", "FOUND", "MATCHER", "MATCHING", "NEXT_MATCHING", "READS", "THE", "TRACE", "UNTIL", "WITH"]);
add_ocaml_element("next_event", "Bap_traces.Std.Trace.next_event", "value", "Bap_traces.Std.Trace.t -> Bap_traces.Std.Trace.event option", "Bap_traces.Std.Trace.html#VALnext_event", "<div class=\"info\">\n<p><code class=\"code\">next_event&nbsp;trace</code> reads next event from the trace</p>\n\n</div>\n", ["EVENT", "FROM", "NEXT", "NEXT_EVENT", "READS", "THE", "TRACE"]);
add_ocaml_element("next", "Bap_traces.Std.Trace.next", "value", "Bap_traces.Std.Trace.t -> 'a Std.tag -> 'a option", "Bap_traces.Std.Trace.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;trace&nbsp;tag</code> reads and discards events until an event with a\n        given tag is found.</p>\n\n</div>\n", ["AND", "DISCARDS", "EVENT", "EVENTS", "FOUND", "GIVEN", "NEXT", "READS", "TAG", "TRACE", "UNTIL", "WITH"]);
add_ocaml_element("read_events", "Bap_traces.Std.Trace.read_events", "value", "Bap_traces.Std.Trace.t -> Bap_traces.Std.Trace.event Std.seq", "Bap_traces.Std.Trace.html#VALread_events", "<div class=\"info\">\n<p><code class=\"code\">read_events&nbsp;trace</code> reads a sequence of events from the <code class=\"code\">trace</code>.</p>\n\n</div>\n", ["EVENTS", "FROM", "READS", "READ_EVENTS", "SEQUENCE", "THE", "TRACE"]);
add_ocaml_element("read_all_matching", "Bap_traces.Std.Trace.read_all_matching", "value", "Bap_traces.Std.Trace.t -> 'a Std.Value.Match.t -> 'a Std.seq", "Bap_traces.Std.Trace.html#VALread_all_matching", "<div class=\"info\">\n<p><code class=\"code\">read_all_matching&nbsp;trace&nbsp;matcher</code> reads all events\n        matching with a provided <code class=\"code\">matcher</code>.</p>\n\n</div>\n", ["ALL", "EVENTS", "MATCHER", "MATCHING", "PROVIDED", "READS", "READ_ALL_MATCHING", "TRACE", "WITH"]);
add_ocaml_element("read_all", "Bap_traces.Std.Trace.read_all", "value", "Bap_traces.Std.Trace.t -> 'a Std.tag -> 'a Std.seq", "Bap_traces.Std.Trace.html#VALread_all", "<div class=\"info\">\n<p><code class=\"code\">read_all&nbsp;trace&nbsp;tag</code> reads all event of the a given type</p>\n\n</div>\n", ["ALL", "EVENT", "GIVEN", "READS", "READ_ALL", "TAG", "THE", "TRACE", "TYPE"]);
add_ocaml_element("supports", "Bap_traces.Std.Trace.supports", "value", "Bap_traces.Std.Trace.t -> 'a Std.tag -> bool", "Bap_traces.Std.Trace.html#VALsupports", "<div class=\"info\">\n<p><code class=\"code\">supports&nbsp;trace&nbsp;feature</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if a tool that was used to\n        generate the trace, as well as transporting protocol and\n        underlying format support the given feature.</p>\n\n</div>\n", ["AND", "FEATURE", "FORMAT", "GENERATE", "GIVEN", "PROTOCOL", "SUPPORT", "SUPPORTS", "THAT", "THE", "TOOL", "TRACE", "TRANSPORTING", "TRUE", "UNDERLYING", "USED", "WAS", "WELL"]);
add_ocaml_element("set_meta", "Bap_traces.Std.Trace.set_meta", "value", "Bap_traces.Std.Trace.t -> Std.dict -> Bap_traces.Std.Trace.t", "Bap_traces.Std.Trace.html#VALset_meta", "<div class=\"info\">\n<p><code class=\"code\">set_meta&nbsp;trace&nbsp;meta</code> substitutes meta attributes of a <code class=\"code\">trace</code> with\n        attributes taken from a dictionary <code class=\"code\">meta</code>.</p>\n\n</div>\n", ["ATTRIBUTES", "DICTIONARY", "FROM", "META", "SET_META", "SUBSTITUTES", "TAKEN", "TRACE", "WITH"]);
add_ocaml_element("meta", "Bap_traces.Std.Trace.meta", "value", "Bap_traces.Std.Trace.t -> Std.dict", "Bap_traces.Std.Trace.html#VALmeta", "<div class=\"info\">\n<p><code class=\"code\">meta&nbsp;trace</code> returns all <code class=\"code\">trace</code> attributes as a dictionary</p>\n\n</div>\n", ["ALL", "ATTRIBUTES", "DICTIONARY", "META", "RETURNS", "TRACE"]);
add_ocaml_element("tool", "Bap_traces.Std.Trace.tool", "value", "Bap_traces.Std.Trace.t -> Bap_traces.Std.Trace.tool", "Bap_traces.Std.Trace.html#VALtool", "<div class=\"info\">\n<p><code class=\"code\">tool&nbsp;trace</code> returns a descriptor of a tool that was used to\n        create the <code class=\"code\">trace</code>.</p>\n\n</div>\n", ["CREATE", "DESCRIPTOR", "RETURNS", "THAT", "THE", "TOOL", "TRACE", "USED", "WAS"]);
add_ocaml_element("has_attr", "Bap_traces.Std.Trace.has_attr", "value", "Bap_traces.Std.Trace.t -> 'a Std.tag -> bool", "Bap_traces.Std.Trace.html#VALhas_attr", "<div class=\"info\">\n<p><code class=\"code\">has_attr&nbsp;trace&nbsp;attr</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">trace</code> has a given\n        attribute <code class=\"code\">attr</code></p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "EVALUATES", "GIVEN", "HAS", "HAS_ATTR", "TRACE", "TRUE"]);
add_ocaml_element("get_attr", "Bap_traces.Std.Trace.get_attr", "value", "Bap_traces.Std.Trace.t -> 'a Std.tag -> 'a option", "Bap_traces.Std.Trace.html#VALget_attr", "<div class=\"info\">\n<p><code class=\"code\">get_attr&nbsp;trace&nbsp;attr</code> retrieves a value of a given attribute\n        <code class=\"code\">attr</code></p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "GET_ATTR", "GIVEN", "RETRIEVES", "TRACE", "VALUE"]);
add_ocaml_element("set_attr", "Bap_traces.Std.Trace.set_attr", "value", "Bap_traces.Std.Trace.t -> 'a Std.tag -> 'a -> Bap_traces.Std.Trace.t", "Bap_traces.Std.Trace.html#VALset_attr", "<div class=\"info\">\n<p><code class=\"code\">set_attr&nbsp;trace&nbsp;attr&nbsp;value</code> updates <code class=\"code\">trace</code> meta attribute <code class=\"code\">attr</code>\n        with a provided value.</p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "META", "PROVIDED", "SET_ATTR", "TRACE", "UPDATES", "VALUE", "WITH"]);
add_ocaml_element("id", "Bap_traces.Std.Trace.id", "value", "Bap_traces.Std.Trace.t -> Bap_traces.Std.Trace.id", "Bap_traces.Std.Trace.html#VALid", "<div class=\"info\">\n<p>Trace global unique identifier.</p>\n\n</div>\n", ["GLOBAL", "IDENTIFIER", "TRACE", "UNIQUE"]);
add_ocaml_element("create", "Bap_traces.Std.Trace.create", "value", "?monitor:Bap_traces.Std.Trace.monitor ->\n  Bap_traces.Std.Trace.tool ->\n  (unit -> Bap_traces.Std.Trace.event Or_error.t option) ->\n  Bap_traces.Std.Trace.t", "Bap_traces.Std.Trace.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;tool&nbsp;next</code> creates a new trace from the observer\n        <code class=\"code\">next</code>.</p>\n\n</div>\n", ["CREATE", "CREATES", "FROM", "NEW", "NEXT", "OBSERVER", "THE", "TOOL", "TRACE"]);
add_ocaml_element("save", "Bap_traces.Std.Trace.save", "value", "Uri.t ->\n  Bap_traces.Std.Trace.t ->\n  (unit, Bap_traces.Std.Trace.error) Result.t", "Bap_traces.Std.Trace.html#VALsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;uri</code> pushes trace to a provided <code class=\"code\">uri</code></p>\n\n</div>\n", ["PROVIDED", "PUSHES", "SAVE", "TRACE", "URI"]);
add_ocaml_element("load", "Bap_traces.Std.Trace.load", "value", "?monitor:Bap_traces.Std.Trace.monitor ->\n  Uri.t ->\n  (Bap_traces.Std.Trace.t, Bap_traces.Std.Trace.error) Result.t", "Bap_traces.Std.Trace.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;~monitor&nbsp;uri</code> fetches trace from a provided <code class=\"code\">uri</code>.</p>\n\n</div>\n", ["DEFAULT", "FAIL_ON_ERROR", "FETCHES", "FROM", "LOAD", "MONITOR", "PROVIDED", "TRACE", "URI"]);
add_ocaml_element("init", "Bap_llvm_loader.init", "value", "unit -> unit Or_error.t", "Bap_llvm_loader.html#VALinit", "", []);
add_ocaml_element("init_loader", "Bap_llvm.Std.init_loader", "value", "?base:int64 -> unit -> unit", "Bap_llvm.Std.html#VALinit_loader", "<div class=\"info\">\n<p><code class=\"code\">init-loader&nbsp;()</code> initializes and registers the LLVM based\n      loader.</p>\n\n</div>\n", ["AND", "BASED", "INIT", "INITIALIZES", "LLVM", "LOADER", "REGISTERS", "THE"]);
add_ocaml_element("init_disassembler", "Bap_llvm.Std.init_disassembler", "value", "?x86_syntax:Bap_llvm.Std.x86_syntax -> unit -> unit Or_error.t", "Bap_llvm.Std.html#VALinit_disassembler", "<div class=\"info\">\n<p><code class=\"code\">init_disassembler&nbsp;()</code> initializes and registers the LLVM based disassembler.</p>\n\n</div>\n", ["AND", "BASED", "DISASSEMBLER", "INITIALIZES", "INIT_DISASSEMBLER", "LLVM", "REGISTERS", "THE"]);
add_ocaml_element("llvm_version", "Bap_llvm.Std.llvm_version", "value", "string", "Bap_llvm.Std.html#VALllvm_version", "<div class=\"info\">\n<p><code class=\"code\">llvm_version</code></p>\n\n</div>\n", ["LLVM_VERSION"]);
add_ocaml_element("provide", "Bap_ida.Std.Service.provide", "value", "(string -> Bap_ida.Std.Service.t) -> unit", "Bap_ida.Std.Service.html#VALprovide", "<div class=\"info\">\n<p><code class=\"code\">provide&nbsp;creator</code> provides for a service that can perform the\n        roles of <code class=\"code\"><span class=\"constructor\">Ida</span>.create</code>, <code class=\"code\"><span class=\"constructor\">Ida</span>.exec</code>, <code class=\"code\"><span class=\"constructor\">Ida</span>.close</code>.</p>\n\n</div>\n", ["ACCEPTS", "AND", "CAN", "CLOSE", "CREATE", "CREATOR", "EXEC", "FILE", "FOR", "FUNCTION", "IDA", "INSTANCE", "PATH", "PERFORM", "PROVIDE", "PROVIDES", "RETURNS", "ROLES", "SERVICE", "TARGET", "THAT", "THE"]);
add_ocaml_element("parser", "Bap_ida.Std.Command.parser", "value", "'a Bap_ida.Std.Command.t -> string -> 'a", "Bap_ida.Std.Command.html#VALparser", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keyword\">parser</span>&nbsp;command</code> the associated parser function.</p>\n\n</div>\n", ["ASSOCIATED", "COMMAND", "FUNCTION", "PARSER", "THE"]);
add_ocaml_element("script", "Bap_ida.Std.Command.script", "value", "'a Bap_ida.Std.Command.t -> string", "Bap_ida.Std.Command.html#VALscript", "<div class=\"info\">\n<p><code class=\"code\">script&nbsp;command</code> the script text</p>\n\n</div>\n", ["COMMAND", "SCRIPT", "TEXT", "THE"]);
add_ocaml_element("language", "Bap_ida.Std.Command.language", "value", "'a Bap_ida.Std.Command.t -> Bap_ida.Std.Command.language", "Bap_ida.Std.Command.html#VALlanguage", "<div class=\"info\">\n<p><code class=\"code\">language&nbsp;command</code> is a script language</p>\n\n</div>\n", ["COMMAND", "LANGUAGE", "SCRIPT"]);
add_ocaml_element("create", "Bap_ida.Std.Command.create", "value", "Bap_ida.Std.Command.language ->\n  script:string -> parser:(string -> 'a) -> 'a Bap_ida.Std.Command.t", "Bap_ida.Std.Command.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;lang&nbsp;~script&nbsp;~<span class=\"keyword\">parser</span></code> create a command that will\n        execute a <code class=\"code\">script</code>, written in a given language, at then\n        parse the output using the specified parser function.</p>\n\n</div>\n", ["AND", "CAN", "COMMAND", "CREATE", "EXECUTE", "FILE", "FILENAME", "FUNCTION", "GET", "GIVEN", "INFORMATION", "LANG", "LANGUAGE", "MUST", "NAME", "NEEDS", "OUTPUT", "PARSE", "PARSER", "READ", "REAL", "SCRIPT", "SPECIFIED", "SUBSTITUTED", "THAT", "THE", "THEN", "USE", "USING", "WILL", "WITH", "WRITTEN"]);
add_ocaml_element("with_file", "Bap_ida.Std.Ida.with_file", "value", "string -> 'a Bap_ida.Std.command -> 'a", "Bap_ida.Std.Ida.html#VALwith_file", "<div class=\"info\">\n<p><code class=\"code\">with_file&nbsp;target&nbsp;analysis</code> creates ida instance on <code class=\"code\">target</code>,\n        perform <code class=\"code\">analysis</code> and close <code class=\"code\">ida</code></p>\n\n</div>\n", ["ANALYSIS", "AND", "CLOSE", "CREATES", "IDA", "INSTANCE", "PERFORM", "TARGET", "WITH_FILE"]);
add_ocaml_element("close", "Bap_ida.Std.Ida.close", "value", "Bap_ida.Std.Ida.t -> unit", "Bap_ida.Std.Ida.html#VALclose", "<div class=\"info\">\n<p><code class=\"code\">close&nbsp;ida</code> finish interaction with IDA and clean all resources</p>\n\n</div>\n", ["ALL", "AND", "CLEAN", "CLOSE", "FINISH", "IDA", "INTERACTION", "RESOURCES", "WITH"]);
add_ocaml_element("exec", "Bap_ida.Std.Ida.exec", "value", "Bap_ida.Std.Ida.t -> 'a Bap_ida.Std.command -> 'a", "Bap_ida.Std.Ida.html#VALexec", "<div class=\"info\">\n<p><code class=\"code\">exec&nbsp;ida&nbsp;command</code> execute the given <code class=\"code\">command</code>.</p>\n\n</div>\n", ["COMMAND", "EXEC", "EXECUTE", "GIVEN", "IDA", "THE"]);
add_ocaml_element("create", "Bap_ida.Std.Ida.create", "value", "string -> Bap_ida.Std.Ida.t", "Bap_ida.Std.Ida.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;target</code> create an IDA instance that will work with\n        <code class=\"code\">target</code> executable.</p>\n\n</div>\n", ["CREATE", "EXECUTABLE", "IDA", "INSTANCE", "TARGET", "THAT", "WILL", "WITH", "WORK"]);
add_ocaml_element("of_int64", "Bap_dwarf.Std.Leb128.of_int64", "value", "int64 Bap_dwarf.Std.Leb128.encoder", "Bap_dwarf.Std.Leb128.html#VALof_int64", "", []);
add_ocaml_element("of_int32", "Bap_dwarf.Std.Leb128.of_int32", "value", "int32 Bap_dwarf.Std.Leb128.encoder", "Bap_dwarf.Std.Leb128.html#VALof_int32", "", []);
add_ocaml_element("of_int", "Bap_dwarf.Std.Leb128.of_int", "value", "int Bap_dwarf.Std.Leb128.encoder", "Bap_dwarf.Std.Leb128.html#VALof_int", "", []);
add_ocaml_element("to_int64", "Bap_dwarf.Std.Leb128.to_int64", "value", "int64 Bap_dwarf.Std.Leb128.decoder", "Bap_dwarf.Std.Leb128.html#VALto_int64", "", []);
add_ocaml_element("to_int32", "Bap_dwarf.Std.Leb128.to_int32", "value", "int32 Bap_dwarf.Std.Leb128.decoder", "Bap_dwarf.Std.Leb128.html#VALto_int32", "", []);
add_ocaml_element("to_int", "Bap_dwarf.Std.Leb128.to_int", "value", "int Bap_dwarf.Std.Leb128.decoder", "Bap_dwarf.Std.Leb128.html#VALto_int", "", []);
add_ocaml_element("write", "Bap_dwarf.Std.Leb128.write", "value", "Bap_dwarf.Std.Leb128.t -> Std.bytes -> pos:int -> unit", "Bap_dwarf.Std.Leb128.html#VALwrite", "", []);
add_ocaml_element("read", "Bap_dwarf.Std.Leb128.read", "value", "?signed:bool ->\n  string ->\n  pos_ref:int ref -> Bap_dwarf.Std.Leb128.t Or_error.t", "Bap_dwarf.Std.Leb128.html#VALread", "", []);
add_ocaml_element("size", "Bap_dwarf.Std.Leb128.size", "value", "Bap_dwarf.Std.Leb128.t -> int", "Bap_dwarf.Std.Leb128.html#VALsize", "<div class=\"info\">\n<p><code class=\"code\">size&nbsp;leb</code> return size in bytes of the number stored in LEB128\n        encoding.</p>\n\n</div>\n", ["BYTES", "ENCODING", "LEB", "LEB128", "NUMBER", "RETURN", "SIZE", "STORED", "THE"]);
add_ocaml_element("functions", "Bap_dwarf.Std.Dwarf.Fbi.functions", "value", "Bap_dwarf.Std.Dwarf.Fbi.t -> (string * Bap_dwarf.Std.Dwarf.fn) Std.seq", "Bap_dwarf.Std.Dwarf.Fbi.html#VALfunctions", "<div class=\"info\">\n<p><code class=\"code\">functions&nbsp;searcher</code> enumerates functions</p>\n\n</div>\n", ["ENUMERATES", "FUNCTIONS", "SEARCHER"]);
add_ocaml_element("create", "Bap_dwarf.Std.Dwarf.Fbi.create", "value", "string Bap_dwarf.Std.Dwarf.Data.t ->\n  Bap_dwarf.Std.Dwarf.Fbi.t Or_error.t", "Bap_dwarf.Std.Dwarf.Fbi.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;data</code> tries to create a DWARF reader, from\n          supplied <code class=\"code\">data</code>.</p>\n\n</div>\n", ["ABBR", "ABOUT", "CREATE", "DATA", "DEBUG_ABBREV", "DEBUG_INFO", "DEBUG_STR", "DWARF", "ERROR", "FORMAT", "FROM", "FUNCTIONS", "INFO", "INFORMATION", "LEAST", "MAY", "NEEDS", "NOT", "PARSER", "PROVIDE", "READER", "SECTION", "SECTIONS", "STR", "SUFFICIENT", "SUPPLIED", "THERE", "THIS", "THREE", "TRIES", "UNDERSTANDABLE", "WASN", "YIELD"]);
add_ocaml_element("endian", "Bap_dwarf.Std.Dwarf.Data.endian", "value", "'a Bap_dwarf.Std.Dwarf.Data.t -> Std.endian", "Bap_dwarf.Std.Dwarf.Data.html#VALendian", "<div class=\"info\">\n<p><code class=\"code\">endian&nbsp;data</code> the endianness of <code class=\"code\">data</code></p>\n\n</div>\n", ["DATA", "ENDIAN", "ENDIANNESS", "THE"]);
add_ocaml_element("section", "Bap_dwarf.Std.Dwarf.Data.section", "value", "'a Bap_dwarf.Std.Dwarf.Data.t ->\n  Bap_dwarf.Std.Dwarf.section ->\n  'a Bap_dwarf.Std.Dwarf.Data.buffer Or_error.t", "Bap_dwarf.Std.Dwarf.Data.html#VALsection", "<div class=\"info\">\n<p><code class=\"code\">section&nbsp;data</code> lookups for a <code class=\"code\">section</code> in <code class=\"code\">data</code></p>\n\n</div>\n", ["DATA", "FOR", "LOOKUPS", "SECTION"]);
add_ocaml_element("create", "Bap_dwarf.Std.Dwarf.Data.create", "value", "Std.endian ->\n  (Bap_dwarf.Std.Dwarf.section * 'a Bap_dwarf.Std.Dwarf.Data.buffer) list ->\n  'a Bap_dwarf.Std.Dwarf.Data.t Or_error.t", "Bap_dwarf.Std.Dwarf.Data.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;endian&nbsp;sections</code> creates data representation from a assoc list\n          of sections.</p>\n\n</div>\n", ["ASSOC", "COMPLAIN", "CREATE", "CREATES", "DATA", "ENDIAN", "FROM", "LIST", "REPEATING", "REPRESENTATION", "SECTIONS", "THERE", "WILL"]);
add_ocaml_element("data", "Bap_dwarf.Std.Dwarf.Buffer.data", "value", "'a Bap_dwarf.Std.Dwarf.Buffer.t -> 'a", "Bap_dwarf.Std.Dwarf.Buffer.html#VALdata", "<div class=\"info\">\n<p><code class=\"code\">data&nbsp;pos</code> actual data.</p>\n\n</div>\n", ["ACTUAL", "DATA", "DOESN", "FROM", "NOTE", "POS", "START"]);
add_ocaml_element("pos", "Bap_dwarf.Std.Dwarf.Buffer.pos", "value", "'a Bap_dwarf.Std.Dwarf.Buffer.t -> int", "Bap_dwarf.Std.Dwarf.Buffer.html#VALpos", "<div class=\"info\">\n<p><code class=\"code\">pos&nbsp;buf</code> starting position</p>\n\n</div>\n", ["BUF", "POS", "POSITION", "STARTING"]);
add_ocaml_element("with_off", "Bap_dwarf.Std.Dwarf.Buffer.with_off", "value", "'a Bap_dwarf.Std.Dwarf.Buffer.t -> int -> 'a Bap_dwarf.Std.Dwarf.Buffer.t", "Bap_dwarf.Std.Dwarf.Buffer.html#VALwith_off", "<div class=\"info\">\n<p><code class=\"code\">with_off&nbsp;buf&nbsp;off</code> creates a new buffer that shares data with\n          <code class=\"code\">buf</code>, but has different starting position equal to <code class=\"code\">pos&nbsp;buf&nbsp;+&nbsp;off</code></p>\n\n</div>\n", ["BUF", "BUFFER", "BUT", "CREATES", "DATA", "DIFFERENT", "EQUAL", "HAS", "NEW", "OFF", "POS", "POSITION", "SHARES", "STARTING", "THAT", "WITH", "WITH_OFF"]);
add_ocaml_element("with_pos", "Bap_dwarf.Std.Dwarf.Buffer.with_pos", "value", "'a Bap_dwarf.Std.Dwarf.Buffer.t -> int -> 'a Bap_dwarf.Std.Dwarf.Buffer.t", "Bap_dwarf.Std.Dwarf.Buffer.html#VALwith_pos", "<div class=\"info\">\n<p><code class=\"code\">with_pos&nbsp;buf&nbsp;pos</code> creates a new buffer that shares data with\n          <code class=\"code\">buf</code>, but has different starting position</p>\n\n</div>\n", ["BUF", "BUFFER", "BUT", "CREATES", "DATA", "DIFFERENT", "HAS", "NEW", "POS", "POSITION", "SHARES", "STARTING", "THAT", "WITH", "WITH_POS"]);
add_ocaml_element("create", "Bap_dwarf.Std.Dwarf.Buffer.create", "value", "?pos:int -> 'a -> 'a Bap_dwarf.Std.Dwarf.Buffer.t", "Bap_dwarf.Std.Dwarf.Buffer.html#VALcreate", "", []);
add_ocaml_element("pc_hi", "Bap_dwarf.Std.Dwarf.Fn.pc_hi", "value", "Bap_dwarf.Std.Dwarf.Fn.t -> Std.addr option", "Bap_dwarf.Std.Dwarf.Fn.html#VALpc_hi", "<div class=\"info\">\n<p><code class=\"code\">pc_hi&nbsp;fn</code> the highest address (if known)</p>\n\n</div>\n", ["ADDRESS", "HIGHEST", "KNOWN", "PC_HI", "THE"]);
add_ocaml_element("pc_lo", "Bap_dwarf.Std.Dwarf.Fn.pc_lo", "value", "Bap_dwarf.Std.Dwarf.Fn.t -> Std.addr", "Bap_dwarf.Std.Dwarf.Fn.html#VALpc_lo", "<div class=\"info\">\n<p><code class=\"code\">pc_lo&nbsp;fn</code> the lowest address of a function (the entry point)</p>\n\n</div>\n", ["ADDRESS", "ENTRY", "FUNCTION", "LOWEST", "PC_LO", "POINT", "THE"]);
add_ocaml_element("available", "Bap_demangle.Std.Demanglers.available", "value", "unit -> Bap_demangle.Std.demangler list", "Bap_demangle.Std.Demanglers.html#VALavailable", "<div class=\"info\">\n<p><code class=\"code\">available&nbsp;()</code> lists currently registered demanglers.</p>\n\n</div>\n", ["AVAILABLE", "CURRENTLY", "DEMANGLERS", "LISTS", "REGISTERED"]);
add_ocaml_element("register", "Bap_demangle.Std.Demanglers.register", "value", "Bap_demangle.Std.demangler -> unit", "Bap_demangle.Std.Demanglers.html#VALregister", "<div class=\"info\">\n<p><code class=\"code\">register&nbsp;demangler</code> register new demangler.</p>\n\n</div>\n", ["DEMANGLER", "NEW", "REGISTER"]);
add_ocaml_element("name", "Bap_demangle.Std.Demangler.name", "value", "Bap_demangle.Std.Demangler.t -> string", "Bap_demangle.Std.Demangler.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;demangler</code> returns a <code class=\"code\">demangler</code>'s name.</p>\n\n</div>\n", ["DEMANGLER", "NAME", "RETURNS"]);
add_ocaml_element("run", "Bap_demangle.Std.Demangler.run", "value", "Bap_demangle.Std.Demangler.t -> string -> string", "Bap_demangle.Std.Demangler.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;demangler&nbsp;name</code> demangle given <code class=\"code\">name</code></p>\n\n</div>\n", ["DEMANGLE", "DEMANGLER", "GIVEN", "NAME", "RUN"]);
add_ocaml_element("create", "Bap_demangle.Std.Demangler.create", "value", "string -> (string -> string) -> Bap_demangle.Std.Demangler.t", "Bap_demangle.Std.Demangler.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;name&nbsp;demangler</code></p>\n\n</div>\n", ["CREATE", "DEMANGLER", "NAME"]);
add_ocaml_element("look", "Bap_byteweight.Corpus.look", "value", "Bap_byteweight.Corpus.t ->\n  length:int -> int -> Bap_byteweight.Corpus.key option", "Bap_byteweight.Corpus.html#VALlook", "<div class=\"info\">\n<p><code class=\"code\">look&nbsp;data&nbsp;~length&nbsp;offset</code> extract data of specified <code class=\"code\">length</code> at\n      the given <code class=\"code\">offset</code>.</p>\n\n</div>\n", ["AND", "CAN", "CHUNK", "DATA", "EXTRACT", "EXTRACTED", "EXTRACTION", "FOR", "FUNCTION", "GIVEN", "IMPLEMENT", "INTERFACE", "JUST", "KEY", "LENGTH", "LIKE", "LOOK", "NEED", "NOTE", "OFFSET", "ONE", "REGULAR", "REPRESENTATIONS", "REPRESENTS", "RETURNS", "SIMPLE", "SPECIFIED", "STRINGS", "STRUCTURE", "SUBSTRING", "THAT", "THE", "THIS", "TRIE", "TYPE", "TYPES", "UNIFIED", "WILL", "WITH"]);
add_ocaml_element("find", "Bap_byteweight.Bytes.find", "value", "t -> length:int -> threshold:float -> corpus -> Std.addr list", "Bap_byteweight.Bytes.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;mem&nbsp;~length&nbsp;~threshold&nbsp;corpus</code> extract addresses of all\n      memory chunks of the specified <code class=\"code\">length</code>, that were classified\n      positively under given <code class=\"code\">threshold</code>.</p>\n\n</div>\n", ["ADDRESSES", "ALL", "CHUNKS", "CLASSIFIED", "CORPUS", "EXTRACT", "FIND", "GIVEN", "LENGTH", "MEM", "MEMORY", "POSITIVELY", "SPECIFIED", "THAT", "THE", "THRESHOLD", "UNDER", "WERE"]);
add_ocaml_element("pp", "Bap_byteweight.S.pp", "value", "Stdlib.Format.formatter -> Bap_byteweight.S.t -> unit", "Bap_byteweight.S.html#VALpp", "", []);
add_ocaml_element("next", "Bap_byteweight.S.next", "value", "Bap_byteweight.S.t ->\n  length:int -> threshold:float -> Bap_byteweight.S.corpus -> int -> int option", "Bap_byteweight.S.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;decider&nbsp;~length&nbsp;~threshold&nbsp;data&nbsp;<span class=\"keyword\">begin</span></code> returns an offset\n      greater then <code class=\"code\"><span class=\"keyword\">begin</span></code> of the next substring of the given\n      <code class=\"code\">length</code>, that is positively classified, with the given\n      <code class=\"code\">thresold</code>.</p>\n\n</div>\n", ["BEGIN", "CLASSIFIED", "DATA", "DECIDER", "GIVEN", "GREATER", "LENGTH", "NEXT", "OFFSET", "POSITIVELY", "RETURNS", "SUBSTRING", "THAT", "THE", "THEN", "THRESHOLD", "THRESOLD", "WITH"]);
add_ocaml_element("length", "Bap_byteweight.S.length", "value", "Bap_byteweight.S.t -> int", "Bap_byteweight.S.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;decider</code> total amount of different substrings known to a\n      decider.</p>\n\n</div>\n", ["AMOUNT", "DECIDER", "DIFFERENT", "KNOWN", "LENGTH", "SUBSTRINGS", "TOTAL"]);
add_ocaml_element("train", "Bap_byteweight.S.train", "value", "Bap_byteweight.S.t ->\n  max_length:int ->\n  (Bap_byteweight.S.key -> bool) -> Bap_byteweight.S.corpus -> unit", "Bap_byteweight.S.html#VALtrain", "<div class=\"info\">\n<p><code class=\"code\">train&nbsp;decider&nbsp;~max_length&nbsp;test&nbsp;corpus</code> train the <code class=\"code\">decider</code> on\n      the specified <code class=\"code\">corpus</code>.</p>\n\n</div>\n", ["BINDS", "CLASSIFIES", "CORPUS", "DECIDER", "EXTRACTED", "FUNCTION", "LENGTH", "MAXIMUM", "MAX_LENGTH", "PARAMETER", "SPECIFIED", "SUBSTRINGS", "TEST", "THE", "TRAIN"]);
add_ocaml_element("create", "Bap_byteweight.S.create", "value", "unit -> Bap_byteweight.S.t", "Bap_byteweight.S.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates an empty instance of the byteweigth decider.</p>\n\n</div>\n", ["BYTEWEIGTH", "CREATE", "CREATES", "DECIDER", "EMPTY", "INSTANCE", "THE"]);
add_ocaml_element("string_of_error", "Bap_byteweight_signatures.string_of_error", "value", "Bap_byteweight_signatures.error -> string", "Bap_byteweight_signatures.html#VALstring_of_error", "<div class=\"info\">\n<p>a human readable representation of an error.</p>\n\n</div>\n", ["ERROR", "HUMAN", "READABLE", "REPRESENTATION"]);
add_ocaml_element("default_path", "Bap_byteweight_signatures.default_path", "value", "string", "Bap_byteweight_signatures.html#VALdefault_path", "<div class=\"info\">\n<p>default path for the signatures database</p>\n\n</div>\n", ["DATABASE", "DEFAULT", "FOR", "PATH", "SIGNATURES", "THE"]);
add_ocaml_element("load", "Bap_byteweight_signatures.load", "value", "?comp:string ->\n  ?path:string ->\n  mode:string ->\n  Std.arch ->\n  (Std.bytes, Bap_byteweight_signatures.error) Result.t", "Bap_byteweight_signatures.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;?comp&nbsp;?path&nbsp;~mode&nbsp;arch</code> finds a signature for the specified\n    <code class=\"code\">arch-comp-path</code> tripple.</p>\n\n</div>\n", ["ARCH", "COMP", "DEFAULTS", "DEFAULT_PATH", "FINDS", "FOR", "LOAD", "MODE", "PATH", "SIGNATURE", "SPECIFIED", "THE", "TRIPPLE"]);
add_ocaml_element("save", "Bap_byteweight_signatures.save", "value", "?comp:string ->\n  mode:string ->\n  path:string ->\n  Std.arch ->\n  Std.bytes ->\n  (unit, Bap_byteweight_signatures.error) Result.t", "Bap_byteweight_signatures.html#VALsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;?comp&nbsp;~mode&nbsp;~path&nbsp;arch&nbsp;data</code> store signatures data in the\n    database of signatures specified by the <code class=\"code\">path</code> parameter.</p>\n\n</div>\n", ["AND", "ARCH", "COMP", "CREATED", "DATA", "DATABASE", "DEFINES", "DESTINATION", "DOESN", "ENTRY", "EXIST", "EXISTED", "FOR", "KEY", "MODE", "NAME", "NEW", "OVERWRITTEN", "PARAMETER", "PATH", "SAME", "SAVE", "SIGNATURES", "SPECIFIED", "STORE", "THE", "THEN", "TRIPLE", "WILL", "WITH", "WOULD"]);
add_ocaml_element("set", "Bap_build.Std.Plugin_options.set", "value", "unit -> unit", "Bap_build.Std.Plugin_options.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;()</code> set default options for <code class=\"code\">bapbuild</code>.</p>\n\n</div>\n", ["BAPBUILD", "DEFAULT", "FOR", "OPTIONS", "SET"]);
add_ocaml_element("install", "Bap_build.Std.Plugin_rules.install", "value", "unit -> unit", "Bap_build.Std.Plugin_rules.html#VALinstall", "<div class=\"info\">\n<p><code class=\"code\">install&nbsp;()</code> installs bap specific rules.</p>\n\n</div>\n", ["BAP", "BUILDING", "FOR", "FUNCTION", "INSTALL", "INSTALLS", "NECESSARY", "PLUGINS", "RULES", "SPECIFIC", "THE"]);
add_ocaml_element("list", "Bap_bml.Registry.list", "value", "unit -> (string * Bap_bml.Registry.t) list", "Bap_bml.Registry.html#VALlist", "<div class=\"info\">\n<p><code class=\"code\">list&nbsp;()</code> list all bindings</p>\n\n</div>\n", ["ALL", "BINDINGS", "LIST"]);
add_ocaml_element("find", "Bap_bml.Registry.find", "value", "string -> Bap_bml.Registry.t option", "Bap_bml.Registry.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;name</code> find a value associated with the given <code class=\"code\">value</code></p>\n\n</div>\n", ["ASSOCIATED", "FIND", "GIVEN", "NAME", "THE", "VALUE", "WITH"]);
add_ocaml_element("register", "Bap_bml.Registry.register", "value", "string -> Bap_bml.Registry.t -> unit", "Bap_bml.Registry.html#VALregister", "<div class=\"info\">\n<p><code class=\"code\">register&nbsp;name&nbsp;value</code> register <code class=\"code\">value</code> with a given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ALREADY", "ASSOCIATED", "BINDING", "GIVEN", "NAME", "NEW", "OTHER", "REGISTER", "SOME", "SUPERSEEDED", "THE", "THEN", "VALUE", "WAS", "WILL", "WITH"]);
add_ocaml_element("provide", "Bap_c_parser.provide", "value", "Bap_c_parser.parser -> unit", "Bap_c_parser.html#VALprovide", "<div class=\"info\">\n<p>called by a plugin that provides a parser.</p>\n\n</div>\n", ["CALLED", "PARSER", "PLUGIN", "PROVIDES", "THAT"]);
add_ocaml_element("run", "Bap_c_parser.run", "value", "Bap_c_parser.parser", "Bap_c_parser.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;filename</code> parses file and returns a mapping from identifier\n    to its type.</p>\n\n</div>\n", ["AND", "FILE", "FILENAME", "FROM", "IDENTIFIER", "ITS", "MAPPING", "PARSES", "RETURNS", "RUN", "TYPE"]);
add_ocaml_element("result", "Bap_c_type_mapper.Search.result", "value", "('a, 'e) t -> 'e option", "Bap_c_type_mapper.Search.html#VALresult", "<div class=\"info\">\n<p><code class=\"code\">result&nbsp;s</code> runs the computation <code class=\"code\">s</code> and extracts the result.</p>\n\n</div>\n", ["AND", "COMPUTATION", "EXTRACTS", "RESULT", "RUNS", "THE"]);
add_ocaml_element("finished", "Bap_c_type_mapper.Search.finished", "value", "'e -> ('a, 'e) t", "Bap_c_type_mapper.Search.html#VALfinished", "<div class=\"info\">\n<p><code class=\"code\">finished&nbsp;needle</code> is called when a search is finished, it will\n      terminate the search with the <code class=\"code\">needle</code> as a result.</p>\n\n</div>\n", ["CALLED", "FINISHED", "NEEDLE", "RESULT", "SEARCH", "TERMINATE", "THE", "WHEN", "WILL", "WITH"]);
add_ocaml_element("create", "Bap_c_abi.Stack.create", "value", "?growsup:Bool.t -> Std.arch -> int -> Std.exp", "Bap_c_abi.Stack.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">stack&nbsp;=&nbsp;create&nbsp;?growsup&nbsp;arch</code> is a function that returns\n      <code class=\"code\">n</code>'th stack slot</p>\n\n</div>\n", ["ARCH", "CREATE", "FUNCTION", "GROWSUP", "RETURNS", "SLOT", "STACK", "THAT"]);
add_ocaml_element("arg_intent", "Bap_c_abi.arg_intent", "value", "Bap_c_type.t -> Std.intent", "Bap_c_abi.html#VALarg_intent", "<div class=\"info\">\n<p><code class=\"code\">arg_intent&nbsp;t</code> infers argument intention based on its C type.</p>\n\n</div>\n", ["ALWAYS", "ANY", "ARGUMENT", "ARGYMENT", "ARG_INTENT", "BASED", "BASIC", "BUT", "CONST", "FIELDS", "FUNCTION", "HAS", "INFERS", "INPUT", "INTENT", "INTENTION", "ITS", "NON", "NOT", "OUTPUT", "PASSED", "REFERENCE", "REFERENCED", "STRUCTURE", "THE", "THEN", "TYPE", "UNION", "VALUE"]);
add_ocaml_element("data", "Bap_c_abi.data", "value", "#Bap_c_size.base -> Bap_c_type.t -> Bap_c_data.t", "Bap_c_abi.html#VALdata", "<div class=\"info\">\n<p><code class=\"code\">data&nbsp;size&nbsp;t</code> creates an abstraction of data that is represented\n    by type <code class=\"code\">t</code>.</p>\n\n</div>\n", ["ABSTRACTION", "ALIGNMENT", "AND", "CREATES", "DATA", "DEFINES", "ETC", "MODEL", "PADDING", "PARAMETER", "PRIMITIVE", "REPRESENTED", "RESTRICTIONS", "SIZE", "SIZES", "THAT", "THE", "TYPE", "TYPES"]);
add_ocaml_element("create_api_processor", "Bap_c_abi.create_api_processor", "value", "#Bap_c_size.base -> Bap_c_abi.t -> Bap_api.t", "Bap_c_abi.html#VALcreate_api_processor", "<div class=\"info\">\n<p><code class=\"code\">create_api_processor&nbsp;size&nbsp;t</code> packs an api processor.</p>\n\n</div>\n", ["AND", "ANNOTATE", "API", "ARG", "ATTRIBUTES", "AVAILABILITY", "BIR", "CORRESPONDING", "CREATE_API_PROCESSOR", "DATUM", "EACH", "END", "FOR", "FRONT", "INSERT", "INSERTED", "INTO", "ITS", "KNOWN", "LANGUAGE", "MODEL", "PACKS", "PARSER", "PROCESSOR", "PROPAGATE", "PROTOTYPE", "RECOGNIZED", "REGOGNIZED", "RELIES", "SIZE", "SOME", "SUBROUTINE", "TERM", "TERMS", "THE", "TYPE", "WILL", "WITH"]);
add_ocaml_element("t", "Bap_c_term_attributes.t", "value", "Bap_c_type.t Std.tag", "Bap_c_term_attributes.html#VALt", "<div class=\"info\">\n<p>A c type associated with a term.</p>\n\n</div>\n", ["ARG", "ASSOCIATED", "ATTACHED", "ATTRIBUTE", "BUT", "EACH", "FURTHER", "INSERTED", "MAYBE", "OTHER", "PASSES", "PROPAGATED", "TERM", "THIS", "TYPE", "WITH"]);
add_ocaml_element("proto", "Bap_c_term_attributes.proto", "value", "Bap_c_type.proto Std.tag", "Bap_c_term_attributes.html#VALproto", "<div class=\"info\">\n<p>Function prototype.</p>\n\n</div>\n", ["ANNOTATED", "ATTRIBUTE", "EACH", "FUNCTION", "INSERTED", "INTO", "PROTOTYPE", "THIS"]);
add_ocaml_element("data", "Bap_c_term_attributes.data", "value", "Bap_c_data.t Std.tag", "Bap_c_term_attributes.html#VALdata", "<div class=\"info\">\n<p>Abstraction of a data representation of C value.</p>\n\n</div>\n", ["ABSTRACTION", "ARG", "ATTACHED", "ATTRIBUTE", "BUT", "CAN", "DATA", "EACH", "FURTHER", "INSERTED", "OTHER", "PASSES", "PROPAGATED", "REPRESENTATION", "TERM", "THIS", "VALUE"]);
add_ocaml_element("pp_proto", "Bap_c_type_printer.pp_proto", "value", "Stdlib.Format.formatter -> Bap_c_type.proto -> unit", "Bap_c_type_printer.html#VALpp_proto", "", []);
add_ocaml_element("pp", "Bap_c_type_printer.pp", "value", "Stdlib.Format.formatter -> Bap_c_type.t -> unit", "Bap_c_type_printer.html#VALpp", "", []);
add_ocaml_element("apply", "Bap_c_attr.apply", "value", "Std.sub Bap_c_attr.pass", "Bap_c_attr.html#VALapply", "<div class=\"info\">\n<p>apply all registered actions</p>\n\n</div>\n", ["ACTIONS", "ALL", "APPLY", "REGISTERED"]);
add_ocaml_element("register", "Bap_c_attr.register", "value", "Std.sub Bap_c_attr.pass -> unit", "Bap_c_attr.html#VALregister", "<div class=\"info\">\n<p>register an action</p>\n\n</div>\n", ["ACTION", "REGISTER"]);
add_ocaml_element("sexp_of_t", "Bap_c_data.sexp_of_t", "value", "Bap_c_data.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_data.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_data.t_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_data.t", "Bap_c_data.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_data.compare", "value", "Bap_c_data.t -> Bap_c_data.t -> int", "Bap_c_data.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_data.bin_t", "value", "Bap_c_data.t Bin_prot.Type_class.t", "Bap_c_data.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_data.bin_reader_t", "value", "Bap_c_data.t Bin_prot.Type_class.reader", "Bap_c_data.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_data.bin_read_t", "value", "Bap_c_data.t Bin_prot.Read.reader", "Bap_c_data.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_data.__bin_read_t__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_data.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_data.bin_writer_t", "value", "Bap_c_data.t Bin_prot.Type_class.writer", "Bap_c_data.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_data.bin_write_t", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> Bap_c_data.t -> Bin_prot.Common.pos", "Bap_c_data.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_data.bin_size_t", "value", "Bap_c_data.t -> int", "Bap_c_data.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_data.bin_shape_t", "value", "Bin_prot.Shape.t", "Bap_c_data.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_value", "Bap_c_data.sexp_of_value", "value", "Bap_c_data.value -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_data.html#VALsexp_of_value", "", []);
add_ocaml_element("value_of_sexp", "Bap_c_data.value_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_data.value", "Bap_c_data.html#VALvalue_of_sexp", "", []);
add_ocaml_element("compare_value", "Bap_c_data.compare_value", "value", "Bap_c_data.value -> Bap_c_data.value -> int", "Bap_c_data.html#VALcompare_value", "", []);
add_ocaml_element("bin_value", "Bap_c_data.bin_value", "value", "Bap_c_data.value Bin_prot.Type_class.t", "Bap_c_data.html#VALbin_value", "", []);
add_ocaml_element("bin_reader_value", "Bap_c_data.bin_reader_value", "value", "Bap_c_data.value Bin_prot.Type_class.reader", "Bap_c_data.html#VALbin_reader_value", "", []);
add_ocaml_element("bin_read_value", "Bap_c_data.bin_read_value", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Bap_c_data.value", "Bap_c_data.html#VALbin_read_value", "", []);
add_ocaml_element("__bin_read_value__", "Bap_c_data.__bin_read_value__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_data.html#VAL__bin_read_value__", "", []);
add_ocaml_element("bin_writer_value", "Bap_c_data.bin_writer_value", "value", "Bap_c_data.value Bin_prot.Type_class.writer", "Bap_c_data.html#VALbin_writer_value", "", []);
add_ocaml_element("bin_write_value", "Bap_c_data.bin_write_value", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> Bap_c_data.value -> Bin_prot.Common.pos", "Bap_c_data.html#VALbin_write_value", "", []);
add_ocaml_element("bin_size_value", "Bap_c_data.bin_size_value", "value", "Bap_c_data.value -> int", "Bap_c_data.html#VALbin_size_value", "", []);
add_ocaml_element("bin_shape_value", "Bap_c_data.bin_shape_value", "value", "Bin_prot.Shape.t", "Bap_c_data.html#VALbin_shape_value", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.Array.sexp_of_t", "value", "'a.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a Bap_c_type.Array.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.Array.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.Array.t_of_sexp", "value", "'a.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a Bap_c_type.Array.t", "Bap_c_type.Array.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_type.Array.compare", "value", "'a.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    'a Bap_c_type.Array.t -> 'a Bap_c_type.Array.t -> Core_kernel__.Import.int", "Bap_c_type.Array.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_type.Array.bin_t", "value", "'a Bin_prot.Type_class.t ->\n  'a Bap_c_type.Array.t Bin_prot.Type_class.t", "Bap_c_type.Array.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.Array.bin_reader_t", "value", "'a Bin_prot.Type_class.reader ->\n  'a Bap_c_type.Array.t Bin_prot.Type_class.reader", "Bap_c_type.Array.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.Array.bin_read_t", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> 'a Bap_c_type.Array.t", "Bap_c_type.Array.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.Array.__bin_read_t__", "value", "'a ->\n  'b -> pos_ref:Bin_prot.Common.pos ref -> 'c -> 'd", "Bap_c_type.Array.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.Array.bin_writer_t", "value", "'a Bin_prot.Type_class.writer ->\n  'a Bap_c_type.Array.t Bin_prot.Type_class.writer", "Bap_c_type.Array.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.Array.bin_write_t", "value", "(Bin_prot.Common.buf -> pos:'a -> 'b -> Bin_prot.Common.pos) ->\n  Bin_prot.Common.buf -> pos:'a -> 'b Bap_c_type.Array.t -> Bin_prot.Common.pos", "Bap_c_type.Array.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.Array.bin_size_t", "value", "('a -> int) -> 'a Bap_c_type.Array.t -> int", "Bap_c_type.Array.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_type.Array.bin_shape_t", "value", "Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.Array.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.Compound.sexp_of_t", "value", "'a.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a Bap_c_type.Compound.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.Compound.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.Compound.t_of_sexp", "value", "'a.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a Bap_c_type.Compound.t", "Bap_c_type.Compound.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_type.Compound.compare", "value", "'a.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    'a Bap_c_type.Compound.t ->\n    'a Bap_c_type.Compound.t -> Core_kernel__.Import.int", "Bap_c_type.Compound.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_type.Compound.bin_t", "value", "'a Bin_prot.Type_class.t ->\n  'a Bap_c_type.Compound.t Bin_prot.Type_class.t", "Bap_c_type.Compound.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.Compound.bin_reader_t", "value", "'a Bin_prot.Type_class.reader ->\n  'a Bap_c_type.Compound.t Bin_prot.Type_class.reader", "Bap_c_type.Compound.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.Compound.bin_read_t", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> 'a Bap_c_type.Compound.t", "Bap_c_type.Compound.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.Compound.__bin_read_t__", "value", "'a ->\n  'b -> pos_ref:Bin_prot.Common.pos ref -> 'c -> 'd", "Bap_c_type.Compound.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.Compound.bin_writer_t", "value", "'a Bin_prot.Type_class.writer ->\n  'a Bap_c_type.Compound.t Bin_prot.Type_class.writer", "Bap_c_type.Compound.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.Compound.bin_write_t", "value", "(Bin_prot.Common.buf -> pos:Bin_prot.Common.pos -> 'a -> Bin_prot.Common.pos) ->\n  Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> 'a Bap_c_type.Compound.t -> Bin_prot.Common.pos", "Bap_c_type.Compound.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.Compound.bin_size_t", "value", "('a -> int) -> 'a Bap_c_type.Compound.t -> int", "Bap_c_type.Compound.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_type.Compound.bin_shape_t", "value", "Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.Compound.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.Proto.sexp_of_t", "value", "'a.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a Bap_c_type.Proto.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.Proto.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.Proto.t_of_sexp", "value", "'a.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a Bap_c_type.Proto.t", "Bap_c_type.Proto.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_type.Proto.compare", "value", "'a.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    'a Bap_c_type.Proto.t -> 'a Bap_c_type.Proto.t -> Core_kernel__.Import.int", "Bap_c_type.Proto.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_type.Proto.bin_t", "value", "'a Bin_prot.Type_class.t ->\n  'a Bap_c_type.Proto.t Bin_prot.Type_class.t", "Bap_c_type.Proto.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.Proto.bin_reader_t", "value", "'a Bin_prot.Type_class.reader ->\n  'a Bap_c_type.Proto.t Bin_prot.Type_class.reader", "Bap_c_type.Proto.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.Proto.bin_read_t", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> 'a Bap_c_type.Proto.t", "Bap_c_type.Proto.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.Proto.__bin_read_t__", "value", "'a ->\n  'b -> pos_ref:Bin_prot.Common.pos ref -> 'c -> 'd", "Bap_c_type.Proto.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.Proto.bin_writer_t", "value", "'a Bin_prot.Type_class.writer ->\n  'a Bap_c_type.Proto.t Bin_prot.Type_class.writer", "Bap_c_type.Proto.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.Proto.bin_write_t", "value", "(Bin_prot.Common.buf -> pos:Bin_prot.Common.pos -> 'a -> Bin_prot.Common.pos) ->\n  Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> 'a Bap_c_type.Proto.t -> Bin_prot.Common.pos", "Bap_c_type.Proto.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.Proto.bin_size_t", "value", "('a -> int) -> 'a Bap_c_type.Proto.t -> int", "Bap_c_type.Proto.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_type.Proto.bin_shape_t", "value", "Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.Proto.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.Spec.sexp_of_t", "value", "'a 'b.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    ('b -> Ppx_sexp_conv_lib.Sexp.t) ->\n    ('a, 'b) Bap_c_type.Spec.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.Spec.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.Spec.t_of_sexp", "value", "'a 'b.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    (Ppx_sexp_conv_lib.Sexp.t -> 'b) ->\n    Ppx_sexp_conv_lib.Sexp.t -> ('a, 'b) Bap_c_type.Spec.t", "Bap_c_type.Spec.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_type.Spec.compare", "value", "'a 'b.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    ('b -> 'b -> Core_kernel__.Import.int) ->\n    ('a, 'b) Bap_c_type.Spec.t ->\n    ('a, 'b) Bap_c_type.Spec.t -> Core_kernel__.Import.int", "Bap_c_type.Spec.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_type.Spec.bin_t", "value", "'a Bin_prot.Type_class.t ->\n  'b Bin_prot.Type_class.t ->\n  ('a, 'b) Bap_c_type.Spec.t Bin_prot.Type_class.t", "Bap_c_type.Spec.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.Spec.bin_reader_t", "value", "'a Bin_prot.Type_class.reader ->\n  'b Bin_prot.Type_class.reader ->\n  ('a, 'b) Bap_c_type.Spec.t Bin_prot.Type_class.reader", "Bap_c_type.Spec.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.Spec.bin_read_t", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  (Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'b) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> ('a, 'b) Bap_c_type.Spec.t", "Bap_c_type.Spec.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.Spec.__bin_read_t__", "value", "'a ->\n  'b ->\n  'c -> pos_ref:Bin_prot.Common.pos ref -> 'd -> 'e", "Bap_c_type.Spec.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.Spec.bin_writer_t", "value", "'a Bin_prot.Type_class.writer ->\n  'b Bin_prot.Type_class.writer ->\n  ('a, 'b) Bap_c_type.Spec.t Bin_prot.Type_class.writer", "Bap_c_type.Spec.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.Spec.bin_write_t", "value", "(Bin_prot.Common.buf -> pos:'a -> 'b -> 'c) ->\n  (Bin_prot.Common.buf -> pos:'c -> 'd -> Bin_prot.Common.pos) ->\n  Bin_prot.Common.buf ->\n  pos:'a -> ('b, 'd) Bap_c_type.Spec.t -> Bin_prot.Common.pos", "Bap_c_type.Spec.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.Spec.bin_size_t", "value", "('a -> int) -> ('b -> int) -> ('a, 'b) Bap_c_type.Spec.t -> int", "Bap_c_type.Spec.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_type.Spec.bin_shape_t", "value", "Bin_prot.Shape.t ->\n  Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.Spec.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.Attr.sexp_of_t", "value", "Bap_c_type.Attr.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.Attr.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.Attr.t_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.Attr.t", "Bap_c_type.Attr.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_type.Attr.compare", "value", "Bap_c_type.Attr.t -> Bap_c_type.Attr.t -> int", "Bap_c_type.Attr.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_type.Attr.bin_t", "value", "Bap_c_type.Attr.t Bin_prot.Type_class.t", "Bap_c_type.Attr.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.Attr.bin_reader_t", "value", "Bap_c_type.Attr.t Bin_prot.Type_class.reader", "Bap_c_type.Attr.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.Attr.bin_read_t", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Bap_c_type.Attr.t", "Bap_c_type.Attr.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.Attr.__bin_read_t__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_type.Attr.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.Attr.bin_writer_t", "value", "Bap_c_type.Attr.t Bin_prot.Type_class.writer", "Bap_c_type.Attr.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.Attr.bin_write_t", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> Bap_c_type.Attr.t -> Bin_prot.Common.pos", "Bap_c_type.Attr.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.Attr.bin_size_t", "value", "Bap_c_type.Attr.t -> int", "Bap_c_type.Attr.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_type.Attr.bin_shape_t", "value", "Bin_prot.Shape.t", "Bap_c_type.Attr.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.Qualifier.sexp_of_t", "value", "'a.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a Bap_c_type.Qualifier.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.Qualifier.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.Qualifier.t_of_sexp", "value", "'a.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a Bap_c_type.Qualifier.t", "Bap_c_type.Qualifier.html#VALt_of_sexp", "", []);
add_ocaml_element("compare", "Bap_c_type.Qualifier.compare", "value", "'a.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    'a Bap_c_type.Qualifier.t ->\n    'a Bap_c_type.Qualifier.t -> Core_kernel__.Import.int", "Bap_c_type.Qualifier.html#VALcompare", "", []);
add_ocaml_element("bin_t", "Bap_c_type.Qualifier.bin_t", "value", "'a Bin_prot.Type_class.t ->\n  'a Bap_c_type.Qualifier.t Bin_prot.Type_class.t", "Bap_c_type.Qualifier.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.Qualifier.bin_reader_t", "value", "'a Bin_prot.Type_class.reader ->\n  'a Bap_c_type.Qualifier.t Bin_prot.Type_class.reader", "Bap_c_type.Qualifier.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.Qualifier.bin_read_t", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> 'a Bap_c_type.Qualifier.t", "Bap_c_type.Qualifier.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.Qualifier.__bin_read_t__", "value", "'a ->\n  'b -> pos_ref:Bin_prot.Common.pos ref -> 'c -> 'd", "Bap_c_type.Qualifier.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.Qualifier.bin_writer_t", "value", "'a Bin_prot.Type_class.writer ->\n  'a Bap_c_type.Qualifier.t Bin_prot.Type_class.writer", "Bap_c_type.Qualifier.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.Qualifier.bin_write_t", "value", "(Bin_prot.Common.buf -> pos:Bin_prot.Common.pos -> 'a -> 'b) ->\n  Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> 'a Bap_c_type.Qualifier.t -> 'b", "Bap_c_type.Qualifier.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.Qualifier.bin_size_t", "value", "('a -> int) -> 'a Bap_c_type.Qualifier.t -> int", "Bap_c_type.Qualifier.html#VALbin_size_t", "", []);
add_ocaml_element("bin_shape_t", "Bap_c_type.Qualifier.bin_shape_t", "value", "Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.Qualifier.html#VALbin_shape_t", "", []);
add_ocaml_element("sexp_of_aggregate", "Bap_c_type.sexp_of_aggregate", "value", "Bap_c_type.aggregate -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_aggregate", "", []);
add_ocaml_element("aggregate_of_sexp", "Bap_c_type.aggregate_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.aggregate", "Bap_c_type.html#VALaggregate_of_sexp", "", []);
add_ocaml_element("__aggregate_of_sexp__", "Bap_c_type.__aggregate_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.aggregate", "Bap_c_type.html#VAL__aggregate_of_sexp__", "", []);
add_ocaml_element("compare_aggregate", "Bap_c_type.compare_aggregate", "value", "Bap_c_type.aggregate -> Bap_c_type.aggregate -> int", "Bap_c_type.html#VALcompare_aggregate", "", []);
add_ocaml_element("bin_aggregate", "Bap_c_type.bin_aggregate", "value", "[ `Array of\n      ([ `no_qualifier ],\n       [ `Array of\n           (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n           Bap_c_type.Spec.t\n       | `Basic of\n           (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n           Bap_c_type.Spec.t\n       | `Function of\n           ([ `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n       | `Pointer of\n           (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n       | `Structure of\n           ([ `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n       | `Union of\n           ([ `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n       | `Void ] as 'a)\n      Bap_c_type.Spec.t\n  | `Structure of\n      ([ `no_qualifier ],\n       ([ `Array of\n            (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n            Bap_c_type.Spec.t\n        | `Basic of\n            (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n             Bap_c_type.basic)\n            Bap_c_type.Spec.t\n        | `Function of\n            ([ `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n        | `Pointer of\n            (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n        | `Structure of\n            ([ `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n        | `Union of\n            ([ `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n        | `Void ] as 'b)\n       Core_kernel__.Import.list)\n      Bap_c_type.Spec.t ]\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_aggregate", "", []);
add_ocaml_element("bin_reader_aggregate", "Bap_c_type.bin_reader_aggregate", "value", "[> `Array of\n       ([> `no_qualifier ],\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              Bap_c_type.basic)\n             Bap_c_type.Spec.t\n         | `Function of\n             ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t\n   | `Structure of\n       ([> `no_qualifier ],\n        ([> `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'b Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               Bap_c_type.basic)\n              Bap_c_type.Spec.t\n          | `Function of\n              ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n          | `Structure of\n              ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of\n              ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Void ]\n         as 'b)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t ]\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_aggregate", "", []);
add_ocaml_element("bin_read_aggregate", "Bap_c_type.bin_read_aggregate", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `Array of\n       ([> `no_qualifier ],\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              Bap_c_type.basic)\n             Bap_c_type.Spec.t\n         | `Function of\n             ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t\n   | `Structure of\n       ([> `no_qualifier ],\n        ([> `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'b Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               Bap_c_type.basic)\n              Bap_c_type.Spec.t\n          | `Function of\n              ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n          | `Structure of\n              ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of\n              ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Void ]\n         as 'b)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t ]", "Bap_c_type.html#VALbin_read_aggregate", "", []);
add_ocaml_element("__bin_read_aggregate__", "Bap_c_type.__bin_read_aggregate__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  int ->\n  [> `Array of\n       ([> `no_qualifier ],\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              Bap_c_type.basic)\n             Bap_c_type.Spec.t\n         | `Function of\n             ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t\n   | `Structure of\n       ([> `no_qualifier ],\n        ([> `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'b Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               Bap_c_type.basic)\n              Bap_c_type.Spec.t\n          | `Function of\n              ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n          | `Structure of\n              ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of\n              ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Void ]\n         as 'b)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t ]", "Bap_c_type.html#VAL__bin_read_aggregate__", "", []);
add_ocaml_element("bin_writer_aggregate", "Bap_c_type.bin_writer_aggregate", "value", "[< `Array of\n       ('a,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of ('c, 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n         | `Structure of ('d, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of ('e, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n        as 'b)\n       Bap_c_type.Spec.t &\n       ([< `no_qualifier ],\n        [< `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'f Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of\n             ([< `no_qualifier ], 'f Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'f) Bap_c_type.Spec.t\n         | `Structure of\n             ([< `no_qualifier ], 'f Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([< `no_qualifier ], 'f Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'f)\n       Bap_c_type.Spec.t\n   | `Structure of\n       ('g,\n        ([> `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'h Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               [< `cdouble\n                | `cfloat\n                | `char\n                | `clong_double\n                | `double\n                | `enum of\n                    (Core_kernel__.Import.string *\n                     Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                    Core_kernel__.Import.list\n                | `float\n                | `long_double\n                | `schar\n                | `sint\n                | `slong\n                | `slong_long\n                | `sshort\n                | `uchar\n                | `uint\n                | `ulong\n                | `ulong_long\n                | `ushort ])\n              Bap_c_type.Spec.t\n          | `Function of ('i, 'h Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'h) Bap_c_type.Spec.t\n          | `Structure of ('j, 'h Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of ('k, 'h Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n         as 'h)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t &\n       ([< `no_qualifier ],\n        ([< `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'l Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               [< `cdouble\n                | `cfloat\n                | `char\n                | `clong_double\n                | `double\n                | `enum of\n                    (Core_kernel__.Import.string *\n                     Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                    Core_kernel__.Import.list\n                | `float\n                | `long_double\n                | `schar\n                | `sint\n                | `slong\n                | `slong_long\n                | `sshort\n                | `uchar\n                | `uint\n                | `ulong\n                | `ulong_long\n                | `ushort ])\n              Bap_c_type.Spec.t\n          | `Function of\n              ([< `no_qualifier ], 'l Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'l) Bap_c_type.Spec.t\n          | `Structure of\n              ([< `no_qualifier ], 'l Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of\n              ([< `no_qualifier ], 'l Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Void ]\n         as 'l)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_aggregate", "", []);
add_ocaml_element("bin_write_aggregate", "Bap_c_type.bin_write_aggregate", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `Array of\n       ([< `no_qualifier ],\n        [< `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of\n             ([< `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t\n   | `Structure of\n       ([< `no_qualifier ],\n        ([< `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'b Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               [< `cdouble\n                | `cfloat\n                | `char\n                | `clong_double\n                | `double\n                | `enum of\n                    (Core_kernel__.Import.string *\n                     Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                    Core_kernel__.Import.list\n                | `float\n                | `long_double\n                | `schar\n                | `sint\n                | `slong\n                | `slong_long\n                | `sshort\n                | `uchar\n                | `uint\n                | `ulong\n                | `ulong_long\n                | `ushort ])\n              Bap_c_type.Spec.t\n          | `Function of\n              ([< `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n          | `Structure of\n              ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of\n              ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Void ]\n         as 'b)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t ] ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_aggregate", "", []);
add_ocaml_element("bin_size_aggregate", "Bap_c_type.bin_size_aggregate", "value", "[< `Array of\n       ('a,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of ('c, 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n         | `Structure of ('d, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of ('e, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n        as 'b)\n       Bap_c_type.Spec.t\n   | `Structure of\n       ('f,\n        ([> `Array of\n              (Bool.t Bap_c_type.Qualifier.t,\n               'g Bap_c_type.Array.t)\n              Bap_c_type.Spec.t\n          | `Basic of\n              (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n               [< `cdouble\n                | `cfloat\n                | `char\n                | `clong_double\n                | `double\n                | `enum of\n                    (Core_kernel__.Import.string *\n                     Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                    Core_kernel__.Import.list\n                | `float\n                | `long_double\n                | `schar\n                | `sint\n                | `slong\n                | `slong_long\n                | `sshort\n                | `uchar\n                | `uint\n                | `ulong\n                | `ulong_long\n                | `ushort ])\n              Bap_c_type.Spec.t\n          | `Function of ('h, 'g Bap_c_type.Proto.t) Bap_c_type.Spec.t\n          | `Pointer of\n              (Bool.t Bap_c_type.Qualifier.t, 'g) Bap_c_type.Spec.t\n          | `Structure of ('i, 'g Bap_c_type.Compound.t) Bap_c_type.Spec.t\n          | `Union of ('j, 'g Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n         as 'g)\n        Core_kernel__.Import.list)\n       Bap_c_type.Spec.t ] ->\n  int", "Bap_c_type.html#VALbin_size_aggregate", "", []);
add_ocaml_element("bin_shape_aggregate", "Bap_c_type.bin_shape_aggregate", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_aggregate", "", []);
add_ocaml_element("sexp_of_scalar", "Bap_c_type.sexp_of_scalar", "value", "Bap_c_type.scalar -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_scalar", "", []);
add_ocaml_element("scalar_of_sexp", "Bap_c_type.scalar_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.scalar", "Bap_c_type.html#VALscalar_of_sexp", "", []);
add_ocaml_element("__scalar_of_sexp__", "Bap_c_type.__scalar_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.scalar", "Bap_c_type.html#VAL__scalar_of_sexp__", "", []);
add_ocaml_element("compare_scalar", "Bap_c_type.compare_scalar", "value", "Bap_c_type.scalar -> Bap_c_type.scalar -> int", "Bap_c_type.html#VALcompare_scalar", "", []);
add_ocaml_element("bin_scalar", "Bap_c_type.bin_scalar", "value", "[ `Basic of\n      (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n      Bap_c_type.Spec.t\n  | `Pointer of\n      (Bool.t Bap_c_type.Qualifier.t,\n       [ `Array of\n           (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n           Bap_c_type.Spec.t\n       | `Basic of\n           (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n           Bap_c_type.Spec.t\n       | `Function of\n           ([ `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n       | `Pointer of\n           (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n       | `Structure of\n           ([ `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n       | `Union of\n           ([ `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n       | `Void ] as 'a)\n      Bap_c_type.Spec.t ]\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_scalar", "", []);
add_ocaml_element("bin_reader_scalar", "Bap_c_type.bin_reader_scalar", "value", "[> `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n       Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              Bap_c_type.basic)\n             Bap_c_type.Spec.t\n         | `Function of\n             ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t ]\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_scalar", "", []);
add_ocaml_element("bin_read_scalar", "Bap_c_type.bin_read_scalar", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n       Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              Bap_c_type.basic)\n             Bap_c_type.Spec.t\n         | `Function of\n             ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t ]", "Bap_c_type.html#VALbin_read_scalar", "", []);
add_ocaml_element("__bin_read_scalar__", "Bap_c_type.__bin_read_scalar__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  int ->\n  [> `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n       Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              Bap_c_type.basic)\n             Bap_c_type.Spec.t\n         | `Function of\n             ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t ]", "Bap_c_type.html#VAL__bin_read_scalar__", "", []);
add_ocaml_element("bin_writer_scalar", "Bap_c_type.bin_writer_scalar", "value", "[< `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n        [< `cdouble\n         | `cfloat\n         | `char\n         | `clong_double\n         | `double\n         | `enum of\n             (Core_kernel__.Import.string *\n              Core_kernel__.Import.int64 Core_kernel__.Import.option)\n             Core_kernel__.Import.list\n         | `float\n         | `long_double\n         | `schar\n         | `sint\n         | `slong\n         | `slong_long\n         | `sshort\n         | `uchar\n         | `uint\n         | `ulong\n         | `ulong_long\n         | `ushort ])\n       Bap_c_type.Spec.t &\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n        [< `cdouble\n         | `cfloat\n         | `char\n         | `clong_double\n         | `double\n         | `enum of\n             (Core_kernel__.Import.string *\n              Core_kernel__.Import.int64 Core_kernel__.Import.option)\n             Core_kernel__.Import.list\n         | `float\n         | `long_double\n         | `schar\n         | `sint\n         | `slong\n         | `slong_long\n         | `sshort\n         | `uchar\n         | `uint\n         | `ulong\n         | `ulong_long\n         | `ushort ])\n       Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of ('b, 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of ('c, 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of ('d, 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n        as 'a)\n       Bap_c_type.Spec.t &\n       (Bool.t Bap_c_type.Qualifier.t,\n        [< `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'e Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of\n             ([< `no_qualifier ], 'e Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'e) Bap_c_type.Spec.t\n         | `Structure of\n             ([< `no_qualifier ], 'e Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([< `no_qualifier ], 'e Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'e)\n       Bap_c_type.Spec.t ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_scalar", "", []);
add_ocaml_element("bin_write_scalar", "Bap_c_type.bin_write_scalar", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n        [< `cdouble\n         | `cfloat\n         | `char\n         | `clong_double\n         | `double\n         | `enum of\n             (Core_kernel__.Import.string *\n              Core_kernel__.Import.int64 Core_kernel__.Import.option)\n             Core_kernel__.Import.list\n         | `float\n         | `long_double\n         | `schar\n         | `sint\n         | `slong\n         | `slong_long\n         | `sshort\n         | `uchar\n         | `uint\n         | `ulong\n         | `ulong_long\n         | `ushort ])\n       Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t,\n        [< `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of\n             ([< `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of\n             ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of\n             ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Void ]\n        as 'a)\n       Bap_c_type.Spec.t ] ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_scalar", "", []);
add_ocaml_element("bin_size_scalar", "Bap_c_type.bin_size_scalar", "value", "[< `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n        [< `cdouble\n         | `cfloat\n         | `char\n         | `clong_double\n         | `double\n         | `enum of\n             (Core_kernel__.Import.string *\n              Core_kernel__.Import.int64 Core_kernel__.Import.option)\n             Core_kernel__.Import.list\n         | `float\n         | `long_double\n         | `schar\n         | `sint\n         | `slong\n         | `slong_long\n         | `sshort\n         | `uchar\n         | `uint\n         | `ulong\n         | `ulong_long\n         | `ushort ])\n       Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t,\n        [> `Array of\n             (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n             Bap_c_type.Spec.t\n         | `Basic of\n             (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n              [< `cdouble\n               | `cfloat\n               | `char\n               | `clong_double\n               | `double\n               | `enum of\n                   (Core_kernel__.Import.string *\n                    Core_kernel__.Import.int64 Core_kernel__.Import.option)\n                   Core_kernel__.Import.list\n               | `float\n               | `long_double\n               | `schar\n               | `sint\n               | `slong\n               | `slong_long\n               | `sshort\n               | `uchar\n               | `uint\n               | `ulong\n               | `ulong_long\n               | `ushort ])\n             Bap_c_type.Spec.t\n         | `Function of ('b, 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n         | `Pointer of\n             (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n         | `Structure of ('c, 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n         | `Union of ('d, 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n        as 'a)\n       Bap_c_type.Spec.t ] ->\n  int", "Bap_c_type.html#VALbin_size_scalar", "", []);
add_ocaml_element("bin_shape_scalar", "Bap_c_type.bin_shape_scalar", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_scalar", "", []);
add_ocaml_element("sexp_of_array", "Bap_c_type.sexp_of_array", "value", "Bap_c_type.array -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_array", "", []);
add_ocaml_element("sexp_of_compound", "Bap_c_type.sexp_of_compound", "value", "Bap_c_type.compound -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_compound", "", []);
add_ocaml_element("sexp_of_proto", "Bap_c_type.sexp_of_proto", "value", "Bap_c_type.proto -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_proto", "", []);
add_ocaml_element("sexp_of_t", "Bap_c_type.sexp_of_t", "value", "Bap_c_type.t -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_t", "", []);
add_ocaml_element("array_of_sexp", "Bap_c_type.array_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.array", "Bap_c_type.html#VALarray_of_sexp", "", []);
add_ocaml_element("compound_of_sexp", "Bap_c_type.compound_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.compound", "Bap_c_type.html#VALcompound_of_sexp", "", []);
add_ocaml_element("proto_of_sexp", "Bap_c_type.proto_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.proto", "Bap_c_type.html#VALproto_of_sexp", "", []);
add_ocaml_element("t_of_sexp", "Bap_c_type.t_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.t", "Bap_c_type.html#VALt_of_sexp", "", []);
add_ocaml_element("__t_of_sexp__", "Bap_c_type.__t_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.t", "Bap_c_type.html#VAL__t_of_sexp__", "", []);
add_ocaml_element("compare_array", "Bap_c_type.compare_array", "value", "Bap_c_type.array -> Bap_c_type.array -> Core_kernel__.Import.int", "Bap_c_type.html#VALcompare_array", "", []);
add_ocaml_element("compare_compound", "Bap_c_type.compare_compound", "value", "Bap_c_type.compound -> Bap_c_type.compound -> Core_kernel__.Import.int", "Bap_c_type.html#VALcompare_compound", "", []);
add_ocaml_element("compare_proto", "Bap_c_type.compare_proto", "value", "Bap_c_type.proto -> Bap_c_type.proto -> Core_kernel__.Import.int", "Bap_c_type.html#VALcompare_proto", "", []);
add_ocaml_element("compare", "Bap_c_type.compare", "value", "Bap_c_type.t -> Bap_c_type.t -> Core_kernel__.Import.int", "Bap_c_type.html#VALcompare", "", []);
add_ocaml_element("bin_array", "Bap_c_type.bin_array", "value", "(([ `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n        Bap_c_type.Spec.t\n    | `Function of ([ `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n    | `Structure of\n        ([ `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of ([ `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void ] as 'b)\n   Bap_c_type.Array.t as 'a)\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_array", "", []);
add_ocaml_element("bin_compound", "Bap_c_type.bin_compound", "value", "(([ `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n        Bap_c_type.Spec.t\n    | `Function of ([ `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n    | `Structure of ([ `no_qualifier ], 'a) Bap_c_type.Spec.t\n    | `Union of ([ `no_qualifier ], 'a) Bap_c_type.Spec.t\n    | `Void ] as 'b)\n   Bap_c_type.Compound.t as 'a)\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_compound", "", []);
add_ocaml_element("bin_proto", "Bap_c_type.bin_proto", "value", "(([ `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n        Bap_c_type.Spec.t\n    | `Function of ([ `no_qualifier ], 'a) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n    | `Structure of\n        ([ `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of ([ `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void ] as 'b)\n   Bap_c_type.Proto.t as 'a)\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_proto", "", []);
add_ocaml_element("bin_t", "Bap_c_type.bin_t", "value", "([ `Array of\n       (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n       Bap_c_type.Spec.t\n   | `Basic of\n       (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n       Bap_c_type.Spec.t\n   | `Function of ([ `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n   | `Pointer of\n       (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n   | `Structure of\n       ([ `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n   | `Union of ([ `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n   | `Void ] as 'a)\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_t", "", []);
add_ocaml_element("bin_reader_array", "Bap_c_type.bin_reader_array", "value", "(([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n         Bap_c_type.Spec.t\n     | `Function of\n         ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Array.t as 'a)\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_array", "", []);
add_ocaml_element("bin_reader_compound", "Bap_c_type.bin_reader_compound", "value", "(([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n         Bap_c_type.Spec.t\n     | `Function of\n         ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ([> `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Union of ([> `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Compound.t as 'a)\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_compound", "", []);
add_ocaml_element("bin_reader_proto", "Bap_c_type.bin_reader_proto", "value", "(([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n         Bap_c_type.Spec.t\n     | `Function of ([> `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Proto.t as 'a)\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_proto", "", []);
add_ocaml_element("bin_reader_t", "Bap_c_type.bin_reader_t", "value", "([> `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n        Bap_c_type.Spec.t\n    | `Function of\n        ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Structure of\n        ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of\n        ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void ]\n   as 'a)\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_t", "", []);
add_ocaml_element("bin_read_array", "Bap_c_type.bin_read_array", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  (([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n         Bap_c_type.Spec.t\n     | `Function of\n         ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Array.t as 'a)", "Bap_c_type.html#VALbin_read_array", "", []);
add_ocaml_element("bin_read_compound", "Bap_c_type.bin_read_compound", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  (([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n         Bap_c_type.Spec.t\n     | `Function of\n         ([> `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ([> `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Union of ([> `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Compound.t as 'a)", "Bap_c_type.html#VALbin_read_compound", "", []);
add_ocaml_element("bin_read_proto", "Bap_c_type.bin_read_proto", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  (([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n         Bap_c_type.Spec.t\n     | `Function of ([> `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([> `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Proto.t as 'a)", "Bap_c_type.html#VALbin_read_proto", "", []);
add_ocaml_element("bin_read_t", "Bap_c_type.bin_read_t", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  ([> `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n        Bap_c_type.Spec.t\n    | `Function of\n        ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Structure of\n        ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of\n        ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void ]\n   as 'a)", "Bap_c_type.html#VALbin_read_t", "", []);
add_ocaml_element("__bin_read_array__", "Bap_c_type.__bin_read_array__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_type.html#VAL__bin_read_array__", "", []);
add_ocaml_element("__bin_read_compound__", "Bap_c_type.__bin_read_compound__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_type.html#VAL__bin_read_compound__", "", []);
add_ocaml_element("__bin_read_proto__", "Bap_c_type.__bin_read_proto__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_type.html#VAL__bin_read_proto__", "", []);
add_ocaml_element("__bin_read_t__", "Bap_c_type.__bin_read_t__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  int ->\n  ([> `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t, Bap_c_type.basic)\n        Bap_c_type.Spec.t\n    | `Function of\n        ([> `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Structure of\n        ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of\n        ([> `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void ]\n   as 'a)", "Bap_c_type.html#VAL__bin_read_t__", "", []);
add_ocaml_element("bin_writer_array", "Bap_c_type.bin_writer_array", "value", "(([< `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of\n         ([< `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void\n     > `Array `Basic `Function `Pointer `Structure `Union ]\n    as 'b)\n   Bap_c_type.Array.t as 'a)\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_array", "", []);
add_ocaml_element("bin_writer_compound", "Bap_c_type.bin_writer_compound", "value", "(([< `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of\n         ([< `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ([< `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Union of ([< `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Void\n     > `Array `Basic `Function `Pointer `Structure `Union ]\n    as 'b)\n   Bap_c_type.Compound.t as 'a)\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_compound", "", []);
add_ocaml_element("bin_writer_proto", "Bap_c_type.bin_writer_proto", "value", "(([< `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of ([< `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void\n     > `Array `Basic `Function `Pointer `Structure `Union ]\n    as 'b)\n   Bap_c_type.Proto.t as 'a)\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_proto", "", []);
add_ocaml_element("bin_writer_t", "Bap_c_type.bin_writer_t", "value", "([< `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n         [< `cdouble\n          | `cfloat\n          | `char\n          | `clong_double\n          | `double\n          | `enum of\n              (Core_kernel__.Import.string *\n               Core_kernel__.Import.int64 Core_kernel__.Import.option)\n              Core_kernel__.Import.list\n          | `float\n          | `long_double\n          | `schar\n          | `sint\n          | `slong\n          | `slong_long\n          | `sshort\n          | `uchar\n          | `uint\n          | `ulong\n          | `ulong_long\n          | `ushort ])\n        Bap_c_type.Spec.t\n    | `Function of\n        ([< `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Structure of\n        ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of\n        ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void\n    > `Array `Basic `Function `Pointer `Structure `Union ]\n   as 'a)\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_t", "", []);
add_ocaml_element("bin_write_array", "Bap_c_type.bin_write_array", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  (([< `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of\n         ([< `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Array.t as 'a) ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_array", "", []);
add_ocaml_element("bin_write_compound", "Bap_c_type.bin_write_compound", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  (([< `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of\n         ([< `no_qualifier ], 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ([< `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Union of ([< `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Compound.t as 'a) ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_compound", "", []);
add_ocaml_element("bin_write_proto", "Bap_c_type.bin_write_proto", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  (([< `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of ([< `no_qualifier ], 'a) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of\n         ([< `no_qualifier ], 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Void ]\n    as 'b)\n   Bap_c_type.Proto.t as 'a) ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_proto", "", []);
add_ocaml_element("bin_write_t", "Bap_c_type.bin_write_t", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  ([< `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n         [< `cdouble\n          | `cfloat\n          | `char\n          | `clong_double\n          | `double\n          | `enum of\n              (Core_kernel__.Import.string *\n               Core_kernel__.Import.int64 Core_kernel__.Import.option)\n              Core_kernel__.Import.list\n          | `float\n          | `long_double\n          | `schar\n          | `sint\n          | `slong\n          | `slong_long\n          | `sshort\n          | `uchar\n          | `uint\n          | `ulong\n          | `ulong_long\n          | `ushort ])\n        Bap_c_type.Spec.t\n    | `Function of\n        ([< `no_qualifier ], 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Structure of\n        ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of\n        ([< `no_qualifier ], 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Void ]\n   as 'a) ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_t", "", []);
add_ocaml_element("bin_size_array", "Bap_c_type.bin_size_array", "value", "(([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of ('c, 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ('d, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of ('e, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n    as 'b)\n   Bap_c_type.Array.t as 'a) ->\n  int", "Bap_c_type.html#VALbin_size_array", "", []);
add_ocaml_element("bin_size_compound", "Bap_c_type.bin_size_compound", "value", "(([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of ('c, 'b Bap_c_type.Proto.t) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ('d, 'a) Bap_c_type.Spec.t\n     | `Union of ('e, 'a) Bap_c_type.Spec.t ]\n    as 'b)\n   Bap_c_type.Compound.t as 'a) ->\n  int", "Bap_c_type.html#VALbin_size_compound", "", []);
add_ocaml_element("bin_size_proto", "Bap_c_type.bin_size_proto", "value", "(([> `Array of\n         (Bool.t Bap_c_type.Qualifier.t, 'b Bap_c_type.Array.t)\n         Bap_c_type.Spec.t\n     | `Basic of\n         (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n          [< `cdouble\n           | `cfloat\n           | `char\n           | `clong_double\n           | `double\n           | `enum of\n               (Core_kernel__.Import.string *\n                Core_kernel__.Import.int64 Core_kernel__.Import.option)\n               Core_kernel__.Import.list\n           | `float\n           | `long_double\n           | `schar\n           | `sint\n           | `slong\n           | `slong_long\n           | `sshort\n           | `uchar\n           | `uint\n           | `ulong\n           | `ulong_long\n           | `ushort ])\n         Bap_c_type.Spec.t\n     | `Function of ('c, 'a) Bap_c_type.Spec.t\n     | `Pointer of\n         (Bool.t Bap_c_type.Qualifier.t, 'b) Bap_c_type.Spec.t\n     | `Structure of ('d, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t\n     | `Union of ('e, 'b Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n    as 'b)\n   Bap_c_type.Proto.t as 'a) ->\n  int", "Bap_c_type.html#VALbin_size_proto", "", []);
add_ocaml_element("bin_size_t", "Bap_c_type.bin_size_t", "value", "([> `Array of\n        (Bool.t Bap_c_type.Qualifier.t, 'a Bap_c_type.Array.t)\n        Bap_c_type.Spec.t\n    | `Basic of\n        (Core_kernel__.Import.unit Bap_c_type.Qualifier.t,\n         [< `cdouble\n          | `cfloat\n          | `char\n          | `clong_double\n          | `double\n          | `enum of\n              (Core_kernel__.Import.string *\n               Core_kernel__.Import.int64 Core_kernel__.Import.option)\n              Core_kernel__.Import.list\n          | `float\n          | `long_double\n          | `schar\n          | `sint\n          | `slong\n          | `slong_long\n          | `sshort\n          | `uchar\n          | `uint\n          | `ulong\n          | `ulong_long\n          | `ushort ])\n        Bap_c_type.Spec.t\n    | `Function of ('b, 'a Bap_c_type.Proto.t) Bap_c_type.Spec.t\n    | `Pointer of\n        (Bool.t Bap_c_type.Qualifier.t, 'a) Bap_c_type.Spec.t\n    | `Structure of ('c, 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t\n    | `Union of ('d, 'a Bap_c_type.Compound.t) Bap_c_type.Spec.t ]\n   as 'a) ->\n  int", "Bap_c_type.html#VALbin_size_t", "", []);
add_ocaml_element("sexp_of_no_qualifier", "Bap_c_type.sexp_of_no_qualifier", "value", "Bap_c_type.no_qualifier -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_no_qualifier", "", []);
add_ocaml_element("no_qualifier_of_sexp", "Bap_c_type.no_qualifier_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.no_qualifier", "Bap_c_type.html#VALno_qualifier_of_sexp", "", []);
add_ocaml_element("__no_qualifier_of_sexp__", "Bap_c_type.__no_qualifier_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.no_qualifier", "Bap_c_type.html#VAL__no_qualifier_of_sexp__", "", []);
add_ocaml_element("compare_no_qualifier", "Bap_c_type.compare_no_qualifier", "value", "Bap_c_type.no_qualifier -> Bap_c_type.no_qualifier -> int", "Bap_c_type.html#VALcompare_no_qualifier", "", []);
add_ocaml_element("bin_no_qualifier", "Bap_c_type.bin_no_qualifier", "value", "[ `no_qualifier ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_no_qualifier", "", []);
add_ocaml_element("bin_reader_no_qualifier", "Bap_c_type.bin_reader_no_qualifier", "value", "[> `no_qualifier ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_no_qualifier", "", []);
add_ocaml_element("bin_read_no_qualifier", "Bap_c_type.bin_read_no_qualifier", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> [> `no_qualifier ]", "Bap_c_type.html#VALbin_read_no_qualifier", "", []);
add_ocaml_element("__bin_read_no_qualifier__", "Bap_c_type.__bin_read_no_qualifier__", "value", "'a -> pos_ref:'b -> int -> [> `no_qualifier ]", "Bap_c_type.html#VAL__bin_read_no_qualifier__", "", []);
add_ocaml_element("bin_writer_no_qualifier", "Bap_c_type.bin_writer_no_qualifier", "value", "[< `no_qualifier ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_no_qualifier", "", []);
add_ocaml_element("bin_write_no_qualifier", "Bap_c_type.bin_write_no_qualifier", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> [< `no_qualifier ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_no_qualifier", "", []);
add_ocaml_element("bin_size_no_qualifier", "Bap_c_type.bin_size_no_qualifier", "value", "'a -> int", "Bap_c_type.html#VALbin_size_no_qualifier", "", []);
add_ocaml_element("bin_shape_no_qualifier", "Bap_c_type.bin_shape_no_qualifier", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_no_qualifier", "", []);
add_ocaml_element("sexp_of_spec", "Bap_c_type.sexp_of_spec", "value", "'a 'b.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    ('b -> Ppx_sexp_conv_lib.Sexp.t) ->\n    ('a, 'b) Bap_c_type.spec -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_spec", "", []);
add_ocaml_element("spec_of_sexp", "Bap_c_type.spec_of_sexp", "value", "'a 'b.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    (Ppx_sexp_conv_lib.Sexp.t -> 'b) ->\n    Ppx_sexp_conv_lib.Sexp.t -> ('a, 'b) Bap_c_type.spec", "Bap_c_type.html#VALspec_of_sexp", "", []);
add_ocaml_element("compare_spec", "Bap_c_type.compare_spec", "value", "'a 'b.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    ('b -> 'b -> Core_kernel__.Import.int) ->\n    ('a, 'b) Bap_c_type.spec ->\n    ('a, 'b) Bap_c_type.spec -> Core_kernel__.Import.int", "Bap_c_type.html#VALcompare_spec", "", []);
add_ocaml_element("bin_spec", "Bap_c_type.bin_spec", "value", "'a Bin_prot.Type_class.t ->\n  'b Bin_prot.Type_class.t ->\n  ('a, 'b) Bap_c_type.Spec.t Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_spec", "", []);
add_ocaml_element("bin_reader_spec", "Bap_c_type.bin_reader_spec", "value", "'a Bin_prot.Type_class.reader ->\n  'b Bin_prot.Type_class.reader ->\n  ('a, 'b) Bap_c_type.Spec.t Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_spec", "", []);
add_ocaml_element("bin_read_spec", "Bap_c_type.bin_read_spec", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  (Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'b) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> ('a, 'b) Bap_c_type.Spec.t", "Bap_c_type.html#VALbin_read_spec", "", []);
add_ocaml_element("__bin_read_spec__", "Bap_c_type.__bin_read_spec__", "value", "'a ->\n  'b ->\n  'c -> pos_ref:Bin_prot.Common.pos ref -> 'd -> 'e", "Bap_c_type.html#VAL__bin_read_spec__", "", []);
add_ocaml_element("bin_writer_spec", "Bap_c_type.bin_writer_spec", "value", "'a Bin_prot.Type_class.writer ->\n  'b Bin_prot.Type_class.writer ->\n  ('a, 'b) Bap_c_type.Spec.t Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_spec", "", []);
add_ocaml_element("bin_write_spec", "Bap_c_type.bin_write_spec", "value", "(Bin_prot.Common.buf -> pos:'a -> 'b -> 'c) ->\n  (Bin_prot.Common.buf -> pos:'c -> 'd -> Bin_prot.Common.pos) ->\n  Bin_prot.Common.buf ->\n  pos:'a -> ('b, 'd) Bap_c_type.Spec.t -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_spec", "", []);
add_ocaml_element("bin_size_spec", "Bap_c_type.bin_size_spec", "value", "('a -> int) -> ('b -> int) -> ('a, 'b) Bap_c_type.Spec.t -> int", "Bap_c_type.html#VALbin_size_spec", "", []);
add_ocaml_element("bin_shape_spec", "Bap_c_type.bin_shape_spec", "value", "Bin_prot.Shape.t ->\n  Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_spec", "", []);
add_ocaml_element("sexp_of_attr", "Bap_c_type.sexp_of_attr", "value", "Bap_c_type.attr -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_attr", "", []);
add_ocaml_element("attr_of_sexp", "Bap_c_type.attr_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.attr", "Bap_c_type.html#VALattr_of_sexp", "", []);
add_ocaml_element("compare_attr", "Bap_c_type.compare_attr", "value", "Bap_c_type.attr -> Bap_c_type.attr -> int", "Bap_c_type.html#VALcompare_attr", "", []);
add_ocaml_element("bin_attr", "Bap_c_type.bin_attr", "value", "Bap_c_type.Attr.t Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_attr", "", []);
add_ocaml_element("bin_reader_attr", "Bap_c_type.bin_reader_attr", "value", "Bap_c_type.Attr.t Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_attr", "", []);
add_ocaml_element("bin_read_attr", "Bap_c_type.bin_read_attr", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Bap_c_type.Attr.t", "Bap_c_type.html#VALbin_read_attr", "", []);
add_ocaml_element("__bin_read_attr__", "Bap_c_type.__bin_read_attr__", "value", "'a -> pos_ref:Bin_prot.Common.pos ref -> 'b -> 'c", "Bap_c_type.html#VAL__bin_read_attr__", "", []);
add_ocaml_element("bin_writer_attr", "Bap_c_type.bin_writer_attr", "value", "Bap_c_type.Attr.t Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_attr", "", []);
add_ocaml_element("bin_write_attr", "Bap_c_type.bin_write_attr", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> Bap_c_type.Attr.t -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_attr", "", []);
add_ocaml_element("bin_size_attr", "Bap_c_type.bin_size_attr", "value", "Bap_c_type.Attr.t -> int", "Bap_c_type.html#VALbin_size_attr", "", []);
add_ocaml_element("bin_shape_attr", "Bap_c_type.bin_shape_attr", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_attr", "", []);
add_ocaml_element("sexp_of_qualifier", "Bap_c_type.sexp_of_qualifier", "value", "'a.\n    ('a -> Ppx_sexp_conv_lib.Sexp.t) ->\n    'a Bap_c_type.qualifier -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_qualifier", "", []);
add_ocaml_element("qualifier_of_sexp", "Bap_c_type.qualifier_of_sexp", "value", "'a.\n    (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->\n    Ppx_sexp_conv_lib.Sexp.t -> 'a Bap_c_type.qualifier", "Bap_c_type.html#VALqualifier_of_sexp", "", []);
add_ocaml_element("compare_qualifier", "Bap_c_type.compare_qualifier", "value", "'a.\n    ('a -> 'a -> Core_kernel__.Import.int) ->\n    'a Bap_c_type.qualifier ->\n    'a Bap_c_type.qualifier -> Core_kernel__.Import.int", "Bap_c_type.html#VALcompare_qualifier", "", []);
add_ocaml_element("bin_qualifier", "Bap_c_type.bin_qualifier", "value", "'a Bin_prot.Type_class.t ->\n  'a Bap_c_type.Qualifier.t Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_qualifier", "", []);
add_ocaml_element("bin_reader_qualifier", "Bap_c_type.bin_reader_qualifier", "value", "'a Bin_prot.Type_class.reader ->\n  'a Bap_c_type.Qualifier.t Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_qualifier", "", []);
add_ocaml_element("bin_read_qualifier", "Bap_c_type.bin_read_qualifier", "value", "(Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> 'a) ->\n  Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> 'a Bap_c_type.Qualifier.t", "Bap_c_type.html#VALbin_read_qualifier", "", []);
add_ocaml_element("__bin_read_qualifier__", "Bap_c_type.__bin_read_qualifier__", "value", "'a ->\n  'b -> pos_ref:Bin_prot.Common.pos ref -> 'c -> 'd", "Bap_c_type.html#VAL__bin_read_qualifier__", "", []);
add_ocaml_element("bin_writer_qualifier", "Bap_c_type.bin_writer_qualifier", "value", "'a Bin_prot.Type_class.writer ->\n  'a Bap_c_type.Qualifier.t Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_qualifier", "", []);
add_ocaml_element("bin_write_qualifier", "Bap_c_type.bin_write_qualifier", "value", "(Bin_prot.Common.buf -> pos:Bin_prot.Common.pos -> 'a -> 'b) ->\n  Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> 'a Bap_c_type.Qualifier.t -> 'b", "Bap_c_type.html#VALbin_write_qualifier", "", []);
add_ocaml_element("bin_size_qualifier", "Bap_c_type.bin_size_qualifier", "value", "('a -> int) -> 'a Bap_c_type.Qualifier.t -> int", "Bap_c_type.html#VALbin_size_qualifier", "", []);
add_ocaml_element("bin_shape_qualifier", "Bap_c_type.bin_shape_qualifier", "value", "Bin_prot.Shape.t -> Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_qualifier", "", []);
add_ocaml_element("sexp_of_cvr", "Bap_c_type.sexp_of_cvr", "value", "Bap_c_type.cvr -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_cvr", "", []);
add_ocaml_element("cvr_of_sexp", "Bap_c_type.cvr_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.cvr", "Bap_c_type.html#VALcvr_of_sexp", "", []);
add_ocaml_element("compare_cvr", "Bap_c_type.compare_cvr", "value", "Bap_c_type.cvr -> Bap_c_type.cvr -> int", "Bap_c_type.html#VALcompare_cvr", "", []);
add_ocaml_element("bin_cvr", "Bap_c_type.bin_cvr", "value", "Bool.t Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_cvr", "", []);
add_ocaml_element("bin_reader_cvr", "Bap_c_type.bin_reader_cvr", "value", "Bool.t Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_cvr", "", []);
add_ocaml_element("bin_read_cvr", "Bap_c_type.bin_read_cvr", "value", "Bool.t Bin_prot.Read.reader", "Bap_c_type.html#VALbin_read_cvr", "", []);
add_ocaml_element("__bin_read_cvr__", "Bap_c_type.__bin_read_cvr__", "value", "(int -> Bool.t) Bin_prot.Read.reader", "Bap_c_type.html#VAL__bin_read_cvr__", "", []);
add_ocaml_element("bin_writer_cvr", "Bap_c_type.bin_writer_cvr", "value", "Bool.t Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_cvr", "", []);
add_ocaml_element("bin_write_cvr", "Bap_c_type.bin_write_cvr", "value", "Bool.t Bin_prot.Write.writer", "Bap_c_type.html#VALbin_write_cvr", "", []);
add_ocaml_element("bin_size_cvr", "Bap_c_type.bin_size_cvr", "value", "Bool.t Bin_prot.Size.sizer", "Bap_c_type.html#VALbin_size_cvr", "", []);
add_ocaml_element("bin_shape_cvr", "Bap_c_type.bin_shape_cvr", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_cvr", "", []);
add_ocaml_element("sexp_of_cv", "Bap_c_type.sexp_of_cv", "value", "Bap_c_type.cv -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_cv", "", []);
add_ocaml_element("cv_of_sexp", "Bap_c_type.cv_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.cv", "Bap_c_type.html#VALcv_of_sexp", "", []);
add_ocaml_element("compare_cv", "Bap_c_type.compare_cv", "value", "Bap_c_type.cv -> Bap_c_type.cv -> int", "Bap_c_type.html#VALcompare_cv", "", []);
add_ocaml_element("bin_cv", "Bap_c_type.bin_cv", "value", "Core_kernel__.Import.unit Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_cv", "", []);
add_ocaml_element("bin_reader_cv", "Bap_c_type.bin_reader_cv", "value", "Core_kernel__.Import.unit Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_cv", "", []);
add_ocaml_element("bin_read_cv", "Bap_c_type.bin_read_cv", "value", "Core_kernel__.Import.unit Bin_prot.Read.reader", "Bap_c_type.html#VALbin_read_cv", "", []);
add_ocaml_element("__bin_read_cv__", "Bap_c_type.__bin_read_cv__", "value", "(Core_kernel__.Import.int -> Core_kernel__.Import.unit) Bin_prot.Read.reader", "Bap_c_type.html#VAL__bin_read_cv__", "", []);
add_ocaml_element("bin_writer_cv", "Bap_c_type.bin_writer_cv", "value", "Core_kernel__.Import.unit Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_cv", "", []);
add_ocaml_element("bin_write_cv", "Bap_c_type.bin_write_cv", "value", "Core_kernel__.Import.unit Bin_prot.Write.writer", "Bap_c_type.html#VALbin_write_cv", "", []);
add_ocaml_element("bin_size_cv", "Bap_c_type.bin_size_cv", "value", "Core_kernel__.Import.unit Bin_prot.Size.sizer", "Bap_c_type.html#VALbin_size_cv", "", []);
add_ocaml_element("bin_shape_cv", "Bap_c_type.bin_shape_cv", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_cv", "", []);
add_ocaml_element("sexp_of_basic", "Bap_c_type.sexp_of_basic", "value", "Bap_c_type.basic -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_basic", "", []);
add_ocaml_element("basic_of_sexp", "Bap_c_type.basic_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.basic", "Bap_c_type.html#VALbasic_of_sexp", "", []);
add_ocaml_element("__basic_of_sexp__", "Bap_c_type.__basic_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.basic", "Bap_c_type.html#VAL__basic_of_sexp__", "", []);
add_ocaml_element("compare_basic", "Bap_c_type.compare_basic", "value", "Bap_c_type.basic -> Bap_c_type.basic -> int", "Bap_c_type.html#VALcompare_basic", "", []);
add_ocaml_element("bin_basic", "Bap_c_type.bin_basic", "value", "Bap_c_type.basic Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_basic", "", []);
add_ocaml_element("bin_reader_basic", "Bap_c_type.bin_reader_basic", "value", "Bap_c_type.basic Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_basic", "", []);
add_ocaml_element("bin_read_basic", "Bap_c_type.bin_read_basic", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Bap_c_type.basic", "Bap_c_type.html#VALbin_read_basic", "", []);
add_ocaml_element("__bin_read_basic__", "Bap_c_type.__bin_read_basic__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> int -> Bap_c_type.basic", "Bap_c_type.html#VAL__bin_read_basic__", "", []);
add_ocaml_element("bin_writer_basic", "Bap_c_type.bin_writer_basic", "value", "[< `cdouble\n   | `cfloat\n   | `char\n   | `clong_double\n   | `double\n   | `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list\n   | `float\n   | `long_double\n   | `schar\n   | `sint\n   | `slong\n   | `slong_long\n   | `sshort\n   | `uchar\n   | `uint\n   | `ulong\n   | `ulong_long\n   | `ushort ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_basic", "", []);
add_ocaml_element("bin_write_basic", "Bap_c_type.bin_write_basic", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `cdouble\n   | `cfloat\n   | `char\n   | `clong_double\n   | `double\n   | `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list\n   | `float\n   | `long_double\n   | `schar\n   | `sint\n   | `slong\n   | `slong_long\n   | `sshort\n   | `uchar\n   | `uint\n   | `ulong\n   | `ulong_long\n   | `ushort ] ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_basic", "", []);
add_ocaml_element("bin_size_basic", "Bap_c_type.bin_size_basic", "value", "[< `cdouble\n   | `cfloat\n   | `char\n   | `clong_double\n   | `double\n   | `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list\n   | `float\n   | `long_double\n   | `schar\n   | `sint\n   | `slong\n   | `slong_long\n   | `sshort\n   | `uchar\n   | `uint\n   | `ulong\n   | `ulong_long\n   | `ushort ] ->\n  int", "Bap_c_type.html#VALbin_size_basic", "", []);
add_ocaml_element("bin_shape_basic", "Bap_c_type.bin_shape_basic", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_basic", "", []);
add_ocaml_element("all_of_floating", "Bap_c_type.all_of_floating", "value", "Bap_c_type.floating list", "Bap_c_type.html#VALall_of_floating", "", []);
add_ocaml_element("sexp_of_floating", "Bap_c_type.sexp_of_floating", "value", "Bap_c_type.floating -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_floating", "", []);
add_ocaml_element("floating_of_sexp", "Bap_c_type.floating_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.floating", "Bap_c_type.html#VALfloating_of_sexp", "", []);
add_ocaml_element("__floating_of_sexp__", "Bap_c_type.__floating_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.floating", "Bap_c_type.html#VAL__floating_of_sexp__", "", []);
add_ocaml_element("compare_floating", "Bap_c_type.compare_floating", "value", "Bap_c_type.floating -> Bap_c_type.floating -> int", "Bap_c_type.html#VALcompare_floating", "", []);
add_ocaml_element("bin_floating", "Bap_c_type.bin_floating", "value", "Bap_c_type.floating Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_floating", "", []);
add_ocaml_element("bin_reader_floating", "Bap_c_type.bin_reader_floating", "value", "Bap_c_type.floating Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_floating", "", []);
add_ocaml_element("bin_read_floating", "Bap_c_type.bin_read_floating", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Bap_c_type.floating", "Bap_c_type.html#VALbin_read_floating", "", []);
add_ocaml_element("__bin_read_floating__", "Bap_c_type.__bin_read_floating__", "value", "'a -> pos_ref:'b -> int -> Bap_c_type.floating", "Bap_c_type.html#VAL__bin_read_floating__", "", []);
add_ocaml_element("bin_writer_floating", "Bap_c_type.bin_writer_floating", "value", "[< `cdouble | `cfloat | `clong_double | `double | `float | `long_double ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_floating", "", []);
add_ocaml_element("bin_write_floating", "Bap_c_type.bin_write_floating", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `cdouble | `cfloat | `clong_double | `double | `float | `long_double ] ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_floating", "", []);
add_ocaml_element("bin_size_floating", "Bap_c_type.bin_size_floating", "value", "[< `cdouble | `cfloat | `clong_double | `double | `float | `long_double ] ->\n  int", "Bap_c_type.html#VALbin_size_floating", "", []);
add_ocaml_element("bin_shape_floating", "Bap_c_type.bin_shape_floating", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_floating", "", []);
add_ocaml_element("all_of_complex", "Bap_c_type.all_of_complex", "value", "Bap_c_type.complex list", "Bap_c_type.html#VALall_of_complex", "", []);
add_ocaml_element("sexp_of_complex", "Bap_c_type.sexp_of_complex", "value", "Bap_c_type.complex -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_complex", "", []);
add_ocaml_element("complex_of_sexp", "Bap_c_type.complex_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.complex", "Bap_c_type.html#VALcomplex_of_sexp", "", []);
add_ocaml_element("__complex_of_sexp__", "Bap_c_type.__complex_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.complex", "Bap_c_type.html#VAL__complex_of_sexp__", "", []);
add_ocaml_element("compare_complex", "Bap_c_type.compare_complex", "value", "Bap_c_type.complex -> Bap_c_type.complex -> int", "Bap_c_type.html#VALcompare_complex", "", []);
add_ocaml_element("bin_complex", "Bap_c_type.bin_complex", "value", "[ `cdouble | `cfloat | `clong_double ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_complex", "", []);
add_ocaml_element("bin_reader_complex", "Bap_c_type.bin_reader_complex", "value", "[> `cdouble | `cfloat | `clong_double ]\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_complex", "", []);
add_ocaml_element("bin_read_complex", "Bap_c_type.bin_read_complex", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `cdouble | `cfloat | `clong_double ]", "Bap_c_type.html#VALbin_read_complex", "", []);
add_ocaml_element("__bin_read_complex__", "Bap_c_type.__bin_read_complex__", "value", "'a -> pos_ref:'b -> int -> [> `cdouble | `cfloat | `clong_double ]", "Bap_c_type.html#VAL__bin_read_complex__", "", []);
add_ocaml_element("bin_writer_complex", "Bap_c_type.bin_writer_complex", "value", "[< `cdouble | `cfloat | `clong_double ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_complex", "", []);
add_ocaml_element("bin_write_complex", "Bap_c_type.bin_write_complex", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `cdouble | `cfloat | `clong_double ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_complex", "", []);
add_ocaml_element("bin_size_complex", "Bap_c_type.bin_size_complex", "value", "'a -> int", "Bap_c_type.html#VALbin_size_complex", "", []);
add_ocaml_element("bin_shape_complex", "Bap_c_type.bin_shape_complex", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_complex", "", []);
add_ocaml_element("all_of_real", "Bap_c_type.all_of_real", "value", "Bap_c_type.real list", "Bap_c_type.html#VALall_of_real", "", []);
add_ocaml_element("sexp_of_real", "Bap_c_type.sexp_of_real", "value", "Bap_c_type.real -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_real", "", []);
add_ocaml_element("real_of_sexp", "Bap_c_type.real_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.real", "Bap_c_type.html#VALreal_of_sexp", "", []);
add_ocaml_element("__real_of_sexp__", "Bap_c_type.__real_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.real", "Bap_c_type.html#VAL__real_of_sexp__", "", []);
add_ocaml_element("compare_real", "Bap_c_type.compare_real", "value", "Bap_c_type.real -> Bap_c_type.real -> int", "Bap_c_type.html#VALcompare_real", "", []);
add_ocaml_element("bin_real", "Bap_c_type.bin_real", "value", "[ `double | `float | `long_double ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_real", "", []);
add_ocaml_element("bin_reader_real", "Bap_c_type.bin_reader_real", "value", "[> `double | `float | `long_double ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_real", "", []);
add_ocaml_element("bin_read_real", "Bap_c_type.bin_read_real", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `double | `float | `long_double ]", "Bap_c_type.html#VALbin_read_real", "", []);
add_ocaml_element("__bin_read_real__", "Bap_c_type.__bin_read_real__", "value", "'a -> pos_ref:'b -> int -> [> `double | `float | `long_double ]", "Bap_c_type.html#VAL__bin_read_real__", "", []);
add_ocaml_element("bin_writer_real", "Bap_c_type.bin_writer_real", "value", "[< `double | `float | `long_double ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_real", "", []);
add_ocaml_element("bin_write_real", "Bap_c_type.bin_write_real", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `double | `float | `long_double ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_real", "", []);
add_ocaml_element("bin_size_real", "Bap_c_type.bin_size_real", "value", "'a -> int", "Bap_c_type.html#VALbin_size_real", "", []);
add_ocaml_element("bin_shape_real", "Bap_c_type.bin_shape_real", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_real", "", []);
add_ocaml_element("sexp_of_integer", "Bap_c_type.sexp_of_integer", "value", "Bap_c_type.integer -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_integer", "", []);
add_ocaml_element("integer_of_sexp", "Bap_c_type.integer_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.integer", "Bap_c_type.html#VALinteger_of_sexp", "", []);
add_ocaml_element("__integer_of_sexp__", "Bap_c_type.__integer_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.integer", "Bap_c_type.html#VAL__integer_of_sexp__", "", []);
add_ocaml_element("compare_integer", "Bap_c_type.compare_integer", "value", "Bap_c_type.integer -> Bap_c_type.integer -> int", "Bap_c_type.html#VALcompare_integer", "", []);
add_ocaml_element("bin_integer", "Bap_c_type.bin_integer", "value", "Bap_c_type.integer Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_integer", "", []);
add_ocaml_element("bin_reader_integer", "Bap_c_type.bin_reader_integer", "value", "Bap_c_type.integer Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_integer", "", []);
add_ocaml_element("bin_read_integer", "Bap_c_type.bin_read_integer", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Bap_c_type.integer", "Bap_c_type.html#VALbin_read_integer", "", []);
add_ocaml_element("__bin_read_integer__", "Bap_c_type.__bin_read_integer__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> int -> Bap_c_type.integer", "Bap_c_type.html#VAL__bin_read_integer__", "", []);
add_ocaml_element("bin_writer_integer", "Bap_c_type.bin_writer_integer", "value", "[< `char\n   | `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list\n   | `schar\n   | `sint\n   | `slong\n   | `slong_long\n   | `sshort\n   | `uchar\n   | `uint\n   | `ulong\n   | `ulong_long\n   | `ushort ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_integer", "", []);
add_ocaml_element("bin_write_integer", "Bap_c_type.bin_write_integer", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `char\n   | `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list\n   | `schar\n   | `sint\n   | `slong\n   | `slong_long\n   | `sshort\n   | `uchar\n   | `uint\n   | `ulong\n   | `ulong_long\n   | `ushort ] ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_integer", "", []);
add_ocaml_element("bin_size_integer", "Bap_c_type.bin_size_integer", "value", "[< `char\n   | `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list\n   | `schar\n   | `sint\n   | `slong\n   | `slong_long\n   | `sshort\n   | `uchar\n   | `uint\n   | `ulong\n   | `ulong_long\n   | `ushort ] ->\n  int", "Bap_c_type.html#VALbin_size_integer", "", []);
add_ocaml_element("bin_shape_integer", "Bap_c_type.bin_shape_integer", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_integer", "", []);
add_ocaml_element("sexp_of_enum", "Bap_c_type.sexp_of_enum", "value", "Bap_c_type.enum -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_enum", "", []);
add_ocaml_element("enum_of_sexp", "Bap_c_type.enum_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.enum", "Bap_c_type.html#VALenum_of_sexp", "", []);
add_ocaml_element("__enum_of_sexp__", "Bap_c_type.__enum_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.enum", "Bap_c_type.html#VAL__enum_of_sexp__", "", []);
add_ocaml_element("compare_enum", "Bap_c_type.compare_enum", "value", "Bap_c_type.enum -> Bap_c_type.enum -> int", "Bap_c_type.html#VALcompare_enum", "", []);
add_ocaml_element("bin_enum", "Bap_c_type.bin_enum", "value", "[ `enum of\n      (Core_kernel__.Import.string *\n       Core_kernel__.Import.int64 Core_kernel__.Import.option)\n      Core_kernel__.Import.list ]\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_enum", "", []);
add_ocaml_element("bin_reader_enum", "Bap_c_type.bin_reader_enum", "value", "[> `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list ]\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_enum", "", []);
add_ocaml_element("bin_read_enum", "Bap_c_type.bin_read_enum", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list ]", "Bap_c_type.html#VALbin_read_enum", "", []);
add_ocaml_element("__bin_read_enum__", "Bap_c_type.__bin_read_enum__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  int ->\n  [> `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list ]", "Bap_c_type.html#VAL__bin_read_enum__", "", []);
add_ocaml_element("bin_writer_enum", "Bap_c_type.bin_writer_enum", "value", "[< `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_enum", "", []);
add_ocaml_element("bin_write_enum", "Bap_c_type.bin_write_enum", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list ] ->\n  Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_enum", "", []);
add_ocaml_element("bin_size_enum", "Bap_c_type.bin_size_enum", "value", "[< `enum of\n       (Core_kernel__.Import.string *\n        Core_kernel__.Import.int64 Core_kernel__.Import.option)\n       Core_kernel__.Import.list ] ->\n  int", "Bap_c_type.html#VALbin_size_enum", "", []);
add_ocaml_element("bin_shape_enum", "Bap_c_type.bin_shape_enum", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_enum", "", []);
add_ocaml_element("all_of_unsigned", "Bap_c_type.all_of_unsigned", "value", "Bap_c_type.unsigned list", "Bap_c_type.html#VALall_of_unsigned", "", []);
add_ocaml_element("sexp_of_unsigned", "Bap_c_type.sexp_of_unsigned", "value", "Bap_c_type.unsigned -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_unsigned", "", []);
add_ocaml_element("unsigned_of_sexp", "Bap_c_type.unsigned_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.unsigned", "Bap_c_type.html#VALunsigned_of_sexp", "", []);
add_ocaml_element("__unsigned_of_sexp__", "Bap_c_type.__unsigned_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.unsigned", "Bap_c_type.html#VAL__unsigned_of_sexp__", "", []);
add_ocaml_element("compare_unsigned", "Bap_c_type.compare_unsigned", "value", "Bap_c_type.unsigned -> Bap_c_type.unsigned -> int", "Bap_c_type.html#VALcompare_unsigned", "", []);
add_ocaml_element("bin_unsigned", "Bap_c_type.bin_unsigned", "value", "[ `uchar | `uint | `ulong | `ulong_long | `ushort ]\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_unsigned", "", []);
add_ocaml_element("bin_reader_unsigned", "Bap_c_type.bin_reader_unsigned", "value", "[> `uchar | `uint | `ulong | `ulong_long | `ushort ]\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_unsigned", "", []);
add_ocaml_element("bin_read_unsigned", "Bap_c_type.bin_read_unsigned", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `uchar | `uint | `ulong | `ulong_long | `ushort ]", "Bap_c_type.html#VALbin_read_unsigned", "", []);
add_ocaml_element("__bin_read_unsigned__", "Bap_c_type.__bin_read_unsigned__", "value", "'a ->\n  pos_ref:'b -> int -> [> `uchar | `uint | `ulong | `ulong_long | `ushort ]", "Bap_c_type.html#VAL__bin_read_unsigned__", "", []);
add_ocaml_element("bin_writer_unsigned", "Bap_c_type.bin_writer_unsigned", "value", "[< `uchar | `uint | `ulong | `ulong_long | `ushort ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_unsigned", "", []);
add_ocaml_element("bin_write_unsigned", "Bap_c_type.bin_write_unsigned", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `uchar | `uint | `ulong | `ulong_long | `ushort ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_unsigned", "", []);
add_ocaml_element("bin_size_unsigned", "Bap_c_type.bin_size_unsigned", "value", "'a -> int", "Bap_c_type.html#VALbin_size_unsigned", "", []);
add_ocaml_element("bin_shape_unsigned", "Bap_c_type.bin_shape_unsigned", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_unsigned", "", []);
add_ocaml_element("all_of_signed", "Bap_c_type.all_of_signed", "value", "Bap_c_type.signed list", "Bap_c_type.html#VALall_of_signed", "", []);
add_ocaml_element("sexp_of_signed", "Bap_c_type.sexp_of_signed", "value", "Bap_c_type.signed -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_signed", "", []);
add_ocaml_element("signed_of_sexp", "Bap_c_type.signed_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.signed", "Bap_c_type.html#VALsigned_of_sexp", "", []);
add_ocaml_element("__signed_of_sexp__", "Bap_c_type.__signed_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.signed", "Bap_c_type.html#VAL__signed_of_sexp__", "", []);
add_ocaml_element("compare_signed", "Bap_c_type.compare_signed", "value", "Bap_c_type.signed -> Bap_c_type.signed -> int", "Bap_c_type.html#VALcompare_signed", "", []);
add_ocaml_element("bin_signed", "Bap_c_type.bin_signed", "value", "[ `schar | `sint | `slong | `slong_long | `sshort ]\n  Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_signed", "", []);
add_ocaml_element("bin_reader_signed", "Bap_c_type.bin_reader_signed", "value", "[> `schar | `sint | `slong | `slong_long | `sshort ]\n  Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_signed", "", []);
add_ocaml_element("bin_read_signed", "Bap_c_type.bin_read_signed", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `schar | `sint | `slong | `slong_long | `sshort ]", "Bap_c_type.html#VALbin_read_signed", "", []);
add_ocaml_element("__bin_read_signed__", "Bap_c_type.__bin_read_signed__", "value", "'a ->\n  pos_ref:'b -> int -> [> `schar | `sint | `slong | `slong_long | `sshort ]", "Bap_c_type.html#VAL__bin_read_signed__", "", []);
add_ocaml_element("bin_writer_signed", "Bap_c_type.bin_writer_signed", "value", "[< `schar | `sint | `slong | `slong_long | `sshort ]\n  Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_signed", "", []);
add_ocaml_element("bin_write_signed", "Bap_c_type.bin_write_signed", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `schar | `sint | `slong | `slong_long | `sshort ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_signed", "", []);
add_ocaml_element("bin_size_signed", "Bap_c_type.bin_size_signed", "value", "'a -> int", "Bap_c_type.html#VALbin_size_signed", "", []);
add_ocaml_element("bin_shape_signed", "Bap_c_type.bin_shape_signed", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_signed", "", []);
add_ocaml_element("all_of_long_long", "Bap_c_type.all_of_long_long", "value", "Bap_c_type.long_long list", "Bap_c_type.html#VALall_of_long_long", "", []);
add_ocaml_element("sexp_of_long_long", "Bap_c_type.sexp_of_long_long", "value", "Bap_c_type.long_long -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_long_long", "", []);
add_ocaml_element("long_long_of_sexp", "Bap_c_type.long_long_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.long_long", "Bap_c_type.html#VALlong_long_of_sexp", "", []);
add_ocaml_element("__long_long_of_sexp__", "Bap_c_type.__long_long_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.long_long", "Bap_c_type.html#VAL__long_long_of_sexp__", "", []);
add_ocaml_element("compare_long_long", "Bap_c_type.compare_long_long", "value", "Bap_c_type.long_long -> Bap_c_type.long_long -> int", "Bap_c_type.html#VALcompare_long_long", "", []);
add_ocaml_element("bin_long_long", "Bap_c_type.bin_long_long", "value", "[ `slong_long | `ulong_long ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_long_long", "", []);
add_ocaml_element("bin_reader_long_long", "Bap_c_type.bin_reader_long_long", "value", "[> `slong_long | `ulong_long ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_long_long", "", []);
add_ocaml_element("bin_read_long_long", "Bap_c_type.bin_read_long_long", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `slong_long | `ulong_long ]", "Bap_c_type.html#VALbin_read_long_long", "", []);
add_ocaml_element("__bin_read_long_long__", "Bap_c_type.__bin_read_long_long__", "value", "'a -> pos_ref:'b -> int -> [> `slong_long | `ulong_long ]", "Bap_c_type.html#VAL__bin_read_long_long__", "", []);
add_ocaml_element("bin_writer_long_long", "Bap_c_type.bin_writer_long_long", "value", "[< `slong_long | `ulong_long ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_long_long", "", []);
add_ocaml_element("bin_write_long_long", "Bap_c_type.bin_write_long_long", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `slong_long | `ulong_long ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_long_long", "", []);
add_ocaml_element("bin_size_long_long", "Bap_c_type.bin_size_long_long", "value", "'a -> int", "Bap_c_type.html#VALbin_size_long_long", "", []);
add_ocaml_element("bin_shape_long_long", "Bap_c_type.bin_shape_long_long", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_long_long", "", []);
add_ocaml_element("all_of_long", "Bap_c_type.all_of_long", "value", "Bap_c_type.long list", "Bap_c_type.html#VALall_of_long", "", []);
add_ocaml_element("sexp_of_long", "Bap_c_type.sexp_of_long", "value", "Bap_c_type.long -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_long", "", []);
add_ocaml_element("long_of_sexp", "Bap_c_type.long_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.long", "Bap_c_type.html#VALlong_of_sexp", "", []);
add_ocaml_element("__long_of_sexp__", "Bap_c_type.__long_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.long", "Bap_c_type.html#VAL__long_of_sexp__", "", []);
add_ocaml_element("compare_long", "Bap_c_type.compare_long", "value", "Bap_c_type.long -> Bap_c_type.long -> int", "Bap_c_type.html#VALcompare_long", "", []);
add_ocaml_element("bin_long", "Bap_c_type.bin_long", "value", "[ `slong | `ulong ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_long", "", []);
add_ocaml_element("bin_reader_long", "Bap_c_type.bin_reader_long", "value", "[> `slong | `ulong ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_long", "", []);
add_ocaml_element("bin_read_long", "Bap_c_type.bin_read_long", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `slong | `ulong ]", "Bap_c_type.html#VALbin_read_long", "", []);
add_ocaml_element("__bin_read_long__", "Bap_c_type.__bin_read_long__", "value", "'a -> pos_ref:'b -> int -> [> `slong | `ulong ]", "Bap_c_type.html#VAL__bin_read_long__", "", []);
add_ocaml_element("bin_writer_long", "Bap_c_type.bin_writer_long", "value", "[< `slong | `ulong ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_long", "", []);
add_ocaml_element("bin_write_long", "Bap_c_type.bin_write_long", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> [< `slong | `ulong ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_long", "", []);
add_ocaml_element("bin_size_long", "Bap_c_type.bin_size_long", "value", "'a -> int", "Bap_c_type.html#VALbin_size_long", "", []);
add_ocaml_element("bin_shape_long", "Bap_c_type.bin_shape_long", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_long", "", []);
add_ocaml_element("all_of_cint", "Bap_c_type.all_of_cint", "value", "Bap_c_type.cint list", "Bap_c_type.html#VALall_of_cint", "", []);
add_ocaml_element("sexp_of_cint", "Bap_c_type.sexp_of_cint", "value", "Bap_c_type.cint -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_cint", "", []);
add_ocaml_element("cint_of_sexp", "Bap_c_type.cint_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.cint", "Bap_c_type.html#VALcint_of_sexp", "", []);
add_ocaml_element("__cint_of_sexp__", "Bap_c_type.__cint_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.cint", "Bap_c_type.html#VAL__cint_of_sexp__", "", []);
add_ocaml_element("compare_cint", "Bap_c_type.compare_cint", "value", "Bap_c_type.cint -> Bap_c_type.cint -> int", "Bap_c_type.html#VALcompare_cint", "", []);
add_ocaml_element("bin_cint", "Bap_c_type.bin_cint", "value", "[ `sint | `uint ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_cint", "", []);
add_ocaml_element("bin_reader_cint", "Bap_c_type.bin_reader_cint", "value", "[> `sint | `uint ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_cint", "", []);
add_ocaml_element("bin_read_cint", "Bap_c_type.bin_read_cint", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> [> `sint | `uint ]", "Bap_c_type.html#VALbin_read_cint", "", []);
add_ocaml_element("__bin_read_cint__", "Bap_c_type.__bin_read_cint__", "value", "'a -> pos_ref:'b -> int -> [> `sint | `uint ]", "Bap_c_type.html#VAL__bin_read_cint__", "", []);
add_ocaml_element("bin_writer_cint", "Bap_c_type.bin_writer_cint", "value", "[< `sint | `uint ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_cint", "", []);
add_ocaml_element("bin_write_cint", "Bap_c_type.bin_write_cint", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> [< `sint | `uint ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_cint", "", []);
add_ocaml_element("bin_size_cint", "Bap_c_type.bin_size_cint", "value", "'a -> int", "Bap_c_type.html#VALbin_size_cint", "", []);
add_ocaml_element("bin_shape_cint", "Bap_c_type.bin_shape_cint", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_cint", "", []);
add_ocaml_element("all_of_short", "Bap_c_type.all_of_short", "value", "Bap_c_type.short list", "Bap_c_type.html#VALall_of_short", "", []);
add_ocaml_element("sexp_of_short", "Bap_c_type.sexp_of_short", "value", "Bap_c_type.short -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_short", "", []);
add_ocaml_element("short_of_sexp", "Bap_c_type.short_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.short", "Bap_c_type.html#VALshort_of_sexp", "", []);
add_ocaml_element("__short_of_sexp__", "Bap_c_type.__short_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.short", "Bap_c_type.html#VAL__short_of_sexp__", "", []);
add_ocaml_element("compare_short", "Bap_c_type.compare_short", "value", "Bap_c_type.short -> Bap_c_type.short -> int", "Bap_c_type.html#VALcompare_short", "", []);
add_ocaml_element("bin_short", "Bap_c_type.bin_short", "value", "[ `sshort | `ushort ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_short", "", []);
add_ocaml_element("bin_reader_short", "Bap_c_type.bin_reader_short", "value", "[> `sshort | `ushort ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_short", "", []);
add_ocaml_element("bin_read_short", "Bap_c_type.bin_read_short", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `sshort | `ushort ]", "Bap_c_type.html#VALbin_read_short", "", []);
add_ocaml_element("__bin_read_short__", "Bap_c_type.__bin_read_short__", "value", "'a -> pos_ref:'b -> int -> [> `sshort | `ushort ]", "Bap_c_type.html#VAL__bin_read_short__", "", []);
add_ocaml_element("bin_writer_short", "Bap_c_type.bin_writer_short", "value", "[< `sshort | `ushort ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_short", "", []);
add_ocaml_element("bin_write_short", "Bap_c_type.bin_write_short", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> [< `sshort | `ushort ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_short", "", []);
add_ocaml_element("bin_size_short", "Bap_c_type.bin_size_short", "value", "'a -> int", "Bap_c_type.html#VALbin_size_short", "", []);
add_ocaml_element("bin_shape_short", "Bap_c_type.bin_shape_short", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_short", "", []);
add_ocaml_element("all_of_char", "Bap_c_type.all_of_char", "value", "Bap_c_type.char list", "Bap_c_type.html#VALall_of_char", "", []);
add_ocaml_element("sexp_of_char", "Bap_c_type.sexp_of_char", "value", "Bap_c_type.char -> Ppx_sexp_conv_lib.Sexp.t", "Bap_c_type.html#VALsexp_of_char", "", []);
add_ocaml_element("char_of_sexp", "Bap_c_type.char_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.char", "Bap_c_type.html#VALchar_of_sexp", "", []);
add_ocaml_element("__char_of_sexp__", "Bap_c_type.__char_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Bap_c_type.char", "Bap_c_type.html#VAL__char_of_sexp__", "", []);
add_ocaml_element("compare_char", "Bap_c_type.compare_char", "value", "Bap_c_type.char -> Bap_c_type.char -> int", "Bap_c_type.html#VALcompare_char", "", []);
add_ocaml_element("bin_char", "Bap_c_type.bin_char", "value", "[ `char | `schar | `uchar ] Bin_prot.Type_class.t", "Bap_c_type.html#VALbin_char", "", []);
add_ocaml_element("bin_reader_char", "Bap_c_type.bin_reader_char", "value", "[> `char | `schar | `uchar ] Bin_prot.Type_class.reader", "Bap_c_type.html#VALbin_reader_char", "", []);
add_ocaml_element("bin_read_char", "Bap_c_type.bin_read_char", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `char | `schar | `uchar ]", "Bap_c_type.html#VALbin_read_char", "", []);
add_ocaml_element("__bin_read_char__", "Bap_c_type.__bin_read_char__", "value", "'a -> pos_ref:'b -> int -> [> `char | `schar | `uchar ]", "Bap_c_type.html#VAL__bin_read_char__", "", []);
add_ocaml_element("bin_writer_char", "Bap_c_type.bin_writer_char", "value", "[< `char | `schar | `uchar ] Bin_prot.Type_class.writer", "Bap_c_type.html#VALbin_writer_char", "", []);
add_ocaml_element("bin_write_char", "Bap_c_type.bin_write_char", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `char | `schar | `uchar ] -> Bin_prot.Common.pos", "Bap_c_type.html#VALbin_write_char", "", []);
add_ocaml_element("bin_size_char", "Bap_c_type.bin_size_char", "value", "'a -> int", "Bap_c_type.html#VALbin_size_char", "", []);
add_ocaml_element("bin_shape_char", "Bap_c_type.bin_shape_char", "value", "Bin_prot.Shape.t", "Bap_c_type.html#VALbin_shape_char", "", []);
add_ocaml_element("name", "Bap_abi.name", "value", "string Std.tag", "Bap_abi.html#VALname", "", []);
add_ocaml_element("register_pass", "Bap_abi.register_pass", "value", "(Std.project -> Std.project) -> unit", "Bap_abi.html#VALregister_pass", "<div class=\"info\">\n<p><code class=\"code\">register_pass&nbsp;pass</code> registers a pass for the later execution.</p>\n\n</div>\n", ["ACTIONS", "AND", "API", "APPLY", "DEMANGLING", "EXECUTION", "FOR", "FURTHER", "INSPECT", "JUST", "LATER", "MAY", "NOT", "OTHERWISE", "PASS", "PROJECT", "RECOGNIZED", "REGISTER", "REGISTERS", "REGISTER_PASS", "RETURN", "RUN", "SOME", "STRUCTURE", "SYSTEM", "THE", "THEN", "TRANSFORMATIONS", "UNTOUCHED", "USUALLY", "WILL"]);
add_ocaml_element("pass", "Bap_abi.pass", "value", "Std.project -> Std.project", "Bap_abi.html#VALpass", "<div class=\"info\">\n<p><code class=\"code\">pass</code> will apply all registered passes in the unspecified order</p>\n\n</div>\n", ["ALL", "APPLY", "ORDER", "PASS", "PASSES", "REGISTERED", "THE", "UNSPECIFIED", "WILL"]);
add_ocaml_element("mapper", "Bap_api.S.mapper", "value", "Bap_api.S.t -> Std.Term.mapper", "Bap_api.S.html#VALmapper", "<div class=\"info\">\n<p>the processor itself</p>\n\n</div>\n", ["ITSELF", "PROCESSOR", "THE"]);
add_ocaml_element("parse", "Bap_api.S.parse", "value", "(Bap_api.api -> Bap_api.filename option) ->\n  Bap_api.api list -> Bap_api.S.t Or_error.t", "Bap_api.S.html#VALparse", "<div class=\"info\">\n<p><code class=\"code\">parse&nbsp;get_api&nbsp;apis</code> creates a language processor from a list of\n      api.</p>\n\n</div>\n", ["API", "APIS", "CORRESPONDS", "CREATES", "EXISTING", "FILE", "FROM", "FUNCTION", "GET_API", "GIVEN", "LANGUAGE", "LIST", "MUST", "NAME", "NAMES", "PARAMETER", "PARSE", "PROCESSOR", "RETURN", "THAT", "THE"]);
add_ocaml_element("language", "Bap_api.S.language", "value", "string", "Bap_api.S.html#VALlanguage", "<div class=\"info\">\n<p><code class=\"code\">language</code> a name of a language, e.g., <code class=\"code\"><span class=\"string\">\"C\"</span></code></p>\n\n</div>\n", ["LANGUAGE", "NAME"]);
add_ocaml_element("processors", "Bap_api.processors", "value", "unit -> Bap_api.t list", "Bap_api.html#VALprocessors", "<div class=\"info\">\n<p>enumerate all registered language processors</p>\n\n</div>\n", ["ALL", "ENUMERATE", "LANGUAGE", "PROCESSORS", "REGISTERED"]);
add_ocaml_element("process", "Bap_api.process", "value", "Bap_api.t -> unit", "Bap_api.html#VALprocess", "<div class=\"info\">\n<p>apply the language processor</p>\n\n</div>\n", ["APPLY", "LANGUAGE", "PROCESSOR", "THE"]);
add_ocaml_element("sexp_of_t", "X86_asm_reg_types.sexp_of_t", "value", "X86_asm_reg_types.t -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_t", "", []);
add_ocaml_element("t_of_sexp", "X86_asm_reg_types.t_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.t", "X86_asm_reg_types.html#VALt_of_sexp", "", []);
add_ocaml_element("__t_of_sexp__", "X86_asm_reg_types.__t_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.t", "X86_asm_reg_types.html#VAL__t_of_sexp__", "", []);
add_ocaml_element("sexp_of_gpr", "X86_asm_reg_types.sexp_of_gpr", "value", "X86_asm_reg_types.gpr -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_gpr", "", []);
add_ocaml_element("gpr_of_sexp", "X86_asm_reg_types.gpr_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.gpr", "X86_asm_reg_types.html#VALgpr_of_sexp", "", []);
add_ocaml_element("__gpr_of_sexp__", "X86_asm_reg_types.__gpr_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.gpr", "X86_asm_reg_types.html#VAL__gpr_of_sexp__", "", []);
add_ocaml_element("sexp_of_segment_base", "X86_asm_reg_types.sexp_of_segment_base", "value", "X86_asm_reg_types.segment_base -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_segment_base", "", []);
add_ocaml_element("segment_base_of_sexp", "X86_asm_reg_types.segment_base_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.segment_base", "X86_asm_reg_types.html#VALsegment_base_of_sexp", "", []);
add_ocaml_element("__segment_base_of_sexp__", "X86_asm_reg_types.__segment_base_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.segment_base", "X86_asm_reg_types.html#VAL__segment_base_of_sexp__", "", []);
add_ocaml_element("sexp_of_segment", "X86_asm_reg_types.sexp_of_segment", "value", "X86_asm_reg_types.segment -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_segment", "", []);
add_ocaml_element("segment_of_sexp", "X86_asm_reg_types.segment_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.segment", "X86_asm_reg_types.html#VALsegment_of_sexp", "", []);
add_ocaml_element("__segment_of_sexp__", "X86_asm_reg_types.__segment_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.segment", "X86_asm_reg_types.html#VAL__segment_of_sexp__", "", []);
add_ocaml_element("sexp_of_ip", "X86_asm_reg_types.sexp_of_ip", "value", "X86_asm_reg_types.ip -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_ip", "", []);
add_ocaml_element("ip_of_sexp", "X86_asm_reg_types.ip_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.ip", "X86_asm_reg_types.html#VALip_of_sexp", "", []);
add_ocaml_element("__ip_of_sexp__", "X86_asm_reg_types.__ip_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.ip", "X86_asm_reg_types.html#VAL__ip_of_sexp__", "", []);
add_ocaml_element("sexp_of_r256", "X86_asm_reg_types.sexp_of_r256", "value", "X86_asm_reg_types.r256 -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r256", "", []);
add_ocaml_element("r256_of_sexp", "X86_asm_reg_types.r256_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r256", "X86_asm_reg_types.html#VALr256_of_sexp", "", []);
add_ocaml_element("__r256_of_sexp__", "X86_asm_reg_types.__r256_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r256", "X86_asm_reg_types.html#VAL__r256_of_sexp__", "", []);
add_ocaml_element("sexp_of_r128", "X86_asm_reg_types.sexp_of_r128", "value", "X86_asm_reg_types.r128 -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r128", "", []);
add_ocaml_element("r128_of_sexp", "X86_asm_reg_types.r128_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r128", "X86_asm_reg_types.html#VALr128_of_sexp", "", []);
add_ocaml_element("__r128_of_sexp__", "X86_asm_reg_types.__r128_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r128", "X86_asm_reg_types.html#VAL__r128_of_sexp__", "", []);
add_ocaml_element("sexp_of_r64", "X86_asm_reg_types.sexp_of_r64", "value", "X86_asm_reg_types.r64 -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r64", "", []);
add_ocaml_element("r64_of_sexp", "X86_asm_reg_types.r64_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r64", "X86_asm_reg_types.html#VALr64_of_sexp", "", []);
add_ocaml_element("__r64_of_sexp__", "X86_asm_reg_types.__r64_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r64", "X86_asm_reg_types.html#VAL__r64_of_sexp__", "", []);
add_ocaml_element("sexp_of_r32", "X86_asm_reg_types.sexp_of_r32", "value", "X86_asm_reg_types.r32 -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r32", "", []);
add_ocaml_element("r32_of_sexp", "X86_asm_reg_types.r32_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r32", "X86_asm_reg_types.html#VALr32_of_sexp", "", []);
add_ocaml_element("__r32_of_sexp__", "X86_asm_reg_types.__r32_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r32", "X86_asm_reg_types.html#VAL__r32_of_sexp__", "", []);
add_ocaml_element("sexp_of_r16", "X86_asm_reg_types.sexp_of_r16", "value", "X86_asm_reg_types.r16 -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r16", "", []);
add_ocaml_element("r16_of_sexp", "X86_asm_reg_types.r16_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r16", "X86_asm_reg_types.html#VALr16_of_sexp", "", []);
add_ocaml_element("__r16_of_sexp__", "X86_asm_reg_types.__r16_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r16", "X86_asm_reg_types.html#VAL__r16_of_sexp__", "", []);
add_ocaml_element("sexp_of_r8", "X86_asm_reg_types.sexp_of_r8", "value", "X86_asm_reg_types.r8 -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r8", "", []);
add_ocaml_element("r8_of_sexp", "X86_asm_reg_types.r8_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r8", "X86_asm_reg_types.html#VALr8_of_sexp", "", []);
add_ocaml_element("__r8_of_sexp__", "X86_asm_reg_types.__r8_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r8", "X86_asm_reg_types.html#VAL__r8_of_sexp__", "", []);
add_ocaml_element("sexp_of_r8h", "X86_asm_reg_types.sexp_of_r8h", "value", "X86_asm_reg_types.r8h -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r8h", "", []);
add_ocaml_element("r8h_of_sexp", "X86_asm_reg_types.r8h_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r8h", "X86_asm_reg_types.html#VALr8h_of_sexp", "", []);
add_ocaml_element("__r8h_of_sexp__", "X86_asm_reg_types.__r8h_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r8h", "X86_asm_reg_types.html#VAL__r8h_of_sexp__", "", []);
add_ocaml_element("sexp_of_r8l", "X86_asm_reg_types.sexp_of_r8l", "value", "X86_asm_reg_types.r8l -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm_reg_types.html#VALsexp_of_r8l", "", []);
add_ocaml_element("r8l_of_sexp", "X86_asm_reg_types.r8l_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r8l", "X86_asm_reg_types.html#VALr8l_of_sexp", "", []);
add_ocaml_element("__r8l_of_sexp__", "X86_asm_reg_types.__r8l_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm_reg_types.r8l", "X86_asm_reg_types.html#VAL__r8l_of_sexp__", "", []);
add_ocaml_element("r", "X86_cpu.AMD64.r", "value", "Std.var array", "X86_cpu.AMD64.html#VALr", "<div class=\"info\">\n<p>r8-r15 registers.</p>\n\n</div>\n", ["DUE", "ISSUES", "LEGACY", "R15", "REGISTERS"]);
add_ocaml_element("ymms", "X86_cpu.IA32.ymms", "value", "Std.var array", "X86_cpu.IA32.html#VALymms", "<div class=\"info\">\n<p>YMM registers that are available</p>\n\n</div>\n", ["ARE", "AVAILABLE", "REGISTERS", "THAT", "YMM"]);
add_ocaml_element("rdx", "X86_cpu.IA32.rdx", "value", "Std.var", "X86_cpu.IA32.html#VALrdx", "<div class=\"info\">\n<p>data register</p>\n\n</div>\n", ["DATA", "REGISTER"]);
add_ocaml_element("rcx", "X86_cpu.IA32.rcx", "value", "Std.var", "X86_cpu.IA32.html#VALrcx", "<div class=\"info\">\n<p>counter register</p>\n\n</div>\n", ["COUNTER", "REGISTER"]);
add_ocaml_element("rbx", "X86_cpu.IA32.rbx", "value", "Std.var", "X86_cpu.IA32.html#VALrbx", "<div class=\"info\">\n<p>base register</p>\n\n</div>\n", ["BASE", "REGISTER"]);
add_ocaml_element("rax", "X86_cpu.IA32.rax", "value", "Std.var", "X86_cpu.IA32.html#VALrax", "<div class=\"info\">\n<p>accumulator register</p>\n\n</div>\n", ["ACCUMULATOR", "REGISTER"]);
add_ocaml_element("rip", "X86_cpu.IA32.rip", "value", "Std.var", "X86_cpu.IA32.html#VALrip", "<div class=\"info\">\n<p>instruction pointer</p>\n\n</div>\n", ["INSTRUCTION", "POINTER"]);
add_ocaml_element("rdi", "X86_cpu.IA32.rdi", "value", "Std.var", "X86_cpu.IA32.html#VALrdi", "<div class=\"info\">\n<p>destination index</p>\n\n</div>\n", ["DESTINATION", "INDEX"]);
add_ocaml_element("rsi", "X86_cpu.IA32.rsi", "value", "Std.var", "X86_cpu.IA32.html#VALrsi", "<div class=\"info\">\n<p>source index</p>\n\n</div>\n", ["INDEX", "SOURCE"]);
add_ocaml_element("rsp", "X86_cpu.IA32.rsp", "value", "Std.var", "X86_cpu.IA32.html#VALrsp", "<div class=\"info\">\n<p>stack pointer</p>\n\n</div>\n", ["POINTER", "STACK"]);
add_ocaml_element("rbp", "X86_cpu.IA32.rbp", "value", "Std.var", "X86_cpu.IA32.html#VALrbp", "<div class=\"info\">\n<p>base pointer</p>\n\n</div>\n", ["BASE", "POINTER"]);
add_ocaml_element("flags", "X86_cpu.IA32.flags", "value", "Std.Var.Set.t", "X86_cpu.IA32.html#VALflags", "<div class=\"info\">\n<p><code class=\"code\">flags</code> is a set of flag registers</p>\n\n</div>\n", ["FLAG", "FLAGS", "REGISTERS", "SET"]);
add_ocaml_element("sexp_of_reg", "X86_asm.sexp_of_reg", "value", "X86_asm.reg -> Ppx_sexp_conv_lib.Sexp.t", "X86_asm.html#VALsexp_of_reg", "", []);
add_ocaml_element("reg_of_sexp", "X86_asm.reg_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm.reg", "X86_asm.html#VALreg_of_sexp", "", []);
add_ocaml_element("__reg_of_sexp__", "X86_asm.__reg_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> X86_asm.reg", "X86_asm.html#VAL__reg_of_sexp__", "", []);
add_ocaml_element("base_var", "X86_llvm_env.base_var", "value", "X86_types.mode -> Std.reg -> Std.Var.t option", "X86_llvm_env.html#VALbase_var", "<div class=\"info\">\n<p><code class=\"code\">base_var&nbsp;mode&nbsp;reg</code> given a <code class=\"code\">reg</code> operand provided by the LLVM\n    disassembler, <code class=\"code\">base_var</code> returns the variable corresponding to\n    the physical register for that <code class=\"code\">mode</code> if it exists.</p>\n\n</div>\n", ["BACKEND", "BASE_VAR", "CORRESPONDING", "DISASSEMBLER", "EXISTS", "FOR", "GIVEN", "LLVM", "MODE", "NONE", "OPERAND", "OUR", "PHYSICAL", "PROVIDED", "REG", "REGISTER", "RETURNED", "RETURNS", "SUCH", "THAT", "THE", "VARIABLE"]);
add_ocaml_element("ymms", "X86_env.ModeVars.ymms", "value", "Std.var array", "X86_env.ModeVars.html#VALymms", "<div class=\"info\">\n<p>array of YMM registers</p>\n\n</div>\n", ["ARRAY", "REGISTERS", "YMM"]);
add_ocaml_element("nums", "X86_env.ModeVars.nums", "value", "Std.var array", "X86_env.ModeVars.html#VALnums", "<div class=\"info\">\n<p>Legacy version of the `r` array.</p>\n\n</div>\n", ["ARRAY", "LEGACY", "THE", "VERSION"]);
add_ocaml_element("r", "X86_env.ModeVars.r", "value", "Std.var array", "X86_env.ModeVars.html#VALr", "<div class=\"info\">\n<p>r8-r15 registers.</p>\n\n</div>\n", ["DUE", "ISSUES", "LEGACY", "R15", "REGISTERS"]);
add_ocaml_element("mem", "X86_env.ModeVars.mem", "value", "Std.var", "X86_env.ModeVars.html#VALmem", "<div class=\"info\">\n<p>memory</p>\n\n</div>\n", ["MEMORY"]);
add_ocaml_element("seg_gs", "X86_env.ModeVars.seg_gs", "value", "Std.var option", "X86_env.ModeVars.html#VALseg_gs", "", []);
add_ocaml_element("seg_fs", "X86_env.ModeVars.seg_fs", "value", "Std.var option", "X86_env.ModeVars.html#VALseg_fs", "", []);
add_ocaml_element("seg_ds", "X86_env.ModeVars.seg_ds", "value", "Std.var option", "X86_env.ModeVars.html#VALseg_ds", "", []);
add_ocaml_element("seg_cs", "X86_env.ModeVars.seg_cs", "value", "Std.var option", "X86_env.ModeVars.html#VALseg_cs", "", []);
add_ocaml_element("seg_es", "X86_env.ModeVars.seg_es", "value", "Std.var option", "X86_env.ModeVars.html#VALseg_es", "", []);
add_ocaml_element("seg_ss", "X86_env.ModeVars.seg_ss", "value", "Std.var option", "X86_env.ModeVars.html#VALseg_ss", "", []);
add_ocaml_element("gs_base", "X86_env.ModeVars.gs_base", "value", "Std.var", "X86_env.ModeVars.html#VALgs_base", "", []);
add_ocaml_element("fs_base", "X86_env.ModeVars.fs_base", "value", "Std.var", "X86_env.ModeVars.html#VALfs_base", "<div class=\"info\">\n<p>segment registers let bases</p>\n\n</div>\n", ["BASES", "LET", "REGISTERS", "SEGMENT"]);
add_ocaml_element("ldt", "X86_env.ModeVars.ldt", "value", "Std.var", "X86_env.ModeVars.html#VALldt", "<div class=\"info\">\n<p>Local Descriptor Table</p>\n\n</div>\n", ["DESCRIPTOR", "LOCAL", "TABLE"]);
add_ocaml_element("gdt", "X86_env.ModeVars.gdt", "value", "Std.var", "X86_env.ModeVars.html#VALgdt", "<div class=\"info\">\n<p>Global Descriptor Table</p>\n\n</div>\n", ["DESCRIPTOR", "GLOBAL", "TABLE"]);
add_ocaml_element("rflags", "X86_env.ModeVars.rflags", "value", "Std.var", "X86_env.ModeVars.html#VALrflags", "<div class=\"info\">\n<p>RFLAGS register</p>\n\n</div>\n", ["REGISTER", "RFLAGS"]);
add_ocaml_element("rdx", "X86_env.ModeVars.rdx", "value", "Std.var", "X86_env.ModeVars.html#VALrdx", "<div class=\"info\">\n<p>data register</p>\n\n</div>\n", ["DATA", "REGISTER"]);
add_ocaml_element("rcx", "X86_env.ModeVars.rcx", "value", "Std.var", "X86_env.ModeVars.html#VALrcx", "<div class=\"info\">\n<p>counter register</p>\n\n</div>\n", ["COUNTER", "REGISTER"]);
add_ocaml_element("rbx", "X86_env.ModeVars.rbx", "value", "Std.var", "X86_env.ModeVars.html#VALrbx", "<div class=\"info\">\n<p>base register</p>\n\n</div>\n", ["BASE", "REGISTER"]);
add_ocaml_element("rax", "X86_env.ModeVars.rax", "value", "Std.var", "X86_env.ModeVars.html#VALrax", "<div class=\"info\">\n<p>accumulator register</p>\n\n</div>\n", ["ACCUMULATOR", "REGISTER"]);
add_ocaml_element("rip", "X86_env.ModeVars.rip", "value", "Std.var", "X86_env.ModeVars.html#VALrip", "<div class=\"info\">\n<p>instruction pointer</p>\n\n</div>\n", ["INSTRUCTION", "POINTER"]);
add_ocaml_element("rdi", "X86_env.ModeVars.rdi", "value", "Std.var", "X86_env.ModeVars.html#VALrdi", "<div class=\"info\">\n<p>destination index</p>\n\n</div>\n", ["DESTINATION", "INDEX"]);
add_ocaml_element("rsi", "X86_env.ModeVars.rsi", "value", "Std.var", "X86_env.ModeVars.html#VALrsi", "<div class=\"info\">\n<p>source index</p>\n\n</div>\n", ["INDEX", "SOURCE"]);
add_ocaml_element("rsp", "X86_env.ModeVars.rsp", "value", "Std.var", "X86_env.ModeVars.html#VALrsp", "<div class=\"info\">\n<p>stack pointer</p>\n\n</div>\n", ["POINTER", "STACK"]);
add_ocaml_element("rbp", "X86_env.ModeVars.rbp", "value", "Std.var", "X86_env.ModeVars.html#VALrbp", "<div class=\"info\">\n<p>base pointer</p>\n\n</div>\n", ["BASE", "POINTER"]);
add_ocaml_element("vars_of_mode", "X86_env.vars_of_mode", "value", "X86_types.mode -> (module X86_env.ModeVars)", "X86_env.html#VALvars_of_mode", "<div class=\"info\">\n<p><code class=\"code\">vars_of_mode&nbsp;mode</code> creates registers for a <code class=\"code\">mode</code></p>\n\n</div>\n", ["CREATES", "FOR", "MODE", "REGISTERS", "VARS_OF_MODE"]);
add_ocaml_element("standard_prefs", "X86_env.standard_prefs", "value", "int list", "X86_env.html#VALstandard_prefs", "<div class=\"info\">\n<p>Prefixes that we can usually handle automatically</p>\n\n</div>\n", ["AUTOMATICALLY", "CAN", "HANDLE", "PREFIXES", "THAT", "USUALLY"]);
add_ocaml_element("pref_addrsize", "X86_env.pref_addrsize", "value", "int", "X86_env.html#VALpref_addrsize", "", []);
add_ocaml_element("pref_opsize", "X86_env.pref_opsize", "value", "int", "X86_env.html#VALpref_opsize", "", []);
add_ocaml_element("pref_gs", "X86_env.pref_gs", "value", "int", "X86_env.html#VALpref_gs", "", []);
add_ocaml_element("pref_fs", "X86_env.pref_fs", "value", "int", "X86_env.html#VALpref_fs", "", []);
add_ocaml_element("pref_es", "X86_env.pref_es", "value", "int", "X86_env.html#VALpref_es", "", []);
add_ocaml_element("pref_ds", "X86_env.pref_ds", "value", "int", "X86_env.html#VALpref_ds", "", []);
add_ocaml_element("pref_ss", "X86_env.pref_ss", "value", "int", "X86_env.html#VALpref_ss", "", []);
add_ocaml_element("pref_cs", "X86_env.pref_cs", "value", "int", "X86_env.html#VALpref_cs", "", []);
add_ocaml_element("hint_bt", "X86_env.hint_bt", "value", "int", "X86_env.html#VALhint_bt", "", []);
add_ocaml_element("hint_bnt", "X86_env.hint_bnt", "value", "int", "X86_env.html#VALhint_bnt", "", []);
add_ocaml_element("repz", "X86_env.repz", "value", "int", "X86_env.html#VALrepz", "", []);
add_ocaml_element("repnz", "X86_env.repnz", "value", "int", "X86_env.html#VALrepnz", "", []);
add_ocaml_element("pref_lock", "X86_env.pref_lock", "value", "int", "X86_env.html#VALpref_lock", "", []);
add_ocaml_element("o_gs", "X86_env.o_gs", "value", "X86_types.operand", "X86_env.html#VALo_gs", "", []);
add_ocaml_element("o_fs", "X86_env.o_fs", "value", "X86_types.operand", "X86_env.html#VALo_fs", "", []);
add_ocaml_element("o_rbp", "X86_env.o_rbp", "value", "X86_types.operand", "X86_env.html#VALo_rbp", "", []);
add_ocaml_element("o_rsp", "X86_env.o_rsp", "value", "X86_types.operand", "X86_env.html#VALo_rsp", "", []);
add_ocaml_element("o_rbx", "X86_env.o_rbx", "value", "X86_types.operand", "X86_env.html#VALo_rbx", "", []);
add_ocaml_element("o_rdx", "X86_env.o_rdx", "value", "X86_types.operand", "X86_env.html#VALo_rdx", "", []);
add_ocaml_element("o_rcx", "X86_env.o_rcx", "value", "X86_types.operand", "X86_env.html#VALo_rcx", "", []);
add_ocaml_element("o_rax", "X86_env.o_rax", "value", "X86_types.operand", "X86_env.html#VALo_rax", "", []);
add_ocaml_element("mxcsr", "X86_env.mxcsr", "value", "Std.var", "X86_env.html#VALmxcsr", "<div class=\"info\">\n<p>mx status control register</p>\n\n</div>\n", ["CONTROL", "REGISTER", "STATUS"]);
add_ocaml_element("fpu_ctrl", "X86_env.fpu_ctrl", "value", "Std.var", "X86_env.html#VALfpu_ctrl", "<div class=\"info\">\n<p>fpu control register</p>\n\n</div>\n", ["CONTROL", "FPU", "REGISTER"]);
add_ocaml_element("ss", "X86_env.ss", "value", "Std.var", "X86_env.html#VALss", "<div class=\"info\">\n<p>stack segment</p>\n\n</div>\n", ["SEGMENT", "STACK"]);
add_ocaml_element("gs", "X86_env.gs", "value", "Std.var", "X86_env.html#VALgs", "<div class=\"info\">\n<p>extra data segment #3</p>\n\n</div>\n", ["DATA", "EXTRA", "SEGMENT"]);
add_ocaml_element("fs", "X86_env.fs", "value", "Std.var", "X86_env.html#VALfs", "<div class=\"info\">\n<p>extra data segment #2</p>\n\n</div>\n", ["DATA", "EXTRA", "SEGMENT"]);
add_ocaml_element("es", "X86_env.es", "value", "Std.var", "X86_env.html#VALes", "<div class=\"info\">\n<p>extra data segment #1</p>\n\n</div>\n", ["DATA", "EXTRA", "SEGMENT"]);
add_ocaml_element("ds", "X86_env.ds", "value", "Std.var", "X86_env.html#VALds", "<div class=\"info\">\n<p>data segment</p>\n\n</div>\n", ["DATA", "SEGMENT"]);
add_ocaml_element("cs", "X86_env.cs", "value", "Std.var", "X86_env.html#VALcs", "<div class=\"info\">\n<p>code segment</p>\n\n</div>\n", ["CODE", "SEGMENT"]);
add_ocaml_element("df", "X86_env.df", "value", "Std.var", "X86_env.html#VALdf", "<div class=\"info\">\n<p>direction flag</p>\n\n</div>\n", ["DIRECTION", "FLAG"]);
add_ocaml_element("oF", "X86_env.oF", "value", "Std.var", "X86_env.html#VALoF", "<div class=\"info\">\n<p>overflow flag</p>\n\n</div>\n", ["FLAG", "OVERFLOW"]);
add_ocaml_element("sf", "X86_env.sf", "value", "Std.var", "X86_env.html#VALsf", "<div class=\"info\">\n<p>sign flag</p>\n\n</div>\n", ["FLAG", "SIGN"]);
add_ocaml_element("zf", "X86_env.zf", "value", "Std.var", "X86_env.html#VALzf", "<div class=\"info\">\n<p>zero flag</p>\n\n</div>\n", ["FLAG", "ZERO"]);
add_ocaml_element("af", "X86_env.af", "value", "Std.var", "X86_env.html#VALaf", "<div class=\"info\">\n<p>adjust flag</p>\n\n</div>\n", ["ADJUST", "FLAG"]);
add_ocaml_element("pf", "X86_env.pf", "value", "Std.var", "X86_env.html#VALpf", "<div class=\"info\">\n<p>parity flag</p>\n\n</div>\n", ["FLAG", "PARITY"]);
add_ocaml_element("cf", "X86_env.cf", "value", "Std.var", "X86_env.html#VALcf", "<div class=\"info\">\n<p>carry flag</p>\n\n</div>\n", ["CARRY", "FLAG"]);
add_ocaml_element("decode", "X86_asm_reg.decode", "value", "Std.reg -> t option", "X86_asm_reg.html#VALdecode", "<div class=\"info\">\n<p><code class=\"code\">decode&nbsp;reg</code> decodes the given <code class=\"code\">reg</code> provided by the\n    disassembler as an x86 register if that is feasible.</p>\n\n</div>\n", ["DECODE", "DECODES", "DISASSEMBLER", "FEASIBLE", "GIVEN", "PROVIDED", "REG", "REGISTER", "THAT", "THE", "X86"]);
add_ocaml_element("bitwidth", "X86_asm_reg.bitwidth", "value", "[ `AH\n  | `AL\n  | `AX\n  | `BH\n  | `BL\n  | `BP\n  | `BPL\n  | `BX\n  | `CH\n  | `CL\n  | `CX\n  | `DH\n  | `DI\n  | `DIL\n  | `DL\n  | `DX\n  | `EAX\n  | `EBP\n  | `EBX\n  | `ECX\n  | `EDI\n  | `EDX\n  | `EIP\n  | `ESI\n  | `ESP\n  | `IP\n  | `R10\n  | `R10B\n  | `R10D\n  | `R10W\n  | `R11\n  | `R11B\n  | `R11D\n  | `R11W\n  | `R12\n  | `R12B\n  | `R12D\n  | `R12W\n  | `R13\n  | `R13B\n  | `R13D\n  | `R13W\n  | `R14\n  | `R14B\n  | `R14D\n  | `R14W\n  | `R15\n  | `R15B\n  | `R15D\n  | `R15W\n  | `R8\n  | `R8B\n  | `R8D\n  | `R8W\n  | `R9\n  | `R9B\n  | `R9D\n  | `R9W\n  | `RAX\n  | `RBP\n  | `RBX\n  | `RCX\n  | `RDI\n  | `RDX\n  | `RIP\n  | `RSI\n  | `RSP\n  | `SI\n  | `SIL\n  | `SP\n  | `SPL\n  | `XMM0\n  | `XMM1\n  | `XMM10\n  | `XMM11\n  | `XMM12\n  | `XMM13\n  | `XMM14\n  | `XMM15\n  | `XMM2\n  | `XMM3\n  | `XMM4\n  | `XMM5\n  | `XMM6\n  | `XMM7\n  | `XMM8\n  | `XMM9\n  | `YMM0\n  | `YMM1\n  | `YMM10\n  | `YMM11\n  | `YMM12\n  | `YMM13\n  | `YMM14\n  | `YMM15\n  | `YMM2\n  | `YMM3\n  | `YMM4\n  | `YMM5\n  | `YMM6\n  | `YMM7\n  | `YMM8\n  | `YMM9 ] -> int", "X86_asm_reg.html#VALbitwidth", "<div class=\"info\">\n<p><code class=\"code\">bitwidth&nbsp;reg_type</code> returns the width in bits of the\n    given <code class=\"code\">reg_type</code></p>\n\n</div>\n", ["BITS", "BITWIDTH", "GIVEN", "REG_TYPE", "RETURNS", "THE", "WIDTH"]);
add_ocaml_element("width", "X86_asm_reg.width", "value", "[ `AH\n  | `AL\n  | `AX\n  | `BH\n  | `BL\n  | `BP\n  | `BPL\n  | `BX\n  | `CH\n  | `CL\n  | `CX\n  | `DH\n  | `DI\n  | `DIL\n  | `DL\n  | `DX\n  | `EAX\n  | `EBP\n  | `EBX\n  | `ECX\n  | `EDI\n  | `EDX\n  | `EIP\n  | `ESI\n  | `ESP\n  | `IP\n  | `R10\n  | `R10B\n  | `R10D\n  | `R10W\n  | `R11\n  | `R11B\n  | `R11D\n  | `R11W\n  | `R12\n  | `R12B\n  | `R12D\n  | `R12W\n  | `R13\n  | `R13B\n  | `R13D\n  | `R13W\n  | `R14\n  | `R14B\n  | `R14D\n  | `R14W\n  | `R15\n  | `R15B\n  | `R15D\n  | `R15W\n  | `R8\n  | `R8B\n  | `R8D\n  | `R8W\n  | `R9\n  | `R9B\n  | `R9D\n  | `R9W\n  | `RAX\n  | `RBP\n  | `RBX\n  | `RCX\n  | `RDI\n  | `RDX\n  | `RIP\n  | `RSI\n  | `RSP\n  | `SI\n  | `SIL\n  | `SP\n  | `SPL\n  | `XMM0\n  | `XMM1\n  | `XMM10\n  | `XMM11\n  | `XMM12\n  | `XMM13\n  | `XMM14\n  | `XMM15\n  | `XMM2\n  | `XMM3\n  | `XMM4\n  | `XMM5\n  | `XMM6\n  | `XMM7\n  | `XMM8\n  | `XMM9\n  | `YMM0\n  | `YMM1\n  | `YMM10\n  | `YMM11\n  | `YMM12\n  | `YMM13\n  | `YMM14\n  | `YMM15\n  | `YMM2\n  | `YMM3\n  | `YMM4\n  | `YMM5\n  | `YMM6\n  | `YMM7\n  | `YMM8\n  | `YMM9 ] -> Std.size", "X86_asm_reg.html#VALwidth", "<div class=\"info\">\n<p><code class=\"code\">width&nbsp;reg_type</code> returns the size of the given <code class=\"code\">reg_type</code></p>\n\n</div>\n", ["GIVEN", "REG_TYPE", "RETURNS", "SIZE", "THE", "WIDTH"]);
add_ocaml_element("lift", "Arm_lifter.lift", "value", "Std.lifter", "Arm_lifter.html#VALlift", "<div class=\"info\">\n<p><code class=\"code\">lift&nbsp;mem&nbsp;insn</code> lifts instruction.</p>\n\n</div>\n", ["INSN", "INSTRUCTION", "LIFT", "LIFTS", "MEM"]);
add_ocaml_element("sexpable_of_string", "Arm_helpers.sexpable_of_string", "value", "(Sexp.t -> 'a) -> string -> 'a option", "Arm_helpers.html#VALsexpable_of_string", "", []);
add_ocaml_element("all_of_insn", "Arm_types.all_of_insn", "value", "Arm_types.insn list", "Arm_types.html#VALall_of_insn", "", []);
add_ocaml_element("sexp_of_insn", "Arm_types.sexp_of_insn", "value", "Arm_types.insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_insn", "", []);
add_ocaml_element("insn_of_sexp", "Arm_types.insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.insn", "Arm_types.html#VALinsn_of_sexp", "", []);
add_ocaml_element("__insn_of_sexp__", "Arm_types.__insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.insn", "Arm_types.html#VAL__insn_of_sexp__", "", []);
add_ocaml_element("compare_insn", "Arm_types.compare_insn", "value", "Arm_types.insn -> Arm_types.insn -> int", "Arm_types.html#VALcompare_insn", "", []);
add_ocaml_element("bin_insn", "Arm_types.bin_insn", "value", "Arm_types.insn Bin_prot.Type_class.t", "Arm_types.html#VALbin_insn", "", []);
add_ocaml_element("bin_reader_insn", "Arm_types.bin_reader_insn", "value", "Arm_types.insn Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_insn", "", []);
add_ocaml_element("bin_read_insn", "Arm_types.bin_read_insn", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Arm_types.insn", "Arm_types.html#VALbin_read_insn", "", []);
add_ocaml_element("__bin_read_insn__", "Arm_types.__bin_read_insn__", "value", "'a -> pos_ref:'b -> int -> Arm_types.insn", "Arm_types.html#VAL__bin_read_insn__", "", []);
add_ocaml_element("bin_writer_insn", "Arm_types.bin_writer_insn", "value", "[< `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BFC\n   | `BFI\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc\n   | `CLZ\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `CPS2p\n   | `DMB\n   | `DSB\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `HINT\n   | `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `LDRBT_POST_IMM\n   | `LDRBT_POST_REG\n   | `LDRB_POST_IMM\n   | `LDRB_POST_REG\n   | `LDRB_PRE_IMM\n   | `LDRB_PRE_REG\n   | `LDRBi12\n   | `LDRBrs\n   | `LDRD\n   | `LDRD_POST\n   | `LDRD_PRE\n   | `LDREX\n   | `LDREXB\n   | `LDREXD\n   | `LDREXH\n   | `LDRH\n   | `LDRHTr\n   | `LDRH_POST\n   | `LDRH_PRE\n   | `LDRSB\n   | `LDRSBTr\n   | `LDRSB_POST\n   | `LDRSB_PRE\n   | `LDRSH\n   | `LDRSHTi\n   | `LDRSHTr\n   | `LDRSH_POST\n   | `LDRSH_PRE\n   | `LDRT_POST_REG\n   | `LDR_POST_IMM\n   | `LDR_POST_REG\n   | `LDR_PRE_IMM\n   | `LDR_PRE_REG\n   | `LDRi12\n   | `LDRrs\n   | `MLA\n   | `MLS\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MRS\n   | `MSR\n   | `MUL\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `PKHTB\n   | `PLDi12\n   | `RBIT\n   | `REV\n   | `REV16\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SBFX\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD\n   | `STRBT_POST_IMM\n   | `STRBT_POST_REG\n   | `STRB_POST_IMM\n   | `STRB_POST_REG\n   | `STRB_PRE_IMM\n   | `STRB_PRE_REG\n   | `STRBi12\n   | `STRBrs\n   | `STRD\n   | `STRD_POST\n   | `STRD_PRE\n   | `STREX\n   | `STREXB\n   | `STREXD\n   | `STREXH\n   | `STRH\n   | `STRHTr\n   | `STRH_POST\n   | `STRH_PRE\n   | `STRT_POST_REG\n   | `STR_POST_IMM\n   | `STR_POST_REG\n   | `STR_PRE_IMM\n   | `STR_PRE_REG\n   | `STRi12\n   | `STRrs\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `SVC\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr\n   | `UBFX\n   | `UMLAL\n   | `UMULL\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_insn", "", []);
add_ocaml_element("bin_write_insn", "Arm_types.bin_write_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BFC\n   | `BFI\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc\n   | `CLZ\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `CPS2p\n   | `DMB\n   | `DSB\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `HINT\n   | `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `LDRBT_POST_IMM\n   | `LDRBT_POST_REG\n   | `LDRB_POST_IMM\n   | `LDRB_POST_REG\n   | `LDRB_PRE_IMM\n   | `LDRB_PRE_REG\n   | `LDRBi12\n   | `LDRBrs\n   | `LDRD\n   | `LDRD_POST\n   | `LDRD_PRE\n   | `LDREX\n   | `LDREXB\n   | `LDREXD\n   | `LDREXH\n   | `LDRH\n   | `LDRHTr\n   | `LDRH_POST\n   | `LDRH_PRE\n   | `LDRSB\n   | `LDRSBTr\n   | `LDRSB_POST\n   | `LDRSB_PRE\n   | `LDRSH\n   | `LDRSHTi\n   | `LDRSHTr\n   | `LDRSH_POST\n   | `LDRSH_PRE\n   | `LDRT_POST_REG\n   | `LDR_POST_IMM\n   | `LDR_POST_REG\n   | `LDR_PRE_IMM\n   | `LDR_PRE_REG\n   | `LDRi12\n   | `LDRrs\n   | `MLA\n   | `MLS\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MRS\n   | `MSR\n   | `MUL\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `PKHTB\n   | `PLDi12\n   | `RBIT\n   | `REV\n   | `REV16\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SBFX\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD\n   | `STRBT_POST_IMM\n   | `STRBT_POST_REG\n   | `STRB_POST_IMM\n   | `STRB_POST_REG\n   | `STRB_PRE_IMM\n   | `STRB_PRE_REG\n   | `STRBi12\n   | `STRBrs\n   | `STRD\n   | `STRD_POST\n   | `STRD_PRE\n   | `STREX\n   | `STREXB\n   | `STREXD\n   | `STREXH\n   | `STRH\n   | `STRHTr\n   | `STRH_POST\n   | `STRH_PRE\n   | `STRT_POST_REG\n   | `STR_POST_IMM\n   | `STR_POST_REG\n   | `STR_PRE_IMM\n   | `STR_PRE_REG\n   | `STRi12\n   | `STRrs\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `SVC\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr\n   | `UBFX\n   | `UMLAL\n   | `UMULL\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_insn", "", []);
add_ocaml_element("bin_size_insn", "Arm_types.bin_size_insn", "value", "[< `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BFC\n   | `BFI\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc\n   | `CLZ\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `CPS2p\n   | `DMB\n   | `DSB\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `HINT\n   | `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `LDRBT_POST_IMM\n   | `LDRBT_POST_REG\n   | `LDRB_POST_IMM\n   | `LDRB_POST_REG\n   | `LDRB_PRE_IMM\n   | `LDRB_PRE_REG\n   | `LDRBi12\n   | `LDRBrs\n   | `LDRD\n   | `LDRD_POST\n   | `LDRD_PRE\n   | `LDREX\n   | `LDREXB\n   | `LDREXD\n   | `LDREXH\n   | `LDRH\n   | `LDRHTr\n   | `LDRH_POST\n   | `LDRH_PRE\n   | `LDRSB\n   | `LDRSBTr\n   | `LDRSB_POST\n   | `LDRSB_PRE\n   | `LDRSH\n   | `LDRSHTi\n   | `LDRSHTr\n   | `LDRSH_POST\n   | `LDRSH_PRE\n   | `LDRT_POST_REG\n   | `LDR_POST_IMM\n   | `LDR_POST_REG\n   | `LDR_PRE_IMM\n   | `LDR_PRE_REG\n   | `LDRi12\n   | `LDRrs\n   | `MLA\n   | `MLS\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MRS\n   | `MSR\n   | `MUL\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `PKHTB\n   | `PLDi12\n   | `RBIT\n   | `REV\n   | `REV16\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SBFX\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD\n   | `STRBT_POST_IMM\n   | `STRBT_POST_REG\n   | `STRB_POST_IMM\n   | `STRB_POST_REG\n   | `STRB_PRE_IMM\n   | `STRB_PRE_REG\n   | `STRBi12\n   | `STRBrs\n   | `STRD\n   | `STRD_POST\n   | `STRD_PRE\n   | `STREX\n   | `STREXB\n   | `STREXD\n   | `STREXH\n   | `STRH\n   | `STRHTr\n   | `STRH_POST\n   | `STRH_PRE\n   | `STRT_POST_REG\n   | `STR_POST_IMM\n   | `STR_POST_REG\n   | `STR_PRE_IMM\n   | `STR_PRE_REG\n   | `STRi12\n   | `STRrs\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `SVC\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr\n   | `UBFX\n   | `UMLAL\n   | `UMULL\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ] ->\n  int", "Arm_types.html#VALbin_size_insn", "", []);
add_ocaml_element("bin_shape_insn", "Arm_types.bin_shape_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_insn", "", []);
add_ocaml_element("all_of_special_insn", "Arm_types.all_of_special_insn", "value", "Arm_types.special_insn list", "Arm_types.html#VALall_of_special_insn", "", []);
add_ocaml_element("sexp_of_special_insn", "Arm_types.sexp_of_special_insn", "value", "Arm_types.special_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_special_insn", "", []);
add_ocaml_element("special_insn_of_sexp", "Arm_types.special_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.special_insn", "Arm_types.html#VALspecial_insn_of_sexp", "", []);
add_ocaml_element("__special_insn_of_sexp__", "Arm_types.__special_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.special_insn", "Arm_types.html#VAL__special_insn_of_sexp__", "", []);
add_ocaml_element("compare_special_insn", "Arm_types.compare_special_insn", "value", "Arm_types.special_insn -> Arm_types.special_insn -> int", "Arm_types.html#VALcompare_special_insn", "", []);
add_ocaml_element("bin_special_insn", "Arm_types.bin_special_insn", "value", "[ `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ]\n  Bin_prot.Type_class.t", "Arm_types.html#VALbin_special_insn", "", []);
add_ocaml_element("bin_reader_special_insn", "Arm_types.bin_reader_special_insn", "value", "[> `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_special_insn", "", []);
add_ocaml_element("bin_read_special_insn", "Arm_types.bin_read_special_insn", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ]", "Arm_types.html#VALbin_read_special_insn", "", []);
add_ocaml_element("__bin_read_special_insn__", "Arm_types.__bin_read_special_insn__", "value", "'a ->\n  pos_ref:'b ->\n  int -> [> `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ]", "Arm_types.html#VAL__bin_read_special_insn__", "", []);
add_ocaml_element("bin_writer_special_insn", "Arm_types.bin_writer_special_insn", "value", "[< `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_special_insn", "", []);
add_ocaml_element("bin_write_special_insn", "Arm_types.bin_write_special_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `CPS2p | `DMB | `DSB | `HINT | `MRS | `MSR | `PLDi12 | `SVC ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_special_insn", "", []);
add_ocaml_element("bin_size_special_insn", "Arm_types.bin_size_special_insn", "value", "'a -> int", "Arm_types.html#VALbin_size_special_insn", "", []);
add_ocaml_element("bin_shape_special_insn", "Arm_types.bin_shape_special_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_special_insn", "", []);
add_ocaml_element("all_of_branch_insn", "Arm_types.all_of_branch_insn", "value", "Arm_types.branch_insn list", "Arm_types.html#VALall_of_branch_insn", "", []);
add_ocaml_element("sexp_of_branch_insn", "Arm_types.sexp_of_branch_insn", "value", "Arm_types.branch_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_branch_insn", "", []);
add_ocaml_element("branch_insn_of_sexp", "Arm_types.branch_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.branch_insn", "Arm_types.html#VALbranch_insn_of_sexp", "", []);
add_ocaml_element("__branch_insn_of_sexp__", "Arm_types.__branch_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.branch_insn", "Arm_types.html#VAL__branch_insn_of_sexp__", "", []);
add_ocaml_element("compare_branch_insn", "Arm_types.compare_branch_insn", "value", "Arm_types.branch_insn -> Arm_types.branch_insn -> int", "Arm_types.html#VALcompare_branch_insn", "", []);
add_ocaml_element("bin_branch_insn", "Arm_types.bin_branch_insn", "value", "[ `BL | `BLX | `BLX_pred | `BLXi | `BL_pred | `BX | `BX_RET | `BX_pred | `Bcc ]\n  Bin_prot.Type_class.t", "Arm_types.html#VALbin_branch_insn", "", []);
add_ocaml_element("bin_reader_branch_insn", "Arm_types.bin_reader_branch_insn", "value", "[> `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_branch_insn", "", []);
add_ocaml_element("bin_read_branch_insn", "Arm_types.bin_read_branch_insn", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc ]", "Arm_types.html#VALbin_read_branch_insn", "", []);
add_ocaml_element("__bin_read_branch_insn__", "Arm_types.__bin_read_branch_insn__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc ]", "Arm_types.html#VAL__bin_read_branch_insn__", "", []);
add_ocaml_element("bin_writer_branch_insn", "Arm_types.bin_writer_branch_insn", "value", "[< `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_branch_insn", "", []);
add_ocaml_element("bin_write_branch_insn", "Arm_types.bin_write_branch_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `BL\n   | `BLX\n   | `BLX_pred\n   | `BLXi\n   | `BL_pred\n   | `BX\n   | `BX_RET\n   | `BX_pred\n   | `Bcc ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_branch_insn", "", []);
add_ocaml_element("bin_size_branch_insn", "Arm_types.bin_size_branch_insn", "value", "'a -> int", "Arm_types.html#VALbin_size_branch_insn", "", []);
add_ocaml_element("bin_shape_branch_insn", "Arm_types.bin_shape_branch_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_branch_insn", "", []);
add_ocaml_element("all_of_mem_insn", "Arm_types.all_of_mem_insn", "value", "Arm_types.mem_insn list", "Arm_types.html#VALall_of_mem_insn", "", []);
add_ocaml_element("sexp_of_mem_insn", "Arm_types.sexp_of_mem_insn", "value", "Arm_types.mem_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_mem_insn", "", []);
add_ocaml_element("mem_insn_of_sexp", "Arm_types.mem_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.mem_insn", "Arm_types.html#VALmem_insn_of_sexp", "", []);
add_ocaml_element("__mem_insn_of_sexp__", "Arm_types.__mem_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.mem_insn", "Arm_types.html#VAL__mem_insn_of_sexp__", "", []);
add_ocaml_element("compare_mem_insn", "Arm_types.compare_mem_insn", "value", "Arm_types.mem_insn -> Arm_types.mem_insn -> int", "Arm_types.html#VALcompare_mem_insn", "", []);
add_ocaml_element("bin_mem_insn", "Arm_types.bin_mem_insn", "value", "Arm_types.mem_insn Bin_prot.Type_class.t", "Arm_types.html#VALbin_mem_insn", "", []);
add_ocaml_element("bin_reader_mem_insn", "Arm_types.bin_reader_mem_insn", "value", "Arm_types.mem_insn Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_mem_insn", "", []);
add_ocaml_element("bin_read_mem_insn", "Arm_types.bin_read_mem_insn", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Arm_types.mem_insn", "Arm_types.html#VALbin_read_mem_insn", "", []);
add_ocaml_element("__bin_read_mem_insn__", "Arm_types.__bin_read_mem_insn__", "value", "'a -> pos_ref:'b -> int -> Arm_types.mem_insn", "Arm_types.html#VAL__bin_read_mem_insn__", "", []);
add_ocaml_element("bin_writer_mem_insn", "Arm_types.bin_writer_mem_insn", "value", "[< `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `LDRBT_POST_IMM\n   | `LDRBT_POST_REG\n   | `LDRB_POST_IMM\n   | `LDRB_POST_REG\n   | `LDRB_PRE_IMM\n   | `LDRB_PRE_REG\n   | `LDRBi12\n   | `LDRBrs\n   | `LDRD\n   | `LDRD_POST\n   | `LDRD_PRE\n   | `LDREX\n   | `LDREXB\n   | `LDREXD\n   | `LDREXH\n   | `LDRH\n   | `LDRHTr\n   | `LDRH_POST\n   | `LDRH_PRE\n   | `LDRSB\n   | `LDRSBTr\n   | `LDRSB_POST\n   | `LDRSB_PRE\n   | `LDRSH\n   | `LDRSHTi\n   | `LDRSHTr\n   | `LDRSH_POST\n   | `LDRSH_PRE\n   | `LDRT_POST_REG\n   | `LDR_POST_IMM\n   | `LDR_POST_REG\n   | `LDR_PRE_IMM\n   | `LDR_PRE_REG\n   | `LDRi12\n   | `LDRrs\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD\n   | `STRBT_POST_IMM\n   | `STRBT_POST_REG\n   | `STRB_POST_IMM\n   | `STRB_POST_REG\n   | `STRB_PRE_IMM\n   | `STRB_PRE_REG\n   | `STRBi12\n   | `STRBrs\n   | `STRD\n   | `STRD_POST\n   | `STRD_PRE\n   | `STREX\n   | `STREXB\n   | `STREXD\n   | `STREXH\n   | `STRH\n   | `STRHTr\n   | `STRH_POST\n   | `STRH_PRE\n   | `STRT_POST_REG\n   | `STR_POST_IMM\n   | `STR_POST_REG\n   | `STR_PRE_IMM\n   | `STR_PRE_REG\n   | `STRi12\n   | `STRrs\n   > `LDMDA `LDMDA_UPD `LDMDB `LDMDB_UPD `LDMIA `LDMIA_UPD `LDMIB `LDMIB_UPD\n     `STMDA `STMDA_UPD `STMDB `STMDB_UPD `STMIA `STMIA_UPD `STMIB `STMIB_UPD ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_mem_insn", "", []);
add_ocaml_element("bin_write_mem_insn", "Arm_types.bin_write_mem_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `LDRBT_POST_IMM\n   | `LDRBT_POST_REG\n   | `LDRB_POST_IMM\n   | `LDRB_POST_REG\n   | `LDRB_PRE_IMM\n   | `LDRB_PRE_REG\n   | `LDRBi12\n   | `LDRBrs\n   | `LDRD\n   | `LDRD_POST\n   | `LDRD_PRE\n   | `LDREX\n   | `LDREXB\n   | `LDREXD\n   | `LDREXH\n   | `LDRH\n   | `LDRHTr\n   | `LDRH_POST\n   | `LDRH_PRE\n   | `LDRSB\n   | `LDRSBTr\n   | `LDRSB_POST\n   | `LDRSB_PRE\n   | `LDRSH\n   | `LDRSHTi\n   | `LDRSHTr\n   | `LDRSH_POST\n   | `LDRSH_PRE\n   | `LDRT_POST_REG\n   | `LDR_POST_IMM\n   | `LDR_POST_REG\n   | `LDR_PRE_IMM\n   | `LDR_PRE_REG\n   | `LDRi12\n   | `LDRrs\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD\n   | `STRBT_POST_IMM\n   | `STRBT_POST_REG\n   | `STRB_POST_IMM\n   | `STRB_POST_REG\n   | `STRB_PRE_IMM\n   | `STRB_PRE_REG\n   | `STRBi12\n   | `STRBrs\n   | `STRD\n   | `STRD_POST\n   | `STRD_PRE\n   | `STREX\n   | `STREXB\n   | `STREXD\n   | `STREXH\n   | `STRH\n   | `STRHTr\n   | `STRH_POST\n   | `STRH_PRE\n   | `STRT_POST_REG\n   | `STR_POST_IMM\n   | `STR_POST_REG\n   | `STR_PRE_IMM\n   | `STR_PRE_REG\n   | `STRi12\n   | `STRrs ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_mem_insn", "", []);
add_ocaml_element("bin_size_mem_insn", "Arm_types.bin_size_mem_insn", "value", "[> Arm_types.mem_multi_insn ] -> int", "Arm_types.html#VALbin_size_mem_insn", "", []);
add_ocaml_element("bin_shape_mem_insn", "Arm_types.bin_shape_mem_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_mem_insn", "", []);
add_ocaml_element("all_of_mem_multi_insn", "Arm_types.all_of_mem_multi_insn", "value", "Arm_types.mem_multi_insn list", "Arm_types.html#VALall_of_mem_multi_insn", "", []);
add_ocaml_element("sexp_of_mem_multi_insn", "Arm_types.sexp_of_mem_multi_insn", "value", "Arm_types.mem_multi_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_mem_multi_insn", "", []);
add_ocaml_element("mem_multi_insn_of_sexp", "Arm_types.mem_multi_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.mem_multi_insn", "Arm_types.html#VALmem_multi_insn_of_sexp", "", []);
add_ocaml_element("__mem_multi_insn_of_sexp__", "Arm_types.__mem_multi_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.mem_multi_insn", "Arm_types.html#VAL__mem_multi_insn_of_sexp__", "", []);
add_ocaml_element("compare_mem_multi_insn", "Arm_types.compare_mem_multi_insn", "value", "Arm_types.mem_multi_insn -> Arm_types.mem_multi_insn -> int", "Arm_types.html#VALcompare_mem_multi_insn", "", []);
add_ocaml_element("bin_mem_multi_insn", "Arm_types.bin_mem_multi_insn", "value", "[ `LDMDA\n  | `LDMDA_UPD\n  | `LDMDB\n  | `LDMDB_UPD\n  | `LDMIA\n  | `LDMIA_UPD\n  | `LDMIB\n  | `LDMIB_UPD\n  | `STMDA\n  | `STMDA_UPD\n  | `STMDB\n  | `STMDB_UPD\n  | `STMIA\n  | `STMIA_UPD\n  | `STMIB\n  | `STMIB_UPD ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_mem_multi_insn", "", []);
add_ocaml_element("bin_reader_mem_multi_insn", "Arm_types.bin_reader_mem_multi_insn", "value", "[> `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_mem_multi_insn", "", []);
add_ocaml_element("bin_read_mem_multi_insn", "Arm_types.bin_read_mem_multi_insn", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD ]", "Arm_types.html#VALbin_read_mem_multi_insn", "", []);
add_ocaml_element("__bin_read_mem_multi_insn__", "Arm_types.__bin_read_mem_multi_insn__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD ]", "Arm_types.html#VAL__bin_read_mem_multi_insn__", "", []);
add_ocaml_element("bin_writer_mem_multi_insn", "Arm_types.bin_writer_mem_multi_insn", "value", "[< `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_mem_multi_insn", "", []);
add_ocaml_element("bin_write_mem_multi_insn", "Arm_types.bin_write_mem_multi_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `LDMDA\n   | `LDMDA_UPD\n   | `LDMDB\n   | `LDMDB_UPD\n   | `LDMIA\n   | `LDMIA_UPD\n   | `LDMIB\n   | `LDMIB_UPD\n   | `STMDA\n   | `STMDA_UPD\n   | `STMDB\n   | `STMDB_UPD\n   | `STMIA\n   | `STMIA_UPD\n   | `STMIB\n   | `STMIB_UPD ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_mem_multi_insn", "", []);
add_ocaml_element("bin_size_mem_multi_insn", "Arm_types.bin_size_mem_multi_insn", "value", "'a -> int", "Arm_types.html#VALbin_size_mem_multi_insn", "", []);
add_ocaml_element("bin_shape_mem_multi_insn", "Arm_types.bin_shape_mem_multi_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_mem_multi_insn", "", []);
add_ocaml_element("all_of_mult_insn", "Arm_types.all_of_mult_insn", "value", "Arm_types.mult_insn list", "Arm_types.html#VALall_of_mult_insn", "", []);
add_ocaml_element("sexp_of_mult_insn", "Arm_types.sexp_of_mult_insn", "value", "Arm_types.mult_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_mult_insn", "", []);
add_ocaml_element("mult_insn_of_sexp", "Arm_types.mult_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.mult_insn", "Arm_types.html#VALmult_insn_of_sexp", "", []);
add_ocaml_element("__mult_insn_of_sexp__", "Arm_types.__mult_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.mult_insn", "Arm_types.html#VAL__mult_insn_of_sexp__", "", []);
add_ocaml_element("compare_mult_insn", "Arm_types.compare_mult_insn", "value", "Arm_types.mult_insn -> Arm_types.mult_insn -> int", "Arm_types.html#VALcompare_mult_insn", "", []);
add_ocaml_element("bin_mult_insn", "Arm_types.bin_mult_insn", "value", "[ `MLA\n  | `MLS\n  | `MUL\n  | `SMLABB\n  | `SMLAD\n  | `SMLAL\n  | `SMLALBT\n  | `SMLAWB\n  | `SMUAD\n  | `SMULBB\n  | `SMULL\n  | `SMULTB\n  | `UMLAL\n  | `UMULL ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_mult_insn", "", []);
add_ocaml_element("bin_reader_mult_insn", "Arm_types.bin_reader_mult_insn", "value", "[> `MLA\n   | `MLS\n   | `MUL\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `UMLAL\n   | `UMULL ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_mult_insn", "", []);
add_ocaml_element("bin_read_mult_insn", "Arm_types.bin_read_mult_insn", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `MLA\n   | `MLS\n   | `MUL\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `UMLAL\n   | `UMULL ]", "Arm_types.html#VALbin_read_mult_insn", "", []);
add_ocaml_element("__bin_read_mult_insn__", "Arm_types.__bin_read_mult_insn__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `MLA\n   | `MLS\n   | `MUL\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `UMLAL\n   | `UMULL ]", "Arm_types.html#VAL__bin_read_mult_insn__", "", []);
add_ocaml_element("bin_writer_mult_insn", "Arm_types.bin_writer_mult_insn", "value", "[< `MLA\n   | `MLS\n   | `MUL\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `UMLAL\n   | `UMULL ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_mult_insn", "", []);
add_ocaml_element("bin_write_mult_insn", "Arm_types.bin_write_mult_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `MLA\n   | `MLS\n   | `MUL\n   | `SMLABB\n   | `SMLAD\n   | `SMLAL\n   | `SMLALBT\n   | `SMLAWB\n   | `SMUAD\n   | `SMULBB\n   | `SMULL\n   | `SMULTB\n   | `UMLAL\n   | `UMULL ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_mult_insn", "", []);
add_ocaml_element("bin_size_mult_insn", "Arm_types.bin_size_mult_insn", "value", "'a -> int", "Arm_types.html#VALbin_size_mult_insn", "", []);
add_ocaml_element("bin_shape_mult_insn", "Arm_types.bin_shape_mult_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_mult_insn", "", []);
add_ocaml_element("all_of_bits_insn", "Arm_types.all_of_bits_insn", "value", "Arm_types.bits_insn list", "Arm_types.html#VALall_of_bits_insn", "", []);
add_ocaml_element("sexp_of_bits_insn", "Arm_types.sexp_of_bits_insn", "value", "Arm_types.bits_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_bits_insn", "", []);
add_ocaml_element("bits_insn_of_sexp", "Arm_types.bits_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.bits_insn", "Arm_types.html#VALbits_insn_of_sexp", "", []);
add_ocaml_element("__bits_insn_of_sexp__", "Arm_types.__bits_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.bits_insn", "Arm_types.html#VAL__bits_insn_of_sexp__", "", []);
add_ocaml_element("compare_bits_insn", "Arm_types.compare_bits_insn", "value", "Arm_types.bits_insn -> Arm_types.bits_insn -> int", "Arm_types.html#VALcompare_bits_insn", "", []);
add_ocaml_element("bin_bits_insn", "Arm_types.bin_bits_insn", "value", "[ `BFC\n  | `BFI\n  | `CLZ\n  | `PKHTB\n  | `RBIT\n  | `REV\n  | `REV16\n  | `SBFX\n  | `SWPB\n  | `SXTAB\n  | `SXTAH\n  | `SXTB\n  | `SXTH\n  | `UBFX\n  | `UXTAB\n  | `UXTAH\n  | `UXTB\n  | `UXTH ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_bits_insn", "", []);
add_ocaml_element("bin_reader_bits_insn", "Arm_types.bin_reader_bits_insn", "value", "[> `BFC\n   | `BFI\n   | `CLZ\n   | `PKHTB\n   | `RBIT\n   | `REV\n   | `REV16\n   | `SBFX\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `UBFX\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_bits_insn", "", []);
add_ocaml_element("bin_read_bits_insn", "Arm_types.bin_read_bits_insn", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `BFC\n   | `BFI\n   | `CLZ\n   | `PKHTB\n   | `RBIT\n   | `REV\n   | `REV16\n   | `SBFX\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `UBFX\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ]", "Arm_types.html#VALbin_read_bits_insn", "", []);
add_ocaml_element("__bin_read_bits_insn__", "Arm_types.__bin_read_bits_insn__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `BFC\n   | `BFI\n   | `CLZ\n   | `PKHTB\n   | `RBIT\n   | `REV\n   | `REV16\n   | `SBFX\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `UBFX\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ]", "Arm_types.html#VAL__bin_read_bits_insn__", "", []);
add_ocaml_element("bin_writer_bits_insn", "Arm_types.bin_writer_bits_insn", "value", "[< `BFC\n   | `BFI\n   | `CLZ\n   | `PKHTB\n   | `RBIT\n   | `REV\n   | `REV16\n   | `SBFX\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `UBFX\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_bits_insn", "", []);
add_ocaml_element("bin_write_bits_insn", "Arm_types.bin_write_bits_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `BFC\n   | `BFI\n   | `CLZ\n   | `PKHTB\n   | `RBIT\n   | `REV\n   | `REV16\n   | `SBFX\n   | `SWPB\n   | `SXTAB\n   | `SXTAH\n   | `SXTB\n   | `SXTH\n   | `UBFX\n   | `UXTAB\n   | `UXTAH\n   | `UXTB\n   | `UXTH ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_bits_insn", "", []);
add_ocaml_element("bin_size_bits_insn", "Arm_types.bin_size_bits_insn", "value", "'a -> int", "Arm_types.html#VALbin_size_bits_insn", "", []);
add_ocaml_element("bin_shape_bits_insn", "Arm_types.bin_shape_bits_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_bits_insn", "", []);
add_ocaml_element("all_of_move_insn", "Arm_types.all_of_move_insn", "value", "Arm_types.move_insn list", "Arm_types.html#VALall_of_move_insn", "", []);
add_ocaml_element("sexp_of_move_insn", "Arm_types.sexp_of_move_insn", "value", "Arm_types.move_insn -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_move_insn", "", []);
add_ocaml_element("move_insn_of_sexp", "Arm_types.move_insn_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.move_insn", "Arm_types.html#VALmove_insn_of_sexp", "", []);
add_ocaml_element("__move_insn_of_sexp__", "Arm_types.__move_insn_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.move_insn", "Arm_types.html#VAL__move_insn_of_sexp__", "", []);
add_ocaml_element("compare_move_insn", "Arm_types.compare_move_insn", "value", "Arm_types.move_insn -> Arm_types.move_insn -> int", "Arm_types.html#VALcompare_move_insn", "", []);
add_ocaml_element("bin_move_insn", "Arm_types.bin_move_insn", "value", "[ `ADCri\n  | `ADCrr\n  | `ADCrsi\n  | `ADCrsr\n  | `ADDri\n  | `ADDrr\n  | `ADDrsi\n  | `ADDrsr\n  | `ANDri\n  | `ANDrr\n  | `ANDrsi\n  | `ANDrsr\n  | `BICri\n  | `BICrr\n  | `BICrsi\n  | `BICrsr\n  | `CMNri\n  | `CMNzrr\n  | `CMNzrsi\n  | `CMNzrsr\n  | `CMPri\n  | `CMPrr\n  | `CMPrsi\n  | `CMPrsr\n  | `EORri\n  | `EORrr\n  | `EORrsi\n  | `EORrsr\n  | `MOVPCLR\n  | `MOVTi16\n  | `MOVi\n  | `MOVi16\n  | `MOVr\n  | `MOVsi\n  | `MOVsr\n  | `MVNi\n  | `MVNr\n  | `MVNsi\n  | `MVNsr\n  | `ORRri\n  | `ORRrr\n  | `ORRrsi\n  | `ORRrsr\n  | `RSBri\n  | `RSBrr\n  | `RSBrsi\n  | `RSBrsr\n  | `RSCri\n  | `RSCrr\n  | `RSCrsi\n  | `RSCrsr\n  | `SBCri\n  | `SBCrr\n  | `SBCrsi\n  | `SBCrsr\n  | `SUBri\n  | `SUBrr\n  | `SUBrsi\n  | `SUBrsr\n  | `TEQri\n  | `TEQrr\n  | `TEQrsi\n  | `TEQrsr\n  | `TSTri\n  | `TSTrr\n  | `TSTrsi\n  | `TSTrsr ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_move_insn", "", []);
add_ocaml_element("bin_reader_move_insn", "Arm_types.bin_reader_move_insn", "value", "[> `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_move_insn", "", []);
add_ocaml_element("bin_read_move_insn", "Arm_types.bin_read_move_insn", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr ]", "Arm_types.html#VALbin_read_move_insn", "", []);
add_ocaml_element("__bin_read_move_insn__", "Arm_types.__bin_read_move_insn__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr ]", "Arm_types.html#VAL__bin_read_move_insn__", "", []);
add_ocaml_element("bin_writer_move_insn", "Arm_types.bin_writer_move_insn", "value", "[< `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_move_insn", "", []);
add_ocaml_element("bin_write_move_insn", "Arm_types.bin_write_move_insn", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `ADCri\n   | `ADCrr\n   | `ADCrsi\n   | `ADCrsr\n   | `ADDri\n   | `ADDrr\n   | `ADDrsi\n   | `ADDrsr\n   | `ANDri\n   | `ANDrr\n   | `ANDrsi\n   | `ANDrsr\n   | `BICri\n   | `BICrr\n   | `BICrsi\n   | `BICrsr\n   | `CMNri\n   | `CMNzrr\n   | `CMNzrsi\n   | `CMNzrsr\n   | `CMPri\n   | `CMPrr\n   | `CMPrsi\n   | `CMPrsr\n   | `EORri\n   | `EORrr\n   | `EORrsi\n   | `EORrsr\n   | `MOVPCLR\n   | `MOVTi16\n   | `MOVi\n   | `MOVi16\n   | `MOVr\n   | `MOVsi\n   | `MOVsr\n   | `MVNi\n   | `MVNr\n   | `MVNsi\n   | `MVNsr\n   | `ORRri\n   | `ORRrr\n   | `ORRrsi\n   | `ORRrsr\n   | `RSBri\n   | `RSBrr\n   | `RSBrsi\n   | `RSBrsr\n   | `RSCri\n   | `RSCrr\n   | `RSCrsi\n   | `RSCrsr\n   | `SBCri\n   | `SBCrr\n   | `SBCrsi\n   | `SBCrsr\n   | `SUBri\n   | `SUBrr\n   | `SUBrsi\n   | `SUBrsr\n   | `TEQri\n   | `TEQrr\n   | `TEQrsi\n   | `TEQrsr\n   | `TSTri\n   | `TSTrr\n   | `TSTrsi\n   | `TSTrsr ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_move_insn", "", []);
add_ocaml_element("bin_size_move_insn", "Arm_types.bin_size_move_insn", "value", "'a -> int", "Arm_types.html#VALbin_size_move_insn", "", []);
add_ocaml_element("bin_shape_move_insn", "Arm_types.bin_shape_move_insn", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_move_insn", "", []);
add_ocaml_element("sexp_of_op", "Arm_types.sexp_of_op", "value", "Arm_types.op -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_op", "", []);
add_ocaml_element("op_of_sexp", "Arm_types.op_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.op", "Arm_types.html#VALop_of_sexp", "", []);
add_ocaml_element("__op_of_sexp__", "Arm_types.__op_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.op", "Arm_types.html#VAL__op_of_sexp__", "", []);
add_ocaml_element("compare_op", "Arm_types.compare_op", "value", "Arm_types.op -> Arm_types.op -> int", "Arm_types.html#VALcompare_op", "", []);
add_ocaml_element("bin_op", "Arm_types.bin_op", "value", "[ `Imm of Std.word | `Reg of Arm_types.reg ]\n  Bin_prot.Type_class.t", "Arm_types.html#VALbin_op", "", []);
add_ocaml_element("bin_reader_op", "Arm_types.bin_reader_op", "value", "[> `Imm of Std.word | `Reg of Arm_types.reg ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_op", "", []);
add_ocaml_element("bin_read_op", "Arm_types.bin_read_op", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `Imm of Std.word | `Reg of Arm_types.reg ]", "Arm_types.html#VALbin_read_op", "", []);
add_ocaml_element("__bin_read_op__", "Arm_types.__bin_read_op__", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  int -> [> `Imm of Std.word | `Reg of Arm_types.reg ]", "Arm_types.html#VAL__bin_read_op__", "", []);
add_ocaml_element("bin_writer_op", "Arm_types.bin_writer_op", "value", "[< `Imm of Std.word\n   | `Reg of\n       [< `CPSR\n        | `ITSTATE\n        | `LR\n        | `Nil\n        | `PC\n        | `R0\n        | `R1\n        | `R10\n        | `R11\n        | `R12\n        | `R2\n        | `R3\n        | `R4\n        | `R5\n        | `R6\n        | `R7\n        | `R8\n        | `R9\n        | `SP\n        | `SPSR ] &\n       [< `CPSR\n        | `ITSTATE\n        | `LR\n        | `Nil\n        | `PC\n        | `R0\n        | `R1\n        | `R10\n        | `R11\n        | `R12\n        | `R2\n        | `R3\n        | `R4\n        | `R5\n        | `R6\n        | `R7\n        | `R8\n        | `R9\n        | `SP\n        | `SPSR ] ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_op", "", []);
add_ocaml_element("bin_write_op", "Arm_types.bin_write_op", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `Imm of Std.word\n   | `Reg of\n       [< `CPSR\n        | `ITSTATE\n        | `LR\n        | `Nil\n        | `PC\n        | `R0\n        | `R1\n        | `R10\n        | `R11\n        | `R12\n        | `R2\n        | `R3\n        | `R4\n        | `R5\n        | `R6\n        | `R7\n        | `R8\n        | `R9\n        | `SP\n        | `SPSR ] ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_op", "", []);
add_ocaml_element("bin_size_op", "Arm_types.bin_size_op", "value", "[< `Imm of Std.word\n   | `Reg of\n       [< `CPSR\n        | `ITSTATE\n        | `LR\n        | `Nil\n        | `PC\n        | `R0\n        | `R1\n        | `R10\n        | `R11\n        | `R12\n        | `R2\n        | `R3\n        | `R4\n        | `R5\n        | `R6\n        | `R7\n        | `R8\n        | `R9\n        | `SP\n        | `SPSR ] ] ->\n  int", "Arm_types.html#VALbin_size_op", "", []);
add_ocaml_element("bin_shape_op", "Arm_types.bin_shape_op", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_op", "", []);
add_ocaml_element("all_of_reg", "Arm_types.all_of_reg", "value", "Arm_types.reg list", "Arm_types.html#VALall_of_reg", "", []);
add_ocaml_element("sexp_of_reg", "Arm_types.sexp_of_reg", "value", "Arm_types.reg -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_reg", "", []);
add_ocaml_element("reg_of_sexp", "Arm_types.reg_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.reg", "Arm_types.html#VALreg_of_sexp", "", []);
add_ocaml_element("__reg_of_sexp__", "Arm_types.__reg_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.reg", "Arm_types.html#VAL__reg_of_sexp__", "", []);
add_ocaml_element("compare_reg", "Arm_types.compare_reg", "value", "Arm_types.reg -> Arm_types.reg -> int", "Arm_types.html#VALcompare_reg", "", []);
add_ocaml_element("bin_reg", "Arm_types.bin_reg", "value", "Arm_types.reg Bin_prot.Type_class.t", "Arm_types.html#VALbin_reg", "", []);
add_ocaml_element("bin_reader_reg", "Arm_types.bin_reader_reg", "value", "Arm_types.reg Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_reg", "", []);
add_ocaml_element("bin_read_reg", "Arm_types.bin_read_reg", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> Arm_types.reg", "Arm_types.html#VALbin_read_reg", "", []);
add_ocaml_element("__bin_read_reg__", "Arm_types.__bin_read_reg__", "value", "'a -> pos_ref:'b -> int -> Arm_types.reg", "Arm_types.html#VAL__bin_read_reg__", "", []);
add_ocaml_element("bin_writer_reg", "Arm_types.bin_writer_reg", "value", "[< `CPSR\n   | `ITSTATE\n   | `LR\n   | `Nil\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP\n   | `SPSR ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_reg", "", []);
add_ocaml_element("bin_write_reg", "Arm_types.bin_write_reg", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `CPSR\n   | `ITSTATE\n   | `LR\n   | `Nil\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP\n   | `SPSR ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_reg", "", []);
add_ocaml_element("bin_size_reg", "Arm_types.bin_size_reg", "value", "[< `CPSR\n   | `ITSTATE\n   | `LR\n   | `Nil\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP\n   | `SPSR ] ->\n  int", "Arm_types.html#VALbin_size_reg", "", []);
add_ocaml_element("bin_shape_reg", "Arm_types.bin_shape_reg", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_reg", "", []);
add_ocaml_element("all_of_non_nil_reg", "Arm_types.all_of_non_nil_reg", "value", "Arm_types.non_nil_reg list", "Arm_types.html#VALall_of_non_nil_reg", "", []);
add_ocaml_element("sexp_of_non_nil_reg", "Arm_types.sexp_of_non_nil_reg", "value", "Arm_types.non_nil_reg -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_non_nil_reg", "", []);
add_ocaml_element("non_nil_reg_of_sexp", "Arm_types.non_nil_reg_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.non_nil_reg", "Arm_types.html#VALnon_nil_reg_of_sexp", "", []);
add_ocaml_element("__non_nil_reg_of_sexp__", "Arm_types.__non_nil_reg_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.non_nil_reg", "Arm_types.html#VAL__non_nil_reg_of_sexp__", "", []);
add_ocaml_element("compare_non_nil_reg", "Arm_types.compare_non_nil_reg", "value", "Arm_types.non_nil_reg -> Arm_types.non_nil_reg -> int", "Arm_types.html#VALcompare_non_nil_reg", "", []);
add_ocaml_element("bin_non_nil_reg", "Arm_types.bin_non_nil_reg", "value", "Arm_types.non_nil_reg Bin_prot.Type_class.t", "Arm_types.html#VALbin_non_nil_reg", "", []);
add_ocaml_element("bin_reader_non_nil_reg", "Arm_types.bin_reader_non_nil_reg", "value", "Arm_types.non_nil_reg Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_non_nil_reg", "", []);
add_ocaml_element("bin_read_non_nil_reg", "Arm_types.bin_read_non_nil_reg", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> Arm_types.non_nil_reg", "Arm_types.html#VALbin_read_non_nil_reg", "", []);
add_ocaml_element("__bin_read_non_nil_reg__", "Arm_types.__bin_read_non_nil_reg__", "value", "'a -> pos_ref:'b -> int -> Arm_types.non_nil_reg", "Arm_types.html#VAL__bin_read_non_nil_reg__", "", []);
add_ocaml_element("bin_writer_non_nil_reg", "Arm_types.bin_writer_non_nil_reg", "value", "[< `CPSR\n   | `ITSTATE\n   | `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP\n   | `SPSR ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_non_nil_reg", "", []);
add_ocaml_element("bin_write_non_nil_reg", "Arm_types.bin_write_non_nil_reg", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `CPSR\n   | `ITSTATE\n   | `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP\n   | `SPSR ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_non_nil_reg", "", []);
add_ocaml_element("bin_size_non_nil_reg", "Arm_types.bin_size_non_nil_reg", "value", "[< `CPSR\n   | `ITSTATE\n   | `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP\n   | `SPSR ] ->\n  int", "Arm_types.html#VALbin_size_non_nil_reg", "", []);
add_ocaml_element("bin_shape_non_nil_reg", "Arm_types.bin_shape_non_nil_reg", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_non_nil_reg", "", []);
add_ocaml_element("all_of_ccr_or_nil", "Arm_types.all_of_ccr_or_nil", "value", "Arm_types.ccr_or_nil list", "Arm_types.html#VALall_of_ccr_or_nil", "", []);
add_ocaml_element("sexp_of_ccr_or_nil", "Arm_types.sexp_of_ccr_or_nil", "value", "Arm_types.ccr_or_nil -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_ccr_or_nil", "", []);
add_ocaml_element("ccr_or_nil_of_sexp", "Arm_types.ccr_or_nil_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.ccr_or_nil", "Arm_types.html#VALccr_or_nil_of_sexp", "", []);
add_ocaml_element("__ccr_or_nil_of_sexp__", "Arm_types.__ccr_or_nil_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.ccr_or_nil", "Arm_types.html#VAL__ccr_or_nil_of_sexp__", "", []);
add_ocaml_element("compare_ccr_or_nil", "Arm_types.compare_ccr_or_nil", "value", "Arm_types.ccr_or_nil -> Arm_types.ccr_or_nil -> int", "Arm_types.html#VALcompare_ccr_or_nil", "", []);
add_ocaml_element("bin_ccr_or_nil", "Arm_types.bin_ccr_or_nil", "value", "Arm_types.ccr_or_nil Bin_prot.Type_class.t", "Arm_types.html#VALbin_ccr_or_nil", "", []);
add_ocaml_element("bin_reader_ccr_or_nil", "Arm_types.bin_reader_ccr_or_nil", "value", "Arm_types.ccr_or_nil Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_ccr_or_nil", "", []);
add_ocaml_element("bin_read_ccr_or_nil", "Arm_types.bin_read_ccr_or_nil", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> Arm_types.ccr_or_nil", "Arm_types.html#VALbin_read_ccr_or_nil", "", []);
add_ocaml_element("__bin_read_ccr_or_nil__", "Arm_types.__bin_read_ccr_or_nil__", "value", "'a -> pos_ref:'b -> int -> Arm_types.ccr_or_nil", "Arm_types.html#VAL__bin_read_ccr_or_nil__", "", []);
add_ocaml_element("bin_writer_ccr_or_nil", "Arm_types.bin_writer_ccr_or_nil", "value", "[< `CPSR | `ITSTATE | `Nil | `SPSR ] Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_ccr_or_nil", "", []);
add_ocaml_element("bin_write_ccr_or_nil", "Arm_types.bin_write_ccr_or_nil", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `CPSR | `ITSTATE | `Nil | `SPSR ] -> Bin_prot.Common.pos", "Arm_types.html#VALbin_write_ccr_or_nil", "", []);
add_ocaml_element("bin_size_ccr_or_nil", "Arm_types.bin_size_ccr_or_nil", "value", "[< `CPSR | `ITSTATE | `Nil | `SPSR ] -> int", "Arm_types.html#VALbin_size_ccr_or_nil", "", []);
add_ocaml_element("bin_shape_ccr_or_nil", "Arm_types.bin_shape_ccr_or_nil", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_ccr_or_nil", "", []);
add_ocaml_element("all_of_ccr_reg", "Arm_types.all_of_ccr_reg", "value", "Arm_types.ccr_reg list", "Arm_types.html#VALall_of_ccr_reg", "", []);
add_ocaml_element("sexp_of_ccr_reg", "Arm_types.sexp_of_ccr_reg", "value", "Arm_types.ccr_reg -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_ccr_reg", "", []);
add_ocaml_element("ccr_reg_of_sexp", "Arm_types.ccr_reg_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.ccr_reg", "Arm_types.html#VALccr_reg_of_sexp", "", []);
add_ocaml_element("__ccr_reg_of_sexp__", "Arm_types.__ccr_reg_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.ccr_reg", "Arm_types.html#VAL__ccr_reg_of_sexp__", "", []);
add_ocaml_element("compare_ccr_reg", "Arm_types.compare_ccr_reg", "value", "Arm_types.ccr_reg -> Arm_types.ccr_reg -> int", "Arm_types.html#VALcompare_ccr_reg", "", []);
add_ocaml_element("bin_ccr_reg", "Arm_types.bin_ccr_reg", "value", "[ `CPSR | `ITSTATE | `SPSR ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_ccr_reg", "", []);
add_ocaml_element("bin_reader_ccr_reg", "Arm_types.bin_reader_ccr_reg", "value", "[> `CPSR | `ITSTATE | `SPSR ] Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_ccr_reg", "", []);
add_ocaml_element("bin_read_ccr_reg", "Arm_types.bin_read_ccr_reg", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> [> `CPSR | `ITSTATE | `SPSR ]", "Arm_types.html#VALbin_read_ccr_reg", "", []);
add_ocaml_element("__bin_read_ccr_reg__", "Arm_types.__bin_read_ccr_reg__", "value", "'a -> pos_ref:'b -> int -> [> `CPSR | `ITSTATE | `SPSR ]", "Arm_types.html#VAL__bin_read_ccr_reg__", "", []);
add_ocaml_element("bin_writer_ccr_reg", "Arm_types.bin_writer_ccr_reg", "value", "[< `CPSR | `ITSTATE | `SPSR ] Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_ccr_reg", "", []);
add_ocaml_element("bin_write_ccr_reg", "Arm_types.bin_write_ccr_reg", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `CPSR | `ITSTATE | `SPSR ] -> Bin_prot.Common.pos", "Arm_types.html#VALbin_write_ccr_reg", "", []);
add_ocaml_element("bin_size_ccr_reg", "Arm_types.bin_size_ccr_reg", "value", "'a -> int", "Arm_types.html#VALbin_size_ccr_reg", "", []);
add_ocaml_element("bin_shape_ccr_reg", "Arm_types.bin_shape_ccr_reg", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_ccr_reg", "", []);
add_ocaml_element("all_of_gpr_or_nil", "Arm_types.all_of_gpr_or_nil", "value", "Arm_types.gpr_or_nil list", "Arm_types.html#VALall_of_gpr_or_nil", "", []);
add_ocaml_element("sexp_of_gpr_or_nil", "Arm_types.sexp_of_gpr_or_nil", "value", "Arm_types.gpr_or_nil -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_gpr_or_nil", "", []);
add_ocaml_element("gpr_or_nil_of_sexp", "Arm_types.gpr_or_nil_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.gpr_or_nil", "Arm_types.html#VALgpr_or_nil_of_sexp", "", []);
add_ocaml_element("__gpr_or_nil_of_sexp__", "Arm_types.__gpr_or_nil_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.gpr_or_nil", "Arm_types.html#VAL__gpr_or_nil_of_sexp__", "", []);
add_ocaml_element("compare_gpr_or_nil", "Arm_types.compare_gpr_or_nil", "value", "Arm_types.gpr_or_nil -> Arm_types.gpr_or_nil -> int", "Arm_types.html#VALcompare_gpr_or_nil", "", []);
add_ocaml_element("bin_gpr_or_nil", "Arm_types.bin_gpr_or_nil", "value", "Arm_types.gpr_or_nil Bin_prot.Type_class.t", "Arm_types.html#VALbin_gpr_or_nil", "", []);
add_ocaml_element("bin_reader_gpr_or_nil", "Arm_types.bin_reader_gpr_or_nil", "value", "Arm_types.gpr_or_nil Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_gpr_or_nil", "", []);
add_ocaml_element("bin_read_gpr_or_nil", "Arm_types.bin_read_gpr_or_nil", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref -> Arm_types.gpr_or_nil", "Arm_types.html#VALbin_read_gpr_or_nil", "", []);
add_ocaml_element("__bin_read_gpr_or_nil__", "Arm_types.__bin_read_gpr_or_nil__", "value", "'a -> pos_ref:'b -> int -> Arm_types.gpr_or_nil", "Arm_types.html#VAL__bin_read_gpr_or_nil__", "", []);
add_ocaml_element("bin_writer_gpr_or_nil", "Arm_types.bin_writer_gpr_or_nil", "value", "[< `LR\n   | `Nil\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_gpr_or_nil", "", []);
add_ocaml_element("bin_write_gpr_or_nil", "Arm_types.bin_write_gpr_or_nil", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `LR\n   | `Nil\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_gpr_or_nil", "", []);
add_ocaml_element("bin_size_gpr_or_nil", "Arm_types.bin_size_gpr_or_nil", "value", "[< `LR\n   | `Nil\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ] ->\n  int", "Arm_types.html#VALbin_size_gpr_or_nil", "", []);
add_ocaml_element("bin_shape_gpr_or_nil", "Arm_types.bin_shape_gpr_or_nil", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_gpr_or_nil", "", []);
add_ocaml_element("all_of_gpr_reg", "Arm_types.all_of_gpr_reg", "value", "Arm_types.gpr_reg list", "Arm_types.html#VALall_of_gpr_reg", "", []);
add_ocaml_element("sexp_of_gpr_reg", "Arm_types.sexp_of_gpr_reg", "value", "Arm_types.gpr_reg -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_gpr_reg", "", []);
add_ocaml_element("gpr_reg_of_sexp", "Arm_types.gpr_reg_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.gpr_reg", "Arm_types.html#VALgpr_reg_of_sexp", "", []);
add_ocaml_element("__gpr_reg_of_sexp__", "Arm_types.__gpr_reg_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.gpr_reg", "Arm_types.html#VAL__gpr_reg_of_sexp__", "", []);
add_ocaml_element("compare_gpr_reg", "Arm_types.compare_gpr_reg", "value", "Arm_types.gpr_reg -> Arm_types.gpr_reg -> int", "Arm_types.html#VALcompare_gpr_reg", "", []);
add_ocaml_element("bin_gpr_reg", "Arm_types.bin_gpr_reg", "value", "[ `LR\n  | `PC\n  | `R0\n  | `R1\n  | `R10\n  | `R11\n  | `R12\n  | `R2\n  | `R3\n  | `R4\n  | `R5\n  | `R6\n  | `R7\n  | `R8\n  | `R9\n  | `SP ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_gpr_reg", "", []);
add_ocaml_element("bin_reader_gpr_reg", "Arm_types.bin_reader_gpr_reg", "value", "[> `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_gpr_reg", "", []);
add_ocaml_element("bin_read_gpr_reg", "Arm_types.bin_read_gpr_reg", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ]", "Arm_types.html#VALbin_read_gpr_reg", "", []);
add_ocaml_element("__bin_read_gpr_reg__", "Arm_types.__bin_read_gpr_reg__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ]", "Arm_types.html#VAL__bin_read_gpr_reg__", "", []);
add_ocaml_element("bin_writer_gpr_reg", "Arm_types.bin_writer_gpr_reg", "value", "[< `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_gpr_reg", "", []);
add_ocaml_element("bin_write_gpr_reg", "Arm_types.bin_write_gpr_reg", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `LR\n   | `PC\n   | `R0\n   | `R1\n   | `R10\n   | `R11\n   | `R12\n   | `R2\n   | `R3\n   | `R4\n   | `R5\n   | `R6\n   | `R7\n   | `R8\n   | `R9\n   | `SP ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_gpr_reg", "", []);
add_ocaml_element("bin_size_gpr_reg", "Arm_types.bin_size_gpr_reg", "value", "'a -> int", "Arm_types.html#VALbin_size_gpr_reg", "", []);
add_ocaml_element("bin_shape_gpr_reg", "Arm_types.bin_shape_gpr_reg", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_gpr_reg", "", []);
add_ocaml_element("all_of_nil_reg", "Arm_types.all_of_nil_reg", "value", "Arm_types.nil_reg list", "Arm_types.html#VALall_of_nil_reg", "", []);
add_ocaml_element("sexp_of_nil_reg", "Arm_types.sexp_of_nil_reg", "value", "Arm_types.nil_reg -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_nil_reg", "", []);
add_ocaml_element("nil_reg_of_sexp", "Arm_types.nil_reg_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.nil_reg", "Arm_types.html#VALnil_reg_of_sexp", "", []);
add_ocaml_element("__nil_reg_of_sexp__", "Arm_types.__nil_reg_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.nil_reg", "Arm_types.html#VAL__nil_reg_of_sexp__", "", []);
add_ocaml_element("compare_nil_reg", "Arm_types.compare_nil_reg", "value", "Arm_types.nil_reg -> Arm_types.nil_reg -> int", "Arm_types.html#VALcompare_nil_reg", "", []);
add_ocaml_element("bin_nil_reg", "Arm_types.bin_nil_reg", "value", "[ `Nil ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_nil_reg", "", []);
add_ocaml_element("bin_reader_nil_reg", "Arm_types.bin_reader_nil_reg", "value", "[> `Nil ] Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_nil_reg", "", []);
add_ocaml_element("bin_read_nil_reg", "Arm_types.bin_read_nil_reg", "value", "Bin_prot.Common.buf -> pos_ref:Bin_prot.Common.pos_ref -> [> `Nil ]", "Arm_types.html#VALbin_read_nil_reg", "", []);
add_ocaml_element("__bin_read_nil_reg__", "Arm_types.__bin_read_nil_reg__", "value", "'a -> pos_ref:'b -> int -> [> `Nil ]", "Arm_types.html#VAL__bin_read_nil_reg__", "", []);
add_ocaml_element("bin_writer_nil_reg", "Arm_types.bin_writer_nil_reg", "value", "[< `Nil ] Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_nil_reg", "", []);
add_ocaml_element("bin_write_nil_reg", "Arm_types.bin_write_nil_reg", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos -> [< `Nil ] -> Bin_prot.Common.pos", "Arm_types.html#VALbin_write_nil_reg", "", []);
add_ocaml_element("bin_size_nil_reg", "Arm_types.bin_size_nil_reg", "value", "'a -> int", "Arm_types.html#VALbin_size_nil_reg", "", []);
add_ocaml_element("bin_shape_nil_reg", "Arm_types.bin_shape_nil_reg", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_nil_reg", "", []);
add_ocaml_element("all_of_cond", "Arm_types.all_of_cond", "value", "Arm_types.cond list", "Arm_types.html#VALall_of_cond", "", []);
add_ocaml_element("sexp_of_cond", "Arm_types.sexp_of_cond", "value", "Arm_types.cond -> Ppx_sexp_conv_lib.Sexp.t", "Arm_types.html#VALsexp_of_cond", "", []);
add_ocaml_element("cond_of_sexp", "Arm_types.cond_of_sexp", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.cond", "Arm_types.html#VALcond_of_sexp", "", []);
add_ocaml_element("__cond_of_sexp__", "Arm_types.__cond_of_sexp__", "value", "Ppx_sexp_conv_lib.Sexp.t -> Arm_types.cond", "Arm_types.html#VAL__cond_of_sexp__", "", []);
add_ocaml_element("compare_cond", "Arm_types.compare_cond", "value", "Arm_types.cond -> Arm_types.cond -> int", "Arm_types.html#VALcompare_cond", "", []);
add_ocaml_element("bin_cond", "Arm_types.bin_cond", "value", "[ `AL\n  | `CC\n  | `CS\n  | `EQ\n  | `GE\n  | `GT\n  | `HI\n  | `LE\n  | `LS\n  | `LT\n  | `MI\n  | `NE\n  | `PL\n  | `VC\n  | `VS ] Bin_prot.Type_class.t", "Arm_types.html#VALbin_cond", "", []);
add_ocaml_element("bin_reader_cond", "Arm_types.bin_reader_cond", "value", "[> `AL\n   | `CC\n   | `CS\n   | `EQ\n   | `GE\n   | `GT\n   | `HI\n   | `LE\n   | `LS\n   | `LT\n   | `MI\n   | `NE\n   | `PL\n   | `VC\n   | `VS ]\n  Bin_prot.Type_class.reader", "Arm_types.html#VALbin_reader_cond", "", []);
add_ocaml_element("bin_read_cond", "Arm_types.bin_read_cond", "value", "Bin_prot.Common.buf ->\n  pos_ref:Bin_prot.Common.pos_ref ->\n  [> `AL\n   | `CC\n   | `CS\n   | `EQ\n   | `GE\n   | `GT\n   | `HI\n   | `LE\n   | `LS\n   | `LT\n   | `MI\n   | `NE\n   | `PL\n   | `VC\n   | `VS ]", "Arm_types.html#VALbin_read_cond", "", []);
add_ocaml_element("__bin_read_cond__", "Arm_types.__bin_read_cond__", "value", "'a ->\n  pos_ref:'b ->\n  int ->\n  [> `AL\n   | `CC\n   | `CS\n   | `EQ\n   | `GE\n   | `GT\n   | `HI\n   | `LE\n   | `LS\n   | `LT\n   | `MI\n   | `NE\n   | `PL\n   | `VC\n   | `VS ]", "Arm_types.html#VAL__bin_read_cond__", "", []);
add_ocaml_element("bin_writer_cond", "Arm_types.bin_writer_cond", "value", "[< `AL\n   | `CC\n   | `CS\n   | `EQ\n   | `GE\n   | `GT\n   | `HI\n   | `LE\n   | `LS\n   | `LT\n   | `MI\n   | `NE\n   | `PL\n   | `VC\n   | `VS ]\n  Bin_prot.Type_class.writer", "Arm_types.html#VALbin_writer_cond", "", []);
add_ocaml_element("bin_write_cond", "Arm_types.bin_write_cond", "value", "Bin_prot.Common.buf ->\n  pos:Bin_prot.Common.pos ->\n  [< `AL\n   | `CC\n   | `CS\n   | `EQ\n   | `GE\n   | `GT\n   | `HI\n   | `LE\n   | `LS\n   | `LT\n   | `MI\n   | `NE\n   | `PL\n   | `VC\n   | `VS ] ->\n  Bin_prot.Common.pos", "Arm_types.html#VALbin_write_cond", "", []);
add_ocaml_element("bin_size_cond", "Arm_types.bin_size_cond", "value", "'a -> int", "Arm_types.html#VALbin_size_cond", "", []);
add_ocaml_element("bin_shape_cond", "Arm_types.bin_shape_cond", "value", "Bin_prot.Shape.t", "Arm_types.html#VALbin_shape_cond", "", []);
add_ocaml_element("lift", "Arm_mov.lift", "value", "?dest:Arm_types.op ->\n  Arm_types.op ->\n  ?src2:Arm_types.op ->\n  Arm_types.data_oper ->\n  ?sreg:Arm_types.op ->\n  ?simm:Arm_types.op ->\n  Std.word -> wflag:Arm_types.op -> Arm_types.op -> Std.stmt list", "Arm_mov.html#VALlift", "", []);
add_ocaml_element("lift_mem", "Arm_shift.lift_mem", "value", "src:Std.exp -> Arm_types.op -> Std.typ -> Std.exp", "Arm_shift.html#VALlift_mem", "<div class=\"info\">\n<p>decodes a shifted operand for a memory operation\n * src - the operand to be shifted\n * shift - an int64,\n *            bits 11 through 0 represent the shift amount\n *            bits 12 represents whether the expression is added or subtracted\n *            bits 15 through 13 represent the shift type, valid shift types\n *              are number 1 through 5\n * typ - the type\n *</p>\n\n</div>\n", ["ADDED", "AMOUNT", "ARE", "BITS", "DECODES", "EXPRESSION", "FOR", "INT64", "MEMORY", "NUMBER", "OPERAND", "OPERATION", "REPRESENT", "REPRESENTS", "SHIFT", "SHIFTED", "SRC", "SUBTRACTED", "THE", "THROUGH", "TYP", "TYPE", "TYPES", "VALID", "WHETHER"]);
add_ocaml_element("lift_i", "Arm_shift.lift_i", "value", "src:Std.exp -> Arm_types.op -> Std.typ -> Std.exp * Std.exp", "Arm_shift.html#VALlift_i", "<div class=\"info\">\n<p>decodes an immediate shifted operand\n * src - the operand to be shifted, cannot be the destination\n *        in practice this means it must be a temp variable.</p>\n\n</div>\n", ["AMOUNT", "AND", "ARE", "BITS", "CANNOT", "DECODES", "DESTINATION", "FOR", "HIGHER", "IMMEDIATE", "IMPLIED", "INT64", "MEANS", "MUST", "NUMBER", "OPERAND", "PRACTICE", "REGISTER", "REPRESENT", "RRX", "SHIFT", "SHIFTED", "SHIFTS", "SHIFT_TYPE", "SRC", "TEMP", "THE", "THESE", "THIS", "THROUGH", "TYPE", "TYPES", "UPPER", "VALID", "VARIABLE"]);
add_ocaml_element("lift_r", "Arm_shift.lift_r", "value", "src:Std.exp ->\n  Arm_types.op -> shift:Std.exp -> Std.typ -> Std.exp * Std.exp", "Arm_shift.html#VALlift_r", "", []);
add_ocaml_element("lift_c", "Arm_shift.lift_c", "value", "src:Std.exp ->\n  Arm_types.shift ->\n  shift:Std.exp -> Std.typ -> Std.exp * Std.exp", "Arm_shift.html#VALlift_c", "<div class=\"info\">\n<p>Need the operand and the carry flag value src - the source, if you\n    intend to use the carry bit, this must not be the destination of the\n    shift expression.</p>\n\n</div>\n", ["ACTUAL", "AMOUNT", "AND", "BIT", "CARRY", "CONTAINS", "DESTINATION", "EXP", "EXPRESSION", "FLAG", "FOR", "IGNORED", "INTEND", "ITSELF", "MEANS", "MUST", "NEED", "NOT", "OPERAND", "RRX", "SHIFT", "SHIFT_TYPE", "SOURCE", "SRC", "TEMP", "THAT", "THE", "THIS", "TYPE", "USE", "VALUE", "YOU"]);
add_ocaml_element("create", "Arm_reg.create", "value", "Std.reg -> Arm_reg.t option", "Arm_reg.html#VALcreate", "<div class=\"info\">\n<p>lifts basic register to a ARM one</p>\n\n</div>\n", ["ARM", "BASIC", "LIFTS", "ONE", "REGISTER"]);
add_ocaml_element("create", "Arm_cond.create", "value", "Std.word -> Arm_types.cond Or_error.t", "Arm_cond.html#VALcreate", "<div class=\"info\">\n<p>decodes condition value from a word</p>\n\n</div>\n", ["CONDITION", "DECODES", "FROM", "VALUE", "WORD"]);
add_ocaml_element("lift", "Arm_branch.lift", "value", "Arm_types.op ->\n  ?link:bool ->\n  ?x:bool -> ?cond:Arm_types.op -> Std.word -> Std.stmt list", "Arm_branch.html#VALlift", "", []);
add_ocaml_element("bit_extract", "Arm_bit.bit_extract", "value", "dest:Arm_types.op ->\n  src:Arm_types.op ->\n  Arm_types.sign ->\n  lsb:Arm_types.op ->\n  widthminus1:Arm_types.op -> Arm_types.op -> Std.stmt list", "Arm_bit.html#VALbit_extract", "", []);
add_ocaml_element("bit_field_insert", "Arm_bit.bit_field_insert", "value", "dest:Arm_types.op ->\n  src:Arm_types.op -> Std.Word.t -> Arm_types.op -> Std.stmt list", "Arm_bit.html#VALbit_field_insert", "", []);
add_ocaml_element("extend", "Arm_bit.extend", "value", "dest:Arm_types.op ->\n  src:Arm_types.op ->\n  ?src2:Arm_types.op ->\n  Arm_types.sign ->\n  [< `B | `H ] -> rot:Arm_types.op -> Arm_types.op -> Std.stmt list", "Arm_bit.html#VALextend", "", []);
add_ocaml_element("create", "Arm_op.create", "value", "Std.op -> Arm_op.t option", "Arm_op.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;op</code> projects bap generic operand into arm specific.</p>\n\n</div>\n", ["ARE", "ARM", "BAP", "CREATE", "CURRENTLY", "FLOATING", "GENERIC", "IGNORED", "INTO", "OPERAND", "OPERANDS", "POINT", "PROJECTS", "SPECIFIC"]);
add_ocaml_element("lift_m", "Arm_mem.lift_m", "value", "Std.var list ->\n  Std.var ->\n  Arm_types.mode_m ->\n  Arm_types.update_m -> Arm_types.operation -> Std.stmt list", "Arm_mem.html#VALlift_m", "", []);
add_ocaml_element("lift_r", "Arm_mem.lift_r", "value", "dst1:Std.var ->\n  ?dst2:Std.var ->\n  base:Std.var ->\n  offset:Std.exp ->\n  Arm_types.mode_r ->\n  Arm_types.sign -> Arm_types.size -> Arm_types.operation -> Std.stmt list", "Arm_mem.html#VALlift_r", "", []);
add_ocaml_element("mem", "Arm_env.mem", "value", "Std.var", "Arm_env.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem</code> BIL variable that denotes the system memory.</p>\n\n</div>\n", ["BIL", "DENOTES", "MEM", "MEMORY", "SYSTEM", "THAT", "THE", "VARIABLE"]);
add_ocaml_element("new_var", "Arm_env.new_var", "value", "string -> Std.var", "Arm_env.html#VALnew_var", "<div class=\"info\">\n<p><code class=\"code\">new_var&nbsp;name</code> creates a freshly new variable prefixed with <code class=\"code\">name</code></p>\n\n</div>\n", ["CREATES", "FRESHLY", "NAME", "NEW", "NEW_VAR", "PREFIXED", "VARIABLE", "WITH"]);
add_ocaml_element("of_reg", "Arm_env.of_reg", "value", "Arm_types.reg -> Std.var", "Arm_env.html#VALof_reg", "<div class=\"info\">\n<p><code class=\"code\">of_reg&nbsp;arm_reg</code> lifts arm register into BIL variable</p>\n\n</div>\n", ["ARM", "ARM_REG", "BIL", "INTO", "LIFTS", "OF_REG", "REGISTER", "VARIABLE"]);
add_ocaml_element("r12", "Arm_env.r12", "value", "Std.var", "Arm_env.html#VALr12", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r11", "Arm_env.r11", "value", "Std.var", "Arm_env.html#VALr11", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r10", "Arm_env.r10", "value", "Std.var", "Arm_env.html#VALr10", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r9", "Arm_env.r9", "value", "Std.var", "Arm_env.html#VALr9", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r8", "Arm_env.r8", "value", "Std.var", "Arm_env.html#VALr8", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r7", "Arm_env.r7", "value", "Std.var", "Arm_env.html#VALr7", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r6", "Arm_env.r6", "value", "Std.var", "Arm_env.html#VALr6", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r5", "Arm_env.r5", "value", "Std.var", "Arm_env.html#VALr5", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r4", "Arm_env.r4", "value", "Std.var", "Arm_env.html#VALr4", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r3", "Arm_env.r3", "value", "Std.var", "Arm_env.html#VALr3", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r2", "Arm_env.r2", "value", "Std.var", "Arm_env.html#VALr2", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r1", "Arm_env.r1", "value", "Std.var", "Arm_env.html#VALr1", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("r0", "Arm_env.r0", "value", "Std.var", "Arm_env.html#VALr0", "<div class=\"info\">\n<p>general purpose register</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTER"]);
add_ocaml_element("sp", "Arm_env.sp", "value", "Std.var", "Arm_env.html#VALsp", "<div class=\"info\">\n<p><code class=\"code\">sp</code> Stack Pointer</p>\n\n</div>\n", ["POINTER", "STACK"]);
add_ocaml_element("pc", "Arm_env.pc", "value", "Std.var", "Arm_env.html#VALpc", "<div class=\"info\">\n<p><code class=\"code\">pc</code> Program Counter</p>\n\n</div>\n", ["COUNTER", "PROGRAM"]);
add_ocaml_element("lr", "Arm_env.lr", "value", "Std.var", "Arm_env.html#VALlr", "<div class=\"info\">\n<p><code class=\"code\">lr</code> Link Register</p>\n\n</div>\n", ["LINK", "REGISTER"]);
add_ocaml_element("itstate", "Arm_env.itstate", "value", "Std.var", "Arm_env.html#VALitstate", "<div class=\"info\">\n<p><code class=\"code\">itstate</code> ITSTATE register</p>\n\n</div>\n", ["ITSTATE", "REGISTER"]);
add_ocaml_element("ge", "Arm_env.ge", "value", "Std.var array", "Arm_env.html#VALge", "<div class=\"info\">\n<p><code class=\"code\">ge</code> array of general registers</p>\n\n</div>\n", ["ARRAY", "GENERAL", "REGISTERS"]);
add_ocaml_element("qf", "Arm_env.qf", "value", "Std.var", "Arm_env.html#VALqf", "<div class=\"info\">\n<p><code class=\"code\">qf</code> underflow (saturation) Flag</p>\n\n</div>\n", ["FLAG", "SATURATION", "UNDERFLOW"]);
add_ocaml_element("vf", "Arm_env.vf", "value", "Std.var", "Arm_env.html#VALvf", "<div class=\"info\">\n<p><code class=\"code\">vf</code> oVerfrlow Flag</p>\n\n</div>\n", ["FLAG", "OVERFRLOW"]);
add_ocaml_element("cf", "Arm_env.cf", "value", "Std.var", "Arm_env.html#VALcf", "<div class=\"info\">\n<p><code class=\"code\">cf</code> Carry Flag</p>\n\n</div>\n", ["CARRY", "FLAG"]);
add_ocaml_element("zf", "Arm_env.zf", "value", "Std.var", "Arm_env.html#VALzf", "<div class=\"info\">\n<p><code class=\"code\">zf</code> Zero Flag</p>\n\n</div>\n", ["FLAG", "ZERO"]);
add_ocaml_element("nf", "Arm_env.nf", "value", "Std.var", "Arm_env.html#VALnf", "<div class=\"info\">\n<p><code class=\"code\">nf</code> Negative Flag</p>\n\n</div>\n", ["FLAG", "NEGATIVE"]);
add_ocaml_element("cpsr", "Arm_env.cpsr", "value", "Std.var", "Arm_env.html#VALcpsr", "<div class=\"info\">\n<p><code class=\"code\">cpsr</code> Current Processor Status Register</p>\n\n</div>\n", ["CPSR", "CURRENT", "PROCESSOR", "REGISTER", "STATUS"]);
add_ocaml_element("spsr", "Arm_env.spsr", "value", "Std.var", "Arm_env.html#VALspsr", "<div class=\"info\">\n<p><code class=\"code\">spsr</code>  Saved Processor Status Register</p>\n\n</div>\n", ["PROCESSOR", "REGISTER", "SAVED", "SPSR", "STATUS"]);
add_ocaml_element("set_cf_data", "Arm_flags.set_cf_data", "value", "imm:Std.word -> data:Std.word -> Std.stmt", "Arm_flags.html#VALset_cf_data", "", []);
add_ocaml_element("set_sbc", "Arm_flags.set_sbc", "value", "Std.exp -> Std.exp -> Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_sbc", "", []);
add_ocaml_element("set_adc", "Arm_flags.set_adc", "value", "Std.exp -> Std.exp -> Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_adc", "", []);
add_ocaml_element("set_vnzf_sub", "Arm_flags.set_vnzf_sub", "value", "Std.exp -> Std.exp -> Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_vnzf_sub", "", []);
add_ocaml_element("set_sub", "Arm_flags.set_sub", "value", "Std.exp -> Std.exp -> Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_sub", "", []);
add_ocaml_element("set_add", "Arm_flags.set_add", "value", "Std.exp -> Std.exp -> Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_add", "", []);
add_ocaml_element("set_vnzf_add", "Arm_flags.set_vnzf_add", "value", "Std.exp -> Std.exp -> Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_vnzf_add", "", []);
add_ocaml_element("set_nzf", "Arm_flags.set_nzf", "value", "Std.exp -> Std.typ -> Std.stmt list", "Arm_flags.html#VALset_nzf", "", []);
add_ocaml_element("mem_offset_reg_or_imm_pos", "Arm_mem_shift.mem_offset_reg_or_imm_pos", "value", "Arm_types.op -> Std.word -> Std.exp", "Arm_mem_shift.html#VALmem_offset_reg_or_imm_pos", "", []);
add_ocaml_element("mem_offset_reg_or_imm_neg", "Arm_mem_shift.mem_offset_reg_or_imm_neg", "value", "Arm_types.op -> Std.word -> Std.exp", "Arm_mem_shift.html#VALmem_offset_reg_or_imm_neg", "", []);
add_ocaml_element("repair_reg", "Arm_mem_shift.repair_reg", "value", "Std.exp ->\n  Std.word -> sign_mask:int -> Arm_types.repair -> Std.exp", "Arm_mem_shift.html#VALrepair_reg", "", []);
add_ocaml_element("repair_imm", "Arm_mem_shift.repair_imm", "value", "Std.word ->\n  sign_mask:int -> imm_mask:int -> Arm_types.repair -> Std.exp", "Arm_mem_shift.html#VALrepair_imm", "<div class=\"info\">\n<p>takes a word and converts it to an exp that is the offset for some\n    memory instructions sign_mask - a bitmask that determines the bit\n    in src that is the repair bit imm_mask - a bitmask that determines\n    which bits in src are the immediate type - whether a set mask\n    indicates a positive or negative immediate.</p>\n\n</div>\n", ["AND", "ARE", "BIT", "BITMASK", "BITS", "CONVERTS", "DETERMINES", "EXP", "FOR", "IMMEDIATE", "IMM_MASK", "INDICATES", "INSTRUCTIONS", "MASK", "MEMORY", "NEGATIVE", "OFFSET", "POSITIVE", "REPAIR", "SET", "SIGN_MASK", "SOME", "SRC", "TAKES", "THAT", "THE", "TYPE", "WHETHER", "WHICH", "WORD"]);
add_ocaml_element("lift_m", "Arm_mem_shift.lift_m", "value", "Arm_types.op list ->\n  Arm_types.op ->\n  Arm_types.mode_m ->\n  Arm_types.update_m -> Arm_types.operation -> Std.stmt list", "Arm_mem_shift.html#VALlift_m", "", []);
add_ocaml_element("lift_r_op", "Arm_mem_shift.lift_r_op", "value", "dest1:Arm_types.op ->\n  ?dest2:Arm_types.op ->\n  ?shift:Arm_types.op ->\n  base:Arm_types.op ->\n  offset:Arm_types.op ->\n  Arm_types.mode_r ->\n  Arm_types.sign -> Arm_types.size -> Arm_types.operation -> Std.stmt list", "Arm_mem_shift.html#VALlift_r_op", "", []);
add_ocaml_element("lift_r_exp", "Arm_mem_shift.lift_r_exp", "value", "dest1:Arm_types.op ->\n  ?dest2:Arm_types.op ->\n  base:Arm_types.op ->\n  offset:Std.exp ->\n  Arm_types.mode_r ->\n  Arm_types.sign -> Arm_types.size -> Arm_types.operation -> Std.stmt list", "Arm_mem_shift.html#VALlift_r_exp", "", []);
add_ocaml_element("zero", "Arm_utils.zero", "value", "Std.typ -> Std.exp", "Arm_utils.html#VALzero", "", []);
add_ocaml_element("msb", "Arm_utils.msb", "value", "Std.exp -> Std.exp", "Arm_utils.html#VALmsb", "", []);
add_ocaml_element("assert_cond", "Arm_utils.assert_cond", "value", "Source_code_position.t -> Arm_types.op -> Arm_types.cond", "Arm_utils.html#VALassert_cond", "", []);
add_ocaml_element("assert_imm", "Arm_utils.assert_imm", "value", "Source_code_position.t -> Arm_types.op -> Std.word", "Arm_utils.html#VALassert_imm", "", []);
add_ocaml_element("assert_reg", "Arm_utils.assert_reg", "value", "Source_code_position.t -> Arm_types.op -> Arm_types.reg", "Arm_utils.html#VALassert_reg", "", []);
add_ocaml_element("cast_of_sign", "Arm_utils.cast_of_sign", "value", "Arm_types.sign -> int -> Std.exp -> Std.exp", "Arm_utils.html#VALcast_of_sign", "", []);
add_ocaml_element("exp_of_reg", "Arm_utils.exp_of_reg", "value", "Arm_types.reg -> Std.exp", "Arm_utils.html#VALexp_of_reg", "", []);
add_ocaml_element("exp_of_op", "Arm_utils.exp_of_op", "value", "Arm_types.op -> Std.exp", "Arm_utils.html#VALexp_of_op", "", []);
add_ocaml_element("exec", "Arm_utils.exec", "value", "Std.stmt list ->\n  ?flags:Std.stmt list ->\n  ?wflag:Arm_types.op -> Arm_types.op -> Std.stmt list", "Arm_utils.html#VALexec", "", []);
add_ocaml_element("bitlen", "Arm_utils.bitlen", "value", "Std.typ -> int", "Arm_utils.html#VALbitlen", "", []);
add_ocaml_element("fail", "Arm_utils.fail", "value", "Source_code_position.t ->\n  ('a, unit, string, 'b) format4 -> 'a", "Arm_utils.html#VALfail", "", []);
add_ocaml_element("assn", "Arm_utils.assn", "value", "Std.var -> Std.exp -> Std.stmt", "Arm_utils.html#VALassn", "", []);
add_ocaml_element("tmp", "Arm_utils.tmp", "value", "?name:string -> Std.typ -> Std.var", "Arm_utils.html#VALtmp", "", []);
add_ocaml_element("lift_smul", "Arm_mul.lift_smul", "value", "dest:Arm_types.op ->\n  ?hidest:Arm_types.op ->\n  src1:Arm_types.op ->\n  src2:Arm_types.op ->\n  ?accum:Arm_types.op ->\n  ?hiaccum:Arm_types.op ->\n  ?q:bool -> Arm_types.smul_size -> Arm_types.op -> Std.stmt list", "Arm_mul.html#VALlift_smul", "", []);
add_ocaml_element("lift_mull", "Arm_mul.lift_mull", "value", "lodest:Arm_types.op ->\n  hidest:Arm_types.op ->\n  src1:Arm_types.op ->\n  src2:Arm_types.op ->\n  Arm_types.sign ->\n  ?addend:'a -> wflag:Arm_types.op -> Arm_types.op -> Std.stmt list", "Arm_mul.html#VALlift_mull", "", []);
add_ocaml_element("of_basic", "Arm_insn.of_basic", "value", "('a, 'b) Std.Disasm_expert.Basic.insn -> Arm_insn.t option", "Arm_insn.html#VALof_basic", "<div class=\"info\">\n<p><code class=\"code\">of_basic&nbsp;insn</code> translate from BAP basic <code class=\"code\">insn</code></p>\n\n</div>\n", ["BAP", "BASIC", "FROM", "INSN", "OF_BASIC", "TRANSLATE"]);
add_ocaml_element("create", "Arm_insn.create", "value", "Std.insn -> Arm_insn.t option", "Arm_insn.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;insn</code> translate from BAP <code class=\"code\">insn</code></p>\n\n</div>\n", ["BAP", "CREATE", "FROM", "INSN", "TRANSLATE"]);
add_ocaml_element("report_error", "Bare.Rule.report_error", "value", "?filename:string -> Stdlib.Format.formatter -> Bare.Rule.error -> unit", "Bare.Rule.html#VALreport_error", "", []);
add_ocaml_element("reset", "Bare.Rule.reset", "value", "Bare.Rule.t -> Bare.Rule.t", "Bare.Rule.html#VALreset", "<div class=\"info\">\n<p><code class=\"code\">reset&nbsp;rule</code> discards the matching state and returns a fresh rule.</p>\n\n</div>\n", ["AND", "DISCARDS", "FRESH", "MATCHING", "RESET", "RETURNS", "RULE", "STATE", "THE"]);
add_ocaml_element("apply", "Bare.Rule.apply", "value", "Bare.Rule.t -> Bare.fact -> Bare.Rule.t * Bare.fact list", "Bare.Rule.html#VALapply", "<div class=\"info\">\n<p><code class=\"code\">apply&nbsp;rule&nbsp;fact</code> applies <code class=\"code\">rule</code> to <code class=\"code\">fact</code> and produces a new\n      rule that contains a partial mathcing state, as well as a list\n      (possibly empty) of newly produced facts.</p>\n\n</div>\n", ["AND", "APPLIES", "APPLY", "CONTAINS", "EMPTY", "FACT", "FACTS", "LIST", "MATHCING", "NEW", "NEWLY", "PARTIAL", "POSSIBLY", "PRODUCED", "PRODUCES", "RULE", "STATE", "THAT", "WELL"]);
add_ocaml_element("pp", "Bare.Rule.pp", "value", "Stdlib.Format.formatter -> Bare.Rule.t -> unit", "Bare.Rule.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;ppf&nbsp;rule</code> prints <code class=\"code\">rule</code> into the formatter <code class=\"code\">ppf</code>.</p>\n\n</div>\n", ["FORMATTER", "INTO", "PPF", "PRINTS", "RULE", "THE"]);
add_ocaml_element("spec", "Bare.Rule.spec", "value", "Bare.Rule.t -> string", "Bare.Rule.html#VALspec", "<div class=\"info\">\n<p><code class=\"code\">spec&nbsp;rule</code> is the human readable and machine parseable\n      well-formed rule specification.</p>\n\n</div>\n", ["AND", "FORMED", "HUMAN", "MACHINE", "PARSEABLE", "READABLE", "RULE", "SPEC", "SPECIFICATION", "THE", "WELL"]);
add_ocaml_element("rhs", "Bare.Rule.rhs", "value", "Bare.Rule.t -> Bare.fact list", "Bare.Rule.html#VALrhs", "<div class=\"info\">\n<p><code class=\"code\">rhs&nbsp;rule</code> is the right hand side of the rule</p>\n\n</div>\n", ["HAND", "RHS", "RIGHT", "RULE", "SIDE", "THE"]);
add_ocaml_element("lhs", "Bare.Rule.lhs", "value", "Bare.Rule.t -> Bare.tuple list", "Bare.Rule.html#VALlhs", "<div class=\"info\">\n<p><code class=\"code\">lhs&nbsp;rule</code> is the left hand side of the rule.</p>\n\n</div>\n", ["HAND", "LEFT", "LHS", "RULE", "SIDE", "THE"]);
add_ocaml_element("of_string", "Bare.Rule.of_string", "value", "string -> Bare.Rule.t", "Bare.Rule.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;s</code> parses the rule specification <code class=\"code\">s</code>.</p>\n\n</div>\n", ["FORMED", "OF_STRING", "PARSES", "PRECONDITION", "RULE", "SPECIFICATION", "THE", "WELL"]);
add_ocaml_element("from_file", "Bare.Rule.from_file", "value", "string -> (Bare.Rule.t list, Bare.Rule.error) Result.t", "Bare.Rule.html#VALfrom_file", "<div class=\"info\">\n<p><code class=\"code\">from_file&nbsp;name</code> parses a file that contains zero or more rule\n      specifications.</p>\n\n</div>\n", ["ALL", "AND", "CONTAINS", "DESCRIPTION", "DETAILED", "ERROR", "FILE", "FORMED", "FROM_FILE", "GRAMMAR", "LOCATION", "MORE", "NAME", "NOT", "OTHERWISE", "PARSES", "PART", "RETURNS", "RULE", "RULES", "SPECIFICATIONS", "SUBTERM", "THAT", "THE", "WELL", "WERE", "WITH", "ZERO"]);
add_ocaml_element("from_string", "Bare.Rule.from_string", "value", "string -> (Bare.Rule.t list, Bare.Rule.error) Result.t", "Bare.Rule.html#VALfrom_string", "", []);
add_ocaml_element("add_printer", "Std.Primus.Exn.add_printer", "value", "(Std.Primus.Exn.t -> string option) -> unit", "Bap_primus.Std.Primus.Exn.html#VALadd_printer", "<div class=\"info\">\n<p><code class=\"code\">add_printer&nbsp;to_string</code> registers a printer.</p>\n\n</div>\n", ["ADD_PRINTER", "PRINTER", "REGISTERS", "TO_STRING"]);
add_ocaml_element("to_string", "Std.Primus.Exn.to_string", "value", "Std.Primus.Exn.t -> string", "Bap_primus.Std.Primus.Exn.html#VALto_string", "<div class=\"info\">\n<p>returns a textual representation of an error</p>\n\n</div>\n", ["ERROR", "REPRESENTATION", "RETURNS", "TEXTUAL"]);
add_ocaml_element("defs", "Std.Primus.Lisp.Primitives.defs", "value", "unit ->\n  Std.Primus.value Machine.t Std.Primus.Lisp.Primitive.t\n  list", "Bap_primus.Std.Primus.Lisp.Primitives.html#VALdefs", "", []);
add_ocaml_element("run", "Std.Primus.Lisp.Closure.run", "value", "Std.Primus.value list -> Std.Primus.value Machine.t", "Bap_primus.Std.Primus.Lisp.Closure.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;args</code> performs the computation.</p>\n\n</div>\n", ["ARGS", "COMPUTATION", "PERFORMS", "RUN", "THE"]);
add_ocaml_element("link_primitives", "Std.Primus.Lisp.Make.link_primitives", "value", "Std.Primus.Lisp.primitives -> unit Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALlink_primitives", "<div class=\"info\">\n<p><code class=\"code\">link_primitives&nbsp;prims</code> provides the primitives <code class=\"code\">prims</code></p>\n\n</div>\n", ["LINK_PRIMITIVES", "PRIMITIVES", "PRIMS", "PROVIDES", "THE"]);
add_ocaml_element("eval_method", "Std.Primus.Lisp.Make.eval_method", "value", "string -> Std.Primus.value list -> unit Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALeval_method", "<div class=\"info\">\n<p><code class=\"code\">eval_method&nbsp;name&nbsp;args</code> invokes all methods with the given\n            <code class=\"code\">name</code> that are applicable in the current context to the\n            specified list of arguments.</p>\n\n</div>\n", ["ALL", "APPLICABLE", "ARE", "ARGS", "ARGUMENTS", "CONTEXT", "CURRENT", "EVAL_METHOD", "GIVEN", "INVOKES", "LIST", "METHODS", "NAME", "SINCE", "SPECIFIED", "THAT", "THE", "WITH"]);
add_ocaml_element("eval_fun", "Std.Primus.Lisp.Make.eval_fun", "value", "string ->\n  Std.Primus.value list -> Std.Primus.value Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALeval_fun", "<div class=\"info\">\n<p><code class=\"code\">eval_fun&nbsp;name&nbsp;args</code> calls a lisp function with the given\n            <code class=\"code\">name</code>, that is the most specific to the current context\n            and is applicable to the specified list of arguments.</p>\n\n</div>\n", ["AND", "APPLICABLE", "ARGS", "ARGUMENTS", "CALLS", "CONTEXT", "CURRENT", "EVAL_FUN", "FUNCTION", "GIVEN", "LISP", "LIST", "MOST", "NAME", "SINCE", "SPECIFIC", "SPECIFIED", "THAT", "THE", "WITH"]);
add_ocaml_element("failf", "Std.Primus.Lisp.Make.failf", "value", "('a, unit, string, unit -> 'b Machine.t) format4 -> 'a", "Bap_primus.Std.Primus.Lisp.Make.html#VALfailf", "<div class=\"info\">\n<p><code class=\"code\">failf&nbsp;msg&nbsp;a1&nbsp;...&nbsp;am&nbsp;()</code> terminates a lisp machine, and\n            correspondingly the Primus machine with the\n            <code class=\"code\"><span class=\"constructor\">Runtime_error</span></code>.</p>\n\n</div>\n", ["AND", "CORRESPONDINGLY", "FAILF", "LISP", "MACHINE", "MSG", "PRIMUS", "RUNTIME_ERROR", "TERMINATES", "THE", "WITH"]);
add_ocaml_element("signal", "Std.Primus.Lisp.Make.signal", "value", "?params:Std.Primus.Lisp.Type.parameters ->\n  ?doc:string ->\n  'a Std.Primus.observation ->\n  ('a -> Std.Primus.value list Machine.t) -> unit Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALsignal", "<div class=\"info\">\n<p><code class=\"code\">signal&nbsp;?params&nbsp;?docs&nbsp;obs&nbsp;proj</code> defines a new signal.</p>\n\n</div>\n", ["AFTER", "AND", "ARE", "ARGS", "ARITIES", "BETWEEN", "DEFINED", "DEFINES", "DIFFERENT", "DOCS", "EACH", "ESTABLISHES", "EVERY", "FROM", "LISP", "LIST", "MADE", "MAPPING", "MATCH", "MAY", "NAME", "NEW", "OBS", "OBSERVATION", "OBSERVATIONS", "ONTO", "OPERATOR", "PARAMS", "PRIMUS", "PRODUCE", "PROJ", "REFLECTED", "REFLECTION", "SAME", "SENT", "SIGNAL", "SIGNALS", "THAT", "THE", "THOUGH", "TIME", "VALUE", "VALUES", "VIA", "WHERE", "WILL", "WITH"]);
add_ocaml_element("define", "Std.Primus.Lisp.Make.define", "value", "?types:Std.Primus.Lisp.Type.signature ->\n  ?docs:string ->\n  string -> Std.Primus.Lisp.closure -> unit Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALdefine", "<div class=\"info\">\n<p><code class=\"code\">define&nbsp;?docs&nbsp;name&nbsp;code</code> defines a lisp primitive with\n            the given <code class=\"code\">name</code> and an optional documentation string\n            <code class=\"code\">doscs</code>.</p>\n\n</div>\n", ["ABS", "AND", "BAD_ABS_CALL", "BAP_PRIMUS", "CODE", "DEFINE", "DEFINES", "DOCS", "DOCUMENTATION", "DOSCS", "END", "EXAMPLE", "EXN", "FUNCTION", "GIVEN", "INIT", "LET", "LIBRARY", "LISP", "MACHINE", "MAKE", "MODULE", "NAME", "OPEN", "OPTIONAL", "PRIMITIVE", "PRIMUS", "RAISE", "RUN", "SEQUENCE", "STD", "STRING", "STRUCT", "THE", "TYPE", "VALUE", "WITH"]);
add_ocaml_element("program", "Std.Primus.Lisp.Make.program", "value", "Std.Primus.Lisp.program Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALprogram", "<div class=\"info\">\n<p><code class=\"code\">program</code> is the current Machine program.</p>\n\n</div>\n", ["CURRENT", "MACHINE", "PROGRAM", "THE"]);
add_ocaml_element("link_program", "Std.Primus.Lisp.Make.link_program", "value", "Std.Primus.Lisp.program -> unit Machine.t", "Bap_primus.Std.Primus.Lisp.Make.html#VALlink_program", "<div class=\"info\">\n<p><code class=\"code\">link_program&nbsp;p</code> links the program <code class=\"code\">p</code> into the Lisp\n            Machine.</p>\n\n</div>\n", ["ANY", "DISCARDED", "INTO", "LINKS", "LINK_PROGRAM", "LISP", "MACHINE", "PREVIOUS", "PROGRAM", "THE"]);
add_ocaml_element("create", "Std.Primus.Lisp.Primitive.create", "value", "?docs:string ->\n  string ->\n  (Std.Primus.value list -> 'a) ->\n  'a Std.Primus.Lisp.Primitive.t", "Bap_primus.Std.Primus.Lisp.Primitive.html#VALcreate", "", []);
add_ocaml_element("pp", "Std.Primus.Lisp.Message.pp", "value", "Stdlib.Format.formatter -> Std.Primus.Lisp.Message.t -> unit", "Bap_primus.Std.Primus.Lisp.Message.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;ppf&nbsp;msg</code> prints the message into the specified\n            formatter <code class=\"code\">ppf</code>.</p>\n\n</div>\n", ["FORMATTER", "INTO", "MESSAGE", "MSG", "PPF", "PRINTS", "SPECIFIED", "THE"]);
add_ocaml_element("(@->)", "Std.Primus.Lisp.Type.Spec.(@->)", "value", "[< Std.Primus.Lisp.Type.parameters ] ->\n  Std.Primus.Lisp.Type.t ->\n  Std.Primus.Lisp.Type.signature", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VAL(@->)", "<div class=\"info\">\n<p><code class=\"code\">params&nbsp;@-&gt;&nbsp;t</code> constructs a signature from the\n              parameter list specifier <code class=\"code\">params</code> and the return type\n              specifier <code class=\"code\">t</code></p>\n\n</div>\n", ["AND", "CONSTRUCTS", "FROM", "LIST", "PARAMETER", "PARAMS", "RETURN", "SIGNATURE", "SPECIFIER", "THE", "TYPE"]);
add_ocaml_element("(//)", "Std.Primus.Lisp.Type.Spec.(//)", "value", "[ `Tuple of Std.Primus.Lisp.Type.t list ] ->\n  [ `All of Std.Primus.Lisp.Type.t ] ->\n  Std.Primus.Lisp.Type.parameters", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VAL(//)", "<div class=\"info\">\n<p><code class=\"code\">params&nbsp;//&nbsp;rest</code> specifies that a function is variadic,\n              but have some number of mandatory arguments, i.e., it\n              accepts a tuple of parameters specified by the <code class=\"code\">params</code>\n              type specifier and a variadic list of arguments\n              specified by the <code class=\"code\">rest</code> type specifier.</p>\n\n</div>\n", ["ACCEPTS", "AND", "ARGUMENTS", "BUT", "FUNCTION", "HAVE", "LIST", "MANDATORY", "NUMBER", "PARAMETERS", "PARAMS", "REST", "SOME", "SPECIFIED", "SPECIFIER", "SPECIFIES", "THAT", "THE", "TUPLE", "TYPE", "VARIADIC"]);
add_ocaml_element("unit", "Std.Primus.Lisp.Type.Spec.unit", "value", "[ `Tuple of Std.Primus.Lisp.Type.t list ]", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALunit", "<div class=\"info\">\n<p><code class=\"code\">unit</code> specifies that a function doesn't have any parameters</p>\n\n</div>\n", ["ANY", "DOESN", "FUNCTION", "HAVE", "PARAMETERS", "SPECIFIES", "THAT", "UNIT"]);
add_ocaml_element("one", "Std.Primus.Lisp.Type.Spec.one", "value", "Std.Primus.Lisp.Type.t ->\n  [ `Tuple of Std.Primus.Lisp.Type.t list ]", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALone", "<div class=\"info\">\n<p><code class=\"code\">one&nbsp;t</code> specifies that a function accepts one argument\n              of type <code class=\"code\">t</code></p>\n\n</div>\n", ["ACCEPTS", "ARGUMENT", "FUNCTION", "ONE", "SPECIFIES", "THAT", "TYPE"]);
add_ocaml_element("all", "Std.Primus.Lisp.Type.Spec.all", "value", "Std.Primus.Lisp.Type.t ->\n  [ `All of Std.Primus.Lisp.Type.t ]", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALall", "<div class=\"info\">\n<p><code class=\"code\">all&nbsp;t</code> specifies that a function accepts a variable\n              number of arguments all having type <code class=\"code\">t</code>.</p>\n\n</div>\n", ["ACCEPTS", "ALL", "ARGUMENTS", "FUNCTION", "HAVING", "NUMBER", "SPECIFIES", "THAT", "TYPE", "VARIABLE"]);
add_ocaml_element("tuple", "Std.Primus.Lisp.Type.Spec.tuple", "value", "Std.Primus.Lisp.Type.t list ->\n  [ `Tuple of Std.Primus.Lisp.Type.t list ]", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALtuple", "<div class=\"info\">\n<p><code class=\"code\">tuple&nbsp;[args]</code> specifies that a function accepts\n              a tuple of arguments of specified types.</p>\n\n</div>\n", ["ACCEPTS", "ARGS", "ARGUMENTS", "FUNCTION", "SPECIFIED", "SPECIFIES", "THAT", "TUPLE", "TYPES"]);
add_ocaml_element("d", "Std.Primus.Lisp.Type.Spec.d", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALd", "<div class=\"info\">\n<p><code class=\"code\">d</code> shortcut for <code class=\"code\">var&nbsp;<span class=\"string\">\"d\"</span></code></p>\n\n</div>\n", ["FOR", "SHORTCUT", "VAR"]);
add_ocaml_element("c", "Std.Primus.Lisp.Type.Spec.c", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALc", "<div class=\"info\">\n<p><code class=\"code\">c</code> shortcut for <code class=\"code\">var&nbsp;<span class=\"string\">\"c\"</span></code></p>\n\n</div>\n", ["FOR", "SHORTCUT", "VAR"]);
add_ocaml_element("b", "Std.Primus.Lisp.Type.Spec.b", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALb", "<div class=\"info\">\n<p><code class=\"code\">b</code> shortcut for <code class=\"code\">var&nbsp;<span class=\"string\">\"b\"</span></code></p>\n\n</div>\n", ["FOR", "SHORTCUT", "VAR"]);
add_ocaml_element("a", "Std.Primus.Lisp.Type.Spec.a", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALa", "<div class=\"info\">\n<p><code class=\"code\">a</code> shortcut for <code class=\"code\">var&nbsp;<span class=\"string\">\"a\"</span></code></p>\n\n</div>\n", ["FOR", "SHORTCUT", "VAR"]);
add_ocaml_element("word", "Std.Primus.Lisp.Type.Spec.word", "value", "int -> Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALword", "<div class=\"info\">\n<p><code class=\"code\">word&nbsp;n</code> an <code class=\"code\">n</code> bit word</p>\n\n</div>\n", ["BIT", "WORD"]);
add_ocaml_element("byte", "Std.Primus.Lisp.Type.Spec.byte", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALbyte", "<div class=\"info\">\n<p><code class=\"code\">byte</code> an eight bit word</p>\n\n</div>\n", ["BIT", "BYTE", "EIGHT", "WORD"]);
add_ocaml_element("bool", "Std.Primus.Lisp.Type.Spec.bool", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALbool", "<div class=\"info\">\n<p><code class=\"code\">bool</code> a one bit word</p>\n\n</div>\n", ["BIT", "BOOL", "ONE", "WORD"]);
add_ocaml_element("int", "Std.Primus.Lisp.Type.Spec.int", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALint", "<div class=\"info\">\n<p>a machine integer - a word that has the same width as\n              <code class=\"code\"><span class=\"constructor\">Arch</span>.addr_size</code></p>\n\n</div>\n", ["ADDR_SIZE", "ARCH", "HAS", "INTEGER", "MACHINE", "SAME", "THAT", "THE", "WIDTH", "WORD"]);
add_ocaml_element("sym", "Std.Primus.Lisp.Type.Spec.sym", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALsym", "<div class=\"info\">\n<p><code class=\"code\">sym</code> symbol type.</p>\n\n</div>\n", ["SYM", "SYMBOL", "TYPE"]);
add_ocaml_element("var", "Std.Primus.Lisp.Type.Spec.var", "value", "string -> Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALvar", "<div class=\"info\">\n<p><code class=\"code\">var&nbsp;x</code> type variable <code class=\"code\">x</code>.</p>\n\n</div>\n", ["ALL", "ARE", "DEFINITON", "NAME", "SAME", "SCOPE", "THE", "TYPE", "UNIFIED", "VAR", "VARIABLE", "VARIABLES", "WITH"]);
add_ocaml_element("any", "Std.Primus.Lisp.Type.Spec.any", "value", "Std.Primus.Lisp.Type.t", "Bap_primus.Std.Primus.Lisp.Type.Spec.html#VALany", "<div class=\"info\">\n<p><code class=\"code\">any</code> top type which is inhabitated by all Primus values</p>\n\n</div>\n", ["ALL", "ANY", "INHABITATED", "PRIMUS", "TOP", "TYPE", "VALUES", "WHICH"]);
add_ocaml_element("pp_error", "Std.Primus.Lisp.Type.pp_error", "value", "Stdlib.Format.formatter -> Std.Primus.Lisp.Type.error -> unit", "Bap_primus.Std.Primus.Lisp.Type.html#VALpp_error", "<div class=\"info\">\n<p><code class=\"code\">pp_error&nbsp;ppf&nbsp;err</code> prints a description of the type error\n            <code class=\"code\">err</code> into the formatter <code class=\"code\">ppf</code></p>\n\n</div>\n", ["DESCRIPTION", "ERR", "ERROR", "FORMATTER", "INTO", "PPF", "PP_ERROR", "PRINTS", "THE", "TYPE"]);
add_ocaml_element("check", "Std.Primus.Lisp.Type.check", "value", "Std.Var.t Std.seq ->\n  Std.Primus.Lisp.program ->\n  Std.Primus.Lisp.Type.error list", "Bap_primus.Std.Primus.Lisp.Type.html#VALcheck", "<div class=\"info\">\n<p><code class=\"code\">check&nbsp;env&nbsp;prog</code> type checks program in the environment\n            <code class=\"code\">env</code> and returns a list of errors.</p>\n\n</div>\n", ["AND", "CHECK", "CHECKS", "CURRENTLY", "EMPTY", "ENV", "ENVIRONMENT", "ERRORS", "EXPERIMENTAL", "FUNCTION", "LIST", "NOTE", "PROG", "PROGRAM", "RETURNS", "THE", "THIS", "TYPE", "TYPED", "WELL"]);
add_ocaml_element("generate_index", "Std.Primus.Lisp.Doc.Make.generate_index", "value", "Std.Primus.Lisp.Doc.index Machine.t", "Bap_primus.Std.Primus.Lisp.Doc.Make.html#VALgenerate_index", "", []);
add_ocaml_element("pp", "Std.Primus.Lisp.Doc.Element.pp", "value", "Stdlib.Format.formatter -> Std.Primus.Lisp.Doc.Element.t -> unit", "Bap_primus.Std.Primus.Lisp.Doc.Element.html#VALpp", "", []);
add_ocaml_element("pp_program", "Std.Primus.Lisp.Load.pp_program", "value", "Stdlib.Format.formatter -> Std.Primus.Lisp.program -> unit", "Bap_primus.Std.Primus.Lisp.Load.html#VALpp_program", "<div class=\"info\">\n<p><code class=\"code\">pp_program&nbsp;ppf&nbsp;program</code> dumps program definitions into the formatter <code class=\"code\">ppf</code></p>\n\n</div>\n", ["DEFINITIONS", "DUMPS", "FORMATTER", "INTO", "PPF", "PP_PROGRAM", "PROGRAM", "THE"]);
add_ocaml_element("pp_error", "Std.Primus.Lisp.Load.pp_error", "value", "Stdlib.Format.formatter -> Std.Primus.Lisp.Load.error -> unit", "Bap_primus.Std.Primus.Lisp.Load.html#VALpp_error", "<div class=\"info\">\n<p><code class=\"code\">pp_error&nbsp;ppf&nbsp;err</code> outputs error information into the\n            pretty-printing formatter <code class=\"code\">ppf</code>.</p>\n\n</div>\n", ["ERR", "ERROR", "FORMATTER", "INFORMATION", "INTO", "OUTPUTS", "PPF", "PP_ERROR", "PRETTY", "PRINTING", "THE"]);
add_ocaml_element("program", "Std.Primus.Lisp.Load.program", "value", "?paths:string list ->\n  Std.project ->\n  string list ->\n  (Std.Primus.Lisp.program, Std.Primus.Lisp.Load.error)\n  result", "Bap_primus.Std.Primus.Lisp.Load.html#VALprogram", "<div class=\"info\">\n<p><code class=\"code\">program&nbsp;?paths&nbsp;proj&nbsp;features</code> loads a program that\n            implements a set of <code class=\"code\">features</code>.</p>\n\n</div>\n", ["ABSTRACT", "BASENAME", "CAN", "CURRENT", "DEFAULTS", "DIRECTORIES", "EACH", "ERROR", "FEATURE", "FEATURES", "FILE", "FIRST", "FOLDER", "FOR", "FORMED", "FOUND", "HAVE", "IMPLEMENTATION", "IMPLEMENTS", "INTO", "ITS", "LINKED", "LISP", "LIST", "LOADS", "LOOKED", "MACHINE", "MATTERS", "MUST", "NAME", "NOT", "ORDER", "PARAMETER", "PATH", "PATHS", "PROGRAM", "PROJ", "REPRESENTATION", "RETURNS", "SAME", "SET", "SPECIFIED", "THAT", "THE", "THUS", "USED", "WELL", "WILL"]);
add_ocaml_element("init", "Std.Primus.Lisp.init", "value", "?log:Stdlib.Format.formatter -> ?paths:string list -> string list -> unit", "Bap_primus.Std.Primus.Lisp.html#VALinit", "", []);
add_ocaml_element("message", "Std.Primus.Lisp.message", "value", "Std.Primus.Lisp.message Std.Primus.observation", "Bap_primus.Std.Primus.Lisp.html#VALmessage", "<div class=\"info\">\n<p><code class=\"code\">message</code> observation occurs every time a message is sent\n          from the Primus Machine.</p>\n\n</div>\n", ["EVERY", "FROM", "MACHINE", "MESSAGE", "OBSERVATION", "OCCURS", "PRIMUS", "SENT", "THE", "TIME"]);
add_ocaml_element("is_writable", "Std.Primus.Memory.Make.is_writable", "value", "Std.addr -> bool Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALis_writable", "<div class=\"info\">\n<p><code class=\"code\">is_writable&nbsp;addr</code> is a computation that evaluates to\n            <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">addr</code> is writable.</p>\n\n</div>\n", ["ADDR", "COMPUTATION", "EVALUATES", "IS_WRITABLE", "THAT", "TRUE", "WRITABLE"]);
add_ocaml_element("is_mapped", "Std.Primus.Memory.Make.is_mapped", "value", "Std.addr -> bool Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALis_mapped", "<div class=\"info\">\n<p><code class=\"code\">is_mapped&nbsp;addr</code> a computation that evaluates to true,\n            when the value is mapped, i.e., it is readable.</p>\n\n</div>\n", ["ADDR", "COMPUTATION", "EVALUATES", "IS_MAPPED", "MAPPED", "READABLE", "THAT", "THE", "TRUE", "VALUE", "WHEN"]);
add_ocaml_element("map", "Std.Primus.Memory.Make.map", "value", "?readonly:bool -> ?executable:bool -> Std.mem -> unit Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;mem</code> maps a memory chunk <code class=\"code\">mem</code> to a segment with the\n            given permissions.</p>\n\n</div>\n", ["ADD_DATA", "ADD_TEXT", "ALSO", "AND", "CHUNK", "GIVEN", "MAP", "MAPS", "MEM", "MEMORY", "PERMISSIONS", "SEE", "SEGMENT", "THE", "WITH"]);
add_ocaml_element("allocate", "Std.Primus.Memory.Make.allocate", "value", "?readonly:bool ->\n  ?executable:bool ->\n  ?generator:Std.Primus.Generator.t ->\n  Std.addr -> int -> unit Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALallocate", "<div class=\"info\">\n<p><code class=\"code\">allocate&nbsp;addr&nbsp;size</code> allocates a segment of the specified\n            <code class=\"code\">size</code>.</p>\n\n</div>\n", ["ADDR", "ALLOCATE", "ALLOCATES", "ATTEMP", "ATTEMPT", "BYTE", "DEFAULTS", "EXECUTABLE", "EXECUTE", "FAULT", "FINE", "FROM", "GENERATE", "GENERATED", "GENERATOR", "GRANULAR", "MORE", "NON", "PRODUCE", "PROVIDE", "RANDOM", "READONLY", "READS", "SEEDED", "SEGMENT", "SEGMENTATION", "SIZE", "SPECIFIED", "THE", "TODO", "TRAPS", "UNITILIALIZED", "VALUES", "WILL", "WRITE"]);
add_ocaml_element("add_data", "Std.Primus.Memory.Make.add_data", "value", "Std.mem -> unit Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALadd_data", "<div class=\"info\">\n<p><code class=\"code\">add_data</code> maps a memory chunk <code class=\"code\">mem</code> as writable and\n            nonexecutable segment of machine memory.</p>\n\n</div>\n", ["ADD_DATA", "AND", "CHUNK", "MACHINE", "MAPS", "MEM", "MEMORY", "NONEXECUTABLE", "SEGMENT", "WRITABLE"]);
add_ocaml_element("add_text", "Std.Primus.Memory.Make.add_text", "value", "Std.mem -> unit Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALadd_text", "<div class=\"info\">\n<p><code class=\"code\">add_text&nbsp;mem</code> maps a memory chunk <code class=\"code\">mem</code> as executable and\n            readonly segment of machine memory.</p>\n\n</div>\n", ["ADD_TEXT", "AND", "CHUNK", "EXECUTABLE", "MACHINE", "MAPS", "MEM", "MEMORY", "READONLY", "SEGMENT"]);
add_ocaml_element("store", "Std.Primus.Memory.Make.store", "value", "Std.addr -> Std.word -> unit Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALstore", "<div class=\"info\">\n<p><code class=\"code\">store&nbsp;a&nbsp;x</code> stores the byte <code class=\"code\">x</code> at the address <code class=\"code\">a</code>.</p>\n\n</div>\n", ["ADDRESS", "BITWIDTH", "BYTE", "OF_WORD", "PRECONDITION", "SAME", "SET", "STORE", "STORES", "THE", "VALUE"]);
add_ocaml_element("load", "Std.Primus.Memory.Make.load", "value", "Std.addr -> Std.word Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;a</code> loads a byte from the given address <code class=\"code\">a</code>.</p>\n\n</div>\n", ["ADDRESS", "BYTE", "FROM", "GET", "GIVEN", "LOAD", "LOADS", "SAME", "THE", "TO_WORD", "VALUE"]);
add_ocaml_element("set", "Std.Primus.Memory.Make.set", "value", "Std.addr -> Std.Primus.value -> unit Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;a&nbsp;x</code> stores the byte <code class=\"code\">x</code> at the address <code class=\"code\">a</code>.</p>\n\n</div>\n", ["ADDRESS", "BITWIDTH", "BYTE", "EXCEPTION", "MACHINE", "MAPPED", "NOT", "PAGEFAULT", "PRECONDITION", "RAISES", "SET", "STORES", "THE", "VALUE", "WRITABLE"]);
add_ocaml_element("get", "Std.Primus.Memory.Make.get", "value", "Std.addr -> Std.Primus.value Machine.t", "Bap_primus.Std.Primus.Memory.Make.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;a</code> loads a byte from the address <code class=\"code\">a</code>.</p>\n\n</div>\n", ["ADDRESS", "BYTE", "EXCEPTION", "FROM", "GET", "LOADS", "MACHINE", "MAPPED", "NOT", "PAGEFAULT", "RAISES", "THE"]);
add_ocaml_element("all", "Std.Primus.Env.Make.all", "value", "Std.var Std.seq Machine.t", "Bap_primus.Std.Primus.Env.Make.html#VALall", "<div class=\"info\">\n<p><code class=\"code\">all</code> is a sequence of all variables defined in the\n            environment.</p>\n\n</div>\n", ["ALL", "DEFINED", "DOESN", "ENVIRONMENT", "INITIALIZED", "MEAN", "NOTE", "SEQUENCE", "THE", "VARIABLES", "WORD"]);
add_ocaml_element("add", "Std.Primus.Env.Make.add", "value", "Std.var -> Std.Primus.Generator.t -> unit Machine.t", "Bap_primus.Std.Primus.Env.Make.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;var&nbsp;generator</code> adds a variable <code class=\"code\">var</code> to the\n            environment.</p>\n\n</div>\n", ["ADD", "ADDS", "AND", "ASSOCIATED", "AUTOMATICALLY", "BEFORE", "DEFINED", "ENVIRONMENT", "GENERATOR", "OPERATION", "PRODUCES", "READ", "RETURNED", "SET", "THE", "THEN", "VALUE", "VAR", "VARIABLE", "WAS", "WILL", "WITH"]);
add_ocaml_element("set", "Std.Primus.Env.Make.set", "value", "Std.var -> Std.Primus.value -> unit Machine.t", "Bap_primus.Std.Primus.Env.Make.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;var&nbsp;value</code> binds a variable <code class=\"code\">var</code> to the given <code class=\"code\">value</code>.</p>\n\n</div>\n", ["BINDS", "GIVEN", "SET", "THE", "VALUE", "VAR", "VARIABLE"]);
add_ocaml_element("get", "Std.Primus.Env.Make.get", "value", "Std.var -> Std.Primus.value Machine.t", "Bap_primus.Std.Primus.Env.Make.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;var</code> returns a value associated with the variable.</p>\n\n</div>\n", ["ALLOW", "ANYONE", "ASSOCIATED", "BIL", "BOTTOM", "DOESN", "ENVIRONEMNT", "GET", "INTERFACE", "LIKE", "LOOKS", "MEMORY", "NOT", "OPERATION", "RESULT", "RETURN", "RETURNS", "SAVE", "SHOULD", "THAT", "THE", "THUS", "TODO", "VALUE", "VALUES", "VAR", "VARIABLE", "WITH"]);
add_ocaml_element("next", "Std.Primus.Generator.Make.next", "value", "Std.Primus.Generator.t -> int Machine.t", "Bap_primus.Std.Primus.Generator.Make.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;iter</code> switches the internal state of <code class=\"code\">iter</code> to the\n            next state and returns the current value</p>\n\n</div>\n", ["AND", "CURRENT", "INTERNAL", "ITER", "NEXT", "RETURNS", "STATE", "SWITCHES", "THE", "VALUE"]);
add_ocaml_element("byte", "Std.Primus.Generator.Random.Seeded.byte", "value", "Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.Random.Seeded.html#VALbyte", "<div class=\"info\">\n<p><code class=\"code\">byte</code> is the same as <code class=\"code\">lcg&nbsp;~min:0&nbsp;~max:255&nbsp;()</code></p>\n\n</div>\n", ["255", "BYTE", "LCG", "MAX", "MIN", "SAME", "THE"]);
add_ocaml_element("lcg", "Std.Primus.Generator.Random.Seeded.lcg", "value", "?min:int -> ?max:int -> unit -> Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.Random.Seeded.html#VALlcg", "<div class=\"info\">\n<p><code class=\"code\">lcg&nbsp;~min&nbsp;~max&nbsp;()</code> a linear congruential generator.</p>\n\n</div>\n", ["CONGRUENTIAL", "GENERATOR", "LCG", "LINEAR", "MAX", "MIN"]);
add_ocaml_element("create", "Std.Primus.Generator.Random.Seeded.create", "value", "(int -> Std.Primus.Generator.t) ->\n  Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.Random.Seeded.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;init</code> creates a self-seeded generator from a\n              regular generator.</p>\n\n</div>\n", ["CREATE", "CREATES", "FROM", "GENERATOR", "INIT", "REGULAR", "SEEDED", "SELF"]);
add_ocaml_element("byte", "Std.Primus.Generator.Random.byte", "value", "int -> Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.Random.html#VALbyte", "<div class=\"info\">\n<p><code class=\"code\">byte&nbsp;seed</code> the same as <code class=\"code\">lcg&nbsp;~min:0&nbsp;~max:255&nbsp;seed</code></p>\n\n</div>\n", ["255", "BYTE", "LCG", "MAX", "MIN", "SAME", "SEED", "THE"]);
add_ocaml_element("lcg", "Std.Primus.Generator.Random.lcg", "value", "?min:int -> ?max:int -> int -> Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.Random.html#VALlcg", "<div class=\"info\">\n<p><code class=\"code\">lcg&nbsp;~min&nbsp;~max&nbsp;seed</code> a linear congruential generator, that\n            produces a sequence of pseudorandom values that lies in the\n            range between <code class=\"code\">min</code> and <code class=\"code\">max</code> (all inclusive).</p>\n\n</div>\n", ["ALL", "AND", "BETWEEN", "CONGRUENTIAL", "GENERATOR", "INCLUSIVE", "LCG", "LIES", "LINEAR", "MAX", "MIN", "PRODUCES", "PSEUDORANDOM", "RANGE", "SEED", "SEQUENCE", "THAT", "THE", "VALUES"]);
add_ocaml_element("unfold", "Std.Primus.Generator.unfold", "value", "?min:int ->\n  ?max:int ->\n  ?seed:int ->\n  f:('a * int -> 'a * int) -> 'a -> Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.html#VALunfold", "<div class=\"info\">\n<p><code class=\"code\">unfold&nbsp;~min&nbsp;~max&nbsp;~seed&nbsp;~f</code> creates a generator that\n          generates values by applying a function <code class=\"code\">f</code> to a pair of\n          a generator state and previous value.</p>\n\n</div>\n", ["AND", "APPLYING", "CREATES", "FUNCTION", "GENERATES", "GENERATOR", "MAX", "MIN", "PAIR", "PREVIOUS", "SEED", "STATE", "THAT", "UNFOLD", "VALUE", "VALUES"]);
add_ocaml_element("static", "Std.Primus.Generator.static", "value", "int -> Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.html#VALstatic", "<div class=\"info\">\n<p><code class=\"code\">static&nbsp;value</code> returns a generator that always produces the\n          same <code class=\"code\">value</code>.</p>\n\n</div>\n", ["ALWAYS", "GENERATOR", "PRODUCES", "RETURNS", "SAME", "STATIC", "THAT", "THE", "VALUE"]);
add_ocaml_element("create", "Std.Primus.Generator.create", "value", "(module Std.Primus.Iterator.Infinite with type dom = int and type t = 'a) ->\n  'a -> Std.Primus.Generator.t", "Bap_primus.Std.Primus.Generator.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">Iterator</span>)&nbsp;seed</code> creates a integer generator\n          from the provided <code class=\"code\"><span class=\"constructor\">Iterator</span></code>, and initializes it with the\n          given seed.</p>\n\n</div>\n", ["AND", "CREATE", "CREATES", "FROM", "GENERATOR", "GIVEN", "INITIALIZES", "INTEGER", "ITERATOR", "MODULE", "PROVIDED", "SEED", "THE", "WITH"]);
add_ocaml_element("next", "Std.Primus.Iterator.Infinite.next", "value", "t -> t", "Bap_primus.Std.Primus.Iterator.Infinite.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;iterator</code> moves the iterator to the next element of\n            the sequence.</p>\n\n</div>\n", ["ELEMENT", "ITERATOR", "MOVES", "NEXT", "SEQUENCE", "THE"]);
add_ocaml_element("next", "Std.Primus.Iterator.Finite.next", "value", "t -> t option", "Bap_primus.Std.Primus.Iterator.Finite.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;iterator</code> moves an <code class=\"code\">iterator</code> to the next element of\n            the sequence, or returns <code class=\"code\"><span class=\"constructor\">None</span></code> if there are no more\n            elements.</p>\n\n</div>\n", ["ARE", "ELEMENT", "ELEMENTS", "ITERATOR", "MORE", "MOVES", "NEXT", "NONE", "RETURNS", "SEQUENCE", "THE", "THERE"]);
add_ocaml_element("value", "Std.Primus.Iterator.Base.value", "value", "Std.Primus.Iterator.Base.t ->\n  Std.Primus.Iterator.Base.dom", "Bap_primus.Std.Primus.Iterator.Base.html#VALvalue", "<div class=\"info\">\n<p>current value</p>\n\n</div>\n", ["CURRENT", "VALUE"]);
add_ocaml_element("max", "Std.Primus.Iterator.Base.max", "value", "Std.Primus.Iterator.Base.dom", "Bap_primus.Std.Primus.Iterator.Base.html#VALmax", "<div class=\"info\">\n<p>maximum value in the iterator domain</p>\n\n</div>\n", ["DOMAIN", "ITERATOR", "MAXIMUM", "THE", "VALUE"]);
add_ocaml_element("min", "Std.Primus.Iterator.Base.min", "value", "Std.Primus.Iterator.Base.dom", "Bap_primus.Std.Primus.Iterator.Base.html#VALmin", "<div class=\"info\">\n<p>minimum value in the iterator domain</p>\n\n</div>\n", ["DOMAIN", "ITERATOR", "MINIMUM", "THE", "VALUE"]);
add_ocaml_element("exec", "Std.Primus.Linker.Code.exec", "value", "unit Machine.t", "Bap_primus.Std.Primus.Linker.Code.html#VALexec", "<div class=\"info\">\n<p><code class=\"code\">exec</code> computes the code.</p>\n\n</div>\n", ["CODE", "COMPUTES", "EXEC", "THE"]);
add_ocaml_element("is_linked", "Std.Primus.Linker.Make.is_linked", "value", "Std.Primus.Linker.name -> bool Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALis_linked", "<div class=\"info\">\n<p><code class=\"code\">is_linked&nbsp;name</code> computes to <code class=\"code\"><span class=\"keyword\">true</span></code> if the <code class=\"code\">name</code> is\n            associated with some code.</p>\n\n</div>\n", ["ASSOCIATED", "CODE", "COMPUTES", "IS_LINKED", "NAME", "SINCE", "SOME", "THE", "TRUE", "WITH"]);
add_ocaml_element("resolve_tid", "Std.Primus.Linker.Make.resolve_tid", "value", "Std.Primus.Linker.name ->\n  Std.tid option Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALresolve_tid", "<div class=\"info\">\n<p><code class=\"code\">resolve_tid&nbsp;name</code> returns the term identifier associated\n            with the given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ASSOCIATED", "GIVEN", "IDENTIFIER", "NAME", "RESOLVE_TID", "RETURNS", "SINCE", "TERM", "THE", "WITH"]);
add_ocaml_element("resolve_symbol", "Std.Primus.Linker.Make.resolve_symbol", "value", "Std.Primus.Linker.name ->\n  string option Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALresolve_symbol", "<div class=\"info\">\n<p><code class=\"code\">resolve_symbol&nbsp;name</code> returns the symbolic name associated\n            with the given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ASSOCIATED", "GIVEN", "NAME", "RESOLVE_SYMBOL", "RETURNS", "SINCE", "SYMBOLIC", "THE", "WITH"]);
add_ocaml_element("resolve_addr", "Std.Primus.Linker.Make.resolve_addr", "value", "Std.Primus.Linker.name ->\n  Std.addr option Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALresolve_addr", "<div class=\"info\">\n<p><code class=\"code\">resolve_addr&nbsp;name</code> returns the address associated with the\n            given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ADDRESS", "ASSOCIATED", "GIVEN", "NAME", "RESOLVE_ADDR", "RETURNS", "THE", "WITH"]);
add_ocaml_element("exec", "Std.Primus.Linker.Make.exec", "value", "Std.Primus.Linker.name -> unit Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALexec", "<div class=\"info\">\n<p><code class=\"code\">exec&nbsp;name</code> executes a code fragment associated with the\n            given name.</p>\n\n</div>\n", ["ANY", "ASSOCIATED", "CODE", "COMPUTATION", "CONDITION", "EXEC", "EXECUTES", "FRAGMENT", "GIVEN", "LINKER", "NAME", "NOT", "TERMINATES", "THE", "UNBOUND_NAME", "WITH"]);
add_ocaml_element("lookup", "Std.Primus.Linker.Make.lookup", "value", "Std.Primus.Linker.name ->\n  Std.Primus.Linker.code option Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALlookup", "<div class=\"info\">\n<p><code class=\"code\">lookup&nbsp;name</code> returns code linked with the given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["CODE", "GIVEN", "LINKED", "LOOKUP", "NAME", "RETURNS", "THE", "WITH"]);
add_ocaml_element("unlink", "Std.Primus.Linker.Make.unlink", "value", "Std.Primus.Linker.name -> unit Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALunlink", "<div class=\"info\">\n<p><code class=\"code\">unlink&nbsp;name</code> removes code linked with the provided <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ALIASES", "ALL", "ALSO", "CODE", "GIVEN", "LINKED", "NAME", "PROVIDED", "REMOVES", "THE", "UNLINK", "WITH"]);
add_ocaml_element("link", "Std.Primus.Linker.Make.link", "value", "?addr:Std.addr ->\n  ?name:string ->\n  ?tid:Std.tid ->\n  Std.Primus.Linker.code -> unit Std.Primus.Linker.Make.m", "Bap_primus.Std.Primus.Linker.Make.html#VALlink", "<div class=\"info\">\n<p><code class=\"code\">link&nbsp;~addr&nbsp;~name&nbsp;~tid&nbsp;code</code> links the given <code class=\"code\">code</code>\n            fragment into the Machine.</p>\n\n</div>\n", ["ADDR", "ALREAD", "APPARENTLY", "BINDING", "BOUND", "CAN", "CODE", "EVER", "FRAGMENT", "GIVEN", "IDENTIFIER", "IDETIFIERS", "INTO", "INVOKED", "LINK", "LINKS", "MACHINE", "NAME", "NEW", "NOT", "OLD", "ONE", "OTHER", "PROVIDED", "SOME", "SUBSTITUTED", "THE", "THEN", "TID", "WAS", "WERE", "WILL"]);
add_ocaml_element("call_returned", "Std.Primus.Linker.Trace.call_returned", "value", "(string * Std.Primus.value list) Std.Primus.statement", "Bap_primus.Std.Primus.Linker.Trace.html#VALcall_returned", "<div class=\"info\">\n<p>the statement that makes <code class=\"code\">return</code> observations</p>\n\n</div>\n", ["MAKES", "OBSERVATIONS", "RETURN", "STATEMENT", "THAT", "THE"]);
add_ocaml_element("call_entered", "Std.Primus.Linker.Trace.call_entered", "value", "(string * Std.Primus.value list) Std.Primus.statement", "Bap_primus.Std.Primus.Linker.Trace.html#VALcall_entered", "<div class=\"info\">\n<p>the statement that makes <code class=\"code\">call</code> observations.</p>\n\n</div>\n", ["CALL", "MAKES", "OBSERVATIONS", "STATEMENT", "THAT", "THE"]);
add_ocaml_element("return", "Std.Primus.Linker.Trace.return", "value", "(string * Std.Primus.value list) Std.Primus.observation", "Bap_primus.Std.Primus.Linker.Trace.html#VALreturn", "<div class=\"info\">\n<p>occurs just before a subroutine returns.</p>\n\n</div>\n", ["0XDEADBEEF", "ALL", "AND", "ARE", "ARGUMENT", "ARGUMENTS", "BEFORE", "CALL", "CONTEXT", "CORRESPONDING", "EXAMPLE", "INCLUDING", "INPUT", "INTERPRETER", "JUST", "LIST", "MADE", "MALLOC", "OBSERVATION", "OCCURS", "ORDER", "OUTPUT", "PROVIDED", "RETURN", "RETURNS", "SAME", "STILL", "SUBROUTINE", "THE", "VALUES", "WHEN", "WISE"]);
add_ocaml_element("call", "Std.Primus.Linker.Trace.call", "value", "(string * Std.Primus.value list) Std.Primus.observation", "Bap_primus.Std.Primus.Linker.Trace.html#VALcall", "<div class=\"info\">\n<p>occurs when a subroutine is called.</p>\n\n</div>\n", ["ARE", "ARGUMENT", "ARGUMENTS", "CALL", "CALLED", "CORRESPONDING", "EXAMPLE", "INPUT", "MALLOC", "OCCURS", "ORDER", "SAME", "SPECIFIED", "SUBROUTINE", "TERM", "THE", "VALUES", "WHEN", "WHICH"]);
add_ocaml_element("unresolved_handler", "Std.Primus.Linker.unresolved_handler", "value", "string", "Bap_primus.Std.Primus.Linker.html#VALunresolved_handler", "<div class=\"info\">\n<p><code class=\"code\">unresolved_handler</code> is called instead of an unbound name.</p>\n\n</div>\n", ["CALLED", "INSTEAD", "NAME", "SINCE", "UNBOUND", "UNRESOLVED_HANDLER"]);
add_ocaml_element("unresolved", "Std.Primus.Linker.unresolved", "value", "Std.Primus.Linker.name Std.Primus.observation", "Bap_primus.Std.Primus.Linker.html#VALunresolved", "<div class=\"info\">\n<p>occurs when an unresolved name is called, just before the\n            unresolved trap is signaled.</p>\n\n</div>\n", ["BEFORE", "CALLED", "COULD", "HANDLER", "INSTALL", "JUST", "NAME", "OCCURS", "SIGNALED", "SINCE", "THE", "TRAP", "UNRESOLVED", "USED", "WHEN"]);
add_ocaml_element("exec", "Std.Primus.Linker.exec", "value", "Std.Primus.Linker.name Std.Primus.observation", "Bap_primus.Std.Primus.Linker.html#VALexec", "<div class=\"info\">\n<p>occurs before a piece of code is executed</p>\n\n</div>\n", ["BEFORE", "CODE", "EXECUTED", "OCCURS", "PIECE"]);
add_ocaml_element("store", "Std.Primus.Interpreter.Make.store", "value", "Std.Primus.value ->\n  Std.Primus.value ->\n  Std.endian ->\n  Std.size -> unit Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALstore", "<div class=\"info\">\n<p><code class=\"code\">store&nbsp;a&nbsp;x&nbsp;d&nbsp;s</code> computes a store operation, that stores at\n            the address <code class=\"code\">a</code> the word <code class=\"code\">x</code> of size <code class=\"code\">s</code>, using an\n            ordering specified by the endianness <code class=\"code\">d</code>.</p>\n\n</div>\n", ["ADDRESS", "AND", "COMPUTES", "ENDIANNESS", "EXCEPTION", "HANDLER", "INVOKED", "MACHINE", "MAPPED", "NOT", "OPERATION", "ORDERING", "OTHERWISE", "PAGEFAULT", "PROVIDED", "RAISED", "REPEATED", "SEGMENTATION_FAULT", "SIZE", "SPECIFIED", "STORE", "STORES", "THAT", "THE", "THEN", "TRAP", "USING", "WORD", "WRITABLE"]);
add_ocaml_element("load", "Std.Primus.Interpreter.Make.load", "value", "Std.Primus.value ->\n  Std.endian ->\n  Std.size ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;a&nbsp;d&nbsp;s</code> computes a load operation, that loads a word\n            of size <code class=\"code\">s</code> using an order specified by the endianness <code class=\"code\">d</code>\n            from address <code class=\"code\">a</code>.</p>\n\n</div>\n", ["ADDRESS", "AND", "ATTEMPT", "COMPUTES", "EITHER", "ENDIANNESS", "ENSURE", "EXCEPTION", "FAULT", "FROM", "HANDLER", "INVOKED", "LINKED", "LOAD", "LOADS", "MACHINE", "MAPPED", "NOT", "NOTE", "OPERATION", "ORDER", "PAGEFAULT", "PAGEFAULT_HANLDER", "PROVIDED", "RAISED", "REPEATS", "RETURN", "SECOND", "SEGMENTATION", "SHALL", "SIGNALED", "SIZE", "SPECIFIED", "SUCCESSFUL", "THAT", "THE", "THEN", "TRAP", "USING", "WORD", "WOULD"]);
add_ocaml_element("const", "Std.Primus.Interpreter.Make.const", "value", "Std.word ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALconst", "<div class=\"info\">\n<p><code class=\"code\">const&nbsp;x</code> computes the constant expression <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "CONST", "CONSTANT", "EXPRESSION", "THE"]);
add_ocaml_element("extract", "Std.Primus.Interpreter.Make.extract", "value", "hi:int ->\n  lo:int ->\n  Std.Primus.value ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALextract", "<div class=\"info\">\n<p><code class=\"code\">extract&nbsp;~hi&nbsp;~lo&nbsp;x</code> extracts bits from <code class=\"code\">lo</code> to <code class=\"code\">hi</code> from\n            <code class=\"code\">x</code>.</p>\n\n</div>\n", ["BITS", "EXTRACT", "EXTRACTS", "FROM"]);
add_ocaml_element("concat", "Std.Primus.Interpreter.Make.concat", "value", "Std.Primus.value ->\n  Std.Primus.value ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat&nbsp;x&nbsp;y</code> computes a concatenation of <code class=\"code\">x</code> and <code class=\"code\">y</code></p>\n\n</div>\n", ["AND", "COMPUTES", "CONCAT", "CONCATENATION"]);
add_ocaml_element("cast", "Std.Primus.Interpreter.Make.cast", "value", "Std.cast ->\n  int ->\n  Std.Primus.value ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALcast", "<div class=\"info\">\n<p><code class=\"code\">cast&nbsp;t&nbsp;n&nbsp;x</code> casts <code class=\"code\">n</code> bits of <code class=\"code\">x</code> using a casting type <code class=\"code\">t</code></p>\n\n</div>\n", ["BITS", "CAST", "CASTING", "CASTS", "TYPE", "USING"]);
add_ocaml_element("unop", "Std.Primus.Interpreter.Make.unop", "value", "Std.unop ->\n  Std.Primus.value ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALunop", "<div class=\"info\">\n<p><code class=\"code\">unop&nbsp;op&nbsp;x</code> computes an unary operation <code class=\"code\">op</code> on <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "OPERATION", "UNARY", "UNOP"]);
add_ocaml_element("binop", "Std.Primus.Interpreter.Make.binop", "value", "Std.binop ->\n  Std.Primus.value ->\n  Std.Primus.value ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALbinop", "<div class=\"info\">\n<p><code class=\"code\">binop&nbsp;op&nbsp;x&nbsp;y</code> computes a binary operation <code class=\"code\">op</code> on <code class=\"code\">x</code> and <code class=\"code\">y</code>.</p>\n\n</div>\n", ["AND", "BINARY", "BINOP", "COMPUTES", "DIVISION", "DIVISION_BY_ZERO", "DIVISION_BY_ZERO_HANDLER", "EXCEPTION", "INVOKED", "INVOLVE", "LINKED", "MACHINE", "NORMALLY", "OPERATION", "OTHERWISE", "PROVIDED", "RAISED", "RESULT", "RETURNS", "SIGNALED", "THE", "THEN", "TRAP", "UNDEFINED", "WILL", "ZERO"]);
add_ocaml_element("set", "Std.Primus.Interpreter.Make.set", "value", "Std.var ->\n  Std.Primus.value -> unit Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;var&nbsp;x</code> sets <code class=\"code\">var</code> to <code class=\"code\">x</code></p>\n\n</div>\n", ["SET", "SETS", "VAR"]);
add_ocaml_element("get", "Std.Primus.Interpreter.Make.get", "value", "Std.var ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;var</code> reads <code class=\"code\">var</code></p>\n\n</div>\n", ["GET", "READS", "VAR"]);
add_ocaml_element("exp", "Std.Primus.Interpreter.Make.exp", "value", "Std.exp ->\n  Std.Primus.value Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALexp", "<div class=\"info\">\n<p><code class=\"code\">exp&nbsp;x</code> returns a value of <code class=\"code\">x</code>.</p>\n\n</div>\n", ["EXP", "RETURNS", "VALUE"]);
add_ocaml_element("blk", "Std.Primus.Interpreter.Make.blk", "value", "Std.blk Std.term -> unit Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALblk", "<div class=\"info\">\n<p><code class=\"code\">blk&nbsp;x</code> interprets the block <code class=\"code\">x</code>.</p>\n\n</div>\n", ["BLK", "BLOCK", "INTERPRETS", "THE"]);
add_ocaml_element("sub", "Std.Primus.Interpreter.Make.sub", "value", "Std.sub Std.term -> unit Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALsub", "<div class=\"info\">\n<p><code class=\"code\">sub&nbsp;x</code> computes the subroutine <code class=\"code\">x</code>.</p>\n\n</div>\n", ["COMPUTES", "SUB", "SUBROUTINE", "THE"]);
add_ocaml_element("pos", "Std.Primus.Interpreter.Make.pos", "value", "Std.Primus.pos Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALpos", "<div class=\"info\">\n<p><code class=\"code\">pos&nbsp;m</code> current program position.</p>\n\n</div>\n", ["CURRENT", "POS", "POSITION", "PROGRAM"]);
add_ocaml_element("pc", "Std.Primus.Interpreter.Make.pc", "value", "Std.addr Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALpc", "<div class=\"info\">\n<p><code class=\"code\">pc</code> current value of a program counter.</p>\n\n</div>\n", ["COUNTER", "CURRENT", "PROGRAM", "VALUE"]);
add_ocaml_element("interrupt", "Std.Primus.Interpreter.Make.interrupt", "value", "int -> unit Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALinterrupt", "<div class=\"info\">\n<p><code class=\"code\">interrupt&nbsp;n</code> interrupts the computation with cpuexn <code class=\"code\">n</code></p>\n\n</div>\n", ["COMPUTATION", "CPUEXN", "INTERRUPT", "INTERRUPTS", "THE", "WITH"]);
add_ocaml_element("halt", "Std.Primus.Interpreter.Make.halt", "value", "never_returns Std.Primus.Interpreter.Make.m", "Bap_primus.Std.Primus.Interpreter.Make.html#VALhalt", "<div class=\"info\">\n<p><code class=\"code\">halt</code> halts the machine by raise the <code class=\"code\"><span class=\"constructor\">Halt</span></code> exception.</p>\n\n</div>\n", ["EXCEPTION", "HALT", "HALTS", "MACHINE", "RAISE", "THE"]);
add_ocaml_element("division_by_zero_handler", "Std.Primus.Interpreter.division_by_zero_handler", "value", "string", "Bap_primus.Std.Primus.Interpreter.html#VALdivision_by_zero_handler", "<div class=\"info\">\n<p><code class=\"code\">division_by_zero_hanlder</code> is a trap handler for\n          the Division_by_zero exception.</p>\n\n</div>\n", ["DIVISION", "DIVISION_BY_ZERO", "DIVISION_BY_ZERO_HANLDER", "EXCEPTION", "FAULTY", "FOR", "HANDLER", "INTO", "INVOKED", "LINKED", "MACHINE", "NORMALLY", "OPERATION", "RESULT", "RETURNS", "SIGNALED", "SINCE", "THE", "THEN", "TRAP", "UNDEFINED", "WHEN", "WILL", "ZERO"]);
add_ocaml_element("pagefault_handler", "Std.Primus.Interpreter.pagefault_handler", "value", "string", "Bap_primus.Std.Primus.Interpreter.html#VALpagefault_handler", "<div class=\"info\">\n<p><code class=\"code\">pagefault_hanlder</code> is a trap handler that is invoked when the <code class=\"code\"><span class=\"constructor\">Pagefault</span></code>\n          exception is raised by the machine memory component.</p>\n\n</div>\n", ["ARE", "COMPONENT", "EXCEPTION", "FAULT", "FAULTS", "FAULTY", "HANDLED", "HANDLER", "HANLDER", "INVOKED", "LINKER", "MACHINE", "MEMORY", "NORMALLY", "NOTE", "OBSERVATION", "OPERATION", "OTHERWISE", "PAGE", "PAGEFAULT", "PAGEFAULT_HANLDER", "PROVIDED", "RAISED", "REPEATED", "RETURNS", "SEGMENTATION", "SINCE", "THAT", "THE", "THEN", "TOGETHER", "TRAP", "USUALLY", "VIA", "WHEN", "WITH"]);
add_ocaml_element("segfault", "Std.Primus.Interpreter.segfault", "value", "Std.addr Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALsegfault", "<div class=\"info\">\n<p><code class=\"code\">segfault&nbsp;x</code> occurs when an invalid memory operation is performed\n          on the address <code class=\"code\">x</code>.</p>\n\n</div>\n", ["ADDRESS", "AND", "FOR", "INVALID", "LOAD", "MEMORY", "MORE", "OCCURS", "OPERATION", "OPERATIONS", "PERFORMED", "SEE", "SEGFAULT", "SINCE", "STORE", "THE", "WHEN"]);
add_ocaml_element("pagefault", "Std.Primus.Interpreter.pagefault", "value", "Std.addr Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALpagefault", "<div class=\"info\">\n<p><code class=\"code\">pagefault&nbsp;x</code> occurs just before the pagefault trap is signaled.</p>\n\n</div>\n", ["AND", "BEFORE", "FOR", "INFORMATION", "JUST", "LOAD", "MORE", "OCCURS", "OPERATIONS", "PAGEFAULT", "PAGEFAULT_HANDLER", "SEE", "SIGNALED", "SINCE", "STORE", "THE", "TRAP"]);
add_ocaml_element("division_by_zero", "Std.Primus.Interpreter.division_by_zero", "value", "unit Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALdivision_by_zero", "<div class=\"info\">\n<p><code class=\"code\">division_by_zero</code> occurs just before the division by zero trap\n          is signaled.</p>\n\n</div>\n", ["AND", "BEFORE", "BINOP", "DIVISION", "DIVISION_BY_ZERO", "DIVISION_BY_ZERO_HANDLER", "FOR", "INFORMATION", "JUST", "MORE", "OCCURS", "OPERATION", "SEE", "SIGNALED", "SINCE", "THE", "TRAP", "ZERO"]);
add_ocaml_element("interrupt", "Std.Primus.Interpreter.interrupt", "value", "int Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALinterrupt", "<div class=\"info\">\n<p><code class=\"code\">interrupt&nbsp;n</code> occurs on the machine interrupt <code class=\"code\">n</code> (aka CPU\n          exception)</p>\n\n</div>\n", ["AKA", "CPU", "EXCEPTION", "INTERRUPT", "MACHINE", "OCCURS", "THE"]);
add_ocaml_element("halting", "Std.Primus.Interpreter.halting", "value", "unit Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALhalting", "<div class=\"info\">\n<p>occurs on <code class=\"code\">halt</code> operation</p>\n\n</div>\n", ["HALT", "OCCURS", "OPERATION"]);
add_ocaml_element("leave_exp", "Std.Primus.Interpreter.leave_exp", "value", "Std.exp Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_exp", "<div class=\"info\">\n<p>an expression was left</p>\n\n</div>\n", ["EXPRESSION", "LEFT", "WAS"]);
add_ocaml_element("enter_exp", "Std.Primus.Interpreter.enter_exp", "value", "Std.exp Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_exp", "<div class=\"info\">\n<p>an expression was entered</p>\n\n</div>\n", ["ENTERED", "EXPRESSION", "WAS"]);
add_ocaml_element("leave_jmp", "Std.Primus.Interpreter.leave_jmp", "value", "Std.jmp Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_jmp", "<div class=\"info\">\n<p>a jump term was left</p>\n\n</div>\n", ["JUMP", "LEFT", "TERM", "WAS"]);
add_ocaml_element("leave_def", "Std.Primus.Interpreter.leave_def", "value", "Std.def Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_def", "<div class=\"info\">\n<p>a definition was left</p>\n\n</div>\n", ["DEFINITION", "LEFT", "WAS"]);
add_ocaml_element("leave_phi", "Std.Primus.Interpreter.leave_phi", "value", "Std.phi Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_phi", "<div class=\"info\">\n<p>a phi-node was left</p>\n\n</div>\n", ["LEFT", "NODE", "PHI", "WAS"]);
add_ocaml_element("leave_blk", "Std.Primus.Interpreter.leave_blk", "value", "Std.blk Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_blk", "<div class=\"info\">\n<p>a basic block was left</p>\n\n</div>\n", ["BASIC", "BLOCK", "LEFT", "WAS"]);
add_ocaml_element("leave_arg", "Std.Primus.Interpreter.leave_arg", "value", "Std.arg Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_arg", "<div class=\"info\">\n<p>a subroutine argument was left</p>\n\n</div>\n", ["ARGUMENT", "LEFT", "SUBROUTINE", "WAS"]);
add_ocaml_element("leave_sub", "Std.Primus.Interpreter.leave_sub", "value", "Std.sub Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_sub", "<div class=\"info\">\n<p>a subroutine was left</p>\n\n</div>\n", ["LEFT", "SUBROUTINE", "WAS"]);
add_ocaml_element("enter_jmp", "Std.Primus.Interpreter.enter_jmp", "value", "Std.jmp Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_jmp", "<div class=\"info\">\n<p>a jump term is entered</p>\n\n</div>\n", ["ENTERED", "JUMP", "TERM"]);
add_ocaml_element("enter_def", "Std.Primus.Interpreter.enter_def", "value", "Std.def Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_def", "<div class=\"info\">\n<p>a definition is entered</p>\n\n</div>\n", ["DEFINITION", "ENTERED"]);
add_ocaml_element("enter_phi", "Std.Primus.Interpreter.enter_phi", "value", "Std.phi Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_phi", "<div class=\"info\">\n<p>a phi-node is entered</p>\n\n</div>\n", ["ENTERED", "NODE", "PHI"]);
add_ocaml_element("enter_blk", "Std.Primus.Interpreter.enter_blk", "value", "Std.blk Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_blk", "<div class=\"info\">\n<p>a basic block is entered</p>\n\n</div>\n", ["BASIC", "BLOCK", "ENTERED"]);
add_ocaml_element("enter_arg", "Std.Primus.Interpreter.enter_arg", "value", "Std.arg Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_arg", "<div class=\"info\">\n<p>a subroutine argument is entered</p>\n\n</div>\n", ["ARGUMENT", "ENTERED", "SUBROUTINE"]);
add_ocaml_element("enter_sub", "Std.Primus.Interpreter.enter_sub", "value", "Std.sub Std.term Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_sub", "<div class=\"info\">\n<p>a subroutine entered</p>\n\n</div>\n", ["ENTERED", "SUBROUTINE"]);
add_ocaml_element("leave_pos", "Std.Primus.Interpreter.leave_pos", "value", "Std.Primus.pos Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_pos", "<div class=\"info\">\n<p>a program location left</p>\n\n</div>\n", ["LEFT", "LOCATION", "PROGRAM"]);
add_ocaml_element("enter_pos", "Std.Primus.Interpreter.enter_pos", "value", "Std.Primus.pos Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_pos", "<div class=\"info\">\n<p>new program locatio entered</p>\n\n</div>\n", ["ENTERED", "LOCATIO", "NEW", "PROGRAM"]);
add_ocaml_element("leave_term", "Std.Primus.Interpreter.leave_term", "value", "Std.tid Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALleave_term", "<div class=\"info\">\n<p>an identifier of a term that just finished the execution.</p>\n\n</div>\n", ["EXECUTION", "FINISHED", "IDENTIFIER", "JUST", "TERM", "THAT", "THE"]);
add_ocaml_element("enter_term", "Std.Primus.Interpreter.enter_term", "value", "Std.tid Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALenter_term", "<div class=\"info\">\n<p>an identifier of a term that will be executed next.</p>\n\n</div>\n", ["EXECUTED", "IDENTIFIER", "NEXT", "TERM", "THAT", "WILL"]);
add_ocaml_element("ite", "Std.Primus.Interpreter.ite", "value", "((Std.Primus.value * Std.Primus.value *\n    Std.Primus.value) *\n   Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALite", "<div class=\"info\">\n<p><code class=\"code\">ite&nbsp;((cond,&nbsp;yes,&nbsp;no),&nbsp;res)</code> happens after the ite expression\n          that corresponds to ite(<code class=\"code\">cond</code>, <code class=\"code\">yes</code>, <code class=\"code\">no</code>) is evaluated\n          to <code class=\"code\">res</code>.</p>\n\n</div>\n", ["AFTER", "COND", "CORRESPONDS", "EVALUATED", "EXPRESSION", "HAPPENS", "ITE", "RES", "THAT", "THE", "YES"]);
add_ocaml_element("concat", "Std.Primus.Interpreter.concat", "value", "((Std.Primus.value * Std.Primus.value) *\n   Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">extract&nbsp;((x,y),z)</code> happens after <code class=\"code\">x</code> is concatenated with <code class=\"code\">y</code>\n          and produces <code class=\"code\">z</code> as a result.</p>\n\n</div>\n", ["AFTER", "AND", "CONCATENATED", "EXTRACT", "HAPPENS", "PRODUCES", "RESULT", "WITH"]);
add_ocaml_element("extract", "Std.Primus.Interpreter.extract", "value", "((int * int * Std.Primus.value) * Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALextract", "<div class=\"info\">\n<p><code class=\"code\">extract&nbsp;((hi,lo,x),r)</code> happens after <code class=\"code\">r</code> is extracted from <code class=\"code\">x</code></p>\n\n</div>\n", ["AFTER", "EXTRACT", "EXTRACTED", "FROM", "HAPPENS"]);
add_ocaml_element("cast", "Std.Primus.Interpreter.cast", "value", "((Std.cast * int * Std.Primus.value) *\n   Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALcast", "<div class=\"info\">\n<p><code class=\"code\">cast&nbsp;((t,x),r)</code> happens after <code class=\"code\">x</code> is casted to <code class=\"code\">r</code> using\n          the casting type <code class=\"code\">t</code></p>\n\n</div>\n", ["AFTER", "CAST", "CASTED", "CASTING", "HAPPENS", "THE", "TYPE", "USING"]);
add_ocaml_element("unop", "Std.Primus.Interpreter.unop", "value", "((Std.unop * Std.Primus.value) * Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALunop", "<div class=\"info\">\n<p><code class=\"code\">unop&nbsp;((op,x),r)</code> happens after the unary operation <code class=\"code\">op</code> is\n          applied to <code class=\"code\">x</code> and results <code class=\"code\">r</code></p>\n\n</div>\n", ["AFTER", "AND", "APPLIED", "HAPPENS", "OPERATION", "RESULTS", "THE", "UNARY", "UNOP"]);
add_ocaml_element("binop", "Std.Primus.Interpreter.binop", "value", "((Std.binop * Std.Primus.value * Std.Primus.value) *\n   Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALbinop", "<div class=\"info\">\n<p><code class=\"code\">binop&nbsp;((op,x,y),r)</code> happens after the binary operation <code class=\"code\">op</code>\n          is applied to values <code class=\"code\">x</code> and <code class=\"code\">y</code> and evaluates to <code class=\"code\">r</code></p>\n\n</div>\n", ["AFTER", "AND", "APPLIED", "BINARY", "BINOP", "EVALUATES", "HAPPENS", "OPERATION", "THE", "VALUES"]);
add_ocaml_element("const", "Std.Primus.Interpreter.const", "value", "Std.Primus.value Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALconst", "<div class=\"info\">\n<p><code class=\"code\">const&nbsp;x</code> happens when a constant <code class=\"code\">x</code> is created</p>\n\n</div>\n", ["CONST", "CONSTANT", "CREATED", "HAPPENS", "WHEN"]);
add_ocaml_element("undefined", "Std.Primus.Interpreter.undefined", "value", "Std.Primus.value Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALundefined", "<div class=\"info\">\n<p><code class=\"code\">undefined&nbsp;x</code> happens when a computation produces an\n          undefined value <code class=\"code\">x</code>.</p>\n\n</div>\n", ["COMPUTATION", "HAPPENS", "PRODUCES", "UNDEFINED", "VALUE", "WHEN"]);
add_ocaml_element("eval_cond", "Std.Primus.Interpreter.eval_cond", "value", "Std.Primus.value Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALeval_cond", "<div class=\"info\">\n<p><code class=\"code\">eval_cond&nbsp;v</code> occurs every time the <code class=\"code\">cond</code> part of a jump is\n          evaluated.</p>\n\n</div>\n", ["COND", "EVALUATED", "EVAL_COND", "EVERY", "JUMP", "OCCURS", "PART", "SINCE", "THE", "TIME"]);
add_ocaml_element("jumping", "Std.Primus.Interpreter.jumping", "value", "(Std.Primus.value * Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALjumping", "<div class=\"info\">\n<p><code class=\"code\">jumping&nbsp;(cond,dest)</code> happens just before a jump to <code class=\"code\">dest</code>\n          is taken under the specified condition <code class=\"code\">cond</code>.</p>\n\n</div>\n", ["ALWAYS", "BEFORE", "COND", "CONDITION", "DEST", "HAPPENS", "JUMP", "JUMPING", "JUST", "NOTE", "SINCE", "SPECIFIED", "TAKEN", "THE", "TRUE", "UNDER"]);
add_ocaml_element("written", "Std.Primus.Interpreter.written", "value", "(Std.var * Std.Primus.value) Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALwritten", "<div class=\"info\">\n<p><code class=\"code\">written&nbsp;(v,x)</code> happens after <code class=\"code\">x</code> is assinged to <code class=\"code\">v</code></p>\n\n</div>\n", ["AFTER", "ASSINGED", "HAPPENS", "WRITTEN"]);
add_ocaml_element("writing", "Std.Primus.Interpreter.writing", "value", "Std.var Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALwriting", "<div class=\"info\">\n<p><code class=\"code\">writing&nbsp;v</code> happens before a value is written to the variable <code class=\"code\">v</code></p>\n\n</div>\n", ["BEFORE", "HAPPENS", "THE", "VALUE", "VARIABLE", "WRITING", "WRITTEN"]);
add_ocaml_element("read", "Std.Primus.Interpreter.read", "value", "(Std.var * Std.Primus.value) Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALread", "<div class=\"info\">\n<p><code class=\"code\">read&nbsp;(var,x)</code> happens after a variable <code class=\"code\">var</code> is evaluated\n          to the value <code class=\"code\">x</code></p>\n\n</div>\n", ["AFTER", "EVALUATED", "HAPPENS", "READ", "THE", "VALUE", "VAR", "VARIABLE"]);
add_ocaml_element("reading", "Std.Primus.Interpreter.reading", "value", "Std.var Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALreading", "<div class=\"info\">\n<p><code class=\"code\">reading&nbsp;x</code> happens before the variable <code class=\"code\">x</code> is read from the\n          environment.</p>\n\n</div>\n", ["BEFORE", "ENVIRONMENT", "FROM", "HAPPENS", "READ", "READING", "THE", "VARIABLE"]);
add_ocaml_element("stored", "Std.Primus.Interpreter.stored", "value", "(Std.Primus.value * Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALstored", "<div class=\"info\">\n<p><code class=\"code\">stored&nbsp;(addr,value)</code> happens after the <code class=\"code\">value</code> is stored at\n          the address <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "ADDRESS", "AFTER", "HAPPENS", "STORED", "THE", "VALUE"]);
add_ocaml_element("storing", "Std.Primus.Interpreter.storing", "value", "Std.Primus.value Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALstoring", "<div class=\"info\">\n<p><code class=\"code\">storing&nbsp;x</code> happens before a value is stored at address <code class=\"code\">x</code></p>\n\n</div>\n", ["ADDRESS", "BEFORE", "HAPPENS", "STORED", "STORING", "VALUE"]);
add_ocaml_element("loaded", "Std.Primus.Interpreter.loaded", "value", "(Std.Primus.value * Std.Primus.value)\n  Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALloaded", "<div class=\"info\">\n<p><code class=\"code\">loaded&nbsp;(addr,value)</code> happens after the <code class=\"code\">value</code> is loaded\n          from the address <code class=\"code\">addr</code>.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "AFTER", "FROM", "HAPPENS", "LOADED", "THE", "VALUE"]);
add_ocaml_element("loading", "Std.Primus.Interpreter.loading", "value", "Std.Primus.value Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALloading", "<div class=\"info\">\n<p><code class=\"code\">loading&nbsp;x</code> happens before a value from the address <code class=\"code\">x</code> is loaded\n          by the interpreter from the memory.</p>\n\n</div>\n", ["ADDRESS", "BEFORE", "FROM", "HAPPENS", "INTERPRETER", "LOADED", "LOADING", "MEMORY", "THE", "VALUE"]);
add_ocaml_element("pc_change", "Std.Primus.Interpreter.pc_change", "value", "Std.addr Std.Primus.observation", "Bap_primus.Std.Primus.Interpreter.html#VALpc_change", "<div class=\"info\">\n<p><code class=\"code\">pc_change&nbsp;x</code> happens every time a code at address <code class=\"code\">x</code> is executed.</p>\n\n</div>\n", ["ADDRESS", "CODE", "EVERY", "EXECUTED", "HAPPENS", "PC_CHANGE", "TIME"]);
add_ocaml_element("key_width", "Std.Primus.Value.Index.key_width", "value", "int", "Bap_primus.Std.Primus.Value.Index.html#VALkey_width", "<div class=\"info\">\n<p>the width of keys in the index.</p>\n\n</div>\n", ["INDEX", "KEYS", "THE", "WIDTH"]);
add_ocaml_element("of_value", "Std.Primus.Value.Make.Symbol.of_value", "value", "Std.Primus.value -> string Machine.t", "Bap_primus.Std.Primus.Value.Make.Symbol.html#VALof_value", "<div class=\"info\">\n<p><code class=\"code\">of_value&nbsp;v</code> returns a symbolic representation of the\n              value <code class=\"code\">v</code>.</p>\n\n</div>\n", ["EMPTY", "ESTABLISHED", "OF_VALUE", "REPRESENTATION", "RETURNS", "STRING", "SYMBOLIC", "THE", "THEN", "VALUE", "WASN"]);
add_ocaml_element("to_value", "Std.Primus.Value.Make.Symbol.to_value", "value", "string -> Std.Primus.value Machine.t", "Bap_primus.Std.Primus.Value.Make.Symbol.html#VALto_value", "<div class=\"info\">\n<p><code class=\"code\">to_value&nbsp;sym</code> returns a value corresponding to the\n              provided symbolic representation.</p>\n\n</div>\n", ["CORRESPONDING", "PROVIDED", "REPRESENTATION", "RETURNS", "SYM", "SYMBOLIC", "THE", "TO_VALUE", "VALUE"]);
add_ocaml_element("(land)", "Std.Primus.Value.Make.Syntax.(land)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(land)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">land</span>)</code></p>\n\n</div>\n", ["LAND", "SEE", "WORD"]);
add_ocaml_element("(lxor)", "Std.Primus.Value.Make.Syntax.(lxor)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(lxor)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">lxor</span>)</code></p>\n\n</div>\n", ["LXOR", "SEE", "WORD"]);
add_ocaml_element("(asr)", "Std.Primus.Value.Make.Syntax.(asr)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(asr)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">asr</span>)</code></p>\n\n</div>\n", ["ASR", "SEE", "WORD"]);
add_ocaml_element("(lsr)", "Std.Primus.Value.Make.Syntax.(lsr)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(lsr)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">lsr</span>)</code></p>\n\n</div>\n", ["LSR", "SEE", "WORD"]);
add_ocaml_element("(lsl)", "Std.Primus.Value.Make.Syntax.(lsl)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(lsl)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">lsl</span>)</code></p>\n\n</div>\n", ["LSL", "SEE", "WORD"]);
add_ocaml_element("(lor)", "Std.Primus.Value.Make.Syntax.(lor)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(lor)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">lor</span>)</code></p>\n\n</div>\n", ["LOR", "SEE", "WORD"]);
add_ocaml_element("(mod)", "Std.Primus.Value.Make.Syntax.(mod)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(mod)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keyword\">mod</span>)</code></p>\n\n</div>\n", ["MOD", "SEE", "WORD"]);
add_ocaml_element("(/)", "Std.Primus.Value.Make.Syntax.(/)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(/)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(/)</code></p>\n\n</div>\n", ["SEE", "WORD"]);
add_ocaml_element("( * )", "Std.Primus.Value.Make.Syntax.( * )", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL( * )", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(&nbsp;*&nbsp;)</code></p>\n\n</div>\n", ["SEE", "WORD"]);
add_ocaml_element("(-)", "Std.Primus.Value.Make.Syntax.(-)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(-)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(-)</code></p>\n\n</div>\n", ["SEE", "WORD"]);
add_ocaml_element("(+)", "Std.Primus.Value.Make.Syntax.(+)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(+)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(+)</code></p>\n\n</div>\n", ["SEE", "WORD"]);
add_ocaml_element("(~-)", "Std.Primus.Value.Make.Syntax.(~-)", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.Syntax.html#VAL(~-)", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.(<span class=\"keywordsign\">~-</span>)</code></p>\n\n</div>\n", ["SEE", "WORD"]);
add_ocaml_element("arshift", "Std.Primus.Value.Make.arshift", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALarshift", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.arshift</code></p>\n\n</div>\n", ["ARSHIFT", "SEE", "WORD"]);
add_ocaml_element("rshift", "Std.Primus.Value.Make.rshift", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALrshift", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.rshift</code></p>\n\n</div>\n", ["RSHIFT", "SEE", "WORD"]);
add_ocaml_element("lshift", "Std.Primus.Value.Make.lshift", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALlshift", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.lshift</code></p>\n\n</div>\n", ["LSHIFT", "SEE", "WORD"]);
add_ocaml_element("logxor", "Std.Primus.Value.Make.logxor", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALlogxor", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.logxor</code></p>\n\n</div>\n", ["LOGXOR", "SEE", "WORD"]);
add_ocaml_element("logor", "Std.Primus.Value.Make.logor", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALlogor", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.logor</code></p>\n\n</div>\n", ["LOGOR", "SEE", "WORD"]);
add_ocaml_element("logand", "Std.Primus.Value.Make.logand", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALlogand", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.logand</code></p>\n\n</div>\n", ["LOGAND", "SEE", "WORD"]);
add_ocaml_element("lnot", "Std.Primus.Value.Make.lnot", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALlnot", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.lnot</code></p>\n\n</div>\n", ["LNOT", "SEE", "WORD"]);
add_ocaml_element("modulo", "Std.Primus.Value.Make.modulo", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALmodulo", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.modulo</code></p>\n\n</div>\n", ["MODULO", "SEE", "WORD"]);
add_ocaml_element("div", "Std.Primus.Value.Make.div", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALdiv", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.div</code></p>\n\n</div>\n", ["DIV", "SEE", "WORD"]);
add_ocaml_element("mul", "Std.Primus.Value.Make.mul", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALmul", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.mul</code></p>\n\n</div>\n", ["MUL", "SEE", "WORD"]);
add_ocaml_element("sub", "Std.Primus.Value.Make.sub", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALsub", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.sub</code></p>\n\n</div>\n", ["SEE", "SUB", "WORD"]);
add_ocaml_element("add", "Std.Primus.Value.Make.add", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALadd", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.add</code></p>\n\n</div>\n", ["ADD", "SEE", "WORD"]);
add_ocaml_element("neg", "Std.Primus.Value.Make.neg", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALneg", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.neg</code></p>\n\n</div>\n", ["NEG", "SEE", "WORD"]);
add_ocaml_element("abs", "Std.Primus.Value.Make.abs", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALabs", "<div class=\"info\">\n<p>see <code class=\"code\"><span class=\"constructor\">Word</span>.abs</code></p>\n\n</div>\n", ["ABS", "SEE", "WORD"]);
add_ocaml_element("npred", "Std.Primus.Value.Make.npred", "value", "Std.Primus.Value.Make.t ->\n  int -> Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALnpred", "<div class=\"info\">\n<p><code class=\"code\">npred</code> see <code class=\"code\"><span class=\"constructor\">Word</span>.npred</code></p>\n\n</div>\n", ["NPRED", "SEE", "WORD"]);
add_ocaml_element("nsucc", "Std.Primus.Value.Make.nsucc", "value", "Std.Primus.Value.Make.t ->\n  int -> Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALnsucc", "<div class=\"info\">\n<p><code class=\"code\">nsucc</code> see <code class=\"code\"><span class=\"constructor\">Word</span>.nsucc</code></p>\n\n</div>\n", ["NSUCC", "SEE", "WORD"]);
add_ocaml_element("pred", "Std.Primus.Value.Make.pred", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALpred", "<div class=\"info\">\n<p><code class=\"code\">pred</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.pred</code></p>\n\n</div>\n", ["LIFT1", "PRED", "WORD"]);
add_ocaml_element("succ", "Std.Primus.Value.Make.succ", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALsucc", "<div class=\"info\">\n<p><code class=\"code\">succ</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.succ</code></p>\n\n</div>\n", ["LIFT1", "SUCC", "WORD"]);
add_ocaml_element("concat", "Std.Primus.Value.Make.concat", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat</code> is <code class=\"code\">lift2&nbsp;<span class=\"constructor\">Word</span>.concat</code></p>\n\n</div>\n", ["CONCAT", "LIFT2", "WORD"]);
add_ocaml_element("extract", "Std.Primus.Value.Make.extract", "value", "?hi:int ->\n  ?lo:int ->\n  Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALextract", "<div class=\"info\">\n<p><code class=\"code\">extracts&nbsp;?hi&nbsp;?lo</code> is <code class=\"code\">lift1&nbsp;(<span class=\"constructor\">Word</span>.extract&nbsp;?hi&nbsp;?lo)</code></p>\n\n</div>\n", ["EXTRACT", "EXTRACTS", "LIFT1", "WORD"]);
add_ocaml_element("bitwidth", "Std.Primus.Value.Make.bitwidth", "value", "Std.Primus.Value.Make.t -> int", "Bap_primus.Std.Primus.Value.Make.html#VALbitwidth", "<div class=\"info\">\n<p><code class=\"code\">bitwidth</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.bitwidth</code></p>\n\n</div>\n", ["BITWIDTH", "LIFT1", "WORD"]);
add_ocaml_element("is_non_negative", "Std.Primus.Value.Make.is_non_negative", "value", "Std.Primus.Value.Make.t -> bool", "Bap_primus.Std.Primus.Value.Make.html#VALis_non_negative", "<div class=\"info\">\n<p><code class=\"code\">is_non_negative</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.is_non_negative</code></p>\n\n</div>\n", ["IS_NON_NEGATIVE", "LIFT1", "WORD"]);
add_ocaml_element("is_non_positive", "Std.Primus.Value.Make.is_non_positive", "value", "Std.Primus.Value.Make.t -> bool", "Bap_primus.Std.Primus.Value.Make.html#VALis_non_positive", "<div class=\"info\">\n<p><code class=\"code\">is_non_positive</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.is_non_positive</code></p>\n\n</div>\n", ["IS_NON_POSITIVE", "LIFT1", "WORD"]);
add_ocaml_element("is_negative", "Std.Primus.Value.Make.is_negative", "value", "Std.Primus.Value.Make.t -> bool", "Bap_primus.Std.Primus.Value.Make.html#VALis_negative", "<div class=\"info\">\n<p><code class=\"code\">is_negative</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.is_negative</code></p>\n\n</div>\n", ["IS_NEGATIVE", "LIFT1", "WORD"]);
add_ocaml_element("is_positive", "Std.Primus.Value.Make.is_positive", "value", "Std.Primus.Value.Make.t -> bool", "Bap_primus.Std.Primus.Value.Make.html#VALis_positive", "<div class=\"info\">\n<p><code class=\"code\">is_positive</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.is_positive</code></p>\n\n</div>\n", ["IS_POSITIVE", "LIFT1", "WORD"]);
add_ocaml_element("is_one", "Std.Primus.Value.Make.is_one", "value", "Std.Primus.Value.Make.t -> bool", "Bap_primus.Std.Primus.Value.Make.html#VALis_one", "<div class=\"info\">\n<p><code class=\"code\">is_one</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.is_one</code></p>\n\n</div>\n", ["IS_ONE", "LIFT1", "WORD"]);
add_ocaml_element("is_zero", "Std.Primus.Value.Make.is_zero", "value", "Std.Primus.Value.Make.t -> bool", "Bap_primus.Std.Primus.Value.Make.html#VALis_zero", "<div class=\"info\">\n<p><code class=\"code\">is_zero</code> is <code class=\"code\">lift1&nbsp;<span class=\"constructor\">Word</span>.is_zero</code></p>\n\n</div>\n", ["IS_ZERO", "LIFT1", "WORD"]);
add_ocaml_element("signed", "Std.Primus.Value.Make.signed", "value", "Std.Primus.Value.Make.t ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALsigned", "<div class=\"info\">\n<p><code class=\"code\">signed&nbsp;x</code> same as <code class=\"code\">of_word&nbsp;@@&nbsp;signed&nbsp;x</code></p>\n\n</div>\n", ["OF_WORD", "SAME", "SIGNED"]);
add_ocaml_element("zero", "Std.Primus.Value.Make.zero", "value", "int -> Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero&nbsp;x</code> same as <code class=\"code\">of_word&nbsp;@@&nbsp;zero&nbsp;x</code></p>\n\n</div>\n", ["OF_WORD", "SAME", "ZERO"]);
add_ocaml_element("one", "Std.Primus.Value.Make.one", "value", "int -> Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALone", "<div class=\"info\">\n<p><code class=\"code\">one&nbsp;x</code> same as <code class=\"code\">of_word&nbsp;@@&nbsp;one&nbsp;x</code></p>\n\n</div>\n", ["OF_WORD", "ONE", "SAME"]);
add_ocaml_element("b1", "Std.Primus.Value.Make.b1", "value", "Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALb1", "<div class=\"info\">\n<p>a fresh new <code class=\"code\"><span class=\"keyword\">true</span></code> computation</p>\n\n</div>\n", ["COMPUTATION", "FRESH", "NEW", "TRUE"]);
add_ocaml_element("b0", "Std.Primus.Value.Make.b0", "value", "Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALb0", "<div class=\"info\">\n<p>a fresh new <code class=\"code\"><span class=\"keyword\">false</span></code> computation</p>\n\n</div>\n", ["COMPUTATION", "FALSE", "FRESH", "NEW"]);
add_ocaml_element("of_int64", "Std.Primus.Value.Make.of_int64", "value", "?width:int ->\n  int64 ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALof_int64", "<div class=\"info\">\n<p><code class=\"code\">of_int64&nbsp;x</code> creates a fresh new value from <code class=\"code\">x</code></p>\n\n</div>\n", ["CREATES", "FRESH", "FROM", "NEW", "OF_INT64", "VALUE"]);
add_ocaml_element("of_int32", "Std.Primus.Value.Make.of_int32", "value", "?width:int ->\n  int32 ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALof_int32", "<div class=\"info\">\n<p><code class=\"code\">of_int32&nbsp;x</code> creates a fresh new value from <code class=\"code\">x</code></p>\n\n</div>\n", ["CREATES", "FRESH", "FROM", "NEW", "OF_INT32", "VALUE"]);
add_ocaml_element("of_int", "Std.Primus.Value.Make.of_int", "value", "width:int ->\n  int -> Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALof_int", "<div class=\"info\">\n<p><code class=\"code\">of_int&nbsp;~width&nbsp;x</code> creates a fresh new value of the given\n            <code class=\"code\">width</code> from the integer <code class=\"code\">x</code></p>\n\n</div>\n", ["CREATES", "FRESH", "FROM", "GIVEN", "INTEGER", "NEW", "OF_INT", "THE", "VALUE", "WIDTH"]);
add_ocaml_element("of_bool", "Std.Primus.Value.Make.of_bool", "value", "bool -> Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALof_bool", "<div class=\"info\">\n<p><code class=\"code\">of_bool&nbsp;x</code> creates a fresh new value from the boolean <code class=\"code\">x</code>.</p>\n\n</div>\n", ["BOOLEAN", "CREATES", "FRESH", "FROM", "NEW", "OF_BOOL", "THE", "VALUE"]);
add_ocaml_element("of_string", "Std.Primus.Value.Make.of_string", "value", "string ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;s</code> computes a fresh new value from a textual\n            representation of a machine word <code class=\"code\">x</code>.</p>\n\n</div>\n", ["BAP", "COMPUTES", "DETAILS", "FOR", "FRESH", "FROM", "MACHINE", "MODULE", "MORE", "NEW", "OF_STRING", "REPRESENTATION", "SEE", "STD", "TEXTUAL", "VALUE", "WORD"]);
add_ocaml_element("of_word", "Std.Primus.Value.Make.of_word", "value", "Std.word ->\n  Std.Primus.Value.Make.t Std.Primus.Value.Make.m", "Bap_primus.Std.Primus.Value.Make.html#VALof_word", "<div class=\"info\">\n<p><code class=\"code\">of_word&nbsp;x</code> computes a fresh new value from <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "FRESH", "FROM", "NEW", "OF_WORD", "VALUE"]);
add_ocaml_element("to_word", "Std.Primus.Value.Make.to_word", "value", "Std.Primus.Value.Make.t -> Std.word", "Bap_primus.Std.Primus.Value.Make.html#VALto_word", "<div class=\"info\">\n<p><code class=\"code\">to_word&nbsp;x</code> projects <code class=\"code\">x</code> to a machine <code class=\"code\">word</code>.</p>\n\n</div>\n", ["ARE", "FROM", "FUNCTOR", "INTO", "LIFTED", "MACHINE", "MANY", "MODULE", "MONAD", "NECESSARY", "NOT", "NOTE", "OPERATION", "OPERATIONS", "PROJECTS", "THE", "THIS", "TO_WORD", "USUALLY", "WORD"]);
add_ocaml_element("id", "Std.Primus.Value.Make.id", "value", "Std.Primus.Value.Make.t -> Std.Primus.Value.id", "Bap_primus.Std.Primus.Value.Make.html#VALid", "<div class=\"info\">\n<p><code class=\"code\">id&nbsp;x</code> is a unique identifier of a value.</p>\n\n</div>\n", ["AND", "ARITHMENTIC", "COMPUTATION", "CONSTAINT", "EACH", "EVALUATION", "EVERY", "EXPRESSION", "IDENTIFIER", "IDENTIFIERS", "MEMORY", "NEW", "NON", "ONLY", "PRESERVES", "PRODUCES", "READING", "SETING", "TRIVIAL", "UNIQUE", "VALUE", "VARIABLE", "WITH"]);
add_ocaml_element("id", "Std.Primus.Value.id", "value", "Std.Primus.Value.t -> Std.Primus.Value.id", "Bap_primus.Std.Primus.Value.html#VALid", "<div class=\"info\">\n<p><code class=\"code\">id&nbsp;value</code> returns the <code class=\"code\">value</code> identifier</p>\n\n</div>\n", ["IDENTIFIER", "RETURNS", "THE", "VALUE"]);
add_ocaml_element("to_word", "Std.Primus.Value.to_word", "value", "Std.Primus.Value.t -> Std.word", "Bap_primus.Std.Primus.Value.html#VALto_word", "<div class=\"info\">\n<p><code class=\"code\">to_word&nbsp;x</code> projects <code class=\"code\">x</code> to a machine word</p>\n\n</div>\n", ["MACHINE", "PROJECTS", "TO_WORD", "WORD"]);
add_ocaml_element("run", "Std.Primus.Machine.Main.run", "value", "?envp:string array ->\n  ?args:string array ->\n  Std.project ->\n  unit M.t -> (Std.Primus.exit_status * Std.project) M.m", "Bap_primus.Std.Primus.Machine.Main.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;?envp&nbsp;?args&nbsp;proj</code> returns a computation that will\n            run a program represented with the <code class=\"code\">proj</code> data structure.</p>\n\n</div>\n", ["ACCESSIBLE", "AND", "ANNOTATED", "ARE", "ARGP", "ARGS", "ATTRIBUTES", "CAN", "COMPONENTS", "COMPUTATION", "CONSTANTS", "DATA", "DURING", "ENVP", "ETC", "EVALUATES", "MACHINE", "MODIFIED", "PAIR", "PARAMETERS", "PRIMUS", "PROGRAM", "PROJ", "PROJECT", "REPRESENTED", "RESULT", "RETURNS", "RUN", "STRUCTURE", "THAT", "THE", "USING", "WHERE", "WILL", "WITH"]);
add_ocaml_element("update", "Std.Primus.Machine.State.update", "value", "'a Std.Primus.Machine.State.t ->\n  f:('a -> 'a) -> unit Std.Primus.Machine.State.m", "Bap_primus.Std.Primus.Machine.State.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;state&nbsp;~f</code> updates a state using function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["FUNCTION", "STATE", "UPDATE", "UPDATES", "USING"]);
add_ocaml_element("put", "Std.Primus.Machine.State.put", "value", "'a Std.Primus.Machine.State.t ->\n  'a -> unit Std.Primus.Machine.State.m", "Bap_primus.Std.Primus.Machine.State.html#VALput", "<div class=\"info\">\n<p><code class=\"code\">put&nbsp;state&nbsp;x</code> saves a machine state</p>\n\n</div>\n", ["MACHINE", "PUT", "SAVES", "STATE"]);
add_ocaml_element("get", "Std.Primus.Machine.State.get", "value", "'a Std.Primus.Machine.State.t ->\n  'a Std.Primus.Machine.State.m", "Bap_primus.Std.Primus.Machine.State.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;state</code> extracts the state.</p>\n\n</div>\n", ["EXTRACTS", "GET", "STATE", "THE"]);
add_ocaml_element("(>>>)", "Std.Primus.Machine.S.Syntax.(>>>)", "value", "'a Std.Primus.observation ->\n  ('a -> unit Std.Primus.Machine.S.t) ->\n  unit Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.Syntax.html#VAL(>>>)", "<div class=\"info\">\n<p><code class=\"code\">event&nbsp;&gt;&gt;&gt;&nbsp;action</code> is the same as\n              <code class=\"code\"><span class=\"constructor\">Observation</span>.observe&nbsp;event&nbsp;action</code></p>\n\n</div>\n", ["ACTION", "EVENT", "OBSERVATION", "OBSERVE", "SAME", "THE"]);
add_ocaml_element("make", "Std.Primus.Machine.S.Observation.make", "value", "'a Std.Primus.statement ->\n  'a -> unit Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.Observation.html#VALmake", "<div class=\"info\">\n<p><code class=\"code\">make&nbsp;observation&nbsp;event</code> make an <code class=\"code\">observation</code> of the\n              given <code class=\"code\">event</code>.</p>\n\n</div>\n", ["EVENT", "GIVEN", "MAKE", "OBSERVATION", "THE"]);
add_ocaml_element("watch", "Std.Primus.Machine.S.Observation.watch", "value", "Std.Primus.Observation.provider ->\n  (Sexp.t -> unit Std.Primus.Machine.S.t) ->\n  unit Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.Observation.html#VALwatch", "", []);
add_ocaml_element("observe", "Std.Primus.Machine.S.Observation.observe", "value", "'a Std.Primus.observation ->\n  ('a -> unit Std.Primus.Machine.S.t) ->\n  unit Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.Observation.html#VALobserve", "<div class=\"info\">\n<p><code class=\"code\">observe&nbsp;obs&nbsp;on_observation</code> subscribes to the given\n              observation <code class=\"code\">obs</code>.</p>\n\n</div>\n", ["ACCESS", "ARBITRARY", "CALLED", "CAN", "COMPONENTS", "COMPUTATIONS", "EVERY", "FUNCTION", "GIVEN", "INTERFACES", "ITS", "MACHINE", "MADE", "MAKE", "MONAD", "OBS", "OBSERVATION", "OBSERVE", "ON_OBSERVATION", "OTHER", "OWN", "PERFORM", "SUBSCRIBES", "THE", "THEIR", "TIME", "VIA"]);
add_ocaml_element("envp", "Std.Primus.Machine.S.envp", "value", "string array Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALenvp", "<div class=\"info\">\n<p><code class=\"code\">envp</code> program environment variables.</p>\n\n</div>\n", ["ENVIRONMENT", "ENVP", "PROGRAM", "VARIABLES"]);
add_ocaml_element("args", "Std.Primus.Machine.S.args", "value", "string array Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALargs", "<div class=\"info\">\n<p><code class=\"code\">args</code> program command line arguments</p>\n\n</div>\n", ["ARGS", "ARGUMENTS", "COMMAND", "LINE", "PROGRAM"]);
add_ocaml_element("arch", "Std.Primus.Machine.S.arch", "value", "Std.arch Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALarch", "<div class=\"info\">\n<p><code class=\"code\">arch</code> code architecture</p>\n\n</div>\n", ["ARCH", "ARCHITECTURE", "CODE"]);
add_ocaml_element("program", "Std.Primus.Machine.S.program", "value", "Std.program Std.term Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALprogram", "<div class=\"info\">\n<p><code class=\"code\">program</code> program representation</p>\n\n</div>\n", ["PROGRAM", "REPRESENTATION"]);
add_ocaml_element("project", "Std.Primus.Machine.S.project", "value", "Std.project Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALproject", "<div class=\"info\">\n<p><code class=\"code\">project</code> is a computation that results with the project\n            data structure.</p>\n\n</div>\n", ["CAN", "COMPUTATION", "DATA", "ENV", "EQUAL", "GET", "MACHINE", "MONAD", "NOTE", "PROJECT", "PUT", "RESULTS", "SHORTCUT", "STATE", "STRUCTURE", "THAT", "THE", "THUS", "TYPE", "UPDATE", "USE", "WITH", "YOU"]);
add_ocaml_element("catch", "Std.Primus.Machine.S.catch", "value", "'a Std.Primus.Machine.S.t ->\n  (Std.Primus.exn -> 'a Std.Primus.Machine.S.t) ->\n  'a Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALcatch", "<div class=\"info\">\n<p><code class=\"code\">catch&nbsp;x&nbsp;f</code> creates a computation that is equal to <code class=\"code\">x</code> if\n            it terminates normally, and to <code class=\"code\">f&nbsp;e</code> if <code class=\"code\">x</code> terminates\n            abnormally with the exception <code class=\"code\">e</code>.</p>\n\n</div>\n", ["ABNORMALLY", "AND", "CATCH", "COMPUTATION", "CREATES", "EQUAL", "EXCEPTION", "NORMALLY", "TERMINATES", "THAT", "THE", "WITH"]);
add_ocaml_element("raise", "Std.Primus.Machine.S.raise", "value", "Std.Primus.exn -> 'a Std.Primus.Machine.S.t", "Bap_primus.Std.Primus.Machine.S.html#VALraise", "<div class=\"info\">\n<p><code class=\"code\">raise&nbsp;exn</code> raises the machine exception <code class=\"code\">exn</code>, intiating\n            an abonormal control flow</p>\n\n</div>\n", ["ABONORMAL", "CONTROL", "EXCEPTION", "EXN", "FLOW", "INTIATING", "MACHINE", "RAISE", "RAISES", "THE"]);
add_ocaml_element("name", "Std.Primus.Machine.State.name", "value", "'a Std.Primus.Machine.State.t -> string", "Bap_primus.Std.Primus.Machine.State.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;state</code> a state name that was given during the construction.</p>\n\n</div>\n", ["CONSTRUCTION", "DURING", "GIVEN", "NAME", "STATE", "THAT", "THE", "WAS"]);
add_ocaml_element("inspect", "Std.Primus.Machine.State.inspect", "value", "'a Std.Primus.Machine.State.t -> 'a -> Sexp.t", "Bap_primus.Std.Primus.Machine.State.html#VALinspect", "<div class=\"info\">\n<p><code class=\"code\">inspect&nbsp;state&nbsp;value</code> introspects given <code class=\"code\">value</code> of the state.</p>\n\n</div>\n", ["GIVEN", "INSPECT", "INTROSPECTS", "STATE", "THE", "VALUE"]);
add_ocaml_element("declare", "Std.Primus.Machine.State.declare", "value", "?inspect:('a -> Sexp.t) ->\n  uuid:Std.Primus.Machine.State.uuid ->\n  name:string ->\n  (Std.project -> 'a) -> 'a Std.Primus.Machine.State.t", "Bap_primus.Std.Primus.Machine.State.html#VALdeclare", "<div class=\"info\">\n<p><code class=\"code\">declare&nbsp;~inspect&nbsp;~uuid&nbsp;~name&nbsp;make</code> declares a state with\n            the given <code class=\"code\">uuid</code> and <code class=\"code\">name</code>.</p>\n\n</div>\n", ["AND", "CAN", "COMMAND", "DECLARE", "DECLARES", "DESCRIPTION", "FOR", "GIVEN", "INSPECT", "LINUX", "MAKE", "NAME", "NEW", "NOT", "OBTAINED", "OBVIOUSLY", "PROVIDED", "REPRESENTATION", "REQUIRED", "SEE", "STATE", "SYSTEM", "THE", "TYPE", "UNIQUE", "UUID", "UUIDGEN", "WHILE", "WITH"]);
add_ocaml_element("add_component", "Std.Primus.Machine.add_component", "value", "Std.Primus.Machine.component -> unit", "Bap_primus.Std.Primus.Machine.html#VALadd_component", "<div class=\"info\">\n<p><code class=\"code\">add_component&nbsp;comp</code> registers a machine component in the\n          Primus Framework.</p>\n\n</div>\n", ["ADD_COMPONENT", "COMP", "COMPONENT", "FRAMEWORK", "MACHINE", "PRIMUS", "REGISTERS", "THE"]);
add_ocaml_element("exn_raised", "Std.Primus.Machine.exn_raised", "value", "Std.Primus.exn Std.Primus.observation", "Bap_primus.Std.Primus.Machine.html#VALexn_raised", "<div class=\"info\">\n<p><code class=\"code\">exn_raised&nbsp;exn</code> occurs every time an abnormal control flow\n          is initiated</p>\n\n</div>\n", ["ABNORMAL", "CONTROL", "EVERY", "EXN", "EXN_RAISED", "FLOW", "INITIATED", "OCCURS", "TIME"]);
add_ocaml_element("finished", "Std.Primus.Machine.finished", "value", "unit Std.Primus.observation", "Bap_primus.Std.Primus.Machine.html#VALfinished", "<div class=\"info\">\n<p>The <code class=\"code\">finished</code> event occurs when the machine terminates.</p>\n\n</div>\n", ["EVENT", "FINISHED", "MACHINE", "OCCURS", "TERMINATES", "THE", "WHEN"]);
add_ocaml_element("init", "Std.Primus.Machine.init", "value", "unit Std.Primus.observation", "Bap_primus.Std.Primus.Machine.html#VALinit", "<div class=\"info\">\n<p><code class=\"code\">init</code> event occurs just after all components have been\n          initialized, and before the execution starts</p>\n\n</div>\n", ["AFTER", "ALL", "AND", "BEEN", "BEFORE", "COMPONENTS", "EVENT", "EXECUTION", "HAVE", "INIT", "INITIALIZED", "JUST", "OCCURS", "STARTS", "THE"]);
add_ocaml_element("next", "Std.Primus.Pos.next", "value", "Std.Primus.Pos.t ->\n  ('p, 't) Std.cls ->\n  't Std.term ->\n  (Std.Primus.Pos.t, Std.Primus.exn)\n  Std.Monad.Result.result", "Bap_primus.Std.Primus.Pos.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;p&nbsp;cls&nbsp;t</code> moves the cursor position <code class=\"code\">p</code> to the next\n          position, that points to the term <code class=\"code\">t</code> of the class\n          <code class=\"code\">cls</code>.</p>\n\n</div>\n", ["CLASS", "CLS", "CURRENT", "CURSOR", "ERROR", "FROM", "MOVES", "NEXT", "POINTS", "POSITION", "PROGRAM", "RETURNS", "SPECIFIED", "TERM", "THAT", "THE", "THERE", "TRANSITION", "VALID"]);
add_ocaml_element("to_string", "Std.Primus.Pos.to_string", "value", "Std.Primus.Pos.t -> string", "Bap_primus.Std.Primus.Pos.html#VALto_string", "<div class=\"info\">\n<p><code class=\"code\">to_string&nbsp;level</code> a textual and human readable\n          representation of a cursor.</p>\n\n</div>\n", ["AND", "CURSOR", "HUMAN", "LEVEL", "READABLE", "REPRESENTATION", "TEXTUAL", "TO_STRING"]);
add_ocaml_element("get", "Std.Primus.Pos.get", "value", "'a Std.tag -> Std.Primus.Pos.t -> 'a option", "Bap_primus.Std.Primus.Pos.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;a&nbsp;p</code> get a value of the attribute <code class=\"code\">a</code> associated with\n          the given position <code class=\"code\">p</code>.</p>\n\n</div>\n", ["ADDRESS", "ASSOCIATED", "ATTRIBUTE", "EXAMPLE", "GET", "GIVEN", "MACHINE", "POS", "POSITION", "RETURNS", "THE", "VALUE", "WITH"]);
add_ocaml_element("tid", "Std.Primus.Pos.tid", "value", "Std.Primus.Pos.t -> Std.tid", "Bap_primus.Std.Primus.Pos.html#VALtid", "<div class=\"info\">\n<p><code class=\"code\">tid&nbsp;p</code> is term identifier of the term enclosing position <code class=\"code\">p</code></p>\n\n</div>\n", ["ENCLOSING", "IDENTIFIER", "POSITION", "TERM", "THE", "TID"]);
add_ocaml_element("data", "Std.Primus.Observation.Provider.data", "value", "Std.Primus.Observation.Provider.t ->\n  Sexp.t Bap_future.Std.stream", "Bap_primus.Std.Primus.Observation.Provider.html#VALdata", "<div class=\"info\">\n<p>a data stream from this observation</p>\n\n</div>\n", ["DATA", "FROM", "OBSERVATION", "STREAM", "THIS"]);
add_ocaml_element("triggers", "Std.Primus.Observation.Provider.triggers", "value", "Std.Primus.Observation.Provider.t -> unit Bap_future.Std.stream", "Bap_primus.Std.Primus.Observation.Provider.html#VALtriggers", "<div class=\"info\">\n<p>triggers a stream of occurences of this observation</p>\n\n</div>\n", ["OBSERVATION", "OCCURENCES", "STREAM", "THIS", "TRIGGERS"]);
add_ocaml_element("observers", "Std.Primus.Observation.Provider.observers", "value", "Std.Primus.Observation.Provider.t -> int", "Bap_primus.Std.Primus.Observation.Provider.html#VALobservers", "<div class=\"info\">\n<p>a total number of observers that subscribed to this provider</p>\n\n</div>\n", ["NUMBER", "OBSERVERS", "PROVIDER", "SUBSCRIBED", "THAT", "THIS", "TOTAL"]);
add_ocaml_element("name", "Std.Primus.Observation.Provider.name", "value", "Std.Primus.Observation.Provider.t -> string", "Bap_primus.Std.Primus.Observation.Provider.html#VALname", "<div class=\"info\">\n<p>unique name of a provider</p>\n\n</div>\n", ["NAME", "PROVIDER", "UNIQUE"]);
add_ocaml_element("list_providers", "Std.Primus.Observation.list_providers", "value", "unit -> Std.Primus.Observation.provider list", "Bap_primus.Std.Primus.Observation.html#VALlist_providers", "<div class=\"info\">\n<p>enumerate all currently available observation providers</p>\n\n</div>\n", ["ALL", "AVAILABLE", "CURRENTLY", "ENUMERATE", "OBSERVATION", "PROVIDERS"]);
add_ocaml_element("inspect", "Std.Primus.Observation.inspect", "value", "'a Std.Primus.observation -> 'a -> Sexp.t", "Bap_primus.Std.Primus.Observation.html#VALinspect", "<div class=\"info\">\n<p><code class=\"code\">inspect&nbsp;observation&nbsp;value</code> returns a sexp representation of\n          an observed <code class=\"code\">value</code></p>\n\n</div>\n", ["INSPECT", "OBSERVATION", "OBSERVED", "REPRESENTATION", "RETURNS", "SEXP", "VALUE"]);
add_ocaml_element("name", "Std.Primus.Observation.name", "value", "'a Std.Primus.observation -> string", "Bap_primus.Std.Primus.Observation.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;observation</code> is a name of the observed attribute.</p>\n\n</div>\n", ["ATTRIBUTE", "NAME", "OBSERVATION", "OBSERVED", "THE"]);
add_ocaml_element("provide", "Std.Primus.Observation.provide", "value", "?inspect:('a -> Sexp.t) ->\n  string ->\n  'a Std.Primus.observation * 'a Std.Primus.statement", "Bap_primus.Std.Primus.Observation.html#VALprovide", "<div class=\"info\">\n<p><code class=\"code\">provide&nbsp;?inspect&nbsp;name</code> returns a pair of two handlers.</p>\n\n</div>\n", ["AND", "DISCLOSE", "ELEMENT", "EVERYTHING", "FIRST", "FOR", "FUNCTION", "HANDLERS", "INSPECT", "INTROSPECTION", "MAY", "NAME", "NECESSARY", "NOT", "OBSERVATION", "OBSERVE", "OBSERVED", "PAIR", "PRETTY", "PRINTING", "PROVIDE", "PROVIDED", "REPRESENTATION", "REQUIRED", "RETURNS", "SECOND", "SEXP", "THAT", "THE", "TWO", "USED", "VALUE", "VALUES", "WILL"]);
add_ocaml_element("of_value", "Bap_taint.Std.Value.of_value", "value", "Std.Primus.value -> Bap_taint.Std.Value.t Bap_taint.Std.Value.m", "Bap_taint.Std.Value.html#VALof_value", "<div class=\"info\">\n<p><code class=\"code\">of_value&nbsp;v</code> project the value <code class=\"code\">v</code> to the abstract domain of <code class=\"code\">t</code></p>\n\n</div>\n", ["ABSTRACT", "DOMAIN", "OF_VALUE", "PROJECT", "THE", "VALUE"]);
add_ocaml_element("to_value", "Bap_taint.Std.Value.to_value", "value", "Bap_taint.Std.Value.t -> Std.Primus.value Bap_taint.Std.Value.m", "Bap_taint.Std.Value.html#VALto_value", "", []);
add_ocaml_element("init", "Std.Primus.Machine.Component.init", "value", "unit -> unit Machine.t", "Bap_primus.Std.Primus.Machine.Component.html#VALinit", "<div class=\"info\">\n<p><code class=\"code\">init&nbsp;()</code> component initialization function.</p>\n\n</div>\n", ["COMPONENT", "FUNCTION", "INIT", "INITIALIZATION"]);
add_ocaml_element("taint_finalize", "Bap_taint.Std.Taint.Gc.taint_finalize", "value", "(Bap_taint.Std.Taint.Object.t * bool) Std.Primus.observation", "Bap_taint.Std.Taint.Gc.html#VALtaint_finalize", "<div class=\"info\">\n<p><code class=\"code\">taint_finalize&nbsp;(t,live)</code> occurs either when the taint <code class=\"code\">t</code>\n          is no longer reachable or when when machine that created this\n          taint finishes.</p>\n\n</div>\n", ["ACTUAL", "AND", "BECOME", "BETWEEN", "CASE", "COLLECTION", "COULD", "CREATED", "CYCLE", "DELAY", "DURING", "EITHER", "EVENT", "FALSE", "FINISHES", "FORMER", "LATTER", "LIVE", "LONGER", "MACHINE", "MADE", "MAY", "OBSERVATION", "OCCUR", "OCCURS", "REACHABLE", "SIGNIFICANT", "TAINT", "TAINT_FINALIZE", "THAT", "THE", "THERE", "THIS", "TIME", "TRUE", "UNREACHABLE", "WHEN", "WOULD"]);
add_ocaml_element("propagate", "Bap_taint.Std.Taint.Propagation.Policy.Make.propagate", "value", "Bap_taint.Std.Taint.Propagation.Policy.t ->\n  Bap_taint.Std.Taint.Rel.t ->\n  Bap_taint.Std.Taint.Rel.t ->\n  Std.Primus.value list ->\n  Std.Primus.value -> unit Machine.t", "Bap_taint.Std.Taint.Propagation.Policy.Make.html#VALpropagate", "<div class=\"info\">\n<p><code class=\"code\">propagate&nbsp;p&nbsp;rs&nbsp;rd&nbsp;srcs&nbsp;dst</code> transfers objects\n              associated with <code class=\"code\">srcs</code> to <code class=\"code\">dst</code> based on the selected\n              policy <code class=\"code\">p</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "ASSOCIATED", "ASSOCIATIONS", "ATTACHED", "BASED", "DST", "EFFECT", "HAVE", "OBJECTS", "POLICY", "PROPAGATE", "PROPAGATION", "RELATION", "REMAIN", "SELECTED", "SRCS", "THAT", "THE", "TRANSFERS", "UNAFFECTED", "USING", "VALUE", "VALUES", "WERE", "WITH"]);
add_ocaml_element("selected", "Bap_taint.Std.Taint.Propagation.Policy.Make.selected", "value", "Bap_taint.Std.Taint.Propagation.Policy.t ->\n  Bap_taint.Std.Taint.Kind.t -> bool Machine.t", "Bap_taint.Std.Taint.Propagation.Policy.Make.html#VALselected", "<div class=\"info\">\n<p><code class=\"code\">selected&nbsp;p&nbsp;k</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if the policy <code class=\"code\">p</code> was selected\n              for the kind <code class=\"code\">k</code>.</p>\n\n</div>\n", ["FOR", "KIND", "POLICY", "SELECTED", "THE", "TRUE", "WAS"]);
add_ocaml_element("set_default", "Bap_taint.Std.Taint.Propagation.Policy.Make.set_default", "value", "Bap_taint.Std.Taint.Propagation.Policy.t -> unit Machine.t", "Bap_taint.Std.Taint.Propagation.Policy.Make.html#VALset_default", "<div class=\"info\">\n<p><code class=\"code\">set_default&nbsp;policy</code> makes <code class=\"code\">policy</code> the default policy\n              for all kinds that didn't select their own taint\n              propagation policies.</p>\n\n</div>\n", ["ALL", "DEFAULT", "DIDN", "FOR", "KINDS", "MAKES", "OWN", "POLICIES", "POLICY", "PROPAGATION", "SELECT", "SET_DEFAULT", "TAINT", "THAT", "THE", "THEIR"]);
add_ocaml_element("select", "Bap_taint.Std.Taint.Propagation.Policy.Make.select", "value", "Bap_taint.Std.Taint.Propagation.Policy.t ->\n  Bap_taint.Std.Taint.Kind.t -> unit Machine.t", "Bap_taint.Std.Taint.Propagation.Policy.Make.html#VALselect", "<div class=\"info\">\n<p><code class=\"code\">select&nbsp;p&nbsp;k</code> selects the taint propagation policy <code class=\"code\">p</code>\n              for objects of kind <code class=\"code\">k</code>.</p>\n\n</div>\n", ["DEFAULT", "FOR", "KIND", "OBJECT", "OBJECTS", "POLICY", "PROPAGATED", "PROPAGATION", "SELECT", "SELECTED", "SELECTS", "TAINT", "THAT", "THE", "THEN", "WILL"]);
add_ocaml_element("sanitize", "Bap_taint.Std.Taint.Tracker.Make.sanitize", "value", "Std.Primus.value ->\n  Bap_taint.Std.Taint.Rel.t -> Bap_taint.Std.Taint.Kind.t -> unit Machine.t", "Bap_taint.Std.Taint.Tracker.Make.html#VALsanitize", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Taint</span>.sanitize&nbsp;r&nbsp;k&nbsp;v</code> detaches all objects related to the\n            value <code class=\"code\">v</code> by the relation <code class=\"code\">r</code> that has the given kind <code class=\"code\">k</code>.</p>\n\n</div>\n", ["ALL", "DETACH", "DETACHES", "FILTER", "GIVEN", "HAS", "HAS_KIND", "KIND", "LEVEL", "LOOKUP", "LOW", "OBJECTS", "OPERATIONS", "RELATED", "RELATION", "SANITIZE", "TAINT", "TERMS", "THAT", "THE", "VALUE"]);
add_ocaml_element("new_indirect", "Bap_taint.Std.Taint.Tracker.Make.new_indirect", "value", "addr:Std.Primus.value ->\n  len:Std.Primus.value ->\n  Bap_taint.Std.Taint.Kind.t -> Bap_taint.Std.Taint.Object.t Machine.t", "Bap_taint.Std.Taint.Tracker.Make.html#VALnew_indirect", "<div class=\"info\">\n<p><code class=\"code\">new_indirect&nbsp;~addr:v&nbsp;~len:n&nbsp;k</code> establishes a new indirect\n            relation between a set of addresses, denoted by interval\n            <code class=\"code\">[v,v+n-1]</code>, and a freshly created object of specified\n            kind.</p>\n\n</div>\n", ["ADDR", "ADDRESSES", "AND", "BETWEEN", "CREATED", "DENOTED", "ESTABLISHES", "FRESHLY", "INDIRECT", "INTERVAL", "KIND", "LEN", "NEW", "NEW_INDIRECT", "OBJECT", "RELATION", "SET", "SPECIFIED"]);
add_ocaml_element("new_direct", "Bap_taint.Std.Taint.Tracker.Make.new_direct", "value", "Std.Primus.value ->\n  Bap_taint.Std.Taint.Kind.t -> Bap_taint.Std.Taint.Object.t Machine.t", "Bap_taint.Std.Taint.Tracker.Make.html#VALnew_direct", "<div class=\"info\">\n<p><code class=\"code\">new_direct&nbsp;v&nbsp;k</code> introduces a new direct relation between the\n            value <code class=\"code\">v</code> and a freshly created object of the given kind\n            <code class=\"code\">k</code>.</p>\n\n</div>\n", ["ADD", "AND", "ATTACH", "BETWEEN", "CREATE", "CREATED", "DIRECT", "ESSENTIALLY", "FRESHLY", "GIVEN", "INTRODUCES", "KIND", "LOOKUP", "NEW", "NEW_DIRECT", "OBJECT", "RELATION", "RETURNED", "THE", "VALUE"]);
add_ocaml_element("detach", "Bap_taint.Std.Taint.Tracker.Make.detach", "value", "Std.Primus.value ->\n  Bap_taint.Std.Taint.Rel.t ->\n  Bap_taint.Std.Taint.Object.Set.t -> unit Machine.t", "Bap_taint.Std.Taint.Tracker.Make.html#VALdetach", "<div class=\"info\">\n<p><code class=\"code\">detach&nbsp;v&nbsp;r&nbsp;xs</code> removes all relations of type <code class=\"code\">r</code> between\n            the value <code class=\"code\">v</code> and elements of the set of objects\n            <code class=\"code\">xs</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "BETWEEN", "CONDITIONS", "DETACH", "ELEMENTS", "FORALL", "NOT", "OBJECTS", "OTHER", "POST", "PRE", "RELATIONS", "REMOVES", "SET", "THE", "TYPE", "TYPES", "UNAFFECTED", "VALUE", "VALUES", "WELL"]);
add_ocaml_element("lookup", "Bap_taint.Std.Taint.Tracker.Make.lookup", "value", "Std.Primus.value ->\n  Bap_taint.Std.Taint.Rel.t -> Bap_taint.Std.Taint.Object.Set.t Machine.t", "Bap_taint.Std.Taint.Tracker.Make.html#VALlookup", "<div class=\"info\">\n<p><code class=\"code\">lookup&nbsp;v&nbsp;r</code> returns a set <code class=\"code\">xs</code> of objects that are related\n            with the value <code class=\"code\">v</code> by the relation <code class=\"code\">r</code>.</p>\n\n</div>\n", ["ARE", "CHANGE", "CONDITIONS", "DOESN", "FORALL", "IFF", "LOOKUP", "OBJECTS", "OPERATION", "POST", "PRE", "RELATED", "RELATION", "RETURNS", "SET", "STATE", "THAT", "THE", "TRACKER", "VALUE", "WITH"]);
add_ocaml_element("attach", "Bap_taint.Std.Taint.Tracker.Make.attach", "value", "Std.Primus.value ->\n  Bap_taint.Std.Taint.Rel.t ->\n  Bap_taint.Std.Taint.Object.Set.t -> unit Machine.t", "Bap_taint.Std.Taint.Tracker.Make.html#VALattach", "<div class=\"info\">\n<p><code class=\"code\">attach&nbsp;v&nbsp;r&nbsp;xs</code> establishes the relation <code class=\"code\">r</code> between the\n            value <code class=\"code\">v</code> and every object <code class=\"code\">x</code> in the set of objects <code class=\"code\">xs</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "ATTACH", "BETWEEN", "CONDITIONS", "ESTABLISHES", "EVERY", "FORALL", "OBJECT", "OBJECTS", "OTHER", "POST", "PRE", "RELATION", "RELATIONS", "SET", "THE", "UNAFFECTED", "VALUE", "VALUES", "WELL", "WITH"]);
add_ocaml_element("kind", "Bap_taint.Std.Taint.Object.Make.kind", "value", "Bap_taint.Std.Taint.Object.t -> Bap_taint.Std.Taint.Kind.t Machine.t", "Bap_taint.Std.Taint.Object.Make.html#VALkind", "<div class=\"info\">\n<p><code class=\"code\">kind&nbsp;obj</code> returns the kind of the object.</p>\n\n</div>\n", ["KIND", "OBJ", "OBJECT", "RETURNS", "THE"]);
add_ocaml_element("create", "Bap_taint.Std.Taint.Object.Make.create", "value", "Bap_taint.Std.Taint.Kind.t -> Bap_taint.Std.Taint.Object.t Machine.t", "Bap_taint.Std.Taint.Object.Make.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;kind</code> creates a fresh new object identifier with\n            the specified <code class=\"code\">kind</code>.</p>\n\n</div>\n", ["AND", "ANY", "BEFORE", "CAN", "CREATE", "CREATED", "CREATES", "DIFFERENT", "EQUAL", "ESTABLISHES", "FRESH", "GIVEN", "IDENTIFIER", "KIND", "KINDS", "MACHINE", "NEVER", "NEW", "OBJECT", "OBJECTS", "ONTO", "PARTITIONS", "SAME", "SET", "SEVERAL", "SHARED", "SPECIFIED", "SURJECTION", "THE", "THEIR", "THUS", "VALUE", "WITH"]);
add_ocaml_element("indirect", "Bap_taint.Std.Taint.Rel.indirect", "value", "Bap_taint.Std.Taint.Rel.t", "Bap_taint.Std.Taint.Rel.html#VALindirect", "<div class=\"info\">\n<p>Denotes the indirect relation between a value and the object\n          that we track, e.g., a value is a pointer that points to a\n          value that has the direct relation with the object.</p>\n\n</div>\n", ["AND", "BETWEEN", "DENOTES", "DIRECT", "HAS", "INDIRECT", "OBJECT", "POINTER", "POINTS", "RELATION", "THAT", "THE", "TRACK", "VALUE", "WITH"]);
add_ocaml_element("direct", "Bap_taint.Std.Taint.Rel.direct", "value", "Bap_taint.Std.Taint.Rel.t", "Bap_taint.Std.Taint.Rel.html#VALdirect", "", []);
add_ocaml_element("name", "Bap_taint.Std.Taint.Kind.Make.name", "value", "Bap_taint.Std.Taint.Kind.t -> string Machine.t", "Bap_taint.Std.Taint.Kind.Make.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;k</code> returns the symbolic name of the kind <code class=\"code\">k</code></p>\n\n</div>\n", ["KIND", "NAME", "RETURNS", "SYMBOLIC", "THE"]);
add_ocaml_element("create", "Bap_taint.Std.Taint.Kind.Make.create", "value", "string -> Bap_taint.Std.Taint.Kind.t Machine.t", "Bap_taint.Std.Taint.Kind.Make.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;name</code> creates a kind with the given name.</p>\n\n</div>\n", ["ALREADY", "AND", "BETWEEN", "BIJECTION", "CREATE", "CREATES", "ESTABLISHES", "EXISTS", "FUNCTION", "GIVEN", "INTERNS", "ISOMORPHISM", "KIND", "KINDS", "MODULE", "NAME", "NAMES", "OTHER", "RETURNS", "SET", "STRINGS", "TERMS", "THAT", "THE", "THEN", "TOGETHER", "WITH"]);
add_ocaml_element("attached", "Bap_taint.Std.Taint.attached", "value", "(Bap_taint.Std.Taint.Rel.t * Bap_taint.Std.Taint.Object.t *\n   Std.Primus.value)\n  Std.Primus.observation", "Bap_taint.Std.Taint.html#VALattached", "<div class=\"info\">\n<p>(attached (r,o,v) occurs when the relation <code class=\"code\">r</code> is established\n        between <code class=\"code\">o</code> and <code class=\"code\">v</code></p>\n\n</div>\n", ["AND", "ATTACHED", "BETWEEN", "ESTABLISHED", "OCCURS", "RELATION", "THE", "WHEN"]);
add_ocaml_element("backward", "Std.Isomorphism.backward", "value", "Std.Isomorphism.t -> Std.Isomorphism.s", "Graphlib.Std.Isomorphism.html#VALbackward", "", []);
add_ocaml_element("forward", "Std.Isomorphism.forward", "value", "Std.Isomorphism.s -> Std.Isomorphism.t", "Graphlib.Std.Isomorphism.html#VALforward", "", []);
add_ocaml_element("node", "Std.Predicate.node", "value", "Std.Predicate.node -> bool", "Graphlib.Std.Predicate.html#VALnode", "", []);
add_ocaml_element("edge", "Std.Predicate.edge", "value", "Std.Predicate.edge -> bool", "Graphlib.Std.Predicate.html#VALedge", "", []);
add_ocaml_element("pp_graph", "Std.Dot.pp_graph", "value", "?name:string ->\n  ?attrs:string list ->\n  ?string_of_node:'n Std.symbolizer ->\n  ?node_label:'n Std.symbolizer ->\n  ?edge_label:'e Std.symbolizer ->\n  nodes_of_edge:('e -> 'n * 'n) ->\n  nodes:'n Sequence.t ->\n  edges:'e Sequence.t -> Stdlib.Format.formatter -> unit", "Graphlib.Std.Graphlib.Dot.html#VALpp_graph", "<div class=\"info\">\n<p><code class=\"code\">pp_graph&nbsp;~nodes_of_edge&nbsp;~nodes&nbsp;~edges&nbsp;ppf</code> - generic dot\n          printer.</p>\n\n</div>\n", ["AND", "CAN", "CUSTOM", "DEFAULT", "DESTINATION", "DOESN", "DOT", "EDGE", "EDGES", "FOR", "FUNCTION", "GENERIC", "GRAPH", "IMPLEMENTING", "NEEDS", "NODES", "NODES_OF_EDGE", "PPF", "PP_GRAPH", "PRINTER", "PRINTERS", "PURPOSE", "REPRESENTED", "RETURNS", "SEQUENCE", "SOURCE", "SUIT", "THE", "THIS", "THREE", "USE", "USEFUL", "VALUES", "WITH", "YOUR"]);
add_ocaml_element("remove", "Std.Edge.remove", "value", "Std.Edge.t -> Std.Edge.graph -> Std.Edge.graph", "Graphlib.Std.Edge.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;e&nbsp;g</code> returns a graph <code class=\"code\">g'</code> that doesn't contain edge\n        <code class=\"code\">e</code>.</p>\n\n</div>\n", ["CONTAIN", "DOESN", "EDGE", "GRAPH", "POSTCONDITIONS", "REMOVE", "RETURNS", "THAT"]);
add_ocaml_element("update", "Std.Edge.update", "value", "Std.Edge.t ->\n  Std.Edge.label -> Std.Edge.graph -> Std.Edge.graph", "Graphlib.Std.Edge.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;e&nbsp;l&nbsp;g</code> if edge <code class=\"code\">e</code> exists in graph <code class=\"code\">g</code> then return a\n        new graph <code class=\"code\">g'</code> in which edge <code class=\"code\">e</code> is associated with label <code class=\"code\">l</code>.</p>\n\n</div>\n", ["ASSOCIATED", "EDGE", "EXISTS", "GRAPH", "LABEL", "NEW", "OTHERWISE", "POSTCONDITION", "RETURN", "THEN", "UNCHANGED", "UPDATE", "WHICH", "WITH"]);
add_ocaml_element("insert", "Std.Edge.insert", "value", "Std.Edge.t -> Std.Edge.graph -> Std.Edge.graph", "Graphlib.Std.Edge.html#VALinsert", "<div class=\"info\">\n<p><code class=\"code\">insert&nbsp;e&nbsp;g</code> returns a graph <code class=\"code\">g'</code> with a set of edges extended\n        with edge <code class=\"code\">e</code>.</p>\n\n</div>\n", ["ARE", "AXIOMS", "DST", "EDGE", "EDGES", "EXTENDED", "GRAPH", "INSERT", "NODES", "POSTCONDITIONS", "PRESERVED", "RETURNS", "SET", "SRC", "THAT", "THE", "THEN", "WASN", "WELL", "WITH"]);
add_ocaml_element("mem", "Std.Edge.mem", "value", "Std.Edge.t -> Std.Edge.graph -> bool", "Graphlib.Std.Edge.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;e&nbsp;g</code> is true if <code class=\"code\">e</code> \226\136\136 E.</p>\n\n</div>\n", ["MEM", "TRUE"]);
add_ocaml_element("dst", "Std.Edge.dst", "value", "Std.Edge.t -> Std.Edge.node", "Graphlib.Std.Edge.html#VALdst", "<div class=\"info\">\n<p><code class=\"code\">dst&nbsp;e</code> returns a destination of an edge <code class=\"code\">e</code></p>\n\n</div>\n", ["DESTINATION", "DST", "EDGE", "RETURNS"]);
add_ocaml_element("src", "Std.Edge.src", "value", "Std.Edge.t -> Std.Edge.node", "Graphlib.Std.Edge.html#VALsrc", "<div class=\"info\">\n<p><code class=\"code\">src&nbsp;e</code> returns a source of an edge <code class=\"code\">e</code></p>\n\n</div>\n", ["EDGE", "RETURNS", "SOURCE", "SRC"]);
add_ocaml_element("label", "Std.Edge.label", "value", "Std.Edge.t -> Std.Edge.label", "Graphlib.Std.Edge.html#VALlabel", "<div class=\"info\">\n<p><code class=\"code\">label&nbsp;e</code> returns a label of an edge <code class=\"code\">e</code></p>\n\n</div>\n", ["EDGE", "LABEL", "RETURNS"]);
add_ocaml_element("create", "Std.Edge.create", "value", "Std.Edge.node ->\n  Std.Edge.node -> Std.Edge.label -> Std.Edge.t", "Graphlib.Std.Edge.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;x&nbsp;y&nbsp;l</code> creates an edge connecting nodes <code class=\"code\">x</code> and <code class=\"code\">y</code>\n        labeled with a a given label <code class=\"code\">l</code></p>\n\n</div>\n", ["AND", "CONNECTING", "CREATE", "CREATES", "EDGE", "GIVEN", "LABEL", "LABELED", "NODES", "WITH"]);
add_ocaml_element("edge", "Std.Node.edge", "value", "Std.Node.t ->\n  Std.Node.t ->\n  Std.Node.graph -> Std.Node.edge option", "Graphlib.Std.Node.html#VALedge", "<div class=\"info\">\n<p><code class=\"code\">edge&nbsp;x&nbsp;y&nbsp;g</code> if graph <code class=\"code\">g</code> has an edge between nodes <code class=\"code\">x</code> and\n        <code class=\"code\">y</code> then it is returned.</p>\n\n</div>\n", ["AND", "BETWEEN", "EDGE", "GRAPH", "HAS", "NODES", "RETURNED", "THEN"]);
add_ocaml_element("has_edge", "Std.Node.has_edge", "value", "Std.Node.t -> Std.Node.t -> Std.Node.graph -> bool", "Graphlib.Std.Node.html#VALhas_edge", "<div class=\"info\">\n<p><code class=\"code\">has_edge&nbsp;x&nbsp;y&nbsp;g</code> is true iff (x,y) \226\136\136 E.</p>\n\n</div>\n", ["HAS_EDGE", "IFF", "TRUE"]);
add_ocaml_element("remove", "Std.Node.remove", "value", "Std.Node.t -> Std.Node.graph -> Std.Node.graph", "Graphlib.Std.Node.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;n&nbsp;g</code> returns graph <code class=\"code\">g'</code>, with a node <code class=\"code\">n</code> removed from\n        a set of nodes <code class=\"code\"><span class=\"constructor\">N</span></code>.</p>\n\n</div>\n", ["FROM", "GRAPH", "NODE", "NODES", "POSTCONDITIONS", "REMOVE", "REMOVED", "RETURNS", "SET", "WITH"]);
add_ocaml_element("update", "Std.Node.update", "value", "Std.Node.t ->\n  Std.Node.label -> Std.Node.graph -> Std.Node.graph", "Graphlib.Std.Node.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;n&nbsp;l&nbsp;g</code> if node <code class=\"code\">n</code> is not in <code class=\"code\"><span class=\"constructor\">N</span>(g)</code> then return <code class=\"code\">g</code>,\n        else return graph <code class=\"code\">g</code> where node <code class=\"code\">n</code> is labeled with <code class=\"code\">l</code>.</p>\n\n</div>\n", ["ELSE", "GRAPH", "LABELED", "NODE", "NOT", "POSTCONDITIONS", "RETURN", "THEN", "UPDATE", "WHERE", "WITH"]);
add_ocaml_element("insert", "Std.Node.insert", "value", "Std.Node.t -> Std.Node.graph -> Std.Node.graph", "Graphlib.Std.Node.html#VALinsert", "<div class=\"info\">\n<p><code class=\"code\">insert&nbsp;n&nbsp;g</code> returns new graph <code class=\"code\">g'</code> that has a set of nodes\n        <code class=\"code\"><span class=\"constructor\">N</span></code> extended with node <code class=\"code\">n</code>.</p>\n\n</div>\n", ["CHANGE", "CONTAINED", "EXISTING", "EXTENDED", "GRAPH", "GRAPHLIB", "HAS", "INSERT", "NEW", "NODE", "NODES", "POSTCONDITIONS", "RETURNS", "SET", "STD", "THAT", "THE", "THEN", "UPDATE", "USE", "WAS", "WITH"]);
add_ocaml_element("degree", "Std.Node.degree", "value", "?dir:[ `In | `Out ] -> Std.Node.t -> Std.Node.graph -> int", "Graphlib.Std.Node.html#VALdegree", "<div class=\"info\">\n<p><code class=\"code\">degree&nbsp;?dir&nbsp;n</code> when <code class=\"code\">in_or_out</code> is <code class=\"code\"><span class=\"keywordsign\">`</span><span class=\"constructor\">In</span></code> then returns\n        the amount of incomming edges, otherwise returns the amount of\n        outcomming edges.</p>\n\n</div>\n", ["ABSENT", "ADJACENT", "AMOUNT", "AND", "DEGREE", "DIR", "EDGES", "INCOMMING", "IN_OR_OUT", "LEFT", "NODES", "OTHERWISE", "OUTCOMMING", "PARAMETER", "RETURN", "RETURNS", "SUM", "THE", "THEN", "WHEN"]);
add_ocaml_element("outputs", "Std.Node.outputs", "value", "Std.Node.t ->\n  Std.Node.graph -> Std.Node.edge Std.seq", "Graphlib.Std.Node.html#VALoutputs", "<div class=\"info\">\n<p><code class=\"code\">outputs&nbsp;node&nbsp;graph</code> is outcomming edges of a <code class=\"code\">node</code> in <code class=\"code\">graph</code></p>\n\n</div>\n", ["EDGES", "GRAPH", "NODE", "OUTCOMMING", "OUTPUTS"]);
add_ocaml_element("inputs", "Std.Node.inputs", "value", "Std.Node.t ->\n  Std.Node.graph -> Std.Node.edge Std.seq", "Graphlib.Std.Node.html#VALinputs", "<div class=\"info\">\n<p><code class=\"code\">inputs&nbsp;node&nbsp;graph</code> is incomming edges of a <code class=\"code\">node</code> in <code class=\"code\">graph</code></p>\n\n</div>\n", ["EDGES", "GRAPH", "INCOMMING", "INPUTS", "NODE"]);
add_ocaml_element("preds", "Std.Node.preds", "value", "Std.Node.t ->\n  Std.Node.graph -> Std.Node.t Std.seq", "Graphlib.Std.Node.html#VALpreds", "<div class=\"info\">\n<p><code class=\"code\">preds&nbsp;node&nbsp;graph</code> returns a sequence of predecessors of a\n        <code class=\"code\">node</code> in a a given <code class=\"code\">graph</code></p>\n\n</div>\n", ["GIVEN", "GRAPH", "NODE", "PREDECESSORS", "PREDS", "RETURNS", "SEQUENCE"]);
add_ocaml_element("succs", "Std.Node.succs", "value", "Std.Node.t ->\n  Std.Node.graph -> Std.Node.t Std.seq", "Graphlib.Std.Node.html#VALsuccs", "<div class=\"info\">\n<p><code class=\"code\">succs&nbsp;node&nbsp;graph</code> returns a sequence of successors of a\n        <code class=\"code\">node</code> in a a given <code class=\"code\">graph</code></p>\n\n</div>\n", ["GIVEN", "GRAPH", "NODE", "RETURNS", "SEQUENCE", "SUCCESSORS", "SUCCS"]);
add_ocaml_element("mem", "Std.Node.mem", "value", "Std.Node.t -> Std.Node.graph -> bool", "Graphlib.Std.Node.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;n&nbsp;g</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">n</code> is a member of nodes <code class=\"code\"><span class=\"constructor\">N</span></code> of graph\n        <code class=\"code\">g</code>.</p>\n\n</div>\n", ["GRAPH", "MEM", "MEMBER", "NODES", "TRUE"]);
add_ocaml_element("label", "Std.Node.label", "value", "Std.Node.t -> Std.Node.label", "Graphlib.Std.Node.html#VALlabel", "<div class=\"info\">\n<p><code class=\"code\">label&nbsp;n</code> returns a value associated with a node <code class=\"code\">n</code>.</p>\n\n</div>\n", ["ASSOCIATED", "LABEL", "NODE", "RETURNS", "VALUE", "WITH"]);
add_ocaml_element("create", "Std.Node.create", "value", "Std.Node.label -> Std.Node.t", "Graphlib.Std.Node.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;label</code> creates a new node, and associates it with a\n        a given <code class=\"code\">label</code>.</p>\n\n</div>\n", ["AND", "ASSOCIATES", "CREATE", "CREATES", "GIVEN", "LABEL", "NEW", "NODE", "WITH"]);
add_ocaml_element("number_of_nodes", "Std.Graph.number_of_nodes", "value", "Std.Graph.t -> int", "Graphlib.Std.Graph.html#VALnumber_of_nodes", "<div class=\"info\">\n<p><code class=\"code\">number_of_nodes&nbsp;g</code> returns the order of a graph <code class=\"code\">g</code></p>\n\n</div>\n", ["GRAPH", "NUMBER_OF_NODES", "ORDER", "RETURNS", "THE"]);
add_ocaml_element("number_of_edges", "Std.Graph.number_of_edges", "value", "Std.Graph.t -> int", "Graphlib.Std.Graph.html#VALnumber_of_edges", "<div class=\"info\">\n<p><code class=\"code\">number_of_edges&nbsp;g</code> returns the size of a graph <code class=\"code\">g</code>.</p>\n\n</div>\n", ["GRAPH", "NUMBER_OF_EDGES", "RETURNS", "SIZE", "THE"]);
add_ocaml_element("is_directed", "Std.Graph.is_directed", "value", "bool", "Graphlib.Std.Graph.html#VALis_directed", "<div class=\"info\">\n<p><code class=\"code\">is_directed</code> is true if graph is a directed graph.</p>\n\n</div>\n", ["DIRECTED", "GRAPH", "IS_DIRECTED", "TRUE"]);
add_ocaml_element("edges", "Std.Graph.edges", "value", "Std.Graph.t -> Std.Graph.edge Std.seq", "Graphlib.Std.Graph.html#VALedges", "<div class=\"info\">\n<p><code class=\"code\">edges&nbsp;g</code> returns all edges of graph <code class=\"code\">g</code> in an unspecified order</p>\n\n</div>\n", ["ALL", "EDGES", "GRAPH", "ORDER", "RETURNS", "UNSPECIFIED"]);
add_ocaml_element("nodes", "Std.Graph.nodes", "value", "Std.Graph.t -> Std.Graph.node Std.seq", "Graphlib.Std.Graph.html#VALnodes", "<div class=\"info\">\n<p><code class=\"code\">nodes&nbsp;g</code> returns all nodes of graph <code class=\"code\">g</code> in an unspecified order</p>\n\n</div>\n", ["ALL", "GRAPH", "NODES", "ORDER", "RETURNS", "UNSPECIFIED"]);
add_ocaml_element("empty", "Std.Graph.empty", "value", "Std.Graph.t", "Graphlib.Std.Graph.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty</code> is an empty graph</p>\n\n</div>\n", ["EMPTY", "GRAPH"]);
add_ocaml_element("by_natural_order", "Std.by_natural_order", "value", "Std.scheme ->\n  ('a -> 'a -> int) ->\n  'a Sequence.t -> 'a Std.symbolizer", "Graphlib.Std.Graphlib.html#VALby_natural_order", "", []);
add_ocaml_element("by_given_order", "Std.by_given_order", "value", "Std.scheme ->\n  ('a -> 'a -> int) ->\n  'a Sequence.t -> 'a Std.symbolizer", "Graphlib.Std.Graphlib.html#VALby_given_order", "", []);
add_ocaml_element("nothing", "Std.nothing", "value", "Std.scheme", "Graphlib.Std.Graphlib.html#VALnothing", "", []);
add_ocaml_element("numbers", "Std.numbers", "value", "Std.scheme", "Graphlib.Std.Graphlib.html#VALnumbers", "<div class=\"info\">\n<p>numbers from zero to inifinity (<code class=\"code\"><span class=\"constructor\">Sys</span>.max_int</code> in fact)</p>\n\n</div>\n", ["EMPTY", "FACT", "FROM", "INIFINITY", "MAX_INT", "NUMBERS", "STRING", "SYS", "ZERO"]);
add_ocaml_element("symbols", "Std.symbols", "value", "Std.scheme", "Graphlib.Std.Graphlib.html#VALsymbols", "<div class=\"info\">\n<p>lower case symbols, starting from 'a' and moving up to 'z'.</p>\n\n</div>\n", ["ALL", "AND", "CASE", "FOREGOING", "FORM", "FROM", "HAVE", "INCREASING", "LOWER", "MOVING", "NATURAL", "NODE_N", "NUMBER", "REACHED", "STARTING", "SYMBOLS", "WHERE", "WILL"]);
add_ocaml_element("create_scheme", "Std.create_scheme", "value", "next:(string -> string) -> string -> Std.scheme", "Graphlib.Std.Graphlib.html#VALcreate_scheme", "<div class=\"info\">\n<p><code class=\"code\">create_scheme&nbsp;~next&nbsp;init</code> create a name generator, that will\n        start with <code class=\"code\">init</code> and apply <code class=\"code\">next</code> on it infinitly.</p>\n\n</div>\n", ["AND", "APPLY", "CREATE", "CREATE_SCHEME", "GENERATOR", "INFINITLY", "INIT", "NAME", "NEXT", "START", "THAT", "WILL", "WITH"]);
add_ocaml_element("fixpoint", "Std.fixpoint", "value", "(module Std.Graph with type node = 'n and type t = 'c) ->\n  ?steps:int ->\n  ?start:'n ->\n  ?rev:bool ->\n  ?step:(int -> 'n -> 'd -> 'd -> 'd) ->\n  init:('n, 'd) Std.Solution.t ->\n  equal:('d -> 'd -> bool) ->\n  merge:('d -> 'd -> 'd) ->\n  f:('n -> 'd -> 'd) -> 'c -> ('n, 'd) Std.Solution.t", "Graphlib.Std.Graphlib.html#VALfixpoint", "<div class=\"info\">\n<p><code class=\"code\">fixpoint&nbsp;~equal&nbsp;~init&nbsp;~merge&nbsp;~f&nbsp;g</code> computes a solution for a\n        system of equations denoted by graph <code class=\"code\">g</code>, using the inital\n        approximation <code class=\"code\">init</code> (obtained either with <code class=\"code\"><span class=\"constructor\">Solution</span>.create</code> or\n        from the previous calls to <code class=\"code\">fixpoint</code>).</p>\n\n</div>\n", ["ALWAYS", "AND", "APPROXIMATION", "ARBITRARY", "ASCENDING", "BEFORE", "BOUND", "CALLS", "CASE", "CHAIN", "COMPLETE", "COMPUTES", "COULD", "CREATE", "DENOTED", "EDGE", "EITHER", "EQUAL", "EQUATIONS", "EQUIVALENCE", "EXAMPLE", "FIXPOINT", "FOR", "FROM", "FUNCTION", "GENERAL", "GRAPH", "INCOMPLETE", "INIT", "INITAL", "ITERATIONS", "LATER", "LOWER", "MAXIMUM", "MERGE", "NODE", "NOT", "NUMBER", "OBTAINED", "OPERATION", "OPERATOR", "OTHERWISE", "PREVIOUS", "REACHED", "REAL", "REPRESENTATION", "RESUMED", "SAFE", "SERIES", "SOLUTION", "STABILIZES", "SYSTEM", "THE", "THEN", "THERE", "THROUGH", "TOTAL", "TRANSFER", "UNTIL", "USE", "USED", "USING", "VALUE", "VARIABLE", "WHERE", "WITH"]);
add_ocaml_element("view", "Std.view", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c and type Edge.label = 'b and type Node.label = 'a) ->\n  node:('n -> 'f) * ('f -> 'n) ->\n  edge:('e -> 'd) * ('d -> 'e) ->\n  node_label:('a -> 'p) * ('p -> 'a) ->\n  edge_label:('b -> 'r) * ('r -> 'b) ->\n  (module Std.Graph with type edge = 'd and type node = 'f and type t = 'c and type Edge.label = 'r and type Node.label = 'p)", "Graphlib.Std.Graphlib.html#VALview", "<div class=\"info\">\n<p><code class=\"code\">view&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;~node&nbsp;~edge&nbsp;~node_label&nbsp;~edge_label</code>\n        creates a proxy module, that will transform back and\n        forward elements of graph, using corresponding functions.</p>\n\n</div>\n", ["AND", "BACK", "CORRESPONDING", "CREATES", "EDGE", "EDGE_LABEL", "ELEMENTS", "FORWARD", "FUNCTIONS", "GRAPH", "MODULE", "NODE", "NODE_LABEL", "PROXY", "THAT", "TRANSFORM", "USING", "VIEW", "WILL"]);
add_ocaml_element("filtered", "Std.filtered", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?skip_node:('n -> bool) ->\n  ?skip_edge:('e -> bool) ->\n  unit ->\n  (module Std.Graph with type edge = 'e and type node = 'n and type t = 'c)", "Graphlib.Std.Graphlib.html#VALfiltered", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keyword\">let</span>&nbsp;<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G'</span>&nbsp;=&nbsp;filtered&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;?skip_node&nbsp;?skip_edge&nbsp;()</code>\n        creates a new module <code class=\"code\"><span class=\"constructor\">G'</span></code> that can be used at any place\n        instead of <code class=\"code\"><span class=\"constructor\">G</span></code>, but that will hide nodes and edges, for which\n        functions <code class=\"code\">skip_node</code> and <code class=\"code\">skip_edge</code> return true.</p>\n\n</div>\n", ["ADD", "ADDED", "ALL", "AND", "ANY", "BUT", "CAN", "CREATE", "CREATES", "EDGE", "EDGES", "EXAMPLE", "FILTERED", "FOR", "FUNCTIONS", "GRAPHLIB", "HASH_SET", "HIDE", "INSTEAD", "KILLED_EDGES", "LET", "LOOP", "MEM", "MODULE", "NEW", "NODES", "NORMAL", "PLACE", "REC", "RETURN", "SKIP_EDGE", "SKIP_NODE", "SOME_EDGE", "THAT", "TRUE", "USE", "USED", "VISIBLE", "WHICH", "WILL"]);
add_ocaml_element("compare", "Std.compare", "value", "(module Std.Graph with type node = 'n and type t = 'a) ->\n  (module Std.Graph with type node = 'n and type t = 'b) ->\n  'a -> 'b -> int", "Graphlib.Std.Graphlib.html#VALcompare", "<div class=\"info\">\n<p><code class=\"code\">compare&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G1</span>)&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G2</span>)&nbsp;g1&nbsp;g2</code> compares two graphs,\n        with different implementation but the same node type.</p>\n\n</div>\n", ["BUT", "COMPARE", "COMPARES", "DIFFERENT", "GRAPHS", "IMPLEMENTATION", "MODULE", "NODE", "SAME", "THE", "TWO", "TYPE", "WITH"]);
add_ocaml_element("fold_reachable", "Std.fold_reachable", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool -> init:'a -> f:('a -> 'n -> 'a) -> 'c -> 'n -> 'a", "Graphlib.Std.Graphlib.html#VALfold_reachable", "<div class=\"info\">\n<p><code class=\"code\">fold_reachable&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;?rev&nbsp;~init&nbsp;~f&nbsp;g&nbsp;n</code> applies function\n        <code class=\"code\">f</code> to all nodes reachable from node <code class=\"code\">g</code> in graph <code class=\"code\">g</code>.</p>\n\n</div>\n", ["ADD", "ALL", "APPLIES", "BUILD", "EMPTY", "EXAMPLE", "FOLD_REACHABLE", "FOLLOWING", "FOR", "FROM", "FUNCTION", "GRAPH", "INIT", "MODULE", "NODE", "NODES", "REACHABLE", "REV", "REVERSED", "SET", "THE", "THEN", "TRUE", "WILL"]);
add_ocaml_element("is_reachable", "Std.is_reachable", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool -> 'c -> 'n -> 'n -> bool", "Graphlib.Std.Graphlib.html#VALis_reachable", "<div class=\"info\">\n<p><code class=\"code\">is_reachable&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;?rev&nbsp;g&nbsp;u&nbsp;v</code> is true if node <code class=\"code\">v</code> is\n        reachable from node <code class=\"code\">u</code> in graph <code class=\"code\">g</code>.</p>\n\n</div>\n", ["BUT", "FROM", "GRAPH", "IS_REACHABLE", "MODULE", "NODE", "PROBLEM", "REACHABLE", "REV", "REVERSED", "SAME", "SOLVE", "THE", "THEN", "TRUE", "WILL"]);
add_ocaml_element("shortest_path", "Std.shortest_path", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?weight:('e -> int) ->\n  ?rev:bool -> 'c -> 'n -> 'n -> 'e Std.path option", "Graphlib.Std.Graphlib.html#VALshortest_path", "<div class=\"info\">\n<p><code class=\"code\">shortest_path&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;?weight&nbsp;?rev&nbsp;g&nbsp;u&nbsp;v</code>\n        Find a shortest path from node <code class=\"code\">u</code> to node <code class=\"code\">v</code>.</p>\n\n</div>\n", ["FIND", "FROM", "MODULE", "NODE", "PATH", "REV", "SHORTEST", "SHORTEST_PATH", "WEIGHT"]);
add_ocaml_element("strong_components", "Std.strong_components", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  'c -> 'n Std.partition", "Graphlib.Std.Graphlib.html#VALstrong_components", "<div class=\"info\">\n<p><code class=\"code\">strong_components&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;g</code> partition graph into strongly\n        connected components.</p>\n\n</div>\n", ["COMPONENT", "COMPONENTS", "CONNECTED", "EACH", "GRAPH", "HAS", "INTO", "LEAST", "MODULE", "NODE", "NUMBER", "ORDER", "PARTITION", "PRE", "ROOT", "STRONGLY", "STRONG_COMPONENTS", "THAT", "THE", "TOP"]);
add_ocaml_element("dom_frontier", "Std.dom_frontier", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool -> 'c -> 'n Std.tree -> 'n Std.frontier", "Graphlib.Std.Graphlib.html#VALdom_frontier", "<div class=\"info\">\n<p><code class=\"code\">dom_frontier&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;g&nbsp;dom_tree</code> calculates dominance\n        frontiers for all nodes in a graph <code class=\"code\">g</code>.</p>\n\n</div>\n", ["ALL", "BUT", "CALCULATES", "DOES", "DOMINANCE", "DOMINATE", "DOMINATES", "DOM_FRONTIER", "DOM_TREE", "FOR", "FRONTIER", "FRONTIERS", "GRAPH", "IMMEDIATE", "MODULE", "NODE", "NODES", "NOT", "PREDECESSOR", "SET", "STOPS", "STRICTLY", "SUCH", "THAT", "THE", "WHERE"]);
add_ocaml_element("dominators", "Std.dominators", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool -> 'c -> 'n -> 'n Std.tree", "Graphlib.Std.Graphlib.html#VALdominators", "<div class=\"info\">\n<p><code class=\"code\">dominators&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;g&nbsp;entry</code> builds a dominators tree for\n        a given graph.</p>\n\n</div>\n", ["ALGORITHM", "ALGOTIHM", "ALL", "ALTERNATING", "ALTHOUGH", "ANALYSIS", "ANCESTORS", "AND", "ANY", "ARE", "ASSUMED", "BINARIES", "BLOCK", "BUILDS", "BUT", "CAN", "CHILD", "COMPUTES", "CONSTRAINED", "CONTAIN", "CONTAINS", "CONTRADICTION", "CONTROL", "CURRENT", "DEFINITION", "DESCENDANT", "DOESN", "DOMINATE", "DOMINATED", "DOMINATES", "DOMINATOR", "DOMINATORS", "EACH", "EDGE", "EDGES", "ENDING", "ENDPOINTS", "ENTRY", "EQUAL", "EVERY", "EVERYTHING", "EXISTS", "EXIT", "FLOW", "FOLLOWING", "FOR", "FROM", "GENERAL", "GET", "GIVEN", "GOOD", "GRAPH", "GRAPHS", "HAS", "HAVE", "IDEA", "IFF", "IMMEDIATELY", "IMPLEMENTATION", "IMPOSED", "LEAST", "LEMMA", "MANY", "MEANS", "MODULE", "MORE", "NODE", "NODES", "NOT", "NOTE", "ONE", "ORIGINAL", "OTHER", "PARENT", "PASS", "PASSING", "PATH", "POST", "PRECEDING", "PREDECESSORS", "PROGRAM", "PROOF", "PROPERTIES", "PROVIDED", "QED", "REACHABLE", "READ", "RECONSTRUCTED", "REV", "REVERSE", "REVERSIBLE", "SATISFIES", "SEQUENCE", "SETS", "SILENTLY", "SOLUTION", "SOME", "STARTING", "STATEMENT", "STRICTLY", "SUPPOSE", "SYSTEM", "TEXTBOOKS", "THAN", "THAT", "THE", "THEN", "THERE", "THEY", "THIS", "TREE", "TRUE", "UNDER", "UNIQUE", "UNREACHABLE", "USUALLY", "WALK", "WALKS", "WHAT", "WHERE", "WITH"]);
add_ocaml_element("postorder_traverse", "Std.postorder_traverse", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool -> ?start:'n -> 'c -> 'n Std.seq", "Graphlib.Std.Graphlib.html#VALpostorder_traverse", "<div class=\"info\">\n<p>returns a sequence of nodes in post order</p>\n\n</div>\n", ["NODES", "ORDER", "POST", "RETURNS", "SEQUENCE"]);
add_ocaml_element("reverse_postorder_traverse", "Std.reverse_postorder_traverse", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool -> ?start:'n -> 'c -> 'n Std.seq", "Graphlib.Std.Graphlib.html#VALreverse_postorder_traverse", "<div class=\"info\">\n<p>returns a sequence of nodes in reverse post order.</p>\n\n</div>\n", ["NODES", "ORDER", "POST", "RETURNS", "REVERSE", "SEQUENCE"]);
add_ocaml_element("depth_first_visit", "Std.depth_first_visit", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool ->\n  ?start:'n -> 'c -> init:'s -> ('n, 'e, 's) Std.dfs_visitor -> 's", "Graphlib.Std.Graphlib.html#VALdepth_first_visit", "<div class=\"info\">\n<p><code class=\"code\">depth_first_visit&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;~init&nbsp;visitor&nbsp;g</code> allows to\n        specify visiting functions using object.</p>\n\n</div>\n", ["ALLOWS", "AND", "DEPTH_FIRST_VISIT", "FOR", "FUNCTIONS", "INIT", "MODULE", "OBJECT", "OPEN", "OPENS", "RECURSION", "SPACE", "SPECIFY", "THAT", "USABILITY", "USING", "VISITING", "VISITOR"]);
add_ocaml_element("depth_first_search", "Std.depth_first_search", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?rev:bool ->\n  ?start:'n ->\n  ?start_tree:('n -> 's -> 's) ->\n  ?enter_node:(int -> 'n -> 's -> 's) ->\n  ?leave_node:(int -> 'n -> 's -> 's) ->\n  ?enter_edge:(Std.edge_kind -> 'e -> 's -> 's) ->\n  ?leave_edge:(Std.edge_kind -> 'e -> 's -> 's) -> 'c -> init:'s -> 's", "Graphlib.Std.Graphlib.html#VALdepth_first_search", "<div class=\"info\">\n<p><code class=\"code\">depth_first_search&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;~init&nbsp;g</code>.</p>\n\n</div>\n", ["ACCEPTS", "ALGORITHM", "ALGORITHMS", "ALLOW", "ALLOWING", "ALLOWS", "ALTHOUGH", "AND", "ARMY", "BLANKS", "BUILDS", "BUT", "CALLED", "CAN", "CLASSIFIES", "DEPTH_FIRST_SEARCH", "DIFFERENT", "DOESN", "DRIVE", "EDGES", "EFFECTIVELY", "ERASING", "EVEN", "FILL", "FILTERED", "FOLD", "FOREST", "FROM", "FUNCTION", "FUNCTIONS", "GRAPH", "GRAPHLIB", "HIDE", "IMPLEMENTING", "IMPORTANT", "INIT", "ITSELF", "KNIFE", "MANY", "MODULE", "MOST", "NODES", "NUMBERS", "ONE", "ONLY", "OTHER", "SITUATIONS", "SPANNING", "STD", "STEROIDS", "STILL", "SWISS", "THAT", "THE", "THEM", "THERE", "THINK", "THIS", "THUS", "TOUCHING", "TREES", "UNLIKE", "USEFUL", "USING", "VERY", "WALK", "WALKER", "WAYS", "WILL", "WITHOUT", "YOU", "YOUR"]);
add_ocaml_element("to_dot", "Std.to_dot", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  ?graph_attrs:('c -> Std.graph_attr list) ->\n  ?node_attrs:('n -> Std.node_attr list) ->\n  ?edge_attrs:('e -> Std.edge_attr list) ->\n  ?string_of_node:('n -> string) ->\n  ?string_of_edge:('e -> string) ->\n  ?channel:Out_channel.t ->\n  ?formatter:Stdlib.Format.formatter -> ?filename:string -> 'c -> unit", "Graphlib.Std.Graphlib.html#VALto_dot", "<div class=\"info\">\n<p><code class=\"code\">to_dot&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;~filename:<span class=\"string\">\"graph.dot\"</span>&nbsp;g</code> dumps graph <code class=\"code\">g</code>\n        using <code class=\"code\">dot</code> format.</p>\n\n</div>\n", ["CASES", "CUSTOMIZABLE", "CUSTOMIZE", "DOT", "DUMPS", "ENOUGH", "FILENAME", "FOR", "FORMAT", "FUNCTION", "GRAPH", "MODULE", "MOST", "NEED", "OUTPUT", "PRINTING", "REALLY", "THIS", "TO_DOT", "TO_STRING", "USE", "USING", "VERSION", "WILL", "YOU", "YOUR"]);
add_ocaml_element("inter", "Std.inter", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  'c -> 'c -> 'c", "Graphlib.Std.Graphlib.html#VALinter", "<div class=\"info\">\n<p><code class=\"code\">inter&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;g1&nbsp;g2</code> returns a graph <code class=\"code\">g</code> that is an\n        intersection of graphs <code class=\"code\">g1</code> and <code class=\"code\">g2</code>, i.e., it contain\n        and edges from this graphs.</p>\n\n</div>\n", ["AND", "CONTAIN", "EDGES", "FROM", "GRAPH", "GRAPHS", "INTER", "INTERSECTION", "MODULE", "POSTCONDITION", "RETURNS", "THAT", "THIS"]);
add_ocaml_element("union", "Std.union", "value", "(module Std.Graph with type edge = 'e and type node = 'n and type t = 'c) ->\n  'c -> 'c -> 'c", "Graphlib.Std.Graphlib.html#VALunion", "<div class=\"info\">\n<p><code class=\"code\">union&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;g1&nbsp;g2</code> returns a graph <code class=\"code\">g</code> that is a union\n        of graphs <code class=\"code\">g1</code> and <code class=\"code\">g2</code>, i.e., contains all nodes and edges\n        from this graphs.</p>\n\n</div>\n", ["ALL", "AND", "CONTAINS", "EDGES", "FROM", "GRAPH", "GRAPHS", "MODULE", "NODES", "POSTCONDITION", "RETURNS", "THAT", "THIS", "UNION"]);
add_ocaml_element("create", "Std.create", "value", "(module Std.Graph with type t = 'c and type Edge.label = 'b and type Node.label = 'a) ->\n  ?nodes:'a list -> ?edges:('a * 'a * 'b) list -> unit -> 'c", "Graphlib.Std.Graphlib.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span>)&nbsp;~nodes&nbsp;~edges&nbsp;()</code> creates a graph using\n        implementation provided by <code class=\"code\"><span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">G</span></code>.</p>\n\n</div>\n", ["BOOL", "CREATE", "CREATES", "EDGES", "ENTRY", "EXAMPLE", "EXIT", "FALSE", "GRAPH", "GRAPHLIB", "IMPLEMENTATION", "LET", "LOOP", "MODULE", "NODES", "PROVIDED", "STRING", "TRUE", "USING"]);
add_ocaml_element("derive", "Std.Solution.derive", "value", "('n, 'd) Std.Solution.t ->\n  f:('n -> 'd -> 'a option) -> 'a -> ('n, 'a) Std.Solution.t", "Graphlib.Std.Solution.html#VALderive", "<div class=\"info\">\n<p><code class=\"code\">derive&nbsp;s&nbsp;~f&nbsp;default</code> creates a new solution from an old one\n        with a new <code class=\"code\">default</code> and where for each node <code class=\"code\">n</code> in <code class=\"code\">s</code>'s finite\n        map, if <code class=\"code\">f&nbsp;n&nbsp;(get&nbsp;s&nbsp;n)&nbsp;=&nbsp;<span class=\"constructor\">Some</span>&nbsp;v</code> then <code class=\"code\">n</code> maps to <code class=\"code\">v</code>.</p>\n\n</div>\n", ["AND", "CREATES", "DEFAULT", "DERIVE", "EACH", "FINITE", "FOR", "FROM", "GET", "MAP", "MAPS", "NEW", "NODE", "OLD", "ONE", "SOLUTION", "SOME", "THEN", "WHERE", "WITH"]);
add_ocaml_element("get", "Std.Solution.get", "value", "('n, 'd) Std.Solution.t -> 'n -> 'd", "Graphlib.Std.Solution.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;s&nbsp;x</code> returns a value of <code class=\"code\">x</code>.</p>\n\n</div>\n", ["GET", "RETURNS", "VALUE"]);
add_ocaml_element("is_fixpoint", "Std.Solution.is_fixpoint", "value", "('n, 'd) Std.Solution.t -> bool", "Graphlib.Std.Solution.html#VALis_fixpoint", "<div class=\"info\">\n<p><code class=\"code\">is_fixpoint&nbsp;s</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if the solution is a fixed point\n        solution, i.e., is a solution that stabilizes the system of\n        equations.</p>\n\n</div>\n", ["EQUATIONS", "FIXED", "IS_FIXPOINT", "POINT", "SOLUTION", "STABILIZES", "SYSTEM", "THAT", "THE", "TRUE"]);
add_ocaml_element("default", "Std.Solution.default", "value", "('n, 'd) Std.Solution.t -> 'd", "Graphlib.Std.Solution.html#VALdefault", "<div class=\"info\">\n<p><code class=\"code\">default&nbsp;s</code> return the default value assigned to all variables\n        not in the internal finite mapping.</p>\n\n</div>\n", ["ALL", "ASSIGNED", "BOTTOM", "DECREASES", "DEFAULT", "DEPENDING", "FINITE", "INCREASES", "INTERNAL", "ITERATION", "MAPPING", "NOT", "RETURN", "THE", "THIS", "TOP", "USUALLY", "VALUE", "VARIABLES", "WHETHER"]);
add_ocaml_element("iterations", "Std.Solution.iterations", "value", "('n, 'd) Std.Solution.t -> int", "Graphlib.Std.Solution.html#VALiterations", "<div class=\"info\">\n<p><code class=\"code\">iterations&nbsp;s</code> returns the total number of iterations that was\n        made to obtain the current solution.</p>\n\n</div>\n", ["CURRENT", "ITERATIONS", "MADE", "NUMBER", "OBTAIN", "RETURNS", "SOLUTION", "THAT", "THE", "TOTAL", "WAS"]);
add_ocaml_element("create", "Std.Solution.create", "value", "('n, 'd, 'a) Map.t -> 'd -> ('n, 'd) Std.Solution.t", "Graphlib.Std.Solution.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;constraints&nbsp;default</code> creates an initial approximation of a\n        solution.</p>\n\n</div>\n", ["ALL", "APPROXIMATION", "CONSTRAINTS", "CREATE", "CREATES", "DEFAULT", "DEFINES", "INITIAL", "PARAMETER", "SOLUTION", "THE", "UNSPECIFIED", "VALUE", "VARIABLES"]);
add_ocaml_element("to_int", "Std.Equiv.to_int", "value", "Std.Equiv.t -> int", "Graphlib.Std.Equiv.html#VALto_int", "", []);
add_ocaml_element("pp", "Std.Group.pp", "value", "'a Std.printer -> 'a Std.Group.t Std.printer", "Graphlib.Std.Group.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elem&nbsp;g</code> prints group <code class=\"code\">g</code> using element printer <code class=\"code\">pp_elem</code></p>\n\n</div>\n", ["ELEMENT", "GROUP", "PP_ELEM", "PRINTER", "PRINTS", "USING"]);
add_ocaml_element("to_equiv", "Std.Group.to_equiv", "value", "'a Std.group -> Std.equiv", "Graphlib.Std.Group.html#VALto_equiv", "<div class=\"info\">\n<p><code class=\"code\">to_equiv&nbsp;g</code> returns the ordinal number representing the\n        particular group <code class=\"code\">g</code></p>\n\n</div>\n", ["GROUP", "NUMBER", "ORDINAL", "PARTICULAR", "REPRESENTING", "RETURNS", "THE", "TO_EQUIV"]);
add_ocaml_element("top", "Std.Group.top", "value", "'a Std.group -> 'a", "Graphlib.Std.Group.html#VALtop", "<div class=\"info\">\n<p><code class=\"code\">top&nbsp;group</code> returns the top element of a group also known as a\n        representative element.</p>\n\n</div>\n", ["ALSO", "ELEMENT", "EMPTY", "FUNCTION", "GROUP", "GROUPS", "GUARANTEED", "KNOWN", "NON", "REPRESENTATIVE", "RETURNS", "SINCE", "THE", "TOP", "TOTAL"]);
add_ocaml_element("mem", "Std.Group.mem", "value", "'a Std.group -> 'a -> bool", "Graphlib.Std.Group.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;group&nbsp;x</code> checks membership of <code class=\"code\">x</code> in a given <code class=\"code\">group</code>.</p>\n\n</div>\n", ["CHECKS", "GIVEN", "GROUP", "MEM", "MEMBERSHIP"]);
add_ocaml_element("enum", "Std.Group.enum", "value", "'a Std.group -> 'a Std.seq", "Graphlib.Std.Group.html#VALenum", "<div class=\"info\">\n<p><code class=\"code\">enum&nbsp;group</code> enumerates all elements of a group, including the\n        designated one.</p>\n\n</div>\n", ["ALL", "DESIGNATED", "ELEMENTS", "ENUM", "ENUMERATES", "GROUP", "INCLUDING", "ONE", "THE"]);
add_ocaml_element("pp", "Std.Partition.pp", "value", "'a Std.printer -> 'a Std.Partition.t Std.printer", "Graphlib.Std.Partition.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elem&nbsp;p</code> prints partition <code class=\"code\">p</code> using element printer <code class=\"code\">pp_elem</code></p>\n\n</div>\n", ["ELEMENT", "PARTITION", "PP_ELEM", "PRINTER", "PRINTS", "USING"]);
add_ocaml_element("of_equiv", "Std.Partition.of_equiv", "value", "'a Std.Partition.t ->\n  Std.equiv -> 'a Std.group option", "Graphlib.Std.Partition.html#VALof_equiv", "<div class=\"info\">\n<p><code class=\"code\">of_equiv&nbsp;p&nbsp;n</code> rebuilds a group from an equivalence class\n        ordinal number.</p>\n\n</div>\n", ["CLASS", "EQUIVALENCE", "FROM", "GROUP", "NUMBER", "OF_EQUIV", "ORDINAL", "REBUILDS"]);
add_ocaml_element("number_of_groups", "Std.Partition.number_of_groups", "value", "'a Std.Partition.t -> int", "Graphlib.Std.Partition.html#VALnumber_of_groups", "<div class=\"info\">\n<p><code class=\"code\">number_of_groups&nbsp;p</code> returns the amount of groups in a given\n        partitioning <code class=\"code\">p</code>.</p>\n\n</div>\n", ["AMOUNT", "GIVEN", "GROUPS", "NUMBER_OF_GROUPS", "PARTITIONING", "RETURNS", "THE"]);
add_ocaml_element("equiv", "Std.Partition.equiv", "value", "'a Std.Partition.t -> 'a -> 'a -> bool", "Graphlib.Std.Partition.html#VALequiv", "<div class=\"info\">\n<p><code class=\"code\">equiv&nbsp;p&nbsp;x&nbsp;y</code> is true of <code class=\"code\">x</code> and <code class=\"code\">y</code> belongs to the same\n        equivalence class (i.e., to the same group).</p>\n\n</div>\n", ["AND", "BELONGS", "CLASS", "EQUIV", "EQUIVALENCE", "GROUP", "SAME", "THE", "TRUE"]);
add_ocaml_element("group", "Std.Partition.group", "value", "'a Std.Partition.t -> 'a -> 'a Std.group option", "Graphlib.Std.Partition.html#VALgroup", "<div class=\"info\">\n<p><code class=\"code\">group&nbsp;p&nbsp;x</code> returns a <code class=\"code\">group</code> of an element <code class=\"code\">x</code>.</p>\n\n</div>\n", ["ALL", "ELEMENT", "FUNCTION", "GROUP", "LARGER", "NOT", "NOTE", "PARTITIONED", "RETURNS", "SET", "SINCE", "THAN", "THAT", "THE", "THIS", "TOTAL", "TYPE", "UNDERLYING", "USUALLY", "VALUES", "WAS"]);
add_ocaml_element("groups", "Std.Partition.groups", "value", "'a Std.Partition.t -> 'a Std.group Std.seq", "Graphlib.Std.Partition.html#VALgroups", "<div class=\"info\">\n<p><code class=\"code\">groups&nbsp;p</code> returns all partition cells of a partitioning <code class=\"code\">p</code></p>\n\n</div>\n", ["ALL", "CELLS", "GROUPS", "PARTITION", "PARTITIONING", "RETURNS"]);
add_ocaml_element("union", "Std.Partition.union", "value", "'a Std.Partition.t -> 'a -> 'a -> 'a Std.Partition.t", "Graphlib.Std.Partition.html#VALunion", "<div class=\"info\">\n<p><code class=\"code\">union&nbsp;p&nbsp;x&nbsp;y</code> returns the partition p with the classes of <code class=\"code\">x</code>\n        and <code class=\"code\">y</code> merged.</p>\n\n</div>\n", ["AND", "ANY", "ARE", "CLASS", "CLASSES", "EITHER", "EQUIVALENCE", "MERGED", "NOT", "PART", "PARTITION", "RETURNS", "THE", "UNCHANGED", "UNION", "WITH"]);
add_ocaml_element("refine", "Std.Partition.refine", "value", "'a Std.Partition.t ->\n  equiv:('a -> 'a -> bool) ->\n  cmp:('a -> 'a -> int) -> 'a Std.Partition.t", "Graphlib.Std.Partition.html#VALrefine", "<div class=\"info\">\n<p><code class=\"code\">refine&nbsp;p&nbsp;~rel&nbsp;~comp</code> takes a partition <code class=\"code\">p</code>, and refines it\n        according to the equivalence relation <code class=\"code\">r</code>, so that the\n        resulting partition corresponds to the classes of <code class=\"code\">r</code>, assuming\n        that those classes are finer that the original <code class=\"code\">p</code>.</p>\n\n</div>\n", ["ACCORDING", "ADDITIONAL", "AND", "ARE", "ARGUMENT", "ASSUMING", "CLASSES", "COMP", "COMPARE", "CORRESPONDS", "EQUALITY", "EQUIVALENCE", "FINER", "FOR", "ORIGINAL", "PARTITION", "REFINE", "REFINES", "REL", "RELATION", "RESULTING", "TAKES", "THAT", "THE", "THOSE", "WITHIN"]);
add_ocaml_element("discrete", "Std.Partition.discrete", "value", "('a, 'b) Set.t -> 'a Std.Partition.t", "Graphlib.Std.Partition.html#VALdiscrete", "<div class=\"info\">\n<p><code class=\"code\">discrete&nbsp;s</code> returns the partition with one class per element of <code class=\"code\">s</code></p>\n\n</div>\n", ["CLASS", "DISCRETE", "ELEMENT", "ONE", "PARTITION", "PER", "RETURNS", "THE", "WITH"]);
add_ocaml_element("trivial", "Std.Partition.trivial", "value", "('a, 'b) Set.t -> 'a Std.Partition.t", "Graphlib.Std.Partition.html#VALtrivial", "<div class=\"info\">\n<p><code class=\"code\">trivial&nbsp;s</code> creates the trivial partition with a single\n        equivalence class containing every member of <code class=\"code\">s</code></p>\n\n</div>\n", ["CLASS", "CONTAINING", "CREATES", "EQUIVALENCE", "EVERY", "MEMBER", "PARTITION", "SINGLE", "THE", "TRIVIAL", "WITH"]);
add_ocaml_element("pp", "Std.Path.pp", "value", "'a Std.printer -> 'a Std.Path.t Std.printer", "Graphlib.Std.Path.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elt</code> constructs a pretty based on element printer\n        <code class=\"code\">pp_elt</code></p>\n\n</div>\n", ["BASED", "CONSTRUCTS", "ELEMENT", "PP_ELT", "PRETTY", "PRINTER"]);
add_ocaml_element("length", "Std.Path.length", "value", "'e Std.Path.t -> int", "Graphlib.Std.Path.html#VALlength", "<div class=\"info\">\n<p>amount of edges in a path</p>\n\n</div>\n", ["AMOUNT", "EDGES", "PATH"]);
add_ocaml_element("weight", "Std.Path.weight", "value", "'e Std.Path.t -> int", "Graphlib.Std.Path.html#VALweight", "<div class=\"info\">\n<p><code class=\"code\">weight&nbsp;p</code> total weight of a path</p>\n\n</div>\n", ["PATH", "TOTAL", "WEIGHT"]);
add_ocaml_element("edges_rev", "Std.Path.edges_rev", "value", "'e Std.Path.t -> 'e Std.seq", "Graphlib.Std.Path.html#VALedges_rev", "<div class=\"info\">\n<p><code class=\"code\">edges_rev&nbsp;p</code> a reversed sequence from finish to start</p>\n\n</div>\n", ["EDGES_REV", "FINISH", "FROM", "REVERSED", "SEQUENCE", "START"]);
add_ocaml_element("edges", "Std.Path.edges", "value", "'e Std.Path.t -> 'e Std.seq", "Graphlib.Std.Path.html#VALedges", "<div class=\"info\">\n<p><code class=\"code\">edges&nbsp;p</code> a sequence of edges from start to finish</p>\n\n</div>\n", ["EDGES", "FINISH", "FROM", "SEQUENCE", "START"]);
add_ocaml_element("finish", "Std.Path.finish", "value", "'e Std.Path.t -> 'e", "Graphlib.Std.Path.html#VALfinish", "<div class=\"info\">\n<p><code class=\"code\">finish&nbsp;p</code> the last edge of a path <code class=\"code\">p</code></p>\n\n</div>\n", ["EDGE", "FINISH", "LAST", "PATH", "THE"]);
add_ocaml_element("start", "Std.Path.start", "value", "'e Std.Path.t -> 'e", "Graphlib.Std.Path.html#VALstart", "<div class=\"info\">\n<p><code class=\"code\">start&nbsp;p</code> the starting edge of a path <code class=\"code\">p</code></p>\n\n</div>\n", ["EDGE", "PATH", "START", "STARTING", "THE"]);
add_ocaml_element("pp", "Std.Frontier.pp", "value", "'a Std.printer -> 'a Std.Frontier.t Std.printer", "Graphlib.Std.Frontier.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elt</code> instantiates a pretty-printer for a given\n        element.</p>\n\n</div>\n", ["ELEMENT", "FOR", "GIVEN", "GRAPHLIB", "INFORMATION", "INSTANTIATES", "MORE", "PP_ELT", "PRETTY", "PRINTER", "SEE", "STD", "TREE"]);
add_ocaml_element("to_sequence", "Std.Frontier.to_sequence", "value", "'a Std.Frontier.t -> 'a Std.seq", "Graphlib.Std.Frontier.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;frontier</code> enumerates all elements of a <code class=\"code\">frontier</code></p>\n\n</div>\n", ["ALL", "ELEMENTS", "ENUMERATES", "FRONTIER", "TO_SEQUENCE"]);
add_ocaml_element("mem", "Std.Frontier.mem", "value", "'a Std.Frontier.t -> 'a -> 'a -> bool", "Graphlib.Std.Frontier.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;f&nbsp;x&nbsp;y</code> is true if <code class=\"code\">y</code> is in a frontier of <code class=\"code\">x</code></p>\n\n</div>\n", ["FRONTIER", "MEM", "TRUE"]);
add_ocaml_element("enum", "Std.Frontier.enum", "value", "'a Std.Frontier.t -> 'a -> 'a Std.seq", "Graphlib.Std.Frontier.html#VALenum", "<div class=\"info\">\n<p><code class=\"code\">enum&nbsp;f&nbsp;x</code> enumerates frontier of <code class=\"code\">x</code></p>\n\n</div>\n", ["ENUM", "ENUMERATES", "FRONTIER"]);
add_ocaml_element("pp", "Std.Tree.pp", "value", "'a Std.printer -> 'a Std.Tree.t Std.printer", "Graphlib.Std.Tree.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elt</code> creates a pretty-printer for a node, based on\n        element's pretty-printer <code class=\"code\">pp_elt</code>.</p>\n\n</div>\n", ["ALL", "ARE", "AUTOMATICALLY", "AVAILABLE", "BASED", "BOOL", "CREATES", "DOT", "EASE", "ELEMENT", "ETC", "EXAMPLE", "FOR", "FORMAT", "GRAPH", "GRAPHLIB", "GROUP", "INSTALLED", "INSTANTIATED", "INSTATIATIONS", "INT", "INTERFACE", "INTO", "LET", "LIBRARY", "LOADED", "NODE", "NOTE", "ONCE", "PARTITION", "PP_ELT", "PP_INT_TREE", "PRETTY", "PRINTABLE", "PRINTED", "PRINTER", "PRINTERS", "PROVIDED", "THE", "TOPLEVEL", "TREE", "UNDER", "VERSION", "VERSIONS", "VISUALIZATION"]);
add_ocaml_element("to_sequence", "Std.Tree.to_sequence", "value", "'a Std.Tree.t -> 'a Std.seq", "Graphlib.Std.Tree.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;tree</code> enumerates nodes of a <code class=\"code\">tree</code> in an\n        unspecified order.</p>\n\n</div>\n", ["ENUMERATES", "NODES", "ORDER", "TO_SEQUENCE", "TREE", "UNSPECIFIED"]);
add_ocaml_element("is_descendant_of", "Std.Tree.is_descendant_of", "value", "'a Std.Tree.t -> parent:'a -> 'a -> bool", "Graphlib.Std.Tree.html#VALis_descendant_of", "<div class=\"info\">\n<p><code class=\"code\">is_descendant_of&nbsp;~parent&nbsp;tree&nbsp;x</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> for all <code class=\"code\">x</code> that\n        are descendants of a <code class=\"code\">parent</code> node.</p>\n\n</div>\n", ["ALL", "ARE", "DESCENDANTS", "FOR", "IS_DESCENDANT_OF", "NODE", "PARENT", "THAT", "TREE", "TRUE"]);
add_ocaml_element("is_ancestor_of", "Std.Tree.is_ancestor_of", "value", "'a Std.Tree.t -> child:'a -> 'a -> bool", "Graphlib.Std.Tree.html#VALis_ancestor_of", "<div class=\"info\">\n<p><code class=\"code\">is_ancestor_of&nbsp;tree&nbsp;child&nbsp;x</code> returns true, if <code class=\"code\">x</code> is one of\n        the ancestors of a <code class=\"code\">child</code> node.</p>\n\n</div>\n", ["ANCESTORS", "CHILD", "IS_ANCESTOR_OF", "NODE", "ONE", "RETURNS", "THE", "TREE", "TRUE"]);
add_ocaml_element("is_child_of", "Std.Tree.is_child_of", "value", "'a Std.Tree.t -> parent:'a -> 'a -> bool", "Graphlib.Std.Tree.html#VALis_child_of", "<div class=\"info\">\n<p><code class=\"code\">is_child_of&nbsp;tree&nbsp;parent&nbsp;child</code> returns <code class=\"code\"><span class=\"keyword\">true</span></code> if child is one\n        of <code class=\"code\">children&nbsp;tree&nbsp;root</code></p>\n\n</div>\n", ["CHILD", "CHILDREN", "IS_CHILD_OF", "ONE", "PARENT", "RETURNS", "ROOT", "TREE", "TRUE"]);
add_ocaml_element("descendants", "Std.Tree.descendants", "value", "'a Std.Tree.t -> 'a -> 'a Std.seq", "Graphlib.Std.Tree.html#VALdescendants", "<div class=\"info\">\n<p><code class=\"code\">descendants&nbsp;tree&nbsp;n</code> returns a set of all descendants of a given\n        node <code class=\"code\">n</code>.</p>\n\n</div>\n", ["ALL", "ARE", "CHILD", "DESCENDANT", "DESCENDANTS", "EITHER", "EXAMPLE", "EXCEPT", "FOR", "GIVEN", "ITSELF", "NODE", "NODES", "RETURNS", "ROOT", "ROOTS", "SET", "THE", "TREE"]);
add_ocaml_element("ancestors", "Std.Tree.ancestors", "value", "'a Std.Tree.t -> 'a -> 'a Std.seq", "Graphlib.Std.Tree.html#VALancestors", "<div class=\"info\">\n<p><code class=\"code\">ancestors&nbsp;tree&nbsp;n</code> returns a sequence of all ancestors of node\n        <code class=\"code\">n</code>.</p>\n\n</div>\n", ["ALL", "ANCESTOR", "ANCESTORS", "AND", "ARE", "EITHER", "EMPTY", "EXAMPLE", "FOR", "HAS", "NODE", "ONE", "ONLY", "PARENT", "RETURNS", "ROOT", "SEQUENCE", "SET", "THAT", "THE", "TREE"]);
add_ocaml_element("parent", "Std.Tree.parent", "value", "'a Std.Tree.t -> 'a -> 'a option", "Graphlib.Std.Tree.html#VALparent", "<div class=\"info\">\n<p><code class=\"code\">parent&nbsp;tree&nbsp;n</code> returns an immediate parent of a given node.</p>\n\n</div>\n", ["AND", "DOESN", "EXAMPLE", "FOR", "GIVEN", "HAVE", "IMMEDIATE", "NODE", "NONE", "ONLY", "PARENT", "RETURNS", "ROOT", "TREE"]);
add_ocaml_element("children", "Std.Tree.children", "value", "'a Std.Tree.t -> 'a -> 'a Std.seq", "Graphlib.Std.Tree.html#VALchildren", "<div class=\"info\">\n<p><code class=\"code\">children&nbsp;tree&nbsp;x</code> returns all immediate successors of node\n        <code class=\"code\">x</code>.</p>\n\n</div>\n", ["ALL", "ANY", "BUT", "CHILDREN", "DOESN", "EXAMPLE", "FOR", "HAVE", "IMMEDIATE", "NODE", "RETURNS", "SEQUENCE", "SUCCESSORS", "TREE"]);
add_ocaml_element("repeat", "Bap_future.Std.Signal.repeat", "value", "'a Bap_future.Std.signal -> times:int -> 'a -> unit", "Bap_future.Std.Signal.html#VALrepeat", "<div class=\"info\">\n<p><code class=\"code\">repeat&nbsp;s&nbsp;~times:n&nbsp;x</code> sends value <code class=\"code\">x</code> to an associated\n        stream <code class=\"code\">n</code> times</p>\n\n</div>\n", ["ASSOCIATED", "REPEAT", "SENDS", "STREAM", "TIMES", "VALUE"]);
add_ocaml_element("send", "Bap_future.Std.Signal.send", "value", "'a Bap_future.Std.signal -> 'a -> unit", "Bap_future.Std.Signal.html#VALsend", "<div class=\"info\">\n<p><code class=\"code\">send&nbsp;s&nbsp;x</code> sends value <code class=\"code\">x</code> to an associated stream.</p>\n\n</div>\n", ["ASSOCIATED", "SEND", "SENDS", "STREAM", "VALUE"]);
add_ocaml_element("last_before", "Bap_future.Std.Stream.last_before", "value", "unit Bap_future.Std.future ->\n  'a Bap_future.Std.Stream.t -> int -> 'a list Bap_future.Std.future", "Bap_future.Std.Stream.html#VALlast_before", "<div class=\"info\">\n<p><code class=\"code\">last_before&nbsp;e&nbsp;xs&nbsp;n</code> returns a list of length up to <code class=\"code\">n</code>, that\n        contains last elements of the stream <code class=\"code\">xs</code> that occurred before the\n        event <code class=\"code\">e</code></p>\n\n</div>\n", ["BEFORE", "CONTAINS", "ELEMENTS", "EVENT", "LAST", "LAST_BEFORE", "LENGTH", "LIST", "OCCURRED", "RETURNS", "STREAM", "THAT", "THE"]);
add_ocaml_element("before", "Bap_future.Std.Stream.before", "value", "unit Bap_future.Std.future ->\n  'a Bap_future.Std.Stream.t -> 'a list Bap_future.Std.future", "Bap_future.Std.Stream.html#VALbefore", "<div class=\"info\">\n<p><code class=\"code\">before&nbsp;e&nbsp;xs</code> returns a list that contains elements of\n        the stream <code class=\"code\">xs</code> that occurred before the event <code class=\"code\">e</code></p>\n\n</div>\n", ["BEFORE", "CONTAINS", "ELEMENTS", "EVENT", "LIST", "OCCURRED", "RETURNS", "STREAM", "THAT", "THE"]);
add_ocaml_element("upon", "Bap_future.Std.Stream.upon", "value", "unit Bap_future.Std.future ->\n  'a Bap_future.Std.Stream.t -> 'a Bap_future.Std.future", "Bap_future.Std.Stream.html#VALupon", "<div class=\"info\">\n<p><code class=\"code\">upon&nbsp;e&nbsp;xs</code> returns a future that will be fulfilled with a\n        last value of a stream <code class=\"code\">xs</code> before an event <code class=\"code\">e</code> has\n        occurred.</p>\n\n</div>\n", ["ANY", "BEFORE", "DIDN", "ELEMENTS", "EVENT", "FULFILLED", "FUTURE", "HAS", "LAST", "NOT", "OCCURRED", "OCCURS", "PRODUCE", "RETURNS", "STREAM", "THAT", "THE", "THEN", "TIME", "UPON", "VALUE", "WHEN", "WILL", "WITH"]);
add_ocaml_element("nth", "Bap_future.Std.Stream.nth", "value", "'a Bap_future.Std.Stream.t -> int -> 'a Bap_future.Std.future", "Bap_future.Std.Stream.html#VALnth", "<div class=\"info\">\n<p><code class=\"code\">nth&nbsp;xs&nbsp;n</code> returns <code class=\"code\">n</code>'th element of the stream <code class=\"code\">xs</code>.</p>\n\n</div>\n", ["AFTER", "CREATION", "ELEMENT", "FUTURE", "NTH", "RESPECT", "RETURNS", "STREAM", "THE", "WAS", "WITH"]);
add_ocaml_element("take", "Bap_future.Std.Stream.take", "value", "'a Bap_future.Std.Stream.t -> int -> 'a list Bap_future.Std.future", "Bap_future.Std.Stream.html#VALtake", "<div class=\"info\">\n<p><code class=\"code\">take&nbsp;xs&nbsp;n</code> returns a future that will evaluate to <code class=\"code\">n</code> values\n        of the stream <code class=\"code\">xs</code> that has occurred after the future was\n        created.</p>\n\n</div>\n", ["AFTER", "CREATED", "EVALUATE", "FUTURE", "HAS", "OCCURRED", "RETURNS", "STREAM", "TAKE", "THAT", "THE", "VALUES", "WAS", "WILL"]);
add_ocaml_element("find_map", "Bap_future.Std.Stream.find_map", "value", "'a Bap_future.Std.Stream.t -> f:('a -> 'b option) -> 'b Bap_future.Std.future", "Bap_future.Std.Stream.html#VALfind_map", "<div class=\"info\">\n<p><code class=\"code\">find_map&nbsp;xs&nbsp;f</code> returns a future that will be fulfilled by a\n        result of a first invocation of <code class=\"code\">f</code> to an element of the stream,\n        that evaluated to <code class=\"code\"><span class=\"constructor\">Some</span></code> value</p>\n\n</div>\n", ["ELEMENT", "EVALUATED", "FIND_MAP", "FIRST", "FULFILLED", "FUTURE", "INVOCATION", "RESULT", "RETURNS", "SOME", "STREAM", "THAT", "THE", "VALUE", "WILL"]);
add_ocaml_element("find", "Bap_future.Std.Stream.find", "value", "'a Bap_future.Std.Stream.t -> f:('a -> bool) -> 'a Bap_future.Std.future", "Bap_future.Std.Stream.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;xs&nbsp;f</code> returns a future that will be fulfilled with a\n        first value for which a function <code class=\"code\">f</code> is <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["FIND", "FIRST", "FOR", "FULFILLED", "FUNCTION", "FUTURE", "RETURNS", "THAT", "TRUE", "VALUE", "WHICH", "WILL", "WITH"]);
add_ocaml_element("tl", "Bap_future.Std.Stream.tl", "value", "'a Bap_future.Std.Stream.t -> 'a Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALtl", "<div class=\"info\">\n<p><code class=\"code\">tl&nbsp;s</code> ignores the next occurrence in the stream <code class=\"code\">s</code></p>\n\n</div>\n", ["IGNORES", "NEXT", "OCCURRENCE", "STREAM", "THE"]);
add_ocaml_element("hd", "Bap_future.Std.Stream.hd", "value", "'a Bap_future.Std.Stream.t -> 'a Bap_future.Std.future", "Bap_future.Std.Stream.html#VALhd", "<div class=\"info\">\n<p><code class=\"code\">hd&nbsp;s</code> returns a <code class=\"code\">future</code> that will occur as soon, as stream\n        <code class=\"code\">s</code> will produce a value.</p>\n\n</div>\n", ["AFTER", "ALREADY", "CALLED", "CREATED", "FIRST", "FULFILLED", "FUTURE", "INTO", "NOTE", "OCCUR", "PRODUCE", "PRODUCED", "PUT", "RETURNED", "RETURNS", "SOME", "SOON", "STILL", "STREAM", "THAT", "THE", "VALUE", "VALUES", "WILL"]);
add_ocaml_element("sample", "Bap_future.Std.Stream.sample", "value", "clk:unit Bap_future.Std.Stream.t ->\n  'a Bap_future.Std.Stream.t -> 'a option Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALsample", "<div class=\"info\">\n<p><code class=\"code\">sample&nbsp;~clk&nbsp;ss</code> is semantically the same as\n        <code class=\"code\">frame&nbsp;~clk&nbsp;ss&nbsp;&gt;&gt;|&nbsp;fst</code></p>\n\n</div>\n", ["CLK", "FRAME", "FST", "SAME", "SAMPLE", "SEMANTICALLY", "THE"]);
add_ocaml_element("frame", "Bap_future.Std.Stream.frame", "value", "clk:unit Bap_future.Std.Stream.t ->\n  'a Bap_future.Std.Stream.t ->\n  init:'b -> f:('b -> 'a -> 'b) -> 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALframe", "<div class=\"info\">\n<p><code class=\"code\">frame&nbsp;~clk&nbsp;s&nbsp;~init&nbsp;~f</code> will gather elements of <code class=\"code\">s</code> into frames,\n        where the start of the new frame is signaled by a stream <code class=\"code\">clk</code>.</p>\n\n</div>\n", ["123", "1234", "12344", "5612312", "AFTERWARDS", "ALL", "AND", "ARE", "BUFFER", "BUFFERED", "BUILD", "CAN", "CLARIFIED", "CLEARED", "CLK", "COLUMN", "COLUMNS", "CONSIDER", "CUSTOM", "DEPICTED", "DESCRIPTION", "DETERMINED", "DIAGRAM", "DYNAMICALLY", "EACH", "ELEMENTS", "EVENT", "EVENTS", "EVERY", "EXAMPLE", "EXCEPT", "FOLDED", "FOLDW", "FOLLOWING", "FRAME", "FRAMED", "FRAMES", "FUNCTION", "GATHER", "IMPOSSIBLE", "INIT", "INTERNAL", "INTO", "NEW", "NOTE", "OCCUR", "ONE", "ONLY", "OUTPUT", "OVER", "PRODUCES", "PUT", "REPRESENT", "REPRESENTS", "RESULT", "ROW", "SAME", "SCALES", "SEMANTICS", "SERIALIZED", "SHOULD", "SIGNALED", "SIMILAR", "SINCE", "START", "STREAM", "STREAMS", "SYMBOL", "THAT", "THE", "THERE", "THIS", "TIME", "TIMING", "TWO", "USEFUL", "VALUE", "VERY", "WAY", "WHERE", "WILL", "WINDOW", "WITH"]);
add_ocaml_element("foldw", "Bap_future.Std.Stream.foldw", "value", "?stride:int ->\n  'a Bap_future.Std.Stream.t ->\n  int -> init:'b -> f:('b -> 'a -> 'b) -> 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALfoldw", "<div class=\"info\">\n<p><code class=\"code\">foldw&nbsp;ss&nbsp;n&nbsp;~init&nbsp;~f</code> performs a windowed fold of the stream.</p>\n\n</div>\n", ["AND", "APPLIED", "AVERAGE", "CONSECUTIVE", "DEFAULTS", "ELEMENTS", "EQUAL", "EXAMPLE", "FILTER", "FLOAT", "FOLD", "FOLDED", "FOLDW", "FOLLOWING", "FOR", "FUN", "FUNCTION", "IMPLEMENTED", "INIT", "INTO", "LENGTH", "LET", "MOVING", "MOVING_AVERAGE", "NEXT", "OF_INT", "ONE", "OUTPUT", "OVER", "PERFORMS", "PRODUCED", "RESULT", "SEQUENCE", "SEQUENCES", "SHIFTED", "STREAM", "STRIDE", "THE", "THEN", "WILL", "WINDOW", "WINDOWED", "WINDOWS", "WITH", "ZERO"]);
add_ocaml_element("parse", "Bap_future.Std.Stream.parse", "value", "'a Bap_future.Std.Stream.t ->\n  init:'b -> f:('b -> 'a -> 'c option * 'b) -> 'c Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALparse", "<div class=\"info\">\n<p><code class=\"code\">parse&nbsp;ss&nbsp;~init&nbsp;~f</code> parses stream <code class=\"code\">ss</code> and builds new stream\n        <code class=\"code\">ss'</code>.</p>\n\n</div>\n", ["AND", "APPLIED", "ARBITRARY", "AUTOMATON", "AUTOMATONS", "BETWEEN", "BUILD", "BUILDS", "CONSECUTIVE", "DOWN", "EACH", "ELEMENT", "FALLS", "FUNCTION", "INCLUDING", "INIT", "INSTANCE", "INVOCATION", "LATTER", "LIST", "MACHINE", "NEW", "NEXT", "NONE", "NOT", "OUTPUT", "PARSE", "PARSES", "PASSED", "PDA", "POSSIBLE", "PRODUCED", "PUSH", "RETURNS", "SOME", "STATE", "STREAM", "THAT", "THE", "THEN", "TURING", "TYPE", "VALUE", "WILL", "WITH"]);
add_ocaml_element("once", "Bap_future.Std.Stream.once", "value", "'a Bap_future.Std.Stream.t -> 'a Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALonce", "<div class=\"info\">\n<p><code class=\"code\">once&nbsp;xs</code> creates a stream that will at most contain the next value \n        produced by <code class=\"code\">xs</code> and nothing more.</p>\n\n</div>\n", ["AND", "CONTAIN", "CREATES", "MORE", "MOST", "NEXT", "NOTHING", "ONCE", "PRODUCED", "STREAM", "THAT", "THE", "VALUE", "WILL"]);
add_ocaml_element("unzip", "Bap_future.Std.Stream.unzip", "value", "('a * 'b) Bap_future.Std.Stream.t ->\n  'a Bap_future.Std.Stream.t * 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALunzip", "<div class=\"info\">\n<p><code class=\"code\">unzip&nbsp;xs</code> creates a pair of streams, where the first stream contains\n        <code class=\"code\">fst&nbsp;x</code> for each <code class=\"code\">x</code> in <code class=\"code\">xs</code> and the second stream contains <code class=\"code\">snd&nbsp;x</code> for\n        each <code class=\"code\">x</code> in <code class=\"code\">xs</code>.</p>\n\n</div>\n", ["AND", "CONTAINS", "CREATES", "EACH", "ESSENTIALLY", "FIRST", "FOR", "FST", "IDENT", "PAIR", "SAME", "SECOND", "SND", "SPLIT", "STREAM", "STREAMS", "THE", "UNZIP", "WHERE"]);
add_ocaml_element("zip", "Bap_future.Std.Stream.zip", "value", "'a Bap_future.Std.Stream.t ->\n  'b Bap_future.Std.Stream.t -> ('a * 'b) Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALzip", "<div class=\"info\">\n<p><code class=\"code\">zip&nbsp;xs&nbsp;ys</code> creates a steam that will produce an element <code class=\"code\">(x,y)</code> \n        every time both <code class=\"code\">xs</code> and <code class=\"code\">ys</code> produce elements <code class=\"code\">x</code> and <code class=\"code\">y</code> respectively</p>\n\n</div>\n", ["AND", "BOTH", "CREATES", "ELEMENT", "ELEMENTS", "EVERY", "PRODUCE", "RESPECTIVELY", "STEAM", "THAT", "TIME", "WILL", "ZIP"]);
add_ocaml_element("split", "Bap_future.Std.Stream.split", "value", "'a Bap_future.Std.Stream.t ->\n  f:('a -> 'b * 'c) -> 'b Bap_future.Std.Stream.t * 'c Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALsplit", "<div class=\"info\">\n<p><code class=\"code\">split&nbsp;xs&nbsp;~f</code> returns a pair of streams, where the first stream \n        contains <code class=\"code\">fst&nbsp;(f&nbsp;x)</code> for each <code class=\"code\">x</code> in <code class=\"code\">xs</code> and the second stream\n        contains <code class=\"code\">snd&nbsp;(f&nbsp;x)</code> for each <code class=\"code\">x</code> in <code class=\"code\">xs</code>.</p>\n\n</div>\n", ["AND", "CONTAINS", "EACH", "FIRST", "FOR", "FST", "PAIR", "RETURNS", "SECOND", "SND", "SPLIT", "STREAM", "STREAMS", "THE", "WHERE"]);
add_ocaml_element("concat_merge", "Bap_future.Std.Stream.concat_merge", "value", "'a Bap_future.Std.Stream.t list ->\n  f:('a -> 'a -> 'a) -> 'a Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALconcat_merge", "<div class=\"info\">\n<p><code class=\"code\">concat_merge&nbsp;xs&nbsp;~f</code> builds a stream, that will \n        produce elements from the input list and applies <code class=\"code\">f</code> to all \n        consecutive elements.</p>\n\n</div>\n", ["ALL", "AND", "APPLIES", "BUILDS", "CONCAT", "CONCAT_MERGE", "CONSECUTIVE", "DOES", "ELEMENETS", "ELEMENTS", "FOR", "FROM", "INFORMATION", "INPUT", "LIST", "MANDATE", "MORE", "NOT", "ORDERING", "OUTPUT", "PRODUCE", "SEE", "STREAM", "THAT", "THE", "UNDEFINED", "WILL"]);
add_ocaml_element("concat", "Bap_future.Std.Stream.concat", "value", "'a Bap_future.Std.Stream.t list -> 'a Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat&nbsp;ss</code> returns a stream that will produce elements from \n        the input list of streams <code class=\"code\">ss</code>.</p>\n\n</div>\n", ["CONCAT", "DIFFERENT", "ELEMENTS", "FROM", "GUARANTEED", "INPUT", "LIST", "ORDERING", "PRESERVE", "PRODUCE", "RETURNS", "SAME", "STREAM", "STREAMS", "THAT", "THE", "THEIR", "THOUGH", "UNSPECIFIED", "WILL"]);
add_ocaml_element("apply", "Bap_future.Std.Stream.apply", "value", "('a -> 'b) Bap_future.Std.Stream.t ->\n  'a Bap_future.Std.Stream.t -> 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALapply", "<div class=\"info\">\n<p><code class=\"code\">apply&nbsp;fs&nbsp;xs</code> apply stream of functions <code class=\"code\">fs</code> to a stream of\n        values xs, producing a stream of results.</p>\n\n</div>\n", ["APPLY", "FUNCTIONS", "PRODUCING", "RESULTS", "STREAM", "VALUES"]);
add_ocaml_element("merge", "Bap_future.Std.Stream.merge", "value", "'a Bap_future.Std.Stream.t ->\n  'b Bap_future.Std.Stream.t ->\n  f:('a -> 'b -> 'c) -> 'c Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALmerge", "<div class=\"info\">\n<p><code class=\"code\">merge&nbsp;xs&nbsp;ys&nbsp;f</code> merges streams <code class=\"code\">xs</code> and <code class=\"code\">ys</code> using function\n        <code class=\"code\">f</code>.</p>\n\n</div>\n", ["AND", "FUNCTION", "MERGE", "MERGES", "STREAMS", "USING"]);
add_ocaml_element("either", "Bap_future.Std.Stream.either", "value", "'a Bap_future.Std.Stream.t ->\n  'b Bap_future.Std.Stream.t ->\n  ('a, 'b) Either.t Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALeither", "<div class=\"info\">\n<p><code class=\"code\">either&nbsp;xs&nbsp;ys</code> is a discriminated union of two streams.</p>\n\n</div>\n", ["DISCRIMINATED", "EITHER", "STREAMS", "TWO", "UNION"]);
add_ocaml_element("filter", "Bap_future.Std.Stream.filter", "value", "'a Bap_future.Std.Stream.t -> f:('a -> bool) -> 'a Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;s&nbsp;f</code> produce a stream that contains the elements of\n        stream <code class=\"code\">s</code>, for which <code class=\"code\">f</code> evaluates to true.</p>\n\n</div>\n", ["CONTAINS", "ELEMENTS", "EVALUATES", "FILTER", "FOR", "PRODUCE", "STREAM", "THAT", "THE", "TRUE", "WHICH"]);
add_ocaml_element("filter_map", "Bap_future.Std.Stream.filter_map", "value", "'a Bap_future.Std.Stream.t ->\n  f:('a -> 'b option) -> 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;s&nbsp;~f</code> for each value <code class=\"code\">x</code> in stream <code class=\"code\">s</code>, produce\n        <code class=\"code\">y</code> if <code class=\"code\">f&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;y</code>, otherwise ignore <code class=\"code\">x</code></p>\n\n</div>\n", ["EACH", "FILTER_MAP", "FOR", "IGNORE", "OTHERWISE", "PRODUCE", "SOME", "STREAM", "VALUE"]);
add_ocaml_element("map", "Bap_future.Std.Stream.map", "value", "'a Bap_future.Std.Stream.t -> f:('a -> 'b) -> 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;ss&nbsp;~f</code> returns new stream, that is build by application\n        of a function <code class=\"code\">f</code> to each element of the stream <code class=\"code\">ss</code></p>\n\n</div>\n", ["APPLICATION", "BUILD", "EACH", "ELEMENT", "FUNCTION", "MAP", "NEW", "RETURNS", "STREAM", "THAT", "THE"]);
add_ocaml_element("map'", "Bap_future.Std.Stream.map'", "value", "'a Bap_future.Std.Stream.t ->\n  f:('a -> 'b Queue.t) -> 'b Bap_future.Std.Stream.t", "Bap_future.Std.Stream.html#VALmap'", "<div class=\"info\">\n<p><code class=\"code\">s'&nbsp;=&nbsp;map'&nbsp;s&nbsp;~f</code> apply function <code class=\"code\">f</code> for each value of a\n        stream <code class=\"code\">s</code> and push values from a resulting queue into the\n        stream <code class=\"code\">s'</code>.</p>\n\n</div>\n", ["AND", "APPLY", "CHAR", "EACH", "EXAMPLE", "FOR", "FROM", "FUNCTION", "INTO", "LET", "LOWERCASE", "MAP", "OF_LIST", "PRODUCE", "PUSH", "QUEUE", "RESULTING", "SINGLETON", "STREAM", "THE", "UPPERCASE", "VALUE", "VALUES", "WILL"]);
add_ocaml_element("on_wait", "Bap_future.Std.Stream.on_wait", "value", "'a Bap_future.Std.Stream.t -> (unit -> unit) -> unit", "Bap_future.Std.Stream.html#VALon_wait", "<div class=\"info\">\n<p><code class=\"code\">on_wait&nbsp;s&nbsp;f</code> will be called every time someone, watching a\n        stream <code class=\"code\">s</code>, will call <code class=\"code\">wait&nbsp;s</code> to ask a producer to slow down.</p>\n\n</div>\n", ["ASK", "CALL", "CALLED", "DOWN", "EVERY", "ON_WAIT", "PRODUCER", "SLOW", "SOMEONE", "STREAM", "TIME", "WAIT", "WATCHING", "WILL"]);
add_ocaml_element("on_unsubscribe", "Bap_future.Std.Stream.on_unsubscribe", "value", "'a Bap_future.Std.Stream.t -> (Bap_future.Std.Stream.id -> unit) -> unit", "Bap_future.Std.Stream.html#VALon_unsubscribe", "<div class=\"info\">\n<p><code class=\"code\">on_unsubscribe&nbsp;s&nbsp;f</code> will call a function <code class=\"code\">f</code> every time\n        someone has canceled subscription to a stream <code class=\"code\">s</code></p>\n\n</div>\n", ["CALL", "CANCELED", "EVERY", "FUNCTION", "HAS", "ON_UNSUBSCRIBE", "SOMEONE", "STREAM", "SUBSCRIPTION", "TIME", "WILL"]);
add_ocaml_element("on_subscribe", "Bap_future.Std.Stream.on_subscribe", "value", "'a Bap_future.Std.Stream.t -> (Bap_future.Std.Stream.id -> unit) -> unit", "Bap_future.Std.Stream.html#VALon_subscribe", "<div class=\"info\">\n<p><code class=\"code\">on_subscribe&nbsp;s&nbsp;f</code> will call a function <code class=\"code\">f</code> every time someone\n        is subscribed to a stream <code class=\"code\">s</code></p>\n\n</div>\n", ["CALL", "EVERY", "FUNCTION", "ON_SUBSCRIBE", "SOMEONE", "STREAM", "SUBSCRIBED", "TIME", "WILL"]);
add_ocaml_element("has_subscribers", "Bap_future.Std.Stream.has_subscribers", "value", "'a Bap_future.Std.Stream.t -> bool", "Bap_future.Std.Stream.html#VALhas_subscribers", "<div class=\"info\">\n<p><code class=\"code\">has_subscribers&nbsp;s</code> is true if someone is watching for the stream</p>\n\n</div>\n", ["FOR", "HAS_SUBSCRIBERS", "SOMEONE", "STREAM", "THE", "TRUE", "WATCHING"]);
add_ocaml_element("wait", "Bap_future.Std.Stream.wait", "value", "'a Bap_future.Std.Stream.t -> unit", "Bap_future.Std.Stream.html#VALwait", "<div class=\"info\">\n<p><code class=\"code\">wait&nbsp;xs</code> a polite way to notify a producer to slow down.</p>\n\n</div>\n", ["DOWN", "NOT", "NOTE", "NOTIFY", "OBEY", "POLITE", "PRODUCER", "REQUIRED", "SLOW", "WAIT", "WAY"]);
add_ocaml_element("unsubscribe", "Bap_future.Std.Stream.unsubscribe", "value", "'a Bap_future.Std.Stream.t -> Bap_future.Std.Stream.id -> unit", "Bap_future.Std.Stream.html#VALunsubscribe", "<div class=\"info\">\n<p><code class=\"code\">unsubscribe&nbsp;s&nbsp;id</code> stop calling a function that was has a\n        provided identifier <code class=\"code\">id</code></p>\n\n</div>\n", ["CALLING", "FUNCTION", "HAS", "IDENTIFIER", "PROVIDED", "STOP", "THAT", "UNSUBSCRIBE", "WAS"]);
add_ocaml_element("subscribe", "Bap_future.Std.Stream.subscribe", "value", "'a Bap_future.Std.Stream.t -> ('a -> unit) -> Bap_future.Std.Stream.id", "Bap_future.Std.Stream.html#VALsubscribe", "<div class=\"info\">\n<p><code class=\"code\">subscribe&nbsp;s&nbsp;f</code> subscribe to a stream <code class=\"code\">s</code> with a function\n        <code class=\"code\">f</code>.</p>\n\n</div>\n", ["FUNCTION", "IDENTIFIER", "RETURNED", "STREAM", "SUBSCRIBE", "SUBSCRIPTION", "WITH"]);
add_ocaml_element("observe", "Bap_future.Std.Stream.observe", "value", "'a Bap_future.Std.Stream.t -> ('a -> unit) -> unit", "Bap_future.Std.Stream.html#VALobserve", "<div class=\"info\">\n<p><code class=\"code\">observe&nbsp;s&nbsp;f</code> is like <code class=\"code\">watch</code> but a subscription identifier is\n        not passed to the function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["BUT", "FUNCTION", "IDENTIFIER", "LIKE", "NOT", "OBSERVE", "PASSED", "SUBSCRIPTION", "THE", "WATCH"]);
add_ocaml_element("watch", "Bap_future.Std.Stream.watch", "value", "'a Bap_future.Std.Stream.t ->\n  (Bap_future.Std.Stream.id -> 'a -> unit) -> unit", "Bap_future.Std.Stream.html#VALwatch", "<div class=\"info\">\n<p><code class=\"code\">watch&nbsp;s&nbsp;f</code> watches a stream <code class=\"code\">s</code> with a function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["CAN", "DIRECTLY", "FROM", "FUNCTION", "IDENTIFIER", "PASSED", "STREAM", "SUBSCRIPTION", "THE", "UNSUBSCRIBE", "USED", "WATCH", "WATCHES", "WITH"]);
add_ocaml_element("of_sequence", "Bap_future.Std.Stream.of_sequence", "value", "'a Sequence.t ->\n  'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal *\n  unit Bap_future.Std.future", "Bap_future.Std.Stream.html#VALof_sequence", "<div class=\"info\">\n<p><code class=\"code\">of_seq&nbsp;xs</code> returns a stream <code class=\"code\">ss</code>, a signal <code class=\"code\">s</code> and a future\n        <code class=\"code\">es</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "CONSECUTIVE", "CONSEQUENTLY", "ELEMENTS", "END", "EVERY", "FROM", "FUTURE", "IGNORED", "OCCUR", "OF_SEQ", "ONCE", "PRODUCE", "PRODUCED", "RETURNS", "SENT", "SEQUENCE", "SIGNAL", "SIGNALS", "SIGNIFYING", "STREAM", "THE", "TIME", "UNDERLYING", "WILL"]);
add_ocaml_element("of_array", "Bap_future.Std.Stream.of_array", "value", "'a array ->\n  'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal *\n  unit Bap_future.Std.future", "Bap_future.Std.Stream.html#VALof_array", "<div class=\"info\">\n<p><code class=\"code\">of_array&nbsp;xs</code> returns a stream <code class=\"code\">ss</code>, a signal <code class=\"code\">s</code> and a future\n        <code class=\"code\">es</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "CONSECUTIVE", "CONSEQUENTLY", "ELEMENTS", "END", "EVERY", "FROM", "FUTURE", "IGNORED", "OCCUR", "OF_ARRAY", "ONCE", "PRODUCE", "PRODUCED", "RETURNS", "SENT", "SEQUENCE", "SIGNAL", "SIGNALS", "SIGNIFYING", "STREAM", "THE", "TIME", "UNDERLYING", "WILL"]);
add_ocaml_element("of_list", "Bap_future.Std.Stream.of_list", "value", "'a list ->\n  'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal *\n  unit Bap_future.Std.future", "Bap_future.Std.Stream.html#VALof_list", "<div class=\"info\">\n<p><code class=\"code\">of_list&nbsp;xs</code> returns a stream <code class=\"code\">ss</code>, a signal <code class=\"code\">s</code> and a future\n        <code class=\"code\">es</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "CONSECUTIVE", "CONSEQUENTLY", "ELEMENTS", "END", "EVERY", "FROM", "FUTURE", "IGNORED", "OCCUR", "OF_LIST", "ONCE", "PRODUCE", "PRODUCED", "RETURNS", "SENT", "SEQUENCE", "SIGNAL", "SIGNALS", "SIGNIFYING", "STREAM", "THE", "TIME", "UNDERLYING", "WILL"]);
add_ocaml_element("repeat", "Bap_future.Std.Stream.repeat", "value", "'a -> 'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal", "Bap_future.Std.Stream.html#VALrepeat", "<div class=\"info\">\n<p><code class=\"code\">repeat&nbsp;x</code> returns a stream <code class=\"code\">xs</code> and a signal <code class=\"code\">s</code>.</p>\n\n</div>\n", ["AND", "EVERY", "PRODUCE", "REPEAT", "RETURNS", "SIGNAL", "SIGNALED", "STREAM", "TIME", "VALUE", "WILL"]);
add_ocaml_element("unfold'", "Bap_future.Std.Stream.unfold'", "value", "init:'b ->\n  f:('b -> 'a Queue.t * 'b) ->\n  'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal", "Bap_future.Std.Stream.html#VALunfold'", "<div class=\"info\">\n<p><code class=\"code\">unfold'&nbsp;~init&nbsp;~f</code> is a batched version of the <code class=\"code\">unfold</code>\n        function.</p>\n\n</div>\n", ["ASSOCIATED", "BATCHED", "EVERY", "FUNCTION", "HANDLER", "INIT", "NEW", "PRODUCED", "SIGNAL", "SIGNALED", "STREAM", "THE", "TIME", "UNFOLD", "VALUE", "VERSION", "WITH"]);
add_ocaml_element("unfold_until", "Bap_future.Std.Stream.unfold_until", "value", "init:'b ->\n  f:('b -> ('a * 'b) option) ->\n  'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal *\n  unit Bap_future.Std.future", "Bap_future.Std.Stream.html#VALunfold_until", "<div class=\"info\">\n<p><code class=\"code\">unfold_until&nbsp;~init&nbsp;~f</code> returns <code class=\"code\">(stream,signal,future)</code> is the\n        same as <code class=\"code\">unfold</code>, except that function <code class=\"code\">f</code> is called until it\n        returns a <code class=\"code\"><span class=\"constructor\">None</span></code> value.</p>\n\n</div>\n", ["BECOMES", "CALLED", "DETERMINED", "EXCEPT", "FUNCTION", "FUTURE", "HAPPENS", "INIT", "NONE", "ONCE", "RETURNS", "SAME", "SIGNAL", "STREAM", "THAT", "THE", "THIS", "UNFOLD", "UNFOLD_UNTIL", "UNTIL", "VALUE"]);
add_ocaml_element("unfold", "Bap_future.Std.Stream.unfold", "value", "init:'b ->\n  f:('b -> 'a * 'b) -> 'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal", "Bap_future.Std.Stream.html#VALunfold", "<div class=\"info\">\n<p><code class=\"code\">unfold&nbsp;~init&nbsp;~f</code> a more general than <code class=\"code\">from</code> way of building a\n        stream, that allows to pass state between consecutive\n        invocations of the generator function.</p>\n\n</div>\n", ["ALLOWS", "ASSOCIATED", "BETWEEN", "BUILDING", "CONSECUTIVE", "EVERY", "FROM", "FUNCTION", "GENERAL", "GENERATOR", "HANDLER", "INIT", "INVOCATIONS", "MORE", "NEW", "PASS", "PRODUCED", "SIGNAL", "SIGNALED", "STATE", "STREAM", "THAN", "THAT", "THE", "TIME", "UNFOLD", "VALUE", "WAY", "WITH"]);
add_ocaml_element("from", "Bap_future.Std.Stream.from", "value", "(unit -> 'a) -> 'a Bap_future.Std.Stream.t * unit Bap_future.Std.signal", "Bap_future.Std.Stream.html#VALfrom", "<div class=\"info\">\n<p><code class=\"code\">from&nbsp;f</code> returns a stream that is generated from successive\n        applications of a function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["APPLICATIONS", "ASSOCIATED", "EVERY", "FROM", "FUNCTION", "GENERATED", "HANDLER", "NEW", "PRODUCED", "RETURNS", "SIGNAL", "SIGNALED", "STREAM", "SUCCESSIVE", "THAT", "TIME", "VALUE", "WITH"]);
add_ocaml_element("create", "Bap_future.Std.Stream.create", "value", "unit -> 'a Bap_future.Std.Stream.t * 'a Bap_future.Std.signal", "Bap_future.Std.Stream.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> retuns a stream and a signal handler that is used\n        to feed the stream.</p>\n\n</div>\n", ["AND", "CREATE", "EVERY", "FEED", "HANDLER", "OCCUR", "RETUNS", "SIGNAL", "SIGNALED", "STREAM", "THAT", "THE", "TIME", "USED", "VALUE", "WILL"]);
add_ocaml_element("is_fulfilled", "Bap_future.Std.Promise.is_fulfilled", "value", "'a Bap_future.Std.Promise.t -> bool", "Bap_future.Std.Promise.html#VALis_fulfilled", "<div class=\"info\">\n<p><code class=\"code\">is_fulfilled&nbsp;promise</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if associated promise is\n        already fulfilled</p>\n\n</div>\n", ["ALREADY", "ASSOCIATED", "FULFILLED", "IS_FULFILLED", "PROMISE", "TRUE"]);
add_ocaml_element("fulfill", "Bap_future.Std.Promise.fulfill", "value", "'a Bap_future.Std.Promise.t -> 'a -> unit", "Bap_future.Std.Promise.html#VALfulfill", "<div class=\"info\">\n<p><code class=\"code\">fulfill&nbsp;promise</code> will fill a future value associated with a\n        <code class=\"code\">promise</code> and evaluate to <code class=\"code\">unit</code> if promise is not yet\n        fulfilled.</p>\n\n</div>\n", ["ACTIONS", "ALL", "AND", "ASSOCIATED", "CALLED", "CALLING", "CALLS", "CASE", "CONTEXT", "DIFFERENT", "EVALUATE", "FILL", "FROM", "FULFILL", "FULFILLED", "FULFULL", "FUNCTION", "FUTURE", "MADE", "NOT", "NOTE", "OBJECT", "ONCE", "PROMISE", "RARELY", "SAFE", "SAME", "SENSE", "SERIALIZED", "SHOULD", "SINCE", "THAT", "THE", "THREAD", "THREADS", "UNIT", "VALUE", "WILL", "WITH", "YET"]);
add_ocaml_element("peek_exn", "Bap_future.Std.peek_exn", "value", "'a Bap_future.Std.t -> 'a", "Bap_future.Std.Future.html#VALpeek_exn", "<div class=\"info\">\n<p><code class=\"code\">peek_exn&nbsp;f</code>\n        will evaluate to <code class=\"code\">x</code> iff <code class=\"code\">is_decided&nbsp;f&nbsp;<span class=\"keywordsign\">&amp;&amp;</span>&nbsp;peek&nbsp;f&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Some</span>&nbsp;x</code></p>\n\n</div>\n", ["EVALUATE", "IFF", "IS_DECIDED", "PEEK", "PEEK_EXN", "SOME", "WILL"]);
add_ocaml_element("peek", "Bap_future.Std.peek", "value", "'a Bap_future.Std.t -> 'a option", "Bap_future.Std.Future.html#VALpeek", "<div class=\"info\">\n<p><code class=\"code\">peek&nbsp;f</code> will return <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;value</code> if future <code class=\"code\">f</code> has already\n        occurred with this <code class=\"code\">value</code>.</p>\n\n</div>\n", ["ALREADY", "FUTURE", "HAS", "OCCURRED", "PEEK", "RETURN", "SOME", "THIS", "VALUE", "WILL", "WITH"]);
add_ocaml_element("is_decided", "Bap_future.Std.is_decided", "value", "'a Bap_future.Std.t -> bool", "Bap_future.Std.Future.html#VALis_decided", "<div class=\"info\">\n<p><code class=\"code\">is_decided&nbsp;f</code> is true if a future <code class=\"code\">f</code> is already decided.</p>\n\n</div>\n", ["ALREADY", "DECIDED", "FUTURE", "IS_DECIDED", "TRUE"]);
add_ocaml_element("upon", "Bap_future.Std.upon", "value", "'a Bap_future.Std.t -> ('a -> unit) -> unit", "Bap_future.Std.Future.html#VALupon", "<div class=\"info\">\n<p><code class=\"code\">upon&nbsp;f&nbsp;action</code> will call <code class=\"code\">action</code> as soon a future <code class=\"code\">f</code> occurs.</p>\n\n</div>\n", ["ACTION", "CALL", "FUTURE", "OCCURS", "SOON", "UPON", "WILL"]);
add_ocaml_element("create", "Bap_future.Std.create", "value", "unit -> 'a Bap_future.Std.t * 'a Bap_future.Std.promise", "Bap_future.Std.Future.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates a new future.</p>\n\n</div>\n", ["AND", "CAN", "CREATE", "CREATES", "FULFILL", "FUNCTION", "FUTURE", "ITSELF", "NEW", "PAIR", "PROMISE", "RETURNS", "THAT", "THE", "USED"]);
add_ocaml_element("apply", "Bap_future.Std.Variadic.S.apply", "value", "f:'f ->\n  ('f, 'r) Bap_future.Std.Variadic.S.t -> 'r Bap_future.Std.Variadic.S.arg", "Bap_future.Std.Variadic.S.html#VALapply", "<div class=\"info\">\n<p><code class=\"code\">apply&nbsp;args&nbsp;~f</code> applies function <code class=\"code\">f</code> to arguments <code class=\"code\">args</code>.</p>\n\n</div>\n", ["APPLIES", "APPLY", "ARGS", "ARGUMENTS", "FUNCTION"]);
add_ocaml_element("($)", "Bap_future.Std.Variadic.S.($)", "value", "('a, 'b -> 'c) Bap_future.Std.Variadic.S.t ->\n  'b Bap_future.Std.Variadic.S.arg -> ('a, 'c) Bap_future.Std.Variadic.S.t", "Bap_future.Std.Variadic.S.html#VAL($)", "<div class=\"info\">\n<p><code class=\"code\">args&nbsp;$x</code> appends argument <code class=\"code\">x</code> to a list of arguments <code class=\"code\">args</code>.</p>\n\n</div>\n", ["APPENDS", "ARGS", "ARGUMENT", "ARGUMENTS", "LIST"]);
add_ocaml_element("args", "Bap_future.Std.Variadic.S.args", "value", "'a Bap_future.Std.Variadic.S.arg ->\n  ('a -> 'b, 'b) Bap_future.Std.Variadic.S.t", "Bap_future.Std.Variadic.S.html#VALargs", "<div class=\"info\">\n<p><code class=\"code\">args&nbsp;x</code> creates a singleton list of arguments that can be\n          applied to a function that takes <code class=\"code\">x</code> argument, and returns a value\n          of type <code class=\"code\"><span class=\"keywordsign\">'</span>b</code>.</p>\n\n</div>\n", ["AND", "APPLIED", "ARGS", "ARGUMENT", "ARGUMENTS", "CAN", "CREATES", "FUNCTION", "LIST", "RETURNS", "SINGLETON", "TAKES", "THAT", "TYPE", "VALUE"]);
add_ocaml_element("apply", "Bap_future.Std.Applicable.S.apply", "value", "('a -> 'b) Bap_future.Std.Applicable.S.t ->\n  'a Bap_future.Std.Applicable.S.t -> 'b Bap_future.Std.Applicable.S.t", "Bap_future.Std.Applicable.S.html#VALapply", "<div class=\"info\">\n<p><code class=\"code\">apply&nbsp;fs&nbsp;xs</code> apply functions <code class=\"code\">fs</code> to <code class=\"code\">xs</code></p>\n\n</div>\n", ["APPLY", "FUNCTIONS"]);
add_ocaml_element("map", "Bap_future.Std.Applicable.S.map", "value", "'a Bap_future.Std.Applicable.S.t ->\n  f:('a -> 'b) -> 'b Bap_future.Std.Applicable.S.t", "Bap_future.Std.Applicable.S.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;xs&nbsp;~f</code> transform <code class=\"code\">xs</code> with <code class=\"code\">f</code></p>\n\n</div>\n", ["MAP", "TRANSFORM", "WITH"]);
add_ocaml_element("run", "Ogre.S.run", "value", "'a t -> Ogre.doc -> ('a * Ogre.doc) Or_error.t m", "Ogre.S.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;op&nbsp;doc</code> runs an operation <code class=\"code\">op</code> that does some inference as\n      well as may update the document.</p>\n\n</div>\n", ["AND", "BAD", "CONSISTENCY", "DOC", "DOCUMENT", "DOES", "FOR", "FUNCTION", "GENERIC", "IDEA", "INFERENCE", "INTERFACE", "MAY", "MONAD", "NOTION", "OPERATION", "PART", "PROVIDED", "RUN", "RUNS", "SOME", "STATE", "STYLE", "THAT", "THE", "THIS", "UPDATE", "USE", "USUAL", "USUALLY", "WELL"]);
add_ocaml_element("exec", "Ogre.S.exec", "value", "'a t -> Ogre.doc -> Ogre.doc Or_error.t m", "Ogre.S.html#VALexec", "<div class=\"info\">\n<p><code class=\"code\">exec&nbsp;op&nbsp;doc</code> executes an operation <code class=\"code\">op</code> that, presumabely,\n      updates the document <code class=\"code\">doc</code>, returns an updated version.</p>\n\n</div>\n", ["DOC", "DOCUMENT", "EXEC", "EXECUTES", "OPERATION", "PRESUMABELY", "RETURNS", "THAT", "THE", "UPDATED", "UPDATES", "VERSION"]);
add_ocaml_element("eval", "Ogre.S.eval", "value", "'a t -> Ogre.doc -> 'a Or_error.t m", "Ogre.S.html#VALeval", "<div class=\"info\">\n<p><code class=\"code\">eval&nbsp;property&nbsp;document</code> makes an inference of a <code class=\"code\">property</code> based\n      on facts stored in a <code class=\"code\">document</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "BASED", "CAN", "DEFINED", "DOCUMENT", "EMPTY", "ERRORS", "EVAL", "EVALUATE", "EXAMPLE", "FACTS", "FLOAT", "FOR", "FOREACH", "FROM", "FUN", "GET", "GIVEN", "GPA", "GREATER", "HAVE", "INFERENCE", "INFERRED", "LET", "MAKES", "NAME", "NAMES_OF_BEST_STUDENTS", "OCCURED", "POSSIBLY", "PROPERTY", "QUERY", "REQUIREMENTS", "RESULT", "RETURN", "SATISFIED", "SCORE", "SELECT", "SEQUENCE", "STORED", "STUDENT", "STUDENTS", "THAN", "THAT", "THE", "THIS", "WHERE", "WITH"]);
add_ocaml_element("failf", "Ogre.S.failf", "value", "('a, Stdlib.Format.formatter, unit, unit -> 'b t) format4 -> 'a", "Ogre.S.html#VALfailf", "<div class=\"info\">\n<p><code class=\"code\">failf&nbsp;fmt&nbsp;args...&nbsp;()</code> constructs an error based on the\n      specified format <code class=\"code\">fmt</code> and arguments, terminated by the unit value\n      <code class=\"code\">()</code>.</p>\n\n</div>\n", ["AND", "ARGS", "ARGUMENT", "ARGUMENTS", "BASED", "CONSTRUCTS", "CORRESPONDING", "DON", "ERROR", "EXAMPLE", "EXTRA", "FAILF", "FAILWITHF", "FILE", "FMT", "FOR", "FORGET", "FORMAT", "FUNCTION", "INVALID_ARGF", "NAME", "NEEDED", "NOTE", "REASON", "SEE", "SEQUENCE", "SPECIFIED", "TERMINATE", "TERMINATED", "THE", "THIS", "TYPE", "UNIT", "UNSUPPORTED", "VALUE", "WHY", "WITH"]);
add_ocaml_element("fail", "Ogre.S.fail", "value", "Error.t -> 'a t", "Ogre.S.html#VALfail", "<div class=\"info\">\n<p><code class=\"code\">fail&nbsp;error</code> aborts an inference process with the specified\n      <code class=\"code\">error</code>.</p>\n\n</div>\n", ["ABORTS", "ERROR", "FAIL", "INFERENCE", "PROCESS", "SPECIFIED", "THE", "WITH"]);
add_ocaml_element("provide", "Ogre.S.provide", "value", "('b, 'a -> unit t) Ogre.attribute -> 'a", "Ogre.S.html#VALprovide", "<div class=\"info\">\n<p><code class=\"code\">provide&nbsp;attr&nbsp;v1&nbsp;v2&nbsp;...&nbsp;vm</code> stores the constituents of an\n      attribute value in the document.</p>\n\n</div>\n", ["ALSO", "AND", "ARGUMENT", "ARITY", "ATTR", "ATTRIBUTE", "BUT", "CAPTURES", "CONSTITUENTS", "DEFINES", "DOCUMENT", "ENCODES", "FIELDS", "FIRST", "FORMAT", "FUNCTION", "FUNCTIONS", "ITSELF", "LIKE", "NOT", "ONLY", "ORDER", "PRINTF", "PROVIDE", "REPRESENTATION", "SAME", "SENSE", "STORES", "THAT", "THE", "THUS", "TYPE", "USED", "VALUE", "VARIADIC", "WHERE"]);
add_ocaml_element("collect", "Ogre.S.collect", "value", "(('a -> 'a) -> 'b) Ogre.query -> 'b Ogre.seq t", "Ogre.S.html#VALcollect", "<div class=\"info\">\n<p><code class=\"code\">collect&nbsp;query</code> is the same as <code class=\"code\">foreach&nbsp;query&nbsp;~f:ident</code></p>\n\n</div>\n", ["COLLECT", "FOREACH", "IDENT", "QUERY", "SAME", "THE"]);
add_ocaml_element("foreach", "Ogre.S.foreach", "value", "('a -> 'b) Ogre.query -> f:'a -> 'b Ogre.seq t", "Ogre.S.html#VALforeach", "<div class=\"info\">\n<p><code class=\"code\">foreach&nbsp;query&nbsp;~f:action</code> applies an <code class=\"code\">action</code> for each value of\n      an attributes specified in the query.</p>\n\n</div>\n", ["ABOUT", "ACTION", "AND", "APPLIES", "ARE", "ATTRIBUTES", "BEGIN", "BETTER_THAN_AVERAGE_STUDENTS", "BUILT", "CLASSID", "CLAUSE", "CLAUSES", "DOCUMENTATION", "DOMAIN", "EACH", "EDSL", "EMBEDDED", "ENCODES", "END", "ENUMERATED", "FIELD", "FLOAT", "FOR", "FOREACH", "FORM", "FORMED", "FROM", "FUN", "FUNCTION", "GPA", "HAS", "INFORMATION", "INTO", "JOIN", "LANGUAGE", "LET", "MODULE", "MORE", "OCAML", "ORDER", "PARTICULAR", "QUERY", "RETURN", "SEE", "SELECT", "SIMILIAR", "SPECIFIC", "SPECIFIED", "SQL", "STUDENTS", "TEACHER", "TEACHERS", "THAT", "THE", "THIS", "TILL", "TYPE", "TYPES", "USING", "VALUE", "VERY", "WELL", "WHERE"]);
add_ocaml_element("request", "Ogre.S.request", "value", "?that:('a -> bool) -> ('a, 'b -> 'c) Ogre.attribute -> 'a option t", "Ogre.S.html#VALrequest", "<div class=\"info\">\n<p><code class=\"code\">request&nbsp;a&nbsp;~that:p</code> request no more than one value of an\n      attribute <code class=\"code\">a</code>, that satisfies a predicate <code class=\"code\">p</code>.</p>\n\n</div>\n", ["ARE", "ATTRIBUTE", "ERROR", "MORE", "ONE", "OPTION", "PREDICATE", "REQUEST", "RETURNED", "SATISFIES", "SATISFYING", "THAN", "THAT", "THE", "THEN", "THERE", "VALUE", "WRAPPED"]);
add_ocaml_element("require", "Ogre.S.require", "value", "?that:('a -> bool) -> ('a, 'b -> 'c) Ogre.attribute -> 'a t", "Ogre.S.html#VALrequire", "<div class=\"info\">\n<p><code class=\"code\">require&nbsp;a&nbsp;~that:p</code> requires that an attribute <code class=\"code\">a</code> has one and\n      only one value that satisfies a predicate <code class=\"code\">p</code>.</p>\n\n</div>\n", ["AND", "ARE", "ATTRIBUTE", "ERROR", "HAS", "MORE", "ONE", "ONLY", "PREDICATE", "REQUIRE", "REQUIRES", "SATISFIES", "SUCH", "THAN", "THAT", "THERE", "VALUE", "VALUES"]);
add_ocaml_element("definitions", "Ogre.Doc.definitions", "value", "Ogre.doc -> int", "Ogre.Doc.html#VALdefinitions", "<div class=\"info\">\n<p><code class=\"code\">definitions&nbsp;doc</code> returns a number of facts, defined in the\n      document.</p>\n\n</div>\n", ["DEFINED", "DEFINITIONS", "DOC", "DOCUMENT", "FACTS", "NUMBER", "RETURNS", "THE"]);
add_ocaml_element("declarations", "Ogre.Doc.declarations", "value", "Ogre.doc -> int", "Ogre.Doc.html#VALdeclarations", "<div class=\"info\">\n<p><code class=\"code\">declarations&nbsp;doc</code> returns a number of declarations in the\n      document</p>\n\n</div>\n", ["DECLARATIONS", "DOC", "DOCUMENT", "NUMBER", "RETURNS", "THE"]);
add_ocaml_element("clear", "Ogre.Doc.clear", "value", "Ogre.doc -> Ogre.doc", "Ogre.Doc.html#VALclear", "<div class=\"info\">\n<p><code class=\"code\">clear&nbsp;doc</code> removes all facts from the document.</p>\n\n</div>\n", ["ALL", "CLEAR", "DOC", "DOCUMENT", "EXTRACTING", "FACTS", "FOR", "FROM", "REMOVES", "SCHEME", "THE", "USEFUL"]);
add_ocaml_element("pp", "Ogre.Doc.pp", "value", "Stdlib.Format.formatter -> Ogre.doc -> unit", "Ogre.Doc.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;ppf&nbsp;doc</code> prints a <code class=\"code\">doc</code> in the specified formatter <code class=\"code\">ppf</code></p>\n\n</div>\n", ["DOC", "FORMATTER", "PPF", "PRINTS", "SPECIFIED", "THE"]);
add_ocaml_element("to_file", "Ogre.Doc.to_file", "value", "Ogre.doc -> string -> unit", "Ogre.Doc.html#VALto_file", "<div class=\"info\">\n<p><code class=\"code\">to_file&nbsp;doc&nbsp;name</code> stores a document to a file with the given name.</p>\n\n</div>\n", ["DOC", "DOCUMENT", "FILE", "GIVEN", "NAME", "STORES", "THE", "TO_FILE", "WITH"]);
add_ocaml_element("to_string", "Ogre.Doc.to_string", "value", "Ogre.doc -> string", "Ogre.Doc.html#VALto_string", "<div class=\"info\">\n<p><code class=\"code\">to_string&nbsp;doc</code> returns a textual representation of a document</p>\n\n</div>\n", ["DOC", "DOCUMENT", "REPRESENTATION", "RETURNS", "TEXTUAL", "TO_STRING"]);
add_ocaml_element("from_string", "Ogre.Doc.from_string", "value", "string -> Ogre.doc Or_error.t", "Ogre.Doc.html#VALfrom_string", "<div class=\"info\">\n<p><code class=\"code\">from_string&nbsp;data</code> parses document from <code class=\"code\">data</code>.</p>\n\n</div>\n", ["DATA", "DOCUMENT", "ERROR", "FORMED", "FROM", "FROM_STRING", "NOT", "PARSES", "RETURNS", "WELL"]);
add_ocaml_element("from_file", "Ogre.Doc.from_file", "value", "string -> Ogre.doc Or_error.t", "Ogre.Doc.html#VALfrom_file", "<div class=\"info\">\n<p><code class=\"code\">from_file&nbsp;name</code> reads a document from a file with the given\n      <code class=\"code\">name</code>, returns an error, if a document is not well-formed, raises\n      an exception if a system error has occured.</p>\n\n</div>\n", ["DOCUMENT", "ERROR", "EXCEPTION", "FILE", "FORMED", "FROM", "FROM_FILE", "GIVEN", "HAS", "NAME", "NOT", "OCCURED", "RAISES", "READS", "RETURNS", "SYSTEM", "THE", "WELL", "WITH"]);
add_ocaml_element("save", "Ogre.Doc.save", "value", "Ogre.doc -> Out_channel.t -> unit", "Ogre.Doc.html#VALsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;doc&nbsp;out</code> stores the document in a channel.</p>\n\n</div>\n", ["CASE", "CHANNEL", "DOC", "DOCUMENT", "ERROR", "EXCEPTION", "OUT", "RAISES", "SAVE", "STORES", "SYSTEM", "THE"]);
add_ocaml_element("load", "Ogre.Doc.load", "value", "In_channel.t -> Ogre.doc Or_error.t", "Ogre.Doc.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;chan</code> loads a document from a channel, returns an error if\n      a document is not well-formed, raises an exception if a system error\n      has occured.</p>\n\n</div>\n", ["CHAN", "CHANNEL", "DOCUMENT", "ERROR", "EXCEPTION", "FORMED", "FROM", "HAS", "LOAD", "LOADS", "NOT", "OCCURED", "RAISES", "RETURNS", "SYSTEM", "WELL"]);
add_ocaml_element("merge", "Ogre.Doc.merge", "value", "Ogre.doc -> Ogre.doc -> Ogre.doc Or_error.t", "Ogre.Doc.html#VALmerge", "<div class=\"info\">\n<p><code class=\"code\">merge&nbsp;d1&nbsp;d2</code> merges two documents in one.</p>\n\n</div>\n", ["CONTAIN", "DECLARATIONS", "DOCUMENTS", "ERROR", "INCONSISTENT", "MERGE", "MERGES", "ONE", "RETURNS", "TWO"]);
add_ocaml_element("empty", "Ogre.Doc.empty", "value", "Ogre.doc", "Ogre.Doc.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty</code> creates an empty document</p>\n\n</div>\n", ["CREATES", "DOCUMENT", "EMPTY"]);
add_ocaml_element("get", "Ogre.Query.String.get", "value", "'a Ogre.field -> int -> Ogre.Query.exp", "Ogre.Query.String.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">filed.(n)</code> creates a field variable that ranges over values\n        of <code class=\"code\">field</code> that belongs to the n'th attribute of a selection.</p>\n\n</div>\n", ["ATTRIBUTE", "BELONGS", "CREATES", "FIELD", "FILED", "OVER", "RANGES", "SELECTION", "THAT", "THE", "VALUES", "VARIABLE"]);
add_ocaml_element("get", "Ogre.Query.Array.get", "value", "('a, 'b -> 'c) Ogre.attribute -> 'd Ogre.field -> Ogre.Query.exp", "Ogre.Query.Array.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">attr.(field)</code> creates a field variable that ranges over\n        values of <code class=\"code\">field</code> that belongs to the attribute <code class=\"code\">attr</code>.</p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "BELONGS", "CREATES", "DESCRIPTION", "DON", "FIELD", "HOW", "MODULE", "OVER", "RANGES", "SEE", "THAT", "THE", "UNDERSTAND", "VALUES", "VARIABLE", "WORKS", "YOU"]);
add_ocaml_element("(-)", "Ogre.Query.(-)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(-)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;-&nbsp;y</code> subtracting</p>\n\n</div>\n", ["SUBTRACTING"]);
add_ocaml_element("(+)", "Ogre.Query.(+)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(+)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;+&nbsp;y</code> summation</p>\n\n</div>\n", ["SUMMATION"]);
add_ocaml_element("(>=)", "Ogre.Query.(>=)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(>=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&gt;=&nbsp;y</code> greater or equal</p>\n\n</div>\n", ["EQUAL", "GREATER"]);
add_ocaml_element("(<=)", "Ogre.Query.(<=)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(<=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;=&nbsp;y</code> less than or equal</p>\n\n</div>\n", ["EQUAL", "LESS", "THAN"]);
add_ocaml_element("(<>)", "Ogre.Query.(<>)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(<>)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;&gt;&nbsp;y</code> nonequality</p>\n\n</div>\n", ["NONEQUALITY"]);
add_ocaml_element("(=)", "Ogre.Query.(=)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;=&nbsp;y</code> equality</p>\n\n</div>\n", ["EQUALITY"]);
add_ocaml_element("(>)", "Ogre.Query.(>)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(>)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&gt;&nbsp;y</code> greater than</p>\n\n</div>\n", ["GREATER", "THAN"]);
add_ocaml_element("(<)", "Ogre.Query.(<)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(<)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;&nbsp;y</code> less than</p>\n\n</div>\n", ["LESS", "THAN"]);
add_ocaml_element("not", "Ogre.Query.not", "value", "Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VALnot", "<div class=\"info\">\n<p><code class=\"code\">not&nbsp;x</code> logical negation.</p>\n\n</div>\n", ["LOGICAL", "NEGATION", "NOT"]);
add_ocaml_element("(==>)", "Ogre.Query.(==>)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(==>)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;==&gt;&nbsp;y</code> implication.</p>\n\n</div>\n", ["ALWAYS", "AWARE", "CODE", "COMMON", "EVEN", "EXPRESSION", "HAS", "HIGHER", "IMPLICATION", "ISSUE", "KNOWN", "MATHEMATICS", "MEANS", "MISTAKE", "NOT", "OCAML", "OPERATOR", "PARENTHESIS", "PARSED", "PRECEDENCE", "PUT", "READER", "RULE", "THAN", "THAT", "THE", "THIS", "THUMB", "WERE", "WHETHER", "WROTE", "YOU", "YOUR"]);
add_ocaml_element("(||)", "Ogre.Query.(||)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(||)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keywordsign\">||</span>&nbsp;y</code> disjunction</p>\n\n</div>\n", ["DISJUNCTION"]);
add_ocaml_element("(&&)", "Ogre.Query.(&&)", "value", "Ogre.Query.exp -> Ogre.Query.exp -> Ogre.Query.exp", "Ogre.Query.html#VAL(&&)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keywordsign\">&amp;&amp;</span>&nbsp;y</code> conjunction</p>\n\n</div>\n", ["CONJUNCTION"]);
add_ocaml_element("float", "Ogre.Query.float", "value", "float -> Ogre.Query.exp", "Ogre.Query.html#VALfloat", "<div class=\"info\">\n<p><code class=\"code\">float&nbsp;x</code> creates a real number constant.</p>\n\n</div>\n", ["CONSTANT", "CREATES", "FLOAT", "NUMBER", "REAL"]);
add_ocaml_element("bool", "Ogre.Query.bool", "value", "bool -> Ogre.Query.exp", "Ogre.Query.html#VALbool", "<div class=\"info\">\n<p><code class=\"code\">bool&nbsp;x</code> creates a logic constant</p>\n\n</div>\n", ["BOOL", "CONSTANT", "CREATES", "LOGIC"]);
add_ocaml_element("int", "Ogre.Query.int", "value", "int64 -> Ogre.Query.exp", "Ogre.Query.html#VALint", "<div class=\"info\">\n<p><code class=\"code\">int&nbsp;x</code> creates an integer constant</p>\n\n</div>\n", ["CONSTANT", "CREATES", "INT", "INTEGER"]);
add_ocaml_element("str", "Ogre.Query.str", "value", "string -> Ogre.Query.exp", "Ogre.Query.html#VALstr", "<div class=\"info\">\n<p><code class=\"code\">str&nbsp;x</code> creates a string constant.</p>\n\n</div>\n", ["CONSTANT", "CREATES", "STR", "STRING"]);
add_ocaml_element("field", "Ogre.Query.field", "value", "?from:('a, 'b -> 'c) Ogre.attribute -> 'd Ogre.field -> Ogre.Query.join", "Ogre.Query.html#VALfield", "<div class=\"info\">\n<p><code class=\"code\">field&nbsp;name</code> creates an unqualified join variable.</p>\n\n</div>\n", ["AND", "ATTR", "CREATES", "DESCRIPTION", "EXPLANATION", "EXPRESSIONS", "FIELD", "FOR", "FROM", "JOIN", "JOINING", "NAME", "OGRE", "QUALIFIED", "QUERY", "SEE", "THE", "TYPE", "UNQUALIFIED", "VARIABLE"]);
add_ocaml_element("($)", "Ogre.Query.($)", "value", "('a -> 'b -> 'r) Ogre.Query.tables ->\n  ('b, 'c -> 'd) Ogre.attribute -> ('a -> 'r) Ogre.Query.tables", "Ogre.Query.html#VAL($)", "<div class=\"info\">\n<p><code class=\"code\">attrs&nbsp;$&nbsp;attr</code> appends an attribute <code class=\"code\">attr</code> to the sequence of\n      chosen attributes <code class=\"code\">attrs</code>.</p>\n\n</div>\n", ["APPENDS", "ATTR", "ATTRIBUTE", "ATTRIBUTES", "ATTRS", "CHOSEN", "SEQUENCE", "THE"]);
add_ocaml_element("from", "Ogre.Query.from", "value", "('a, 'b -> 'c) Ogre.attribute -> (('a -> 'r) -> 'r) Ogre.Query.tables", "Ogre.Query.html#VALfrom", "<div class=\"info\">\n<p><code class=\"code\">from&nbsp;attr</code> adds an attribute <code class=\"code\">attr</code> to the query.</p>\n\n</div>\n", ["ADDS", "ATTR", "ATTRIBUTE", "CAN", "CLAUSE", "FORMED", "FROM", "NOT", "OCCURS", "OTHERWISE", "QUERY", "REFERENCED", "THE", "WELL"]);
add_ocaml_element("select", "Ogre.Query.select", "value", "?where:Ogre.Query.exp ->\n  ?join:Ogre.Query.join list list -> 'a Ogre.Query.tables -> 'a Ogre.Query.t", "Ogre.Query.html#VALselect", "<div class=\"info\">\n<p><code class=\"code\">select&nbsp;~where&nbsp;~join&nbsp;(from&nbsp;t1&nbsp;t2&nbsp;...&nbsp;tm)</code> selects attributes\n      <code class=\"code\">t1</code>, <code class=\"code\">t2</code>, ..., <code class=\"code\">tm</code>, join them by the fields specified in the\n      <code class=\"code\">join</code> clause, and filters those that satisfy the condition\n      defined with the <code class=\"code\">where</code> clause.</p>\n\n</div>\n", ["ALL", "AND", "ASSUMING", "ATTRIBUTES", "BUT", "CAN", "CLAUSE", "COLUMNS", "COMMAND", "COMPLETE", "COMPOSABLE", "CONDITION", "CONSTRUCTOR", "CORRESPONDANCE", "CORRESPONDING", "DEFINED", "EXAMPLES", "FIELD", "FIELDS", "FILTERS", "FLOAT", "FOLLOWING", "FOR", "FOREACH", "FOREIGN", "FROM", "FUN", "GPA", "GREATER", "HAS", "HAVE", "INDIVIDUALLY", "JOIN", "KEY", "LACKS", "LONG", "MAY", "NAME", "NEARLY", "NEEDED", "NOT", "NOTICE", "PASSED", "POSSIBLE", "QUERY", "RATE", "REASON", "RETURN", "SAFE", "SATISFY", "SELECT", "SELECTS", "SOME", "SPECIFIED", "SPECIFY", "SQL", "STUDENT", "STUDENTS", "TABLE", "TEACHER", "TEACHERS", "THAN", "THAT", "THE", "THEIR", "THEM", "THIS", "THOSE", "THREE", "TIMES", "TYPE", "USED", "VALUE", "WHAT", "WHERE", "WITH", "WORK", "YOU"]);
add_ocaml_element("(%:)", "Ogre.Type.(%:)", "value", "string -> 'a Ogre.Type.t -> 'a Ogre.field", "Ogre.Type.html#VAL(%:)", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;:&nbsp;t</code> is the same as <code class=\"code\">def&nbsp;name&nbsp;t</code></p>\n\n</div>\n", ["DEF", "NAME", "SAME", "THE"]);
add_ocaml_element("def", "Ogre.Type.def", "value", "string -> 'a Ogre.Type.t -> 'a Ogre.field", "Ogre.Type.html#VALdef", "<div class=\"info\">\n<p><code class=\"code\">def&nbsp;name&nbsp;t</code> defines a field with the give <code class=\"code\">name</code> and type <code class=\"code\">t</code>.</p>\n\n</div>\n", ["AND", "DEF", "DEFINES", "FIELD", "GIVE", "NAME", "THE", "TYPE", "WITH"]);
add_ocaml_element("($)", "Ogre.Type.($)", "value", "('a -> 'b -> 'r, 'd -> 'b -> 'p) Ogre.scheme ->\n  'b Ogre.field -> ('a -> 'r, 'd -> 'p) Ogre.scheme", "Ogre.Type.html#VAL($)", "<div class=\"info\">\n<p><code class=\"code\">scm&nbsp;$field</code> adds a <code class=\"code\">field</code> to a scheme <code class=\"code\">scm</code>.</p>\n\n</div>\n", ["ADDS", "AGE", "ALL", "AND", "ARE", "ASSUMING", "ATTACHED", "ATTRIBUTE", "BELOW", "CALL", "COMBINED", "CONSTRUCT", "CORRESPONDINGLY", "EXAMPLE", "EXPRESSION", "FIELD", "FIELDS", "FOR", "FUNCTION", "HAD", "HAVE", "INT", "INT64", "NAME", "ONE", "REPRESENTED", "RESULTING", "SALARY", "SCHEME", "SCM", "SEE", "STARTING", "STRING", "THAT", "THE", "THEN", "TYPE", "USED", "USUALLY", "WILL", "WITH", "WOULD"]);
add_ocaml_element("scheme", "Ogre.Type.scheme", "value", "'a Ogre.field -> (('a -> 'r) -> 'r, ('a -> 'p) -> 'p) Ogre.scheme", "Ogre.Type.html#VALscheme", "<div class=\"info\">\n<p><code class=\"code\">scheme&nbsp;field</code> defines a scheme with one field.</p>\n\n</div>\n", ["DEFINES", "FIELD", "ONE", "SCHEME", "WITH"]);
add_ocaml_element("float", "Ogre.Type.float", "value", "float Ogre.Type.t", "Ogre.Type.html#VALfloat", "", []);
add_ocaml_element("str", "Ogre.Type.str", "value", "string Ogre.Type.t", "Ogre.Type.html#VALstr", "<div class=\"info\">\n<p><code class=\"code\">str</code> represented by a sequence of characters.</p>\n\n</div>\n", ["ARE", "BACKEND", "BOTHERED", "CHARACTERS", "CONTAINS", "DATABASE", "DELIMITED", "FOR", "IMPLEMENTATIONS", "LIBRARY", "NOTE", "PARENTHESIS", "QUOTES", "REPRESENTATION", "REPRESENTED", "REQUIREMENTS", "SEQUENCE", "SHOULD", "SHOULDN", "STR", "THE", "THEN", "USER", "WHITESPACES", "WITH"]);
add_ocaml_element("bool", "Ogre.Type.bool", "value", "bool Ogre.Type.t", "Ogre.Type.html#VALbool", "<div class=\"info\">\n<p><code class=\"code\">bool</code> is either <code class=\"code\"><span class=\"keyword\">true</span></code> or <code class=\"code\"><span class=\"keyword\">false</span></code>.</p>\n\n</div>\n", ["BOOL", "EITHER", "FALSE", "TRUE"]);
add_ocaml_element("int", "Ogre.Type.int", "value", "int64 Ogre.Type.t", "Ogre.Type.html#VALint", "<div class=\"info\">\n<p><code class=\"code\">int</code> is represented with OCaml's int64, and has a\n      corresponding representation</p>\n\n</div>\n", ["AND", "CORRESPONDING", "HAS", "INT", "INT64", "OCAML", "REPRESENTATION", "REPRESENTED", "WITH"]);
add_ocaml_element("declare", "Ogre.declare", "value", "name:string ->\n  ('f -> 'a, 'b -> 'c) Ogre.scheme -> 'f -> ('a, 'b -> 'c) Ogre.typeinfo", "Ogre.html#VALdeclare", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keyword\">let</span>&nbsp;attr&nbsp;()&nbsp;=&nbsp;declare&nbsp;~name&nbsp;scheme</code> declares an attribute named\n    with <code class=\"code\">name</code>, and having a type described by the <code class=\"code\">scheme</code>.</p>\n\n</div>\n", ["AND", "ATTR", "ATTRIBUTE", "DECLARE", "DECLARES", "DEFINED", "DESCRIBED", "DUE", "EACH", "FUNCTION", "HAVING", "LET", "NAME", "NAMED", "RESTRICTION", "SCHEME", "SHOULD", "THE", "THUNK", "TYPE", "VALUE", "WITH"]);
add_ocaml_element("bind", "Std.Monad.Minimal2.bind", "value", "('a, 'e) Std.Monad.Minimal2.t ->\n  ('a -> ('b, 'e) Std.Monad.Minimal2.t) ->\n  ('b, 'e) Std.Monad.Minimal2.t", "Monads.Std.Monad.Minimal2.html#VALbind", "", []);
add_ocaml_element("return", "Std.Monad.Minimal2.return", "value", "'a -> ('a, 'e) Std.Monad.Minimal2.t", "Monads.Std.Monad.Minimal2.html#VALreturn", "", []);
add_ocaml_element("bind", "Std.Monad.Minimal.bind", "value", "'a Std.Monad.Minimal.t ->\n  ('a -> 'b Std.Monad.Minimal.t) -> 'b Std.Monad.Minimal.t", "Monads.Std.Monad.Minimal.html#VALbind", "", []);
add_ocaml_element("return", "Std.Monad.Minimal.return", "value", "'a -> 'a Std.Monad.Minimal.t", "Monads.Std.Monad.Minimal.html#VALreturn", "", []);
add_ocaml_element("return", "Std.Monad.Basic2.return", "value", "'a -> ('a, 'b) Std.Monad.Basic2.t", "Monads.Std.Monad.Basic2.html#VALreturn", "<div class=\"info\">\n<p><code class=\"code\">return&nbsp;x</code> creates a trivial compuation that results in <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUATION", "CREATES", "RESULTS", "RETURN", "THAT", "TRIVIAL"]);
add_ocaml_element("map", "Std.Monad.Basic2.map", "value", "[ `Custom of\n      ('a, 'e) Std.Monad.Basic2.t ->\n      f:('a -> 'b) -> ('b, 'e) Std.Monad.Basic2.t\n  | `Define_using_bind ]", "Monads.Std.Monad.Basic2.html#VALmap", "<div class=\"info\">\n<p>map function can be derived from bind or provided explicitly</p>\n\n</div>\n", ["BIND", "CAN", "DERIVED", "EXPLICITLY", "FROM", "FUNCTION", "MAP", "PROVIDED"]);
add_ocaml_element("bind", "Std.Monad.Basic2.bind", "value", "('a, 'e) Std.Monad.Basic2.t ->\n  ('a -> ('b, 'e) Std.Monad.Basic2.t) ->\n  ('b, 'e) Std.Monad.Basic2.t", "Monads.Std.Monad.Basic2.html#VALbind", "<div class=\"info\">\n<p><code class=\"code\">bind&nbsp;m&nbsp;f</code> passes the result of computation <code class=\"code\">m</code> to function <code class=\"code\">f</code></p>\n\n</div>\n", ["BIND", "COMPUTATION", "FUNCTION", "PASSES", "RESULT", "THE"]);
add_ocaml_element("map", "Std.Monad.Basic.map", "value", "[ `Custom of\n      'a Std.Monad.Basic.t ->\n      f:('a -> 'b) -> 'b Std.Monad.Basic.t\n  | `Define_using_bind ]", "Monads.Std.Monad.Basic.html#VALmap", "<div class=\"info\">\n<p>map function can be derived from bind or provided explicitly</p>\n\n</div>\n", ["BIND", "CAN", "DERIVED", "EXPLICITLY", "FROM", "FUNCTION", "MAP", "PROVIDED"]);
add_ocaml_element("return", "Std.Monad.Basic.return", "value", "'a -> 'a Std.Monad.Basic.t", "Monads.Std.Monad.Basic.html#VALreturn", "<div class=\"info\">\n<p><code class=\"code\">return&nbsp;x</code> creates a trivial compuation that results in <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUATION", "CREATES", "RESULTS", "RETURN", "THAT", "TRIVIAL"]);
add_ocaml_element("bind", "Std.Monad.Basic.bind", "value", "'a Std.Monad.Basic.t ->\n  ('a -> 'b Std.Monad.Basic.t) -> 'b Std.Monad.Basic.t", "Monads.Std.Monad.Basic.html#VALbind", "<div class=\"info\">\n<p><code class=\"code\">bind&nbsp;m&nbsp;f</code> passes the result of computation <code class=\"code\">m</code> to function <code class=\"code\">f</code></p>\n\n</div>\n", ["BIND", "COMPUTATION", "FUNCTION", "PASSES", "RESULT", "THE"]);
add_ocaml_element("call", "Std.Monad.Cont.S2.call", "value", "f:(cc:('a -> ('b, 'e) t) -> ('a, 'e) t) -> ('a, 'e) t", "Monads.Std.Monad.Cont.S2.html#VALcall", "", []);
add_ocaml_element("call", "Std.Monad.Cont.S.call", "value", "f:(cc:('a -> 'b t) -> 'a t) -> 'a t", "Monads.Std.Monad.Cont.S.html#VALcall", "<div class=\"info\">\n<p><code class=\"code\">call&nbsp;~f</code> calls <code class=\"code\">f&nbsp;~cc</code> with the current continuation <code class=\"code\">cc</code>.</p>\n\n</div>\n", ["ACTS", "ALL", "ALLOWS", "AND", "ANY", "AROUND", "CALL", "CALLED", "CALLS", "CAN", "CAPTURED", "COMPUTATION", "COMPUTATIONS", "COMPUTED", "CONSEQUENT", "CONTAINS", "CONTINUATION", "CONTINUE", "CURRENT", "DISCARDING", "EFFECTIVELY", "ENTRY", "ESCAPE", "EVERY", "FOLLOWS", "FUNCTION", "HAS", "INVOKED", "INVOKING", "ITSELF", "KEY", "LIKE", "MARKS", "MAY", "MORE", "MULTI", "MULTIPLE", "NOT", "ONCE", "POINT", "REENTER", "REENTERABLE", "REPRESENTS", "RESUME", "RESUMED", "SAME", "SEEN", "SENSE", "SHOT", "SUBROUTINE", "THAN", "THAT", "THE", "THIS", "THUS", "TIME", "TIMES", "WILL", "WITH", "WOULD"]);
add_ocaml_element("update", "Std.Monad.State.S2.update", "value", "('s -> 's) -> (unit, 's) t", "Monads.Std.Monad.State.S2.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;f</code> updates the current state with the function <code class=\"code\">f</code></p>\n\n</div>\n", ["CURRENT", "FUNCTION", "STATE", "THE", "UPDATE", "UPDATES", "WITH"]);
add_ocaml_element("gets", "Std.Monad.State.S2.gets", "value", "('s -> 'r) -> ('r, 's) t", "Monads.Std.Monad.State.S2.html#VALgets", "", []);
add_ocaml_element("get", "Std.Monad.State.S2.get", "value", "unit -> ('s, 's) t", "Monads.Std.Monad.State.S2.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;s</code> gets the current state</p>\n\n</div>\n", ["CURRENT", "FUNCTION", "GET", "GETS", "PROJECTS", "STATE", "THE", "WITH"]);
add_ocaml_element("put", "Std.Monad.State.S2.put", "value", "'s -> (unit, 's) t", "Monads.Std.Monad.State.S2.html#VALput", "<div class=\"info\">\n<p><code class=\"code\">put&nbsp;s</code> changes the current state to <code class=\"code\">s</code></p>\n\n</div>\n", ["CHANGES", "CURRENT", "PUT", "STATE", "THE"]);
add_ocaml_element("update", "Std.Monad.State.S.update", "value", "(Std.Monad.State.S.env -> Std.Monad.State.S.env) -> unit t", "Monads.Std.Monad.State.S.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;f</code> updates the current state with the function <code class=\"code\">f</code></p>\n\n</div>\n", ["CURRENT", "FUNCTION", "STATE", "THE", "UPDATE", "UPDATES", "WITH"]);
add_ocaml_element("gets", "Std.Monad.State.S.gets", "value", "(Std.Monad.State.S.env -> 'r) -> 'r t", "Monads.Std.Monad.State.S.html#VALgets", "<div class=\"info\">\n<p><code class=\"code\">gets&nbsp;p</code> projects the current state with the function <code class=\"code\">p</code></p>\n\n</div>\n", ["CURRENT", "FUNCTION", "GETS", "PROJECTS", "STATE", "THE", "WITH"]);
add_ocaml_element("get", "Std.Monad.State.S.get", "value", "unit -> Std.Monad.State.S.env t", "Monads.Std.Monad.State.S.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;s</code> gets the current state</p>\n\n</div>\n", ["CURRENT", "GET", "GETS", "STATE", "THE"]);
add_ocaml_element("put", "Std.Monad.State.S.put", "value", "Std.Monad.State.S.env -> unit t", "Monads.Std.Monad.State.S.html#VALput", "<div class=\"info\">\n<p><code class=\"code\">put&nbsp;s</code> changes the current state to <code class=\"code\">s</code></p>\n\n</div>\n", ["CHANGES", "CURRENT", "PUT", "STATE", "THE"]);
add_ocaml_element("status", "Std.Monad.State.Multi.S2.status", "value", "Std.Monad.State.Multi.S2.id ->\n  (Std.Monad.State.Multi.status, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALstatus", "<div class=\"info\">\n<p><code class=\"code\">status&nbsp;id</code> returns a status of a state with the given <code class=\"code\">id</code></p>\n\n</div>\n", ["GIVEN", "RETURNS", "STATE", "STATUS", "THE", "WITH"]);
add_ocaml_element("forks", "Std.Monad.State.Multi.S2.forks", "value", "unit -> (Std.Monad.State.Multi.S2.id Sequence.t, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALforks", "<div class=\"info\">\n<p><code class=\"code\">forks&nbsp;xs</code> returns a sequence of all alive states</p>\n\n</div>\n", ["ALIVE", "ALL", "FORKS", "RETURNS", "SEQUENCE", "STATES"]);
add_ocaml_element("kill", "Std.Monad.State.Multi.S2.kill", "value", "Std.Monad.State.Multi.S2.id -> (unit, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALkill", "<div class=\"info\">\n<p><code class=\"code\">kill&nbsp;id</code> kills a state with the specified <code class=\"code\">id</code>.</p>\n\n</div>\n", ["ANCESTOR", "CLOSEST", "CORRESPONDS", "CURRENT", "GLOBAL", "KILL", "KILLS", "NOTHING", "SPECIFIED", "STATE", "SWITCHES", "THE", "THEN", "WITH"]);
add_ocaml_element("current", "Std.Monad.State.Multi.S2.current", "value", "unit -> (Std.Monad.State.Multi.S2.id, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALcurrent", "<div class=\"info\">\n<p><code class=\"code\">current&nbsp;id</code> returns an identifier of current state.</p>\n\n</div>\n", ["CURRENT", "IDENTIFIER", "RETURNS", "STATE"]);
add_ocaml_element("ancestor", "Std.Monad.State.Multi.S2.ancestor", "value", "Std.Monad.State.Multi.S2.id list ->\n  (Std.Monad.State.Multi.S2.id, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALancestor", "<div class=\"info\">\n<p><code class=\"code\">ancestor&nbsp;ids</code> returns an identifier of the closest\n              common ancestor of states with the given identifiers.</p>\n\n</div>\n", ["ANCESTOR", "CLOSEST", "COMMON", "GIVEN", "IDENTIFIER", "IDENTIFIERS", "IDS", "RETURNS", "STATES", "THE", "WITH"]);
add_ocaml_element("parent", "Std.Monad.State.Multi.S2.parent", "value", "unit -> (Std.Monad.State.Multi.S2.id, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALparent", "<div class=\"info\">\n<p><code class=\"code\">parent&nbsp;()</code> returns an identifier of the closest alive parent.</p>\n\n</div>\n", ["ALIVE", "CLOSEST", "IDENTIFIER", "PARENT", "RETURNS", "THE"]);
add_ocaml_element("switch", "Std.Monad.State.Multi.S2.switch", "value", "Std.Monad.State.Multi.S2.id -> (unit, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALswitch", "<div class=\"info\">\n<p><code class=\"code\">switch&nbsp;id</code> switches to the state with the given <code class=\"code\">id</code> if\n              such state is alive, otherwise switches to the closest\n              alive ancestor of the state with the given <code class=\"code\">id</code></p>\n\n</div>\n", ["ALIVE", "ANCESTOR", "CLOSEST", "GIVEN", "OTHERWISE", "STATE", "SUCH", "SWITCH", "SWITCHES", "THE", "WITH"]);
add_ocaml_element("fork", "Std.Monad.State.Multi.S2.fork", "value", "unit -> (unit, 'e) t", "Monads.Std.Monad.State.Multi.S2.html#VALfork", "<div class=\"info\">\n<p><code class=\"code\">fork&nbsp;()</code> forks the current state.</p>\n\n</div>\n", ["CURRENT", "FORK", "FORKS", "STATE", "THE"]);
add_ocaml_element("global", "Std.Monad.State.Multi.S2.global", "value", "Std.Monad.State.Multi.S2.id", "Monads.Std.Monad.State.Multi.S2.html#VALglobal", "<div class=\"info\">\n<p>the identifier of the global (initial) state.</p>\n\n</div>\n", ["GLOBAL", "IDENTIFIER", "INITIAL", "STATE", "THE"]);
add_ocaml_element("status", "Std.Monad.State.Multi.S.status", "value", "Std.Monad.State.Multi.S.id -> Std.Monad.State.Multi.status t", "Monads.Std.Monad.State.Multi.S.html#VALstatus", "<div class=\"info\">\n<p><code class=\"code\">status&nbsp;id</code> returns a status of a state with the given <code class=\"code\">id</code></p>\n\n</div>\n", ["GIVEN", "RETURNS", "STATE", "STATUS", "THE", "WITH"]);
add_ocaml_element("forks", "Std.Monad.State.Multi.S.forks", "value", "unit -> Std.Monad.State.Multi.S.id Sequence.t t", "Monads.Std.Monad.State.Multi.S.html#VALforks", "<div class=\"info\">\n<p><code class=\"code\">forks&nbsp;xs</code> returns a sequence of all alive states</p>\n\n</div>\n", ["ALIVE", "ALL", "FORKS", "RETURNS", "SEQUENCE", "STATES"]);
add_ocaml_element("kill", "Std.Monad.State.Multi.S.kill", "value", "Std.Monad.State.Multi.S.id -> unit t", "Monads.Std.Monad.State.Multi.S.html#VALkill", "<div class=\"info\">\n<p><code class=\"code\">kill&nbsp;id</code> kills a state with the specified <code class=\"code\">id</code>.</p>\n\n</div>\n", ["ANCESTOR", "CLOSEST", "CORRESPONDS", "CURRENT", "GLOBAL", "KILL", "KILLS", "NOTHING", "SPECIFIED", "STATE", "SWITCHES", "THE", "THEN", "WITH"]);
add_ocaml_element("current", "Std.Monad.State.Multi.S.current", "value", "unit -> Std.Monad.State.Multi.S.id t", "Monads.Std.Monad.State.Multi.S.html#VALcurrent", "<div class=\"info\">\n<p><code class=\"code\">current&nbsp;id</code> returns an identifier of current state.</p>\n\n</div>\n", ["CURRENT", "IDENTIFIER", "RETURNS", "STATE"]);
add_ocaml_element("ancestor", "Std.Monad.State.Multi.S.ancestor", "value", "Std.Monad.State.Multi.S.id list -> Std.Monad.State.Multi.S.id t", "Monads.Std.Monad.State.Multi.S.html#VALancestor", "<div class=\"info\">\n<p><code class=\"code\">ancestor&nbsp;ids</code> returns an identifier of the closest\n              common ancestor of states with the given identifiers.</p>\n\n</div>\n", ["ANCESTOR", "CLOSEST", "COMMON", "GIVEN", "IDENTIFIER", "IDENTIFIERS", "IDS", "RETURNS", "STATES", "THE", "WITH"]);
add_ocaml_element("parent", "Std.Monad.State.Multi.S.parent", "value", "unit -> Std.Monad.State.Multi.S.id t", "Monads.Std.Monad.State.Multi.S.html#VALparent", "<div class=\"info\">\n<p><code class=\"code\">parent&nbsp;()</code> returns an identifier of the closest alive parent.</p>\n\n</div>\n", ["ALIVE", "CLOSEST", "IDENTIFIER", "PARENT", "RETURNS", "THE"]);
add_ocaml_element("switch", "Std.Monad.State.Multi.S.switch", "value", "Std.Monad.State.Multi.S.id -> unit t", "Monads.Std.Monad.State.Multi.S.html#VALswitch", "<div class=\"info\">\n<p><code class=\"code\">switch&nbsp;id</code> switches to the state with the given <code class=\"code\">id</code> if\n              such state is alive, otherwise switches to the closest\n              alive ancestor of the state with the given <code class=\"code\">id</code></p>\n\n</div>\n", ["ALIVE", "ANCESTOR", "CLOSEST", "GIVEN", "OTHERWISE", "STATE", "SUCH", "SWITCH", "SWITCHES", "THE", "WITH"]);
add_ocaml_element("fork", "Std.Monad.State.Multi.S.fork", "value", "unit -> unit t", "Monads.Std.Monad.State.Multi.S.html#VALfork", "<div class=\"info\">\n<p><code class=\"code\">fork&nbsp;()</code> forks the current state.</p>\n\n</div>\n", ["CURRENT", "FORK", "FORKS", "STATE", "THE"]);
add_ocaml_element("global", "Std.Monad.State.Multi.S.global", "value", "Std.Monad.State.Multi.S.id", "Monads.Std.Monad.State.Multi.S.html#VALglobal", "<div class=\"info\">\n<p>the identifier of the global (initial) state.</p>\n\n</div>\n", ["GLOBAL", "IDENTIFIER", "INITIAL", "STATE", "THE"]);
add_ocaml_element("pp", "Std.Monad.State.Multi.Id.pp", "value", "Stdlib.Format.formatter -> Std.Monad.State.Multi.id -> unit", "Monads.Std.Monad.State.Multi.Id.html#VALpp", "", []);
add_ocaml_element("exec", "Std.Monad.State.exec", "value", "('a, 'e) t -> 'e -> 'e", "Monads.Std.Monad.State.html#VALexec", "<div class=\"info\">\n<p><code class=\"code\">exec&nbsp;m</code> is the same as <code class=\"code\">run&nbsp;m&nbsp;&gt;&gt;|&nbsp;snd</code>, i.e., it runs the\n          computation and returns the final state.</p>\n\n</div>\n", ["AND", "COMPUTATION", "EXEC", "FINAL", "RETURNS", "RUN", "RUNS", "SAME", "SND", "STATE", "THE"]);
add_ocaml_element("eval", "Std.Monad.State.eval", "value", "('a, 'e) t -> 'e -> 'a", "Monads.Std.Monad.State.html#VALeval", "<div class=\"info\">\n<p><code class=\"code\">eval&nbsp;m</code> is the same as <code class=\"code\">run&nbsp;m&nbsp;&gt;&gt;|&nbsp;fst</code>, i.e., it runs the\n          computation and returns the computed value.</p>\n\n</div>\n", ["AND", "COMPUTATION", "COMPUTED", "EVAL", "FST", "RETURNS", "RUN", "RUNS", "SAME", "THE", "VALUE"]);
add_ocaml_element("read", "Std.Monad.Reader.S2.read", "value", "unit -> ('e, 'e) t", "Monads.Std.Monad.Reader.S2.html#VALread", "<div class=\"info\">\n<p><code class=\"code\">read&nbsp;()</code> reads the environment.</p>\n\n</div>\n", ["ENVIRONMENT", "READ", "READS", "THE"]);
add_ocaml_element("read", "Std.Monad.Reader.S.read", "value", "unit -> Std.Monad.Reader.S.env t", "Monads.Std.Monad.Reader.S.html#VALread", "<div class=\"info\">\n<p><code class=\"code\">read&nbsp;()</code> reads the environemnt</p>\n\n</div>\n", ["ENVIRONEMNT", "READ", "READS", "THE"]);
add_ocaml_element("exec", "Std.Monad.Writer.S.exec", "value", "unit t -> Std.Monad.Writer.S.state m", "Monads.Std.Monad.Writer.S.html#VALexec", "<div class=\"info\">\n<p><code class=\"code\">exec&nbsp;m</code> executes computation <code class=\"code\">m</code> and reads the state</p>\n\n</div>\n", ["AND", "COMPUTATION", "EXEC", "EXECUTES", "READS", "STATE", "THE"]);
add_ocaml_element("listen", "Std.Monad.Writer.S.listen", "value", "'a t -> ('a * Std.Monad.Writer.S.state) t", "Monads.Std.Monad.Writer.S.html#VALlisten", "<div class=\"info\">\n<p><code class=\"code\">listen&nbsp;m</code> reads both the computation result and the\n            current state.</p>\n\n</div>\n", ["AND", "BOTH", "COMPUTATION", "CURRENT", "LISTEN", "READS", "RESULT", "STATE", "THE"]);
add_ocaml_element("read", "Std.Monad.Writer.S.read", "value", "'a t -> Std.Monad.Writer.S.state t", "Monads.Std.Monad.Writer.S.html#VALread", "<div class=\"info\">\n<p><code class=\"code\">read&nbsp;m</code> reads the current state of computation <code class=\"code\">m</code></p>\n\n</div>\n", ["COMPUTATION", "CURRENT", "READ", "READS", "STATE", "THE"]);
add_ocaml_element("write", "Std.Monad.Writer.S.write", "value", "Std.Monad.Writer.S.state -> unit t", "Monads.Std.Monad.Writer.S.html#VALwrite", "<div class=\"info\">\n<p><code class=\"code\">write&nbsp;s</code> add <code class=\"code\">s</code> to the current state</p>\n\n</div>\n", ["ADD", "CURRENT", "STATE", "THE", "WRITE"]);
add_ocaml_element("failf", "Std.Monad.Result.Error.S.failf", "value", "('a, Stdlib.Format.formatter, unit, unit -> 'b t) format4 -> 'a", "Monads.Std.Monad.Result.Error.S.html#VALfailf", "<div class=\"info\">\n<p><code class=\"code\">failf&nbsp;<span class=\"string\">\"&lt;fmt&gt;\"</span>&nbsp;&lt;args&gt;&nbsp;()</code> constructs an error message\n              using the specified format descripton and returns a\n              computation that will result in the constructed\n              error.</p>\n\n</div>\n", ["AND", "ARGS", "COMPUTATION", "CONSTRUCTED", "CONSTRUCTS", "DESCRIPTON", "ERROR", "FAILF", "FMT", "FORMAT", "MESSAGE", "RESULT", "RETURNS", "SPECIFIED", "THAT", "THE", "USING", "WILL"]);
add_ocaml_element("expect", "Std.Monad.S2.Exn.expect", "value", "?finally:(unit -> (unit, 's) Std.Monad.S2.t) ->\n  f:(unit -> ('a, 's) Std.Monad.S2.t) ->\n  catch:(exn -> ('a, 's) Std.Monad.S2.t) ->\n  ('a, 's) Std.Monad.S2.t", "Monads.Std.Monad.S2.Exn.html#VALexpect", "<div class=\"info\">\n<p><code class=\"code\">expect&nbsp;?finally&nbsp;~f&nbsp;~catch</code> evaluates <code class=\"code\">f&nbsp;()</code>, if an\n            exception <code class=\"code\">e</code> is raised during the evaluation (or call)\n            then the result of whole computation will be <code class=\"code\">catch&nbsp;e</code>.</p>\n\n</div>\n", ["AFTER", "ARGUMENT", "CALL", "CALLED", "CATCH", "COMPUTATION", "DURING", "EVALUATES", "EVALUATION", "EXCEPTION", "EXPECT", "FINALLY", "OPTIONAL", "PASSED", "RAISED", "RESULT", "THE", "THEN", "WAS", "WHOLE", "WILL"]);
add_ocaml_element("quinary", "Std.Monad.S2.Lift.quinary", "value", "('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->\n  ('a, 's) Std.Monad.S2.t ->\n  ('b, 's) Std.Monad.S2.t ->\n  ('c, 's) Std.Monad.S2.t ->\n  ('d, 's) Std.Monad.S2.t ->\n  ('e, 's) Std.Monad.S2.t -> ('f, 's) Std.Monad.S2.t", "Monads.Std.Monad.S2.Lift.html#VALquinary", "<div class=\"info\">\n<p><code class=\"code\">quinary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "QUINARY"]);
add_ocaml_element("quaternary", "Std.Monad.S2.Lift.quaternary", "value", "('a -> 'b -> 'c -> 'd -> 'e) ->\n  ('a, 's) Std.Monad.S2.t ->\n  ('b, 's) Std.Monad.S2.t ->\n  ('c, 's) Std.Monad.S2.t ->\n  ('d, 's) Std.Monad.S2.t -> ('e, 's) Std.Monad.S2.t", "Monads.Std.Monad.S2.Lift.html#VALquaternary", "<div class=\"info\">\n<p><code class=\"code\">quaternary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "QUATERNARY"]);
add_ocaml_element("ternary", "Std.Monad.S2.Lift.ternary", "value", "('a -> 'b -> 'c -> 'd) ->\n  ('a, 'e) Std.Monad.S2.t ->\n  ('b, 'e) Std.Monad.S2.t ->\n  ('c, 'e) Std.Monad.S2.t -> ('d, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Lift.html#VALternary", "<div class=\"info\">\n<p><code class=\"code\">ternary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "TERNARY"]);
add_ocaml_element("binary", "Std.Monad.S2.Lift.binary", "value", "('a -> 'b -> 'c) ->\n  ('a, 'e) Std.Monad.S2.t ->\n  ('b, 'e) Std.Monad.S2.t -> ('c, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Lift.html#VALbinary", "<div class=\"info\">\n<p><code class=\"code\">binary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["BINARY", "LIFTS"]);
add_ocaml_element("unary", "Std.Monad.S2.Lift.unary", "value", "('a -> 'b) ->\n  ('a, 'e) Std.Monad.S2.t -> ('b, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Lift.html#VALunary", "<div class=\"info\">\n<p><code class=\"code\">unary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "UNARY"]);
add_ocaml_element("nullary", "Std.Monad.S2.Lift.nullary", "value", "'a -> ('a, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Lift.html#VALnullary", "<div class=\"info\">\n<p><code class=\"code\">nullary&nbsp;x</code> lifts <code class=\"code\">x</code> (a synonym to <code class=\"code\">return</code>)</p>\n\n</div>\n", ["LIFTS", "NULLARY", "RETURN", "SYNONYM"]);
add_ocaml_element("trd", "Std.Monad.S2.Triple.trd", "value", "('a * 'b * 'c, 'e) Std.Monad.S2.t -> ('c, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Triple.html#VALtrd", "<div class=\"info\">\n<p><code class=\"code\">trd&nbsp;(x,y,z)</code> computes <code class=\"code\">z</code></p>\n\n</div>\n", ["COMPUTES", "TRD"]);
add_ocaml_element("snd", "Std.Monad.S2.Triple.snd", "value", "('a * 'b * 'c, 'e) Std.Monad.S2.t -> ('b, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Triple.html#VALsnd", "<div class=\"info\">\n<p><code class=\"code\">snd&nbsp;(x,y,z</code> computes <code class=\"code\">y</code></p>\n\n</div>\n", ["COMPUTES", "SND"]);
add_ocaml_element("fst", "Std.Monad.S2.Triple.fst", "value", "('a * 'b * 'c, 'e) Std.Monad.S2.t -> ('a, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Triple.html#VALfst", "<div class=\"info\">\n<p><code class=\"code\">fst&nbsp;(x,y,z)</code> computes <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "FST"]);
add_ocaml_element("snd", "Std.Monad.S2.Pair.snd", "value", "('a * 'b, 'e) Std.Monad.S2.t -> ('b, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Pair.html#VALsnd", "<div class=\"info\">\n<p><code class=\"code\">snd&nbsp;(x,y)</code> computes <code class=\"code\">y</code></p>\n\n</div>\n", ["COMPUTES", "SND"]);
add_ocaml_element("fst", "Std.Monad.S2.Pair.fst", "value", "('a * 'b, 'e) Std.Monad.S2.t -> ('a, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Pair.html#VALfst", "<div class=\"info\">\n<p><code class=\"code\">fst&nbsp;(x,y)</code> computes <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "FST"]);
add_ocaml_element("compose", "Std.Monad.S2.Fn.compose", "value", "('b -> ('c, 'e) Std.Monad.S2.t) ->\n  ('a -> ('b, 'e) Std.Monad.S2.t) ->\n  'a -> ('c, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Fn.html#VALcompose", "<div class=\"info\">\n<p><code class=\"code\">compose&nbsp;f&nbsp;g</code> creates a composition <code class=\"code\">f.g</code> of two\n            function.</p>\n\n</div>\n", ["COMPOSE", "COMPOSITION", "CREATES", "FUNCTION", "TWO"]);
add_ocaml_element("apply_n_times", "Std.Monad.S2.Fn.apply_n_times", "value", "n:int ->\n  ('a -> ('a, 'e) Std.Monad.S2.t) ->\n  'a -> ('a, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Fn.html#VALapply_n_times", "<div class=\"info\">\n<p><code class=\"code\">apply_n_times&nbsp;~n&nbsp;f</code> creates a chaing of computation of\n            size <code class=\"code\">n</code> made from applications of the same function to its\n            own result.</p>\n\n</div>\n", ["APPLICATIONS", "APPLY_N_TIMES", "CHAING", "COMPUTATION", "CREATES", "FROM", "FUNCTION", "ITS", "MADE", "OWN", "RESULT", "SAME", "SIZE", "THE"]);
add_ocaml_element("non", "Std.Monad.S2.Fn.non", "value", "('a -> (bool, 'e) Std.Monad.S2.t) ->\n  'a -> (bool, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Fn.html#VALnon", "<div class=\"info\">\n<p><code class=\"code\">non&nbsp;f</code> returns a negation of the function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["FUNCTION", "NEGATION", "NON", "RETURNS", "THE"]);
add_ocaml_element("nothing", "Std.Monad.S2.Fn.nothing", "value", "unit -> (unit, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Fn.html#VALnothing", "<div class=\"info\">\n<p><code class=\"code\">nothing</code> is a computation that does nothing.</p>\n\n</div>\n", ["COMPUTATION", "DOES", "NOTHING", "THAT"]);
add_ocaml_element("ignore", "Std.Monad.S2.Fn.ignore", "value", "('a, 'e) Std.Monad.S2.t -> (unit, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Fn.html#VALignore", "<div class=\"info\">\n<p><code class=\"code\">ignore&nbsp;m</code> computes <code class=\"code\">m</code> and discards the result.</p>\n\n</div>\n", ["AND", "COMPUTES", "DISCARDS", "IGNORE", "RESULT", "THE"]);
add_ocaml_element("id", "Std.Monad.S2.Fn.id", "value", "'a -> ('a, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.Fn.html#VALid", "<div class=\"info\">\n<p><code class=\"code\">id&nbsp;x</code> a monadic identity function</p>\n\n</div>\n", ["FUNCTION", "IDENTITY", "MONADIC"]);
add_ocaml_element("forever", "Std.Monad.S2.forever", "value", "('a, 'e) Std.Monad.S2.t -> ('b, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.html#VALforever", "<div class=\"info\">\n<p><code class=\"code\">forever&nbsp;xs</code> creates a computationt that never returns.</p>\n\n</div>\n", ["COMPUTATIONT", "CREATES", "FOREVER", "NEVER", "RETURNS", "THAT"]);
add_ocaml_element("sequence", "Std.Monad.S2.sequence", "value", "(unit, 'e) Std.Monad.S2.t list -> (unit, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.html#VALsequence", "<div class=\"info\">\n<p><code class=\"code\">sequence&nbsp;xs</code> computes a sequence of computations <code class=\"code\">xs</code> in\n          the left to right order.</p>\n\n</div>\n", ["COMPUTATIONS", "COMPUTES", "LEFT", "ORDER", "RIGHT", "SEQUENCE", "THE"]);
add_ocaml_element("void", "Std.Monad.S2.void", "value", "('a, 'e) Std.Monad.S2.t -> (unit, 'e) Std.Monad.S2.t", "Monads.Std.Monad.S2.html#VALvoid", "<div class=\"info\">\n<p><code class=\"code\">void&nbsp;m</code> computes <code class=\"code\">m</code> and discrards the result.</p>\n\n</div>\n", ["AND", "COMPUTES", "DISCRARDS", "RESULT", "THE", "VOID"]);
add_ocaml_element("expect", "Std.Monad.S.Exn.expect", "value", "?finally:(unit -> unit Std.Monad.S.t) ->\n  f:(unit -> 'a Std.Monad.S.t) ->\n  catch:(exn -> 'a Std.Monad.S.t) -> 'a Std.Monad.S.t", "Monads.Std.Monad.S.Exn.html#VALexpect", "<div class=\"info\">\n<p><code class=\"code\">expect&nbsp;?finally&nbsp;~f&nbsp;~catch</code> evaluates <code class=\"code\">f&nbsp;()</code>, if an\n            exception <code class=\"code\">e</code> is raised during the evaluation (or call)\n            then the result of whole computation will be <code class=\"code\">catch&nbsp;e</code>.</p>\n\n</div>\n", ["AFTER", "ARGUMENT", "CALL", "CALLED", "CATCH", "COMPUTATION", "DURING", "EVALUATES", "EVALUATION", "EXCEPTION", "EXPECT", "FINALLY", "OPTIONAL", "PASSED", "RAISED", "RESULT", "THE", "THEN", "WAS", "WHOLE", "WILL"]);
add_ocaml_element("quinary", "Std.Monad.S.Lift.quinary", "value", "('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->\n  'a Std.Monad.S.t ->\n  'b Std.Monad.S.t ->\n  'c Std.Monad.S.t ->\n  'd Std.Monad.S.t -> 'e Std.Monad.S.t -> 'f Std.Monad.S.t", "Monads.Std.Monad.S.Lift.html#VALquinary", "<div class=\"info\">\n<p><code class=\"code\">quinary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "QUINARY"]);
add_ocaml_element("quaternary", "Std.Monad.S.Lift.quaternary", "value", "('a -> 'b -> 'c -> 'd -> 'e) ->\n  'a Std.Monad.S.t ->\n  'b Std.Monad.S.t ->\n  'c Std.Monad.S.t -> 'd Std.Monad.S.t -> 'e Std.Monad.S.t", "Monads.Std.Monad.S.Lift.html#VALquaternary", "<div class=\"info\">\n<p><code class=\"code\">quaternary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "QUATERNARY"]);
add_ocaml_element("ternary", "Std.Monad.S.Lift.ternary", "value", "('a -> 'b -> 'c -> 'd) ->\n  'a Std.Monad.S.t ->\n  'b Std.Monad.S.t -> 'c Std.Monad.S.t -> 'd Std.Monad.S.t", "Monads.Std.Monad.S.Lift.html#VALternary", "<div class=\"info\">\n<p><code class=\"code\">ternary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "TERNARY"]);
add_ocaml_element("binary", "Std.Monad.S.Lift.binary", "value", "('a -> 'b -> 'c) ->\n  'a Std.Monad.S.t -> 'b Std.Monad.S.t -> 'c Std.Monad.S.t", "Monads.Std.Monad.S.Lift.html#VALbinary", "<div class=\"info\">\n<p><code class=\"code\">binary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["BINARY", "LIFTS"]);
add_ocaml_element("unary", "Std.Monad.S.Lift.unary", "value", "('a -> 'b) -> 'a Std.Monad.S.t -> 'b Std.Monad.S.t", "Monads.Std.Monad.S.Lift.html#VALunary", "<div class=\"info\">\n<p><code class=\"code\">unary&nbsp;f</code> lifts <code class=\"code\">f</code></p>\n\n</div>\n", ["LIFTS", "UNARY"]);
add_ocaml_element("nullary", "Std.Monad.S.Lift.nullary", "value", "'a -> 'a Std.Monad.S.t", "Monads.Std.Monad.S.Lift.html#VALnullary", "<div class=\"info\">\n<p><code class=\"code\">nullary&nbsp;x</code> lifts <code class=\"code\">x</code> (a synonym to <code class=\"code\">return</code>)</p>\n\n</div>\n", ["LIFTS", "NULLARY", "RETURN", "SYNONYM"]);
add_ocaml_element("trd", "Std.Monad.S.Triple.trd", "value", "('a * 'b * 'c) Std.Monad.S.t -> 'c Std.Monad.S.t", "Monads.Std.Monad.S.Triple.html#VALtrd", "<div class=\"info\">\n<p><code class=\"code\">trd&nbsp;(x,y,z)</code> computes <code class=\"code\">z</code></p>\n\n</div>\n", ["COMPUTES", "TRD"]);
add_ocaml_element("snd", "Std.Monad.S.Triple.snd", "value", "('a * 'b * 'c) Std.Monad.S.t -> 'b Std.Monad.S.t", "Monads.Std.Monad.S.Triple.html#VALsnd", "<div class=\"info\">\n<p><code class=\"code\">snd&nbsp;(x,y,z</code> computes <code class=\"code\">y</code></p>\n\n</div>\n", ["COMPUTES", "SND"]);
add_ocaml_element("fst", "Std.Monad.S.Triple.fst", "value", "('a * 'b * 'c) Std.Monad.S.t -> 'a Std.Monad.S.t", "Monads.Std.Monad.S.Triple.html#VALfst", "<div class=\"info\">\n<p><code class=\"code\">fst&nbsp;(x,y,z)</code> computes <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "FST"]);
add_ocaml_element("snd", "Std.Monad.S.Pair.snd", "value", "('a * 'b) Std.Monad.S.t -> 'b Std.Monad.S.t", "Monads.Std.Monad.S.Pair.html#VALsnd", "<div class=\"info\">\n<p><code class=\"code\">snd&nbsp;(x,y)</code> computes <code class=\"code\">y</code></p>\n\n</div>\n", ["COMPUTES", "SND"]);
add_ocaml_element("fst", "Std.Monad.S.Pair.fst", "value", "('a * 'b) Std.Monad.S.t -> 'a Std.Monad.S.t", "Monads.Std.Monad.S.Pair.html#VALfst", "<div class=\"info\">\n<p><code class=\"code\">fst&nbsp;(x,y)</code> computes <code class=\"code\">x</code></p>\n\n</div>\n", ["COMPUTES", "FST"]);
add_ocaml_element("compose", "Std.Monad.S.Fn.compose", "value", "('b -> 'c Std.Monad.S.t) ->\n  ('a -> 'b Std.Monad.S.t) -> 'a -> 'c Std.Monad.S.t", "Monads.Std.Monad.S.Fn.html#VALcompose", "<div class=\"info\">\n<p><code class=\"code\">compose&nbsp;f&nbsp;g</code> creates a composition <code class=\"code\">f.g</code> of two\n            function.</p>\n\n</div>\n", ["COMPOSE", "COMPOSITION", "CREATES", "FUNCTION", "TWO"]);
add_ocaml_element("apply_n_times", "Std.Monad.S.Fn.apply_n_times", "value", "n:int -> ('a -> 'a Std.Monad.S.t) -> 'a -> 'a Std.Monad.S.t", "Monads.Std.Monad.S.Fn.html#VALapply_n_times", "<div class=\"info\">\n<p><code class=\"code\">apply_n_times&nbsp;~n&nbsp;f</code> creates a chaing of computation of\n            size <code class=\"code\">n</code> made from applications of the same function to its\n            own result.</p>\n\n</div>\n", ["APPLICATIONS", "APPLY_N_TIMES", "CHAING", "COMPUTATION", "CREATES", "FROM", "FUNCTION", "ITS", "MADE", "OWN", "RESULT", "SAME", "SIZE", "THE"]);
add_ocaml_element("non", "Std.Monad.S.Fn.non", "value", "('a -> bool Std.Monad.S.t) -> 'a -> bool Std.Monad.S.t", "Monads.Std.Monad.S.Fn.html#VALnon", "<div class=\"info\">\n<p><code class=\"code\">non&nbsp;f</code> returns a negation of the function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["FUNCTION", "NEGATION", "NON", "RETURNS", "THE"]);
add_ocaml_element("nothing", "Std.Monad.S.Fn.nothing", "value", "unit -> unit Std.Monad.S.t", "Monads.Std.Monad.S.Fn.html#VALnothing", "<div class=\"info\">\n<p><code class=\"code\">nothing</code> is a computation that does nothing.</p>\n\n</div>\n", ["COMPUTATION", "DOES", "NOTHING", "THAT"]);
add_ocaml_element("ignore", "Std.Monad.S.Fn.ignore", "value", "'a Std.Monad.S.t -> unit Std.Monad.S.t", "Monads.Std.Monad.S.Fn.html#VALignore", "<div class=\"info\">\n<p><code class=\"code\">ignore&nbsp;m</code> computes <code class=\"code\">m</code> and discards the result.</p>\n\n</div>\n", ["AND", "COMPUTES", "DISCARDS", "IGNORE", "RESULT", "THE"]);
add_ocaml_element("id", "Std.Monad.S.Fn.id", "value", "'a -> 'a Std.Monad.S.t", "Monads.Std.Monad.S.Fn.html#VALid", "<div class=\"info\">\n<p><code class=\"code\">id&nbsp;x</code> a monadic identity function</p>\n\n</div>\n", ["FUNCTION", "IDENTITY", "MONADIC"]);
add_ocaml_element("forever", "Std.Monad.S.forever", "value", "'a Std.Monad.S.t -> 'b Std.Monad.S.t", "Monads.Std.Monad.S.html#VALforever", "<div class=\"info\">\n<p><code class=\"code\">forever&nbsp;xs</code> creates a computationt that never returns.</p>\n\n</div>\n", ["COMPUTATIONT", "CREATES", "FOREVER", "NEVER", "RETURNS", "THAT"]);
add_ocaml_element("sequence", "Std.Monad.S.sequence", "value", "unit Std.Monad.S.t list -> unit Std.Monad.S.t", "Monads.Std.Monad.S.html#VALsequence", "<div class=\"info\">\n<p><code class=\"code\">sequence&nbsp;xs</code> computes a sequence of computations <code class=\"code\">xs</code> in\n          the left to right order.</p>\n\n</div>\n", ["COMPUTATIONS", "COMPUTES", "LEFT", "ORDER", "RIGHT", "SEQUENCE", "THE"]);
add_ocaml_element("void", "Std.Monad.S.void", "value", "'a Std.Monad.S.t -> unit Std.Monad.S.t", "Monads.Std.Monad.S.html#VALvoid", "<div class=\"info\">\n<p><code class=\"code\">void&nbsp;m</code> computes <code class=\"code\">m</code> and discrards the result.</p>\n\n</div>\n", ["AND", "COMPUTES", "DISCRARDS", "RESULT", "THE", "VOID"]);
add_ocaml_element("(!$$$$$)", "Std.Monad.Syntax.S2.(!$$$$$)", "value", "('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->\n  ('a, 's) Std.Monad.Syntax.S2.t ->\n  ('b, 's) Std.Monad.Syntax.S2.t ->\n  ('c, 's) Std.Monad.Syntax.S2.t ->\n  ('d, 's) Std.Monad.Syntax.S2.t ->\n  ('e, 's) Std.Monad.Syntax.S2.t ->\n  ('f, 's) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(!$$$$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$$$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.quinary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "QUINARY"]);
add_ocaml_element("(!$$$$)", "Std.Monad.Syntax.S2.(!$$$$)", "value", "('a -> 'b -> 'c -> 'd -> 'e) ->\n  ('a, 's) Std.Monad.Syntax.S2.t ->\n  ('b, 's) Std.Monad.Syntax.S2.t ->\n  ('c, 's) Std.Monad.Syntax.S2.t ->\n  ('d, 's) Std.Monad.Syntax.S2.t ->\n  ('e, 's) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(!$$$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.quaternary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "QUATERNARY"]);
add_ocaml_element("(!$$$)", "Std.Monad.Syntax.S2.(!$$$)", "value", "('a -> 'b -> 'c -> 'd) ->\n  ('a, 'e) Std.Monad.Syntax.S2.t ->\n  ('b, 'e) Std.Monad.Syntax.S2.t ->\n  ('c, 'e) Std.Monad.Syntax.S2.t ->\n  ('d, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(!$$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.ternary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "TERNARY"]);
add_ocaml_element("(!$$)", "Std.Monad.Syntax.S2.(!$$)", "value", "('a -> 'b -> 'c) ->\n  ('a, 'e) Std.Monad.Syntax.S2.t ->\n  ('b, 'e) Std.Monad.Syntax.S2.t ->\n  ('c, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(!$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.binary&nbsp;f</code></p>\n\n</div>\n", ["BINARY", "LIFT"]);
add_ocaml_element("(!$)", "Std.Monad.Syntax.S2.(!$)", "value", "('a -> 'b) ->\n  ('a, 'e) Std.Monad.Syntax.S2.t ->\n  ('b, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(!$)", "<div class=\"info\">\n<p><code class=\"code\">!$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.unary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "UNARY"]);
add_ocaml_element("(!!)", "Std.Monad.Syntax.S2.(!!)", "value", "'a -> ('a, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(!!)", "<div class=\"info\">\n<p><code class=\"code\">!!x</code> is <code class=\"code\">return&nbsp;x</code></p>\n\n</div>\n", ["RETURN"]);
add_ocaml_element("(>=>)", "Std.Monad.Syntax.S2.(>=>)", "value", "('a -> ('b, 'e) Std.Monad.Syntax.S2.t) ->\n  ('b -> ('c, 'e) Std.Monad.Syntax.S2.t) ->\n  'a -> ('c, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(>=>)", "<div class=\"info\">\n<p><code class=\"code\">f&nbsp;&gt;=&gt;&nbsp;g</code> is <code class=\"code\"><span class=\"keyword\">fun</span>&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;f&nbsp;x&nbsp;&gt;&gt;=&nbsp;g</code></p>\n\n</div>\n", ["FUN"]);
add_ocaml_element("(>>|)", "Std.Monad.Syntax.S2.(>>|)", "value", "('a, 'e) Std.Monad.Syntax.S2.t ->\n  ('a -> 'b) -> ('b, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(>>|)", "<div class=\"info\">\n<p><code class=\"code\">m&nbsp;&gt;&gt;=&nbsp;f</code> is <code class=\"code\">map&nbsp;m&nbsp;~f</code></p>\n\n</div>\n", ["MAP"]);
add_ocaml_element("(>>=)", "Std.Monad.Syntax.S2.(>>=)", "value", "('a, 'e) Std.Monad.Syntax.S2.t ->\n  ('a -> ('b, 'e) Std.Monad.Syntax.S2.t) ->\n  ('b, 'e) Std.Monad.Syntax.S2.t", "Monads.Std.Monad.Syntax.S2.html#VAL(>>=)", "<div class=\"info\">\n<p><code class=\"code\">m&nbsp;&gt;&gt;=&nbsp;f</code> is <code class=\"code\">bind&nbsp;m&nbsp;f</code></p>\n\n</div>\n", ["BIND"]);
add_ocaml_element("(!$$$$$)", "Std.Monad.Syntax.S.(!$$$$$)", "value", "('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->\n  'a Std.Monad.Syntax.S.t ->\n  'b Std.Monad.Syntax.S.t ->\n  'c Std.Monad.Syntax.S.t ->\n  'd Std.Monad.Syntax.S.t ->\n  'e Std.Monad.Syntax.S.t -> 'f Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(!$$$$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$$$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.quinary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "QUINARY"]);
add_ocaml_element("(!$$$$)", "Std.Monad.Syntax.S.(!$$$$)", "value", "('a -> 'b -> 'c -> 'd -> 'e) ->\n  'a Std.Monad.Syntax.S.t ->\n  'b Std.Monad.Syntax.S.t ->\n  'c Std.Monad.Syntax.S.t ->\n  'd Std.Monad.Syntax.S.t -> 'e Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(!$$$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.quaternary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "QUATERNARY"]);
add_ocaml_element("(!$$$)", "Std.Monad.Syntax.S.(!$$$)", "value", "('a -> 'b -> 'c -> 'd) ->\n  'a Std.Monad.Syntax.S.t ->\n  'b Std.Monad.Syntax.S.t ->\n  'c Std.Monad.Syntax.S.t -> 'd Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(!$$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.ternary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "TERNARY"]);
add_ocaml_element("(!$$)", "Std.Monad.Syntax.S.(!$$)", "value", "('a -> 'b -> 'c) ->\n  'a Std.Monad.Syntax.S.t ->\n  'b Std.Monad.Syntax.S.t -> 'c Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(!$$)", "<div class=\"info\">\n<p><code class=\"code\">!$$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.binary&nbsp;f</code></p>\n\n</div>\n", ["BINARY", "LIFT"]);
add_ocaml_element("(!$)", "Std.Monad.Syntax.S.(!$)", "value", "('a -> 'b) ->\n  'a Std.Monad.Syntax.S.t -> 'b Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(!$)", "<div class=\"info\">\n<p><code class=\"code\">!$f</code> is <code class=\"code\"><span class=\"constructor\">Lift</span>.unary&nbsp;f</code></p>\n\n</div>\n", ["LIFT", "UNARY"]);
add_ocaml_element("(!!)", "Std.Monad.Syntax.S.(!!)", "value", "'a -> 'a Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(!!)", "<div class=\"info\">\n<p><code class=\"code\">!!x</code> is <code class=\"code\">return&nbsp;x</code></p>\n\n</div>\n", ["RETURN"]);
add_ocaml_element("(>=>)", "Std.Monad.Syntax.S.(>=>)", "value", "('a -> 'b Std.Monad.Syntax.S.t) ->\n  ('b -> 'c Std.Monad.Syntax.S.t) ->\n  'a -> 'c Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(>=>)", "<div class=\"info\">\n<p><code class=\"code\">f&nbsp;&gt;=&gt;&nbsp;g</code> is <code class=\"code\"><span class=\"keyword\">fun</span>&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;f&nbsp;x&nbsp;&gt;&gt;=&nbsp;g</code></p>\n\n</div>\n", ["FUN"]);
add_ocaml_element("(>>|)", "Std.Monad.Syntax.S.(>>|)", "value", "'a Std.Monad.Syntax.S.t ->\n  ('a -> 'b) -> 'b Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(>>|)", "<div class=\"info\">\n<p><code class=\"code\">m&nbsp;&gt;&gt;=&nbsp;f</code> is <code class=\"code\">map&nbsp;m&nbsp;~f</code></p>\n\n</div>\n", ["MAP"]);
add_ocaml_element("(>>=)", "Std.Monad.Syntax.S.(>>=)", "value", "'a Std.Monad.Syntax.S.t ->\n  ('a -> 'b Std.Monad.Syntax.S.t) -> 'b Std.Monad.Syntax.S.t", "Monads.Std.Monad.Syntax.S.html#VAL(>>=)", "<div class=\"info\">\n<p><code class=\"code\">m&nbsp;&gt;&gt;=&nbsp;f</code> is <code class=\"code\">bind&nbsp;m&nbsp;f</code></p>\n\n</div>\n", ["BIND"]);
add_ocaml_element("filter_map", "Std.Monad.Collection.S.filter_map", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> 'b option Std.Monad.Collection.S.m) ->\n  'b Std.Monad.Collection.S.t Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;xs&nbsp;~f</code> is a partial mapping from <code class=\"code\">xs</code> to a\n            collection <code class=\"code\">ys</code>, such that all the elements of <code class=\"code\">xs</code> for which\n            <code class=\"code\">f</code> returned <code class=\"code\"><span class=\"constructor\">Some</span></code> value are mapped, while the rest are\n            omitted.</p>\n\n</div>\n", ["ALL", "ARE", "COLLECTION", "ELEMENTS", "FILTER_MAP", "FOR", "FROM", "MAPPED", "MAPPING", "OMITTED", "PARTIAL", "REST", "RETURNED", "SOME", "SUCH", "THAT", "THE", "VALUE", "WHICH", "WHILE"]);
add_ocaml_element("filter", "Std.Monad.Collection.S.filter", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> bool Std.Monad.Collection.S.m) ->\n  'a Std.Monad.Collection.S.t Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;xs&nbsp;~f</code> returns a computation that contains all\n            the elements of <code class=\"code\">xs</code> for which <code class=\"code\">f</code> evaluated to <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["ALL", "COMPUTATION", "CONTAINS", "ELEMENTS", "EVALUATED", "FILTER", "FOR", "ORDER", "RETURNS", "SAME", "THAT", "THE", "TRUE", "WHICH"]);
add_ocaml_element("find_map", "Std.Monad.Collection.S.find_map", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> 'b option Std.Monad.Collection.S.m) ->\n  'b option Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfind_map", "<div class=\"info\">\n<p><code class=\"code\">find_map&nbsp;xs&nbsp;~f</code> returns the first computation <code class=\"code\">f&nbsp;x</code> for\n            <code class=\"code\">x</code> in <code class=\"code\">xs</code> which will result in non <code class=\"code\"><span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["COMPUTATION", "FIND_MAP", "FIRST", "FOR", "NON", "NONE", "RESULT", "RETURNS", "THE", "WHICH", "WILL"]);
add_ocaml_element("find", "Std.Monad.Collection.S.find", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> bool Std.Monad.Collection.S.m) ->\n  'a option Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;xs&nbsp;~f</code> returns the first element <code class=\"code\">x</code> of <code class=\"code\">xs</code> for\n            wich <code class=\"code\">f&nbsp;x</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["ELEMENT", "EVALUATES", "FIND", "FIRST", "FOR", "RETURNS", "THE", "TRUE", "WICH"]);
add_ocaml_element("map_reduce", "Std.Monad.Collection.S.map_reduce", "value", "(module Std.Monoid.S with type t = 'a) ->\n  'b Std.Monad.Collection.S.t ->\n  f:('b -> 'a Std.Monad.Collection.S.m) ->\n  'a Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALmap_reduce", "<div class=\"info\">\n<p><code class=\"code\">map_reduce&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">Monoid</span>)&nbsp;xs&nbsp;~f</code> a composition of <code class=\"code\">map</code>\n            and <code class=\"code\">reduce</code>.</p>\n\n</div>\n", ["AND", "ARE", "COLLECTIONS", "COMPOSITION", "CREATED", "EFFECTIVELY", "EXCEPT", "INTERMEDIATE", "MAP", "MAP_REDUCE", "MODULE", "MONOID", "REDUCE", "SAME", "THAT", "THE", "THEN"]);
add_ocaml_element("count", "Std.Monad.Collection.S.count", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> bool Std.Monad.Collection.S.m) ->\n  int Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALcount", "<div class=\"info\">\n<p><code class=\"code\">count&nbsp;xs&nbsp;~f</code> returns a computation that results to a\n            number of elements of <code class=\"code\">xs</code> for which <code class=\"code\">f</code> evaluates to\n            <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["APPLICATION", "COMPUTATION", "COUNT", "ELEMENTS", "EVALUATES", "FOR", "NUMBER", "ORDER", "RESULTS", "RETURNS", "THAT", "THE", "TRUE", "UNSPECIFIED", "WHICH"]);
add_ocaml_element("for_all", "Std.Monad.Collection.S.for_all", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> bool Std.Monad.Collection.S.m) ->\n  bool Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfor_all", "<div class=\"info\">\n<p><code class=\"code\">for_all&nbsp;xs&nbsp;~f</code> returns a computation that results in\n            <code class=\"code\"><span class=\"keyword\">true</span></code> iff for all <code class=\"code\">x</code> in <code class=\"code\">xs</code> <code class=\"code\">f&nbsp;x</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["ALL", "COMPUTATION", "EVALUATES", "FOR", "FOR_ALL", "IFF", "RESULTS", "RETURNS", "THAT", "TRUE"]);
add_ocaml_element("exists", "Std.Monad.Collection.S.exists", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> bool Std.Monad.Collection.S.m) ->\n  bool Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALexists", "<div class=\"info\">\n<p><code class=\"code\">exists&nbsp;xs&nbsp;~f</code> returns a computation that results in\n            <code class=\"code\"><span class=\"keyword\">true</span></code> iff there exists an element <code class=\"code\">x</code> in <code class=\"code\">xs</code> such that\n            <code class=\"code\">f&nbsp;x</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code></p>\n\n</div>\n", ["COMPUTATION", "ELEMENT", "EVALUATES", "EXISTS", "IFF", "RESULTS", "RETURNS", "SUCH", "THAT", "THERE", "TRUE"]);
add_ocaml_element("reduce", "Std.Monad.Collection.S.reduce", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> 'a -> 'a Std.Monad.Collection.S.m) ->\n  'a option Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALreduce", "<div class=\"info\">\n<p><code class=\"code\">reduce&nbsp;xs&nbsp;~f</code> same as <code class=\"code\">fold</code> except that the initial\n            state is obtained from the first element of the\n            container, i.e., computes a sequence</p>\n\n</div>\n", ["COMPUTES", "CONTAINER", "ELEMENT", "EXCEPT", "FIRST", "FOLD", "FROM", "FUN", "INITIAL", "OBTAINED", "REDUCE", "SAME", "SEQUENCE", "STATE", "THAT", "THE"]);
add_ocaml_element("fold_right", "Std.Monad.Collection.S.fold_right", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> 'b -> 'b Std.Monad.Collection.S.m) ->\n  init:'b -> 'b Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfold_right", "<div class=\"info\">\n<p><code class=\"code\">fold_right&nbsp;xs&nbsp;~f&nbsp;~init:s0</code> folds <code class=\"code\">f</code> over <code class=\"code\">xs</code> from right to\n            left in the given monad.</p>\n\n</div>\n", ["CHAIN", "COMPUTATION", "COMPUTES", "CONSTANT", "EFFECTIVELY", "EXCEPT", "FOLDS", "FOLD_RIGHT", "FROM", "FUN", "GIVEN", "INIT", "LEFT", "MONAD", "OVER", "RIGHT", "SIZE", "STACK", "S_N", "THAT", "THE", "USES", "X_N"]);
add_ocaml_element("fold_left", "Std.Monad.Collection.S.fold_left", "value", "'a Std.Monad.Collection.S.t ->\n  init:'b ->\n  f:('b -> 'a -> 'b Std.Monad.Collection.S.m) ->\n  'b Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfold_left", "<div class=\"info\">\n<p><code class=\"code\">fold_left</code> is a synonym for <code class=\"code\">fold</code>.</p>\n\n</div>\n", ["FOLD", "FOLD_LEFT", "FOR", "SYNONYM"]);
add_ocaml_element("fold", "Std.Monad.Collection.S.fold", "value", "'a Std.Monad.Collection.S.t ->\n  init:'b ->\n  f:('b -> 'a -> 'b Std.Monad.Collection.S.m) ->\n  'b Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALfold", "", []);
add_ocaml_element("iter", "Std.Monad.Collection.S.iter", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> unit Std.Monad.Collection.S.m) ->\n  unit Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALiter", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;xs&nbsp;~init:s0&nbsp;~f</code> folds <code class=\"code\">f</code> over <code class=\"code\">xs</code> in the given monad.</p>\n\n</div>\n", ["CHAIN", "COMPUTATION", "COMPUTES", "CONSTANT", "EFFECTIVELY", "EXCEPT", "FOLD", "FOLDS", "FUN", "GIVEN", "INIT", "MONAD", "OVER", "SIZE", "STACK", "THAT", "THE", "USES"]);
add_ocaml_element("map", "Std.Monad.Collection.S.map", "value", "'a Std.Monad.Collection.S.t ->\n  f:('a -> 'b Std.Monad.Collection.S.m) ->\n  'b Std.Monad.Collection.S.t Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;xs&nbsp;~f</code> returns a container where <code class=\"code\">n</code>'th element is a\n            result of computation <code class=\"code\">f&nbsp;x_n</code>, where <code class=\"code\">x_n</code> is the <code class=\"code\">n</code>'th\n            element of the input container.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "COMPUTATION", "COMPUTATIONS", "CONTAINER", "EACH", "ELEMENT", "EVALUATED", "FOR", "INPUT", "ITER", "LEFT", "MAP", "ORDER", "PERFORMED", "PERFORMS", "RESULT", "RETURNS", "RIGHT", "THE", "UNSPECIFIED", "WHERE", "WHETHER", "WHICH", "X_N"]);
add_ocaml_element("sequence", "Std.Monad.Collection.S.sequence", "value", "unit Std.Monad.Collection.S.m Std.Monad.Collection.S.t ->\n  unit Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALsequence", "<div class=\"info\">\n<p><code class=\"code\">sequence&nbsp;cs</code> performs all computations in <code class=\"code\">cs</code> from left\n            to right.</p>\n\n</div>\n", ["ALL", "COMPUTATIONS", "FROM", "LEFT", "PERFORMS", "RIGHT", "SEQUENCE"]);
add_ocaml_element("all_ignore", "Std.Monad.Collection.S.all_ignore", "value", "'a Std.Monad.Collection.S.m Std.Monad.Collection.S.t ->\n  unit Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALall_ignore", "<div class=\"info\">\n<p><code class=\"code\">all_ignore&nbsp;cs</code> performs all computations in <code class=\"code\">cs</code> in an\n            unspecified order, and discards the results.</p>\n\n</div>\n", ["ALL", "ALL_IGNORE", "AND", "COMPUTATIONS", "DISCARDS", "ORDER", "PERFORMS", "RESULTS", "THE", "UNSPECIFIED"]);
add_ocaml_element("all", "Std.Monad.Collection.S.all", "value", "'a Std.Monad.Collection.S.m Std.Monad.Collection.S.t ->\n  'a Std.Monad.Collection.S.t Std.Monad.Collection.S.m", "Monads.Std.Monad.Collection.S.html#VALall", "<div class=\"info\">\n<p><code class=\"code\">all&nbsp;cs</code> perfoms all computations in <code class=\"code\">cs</code> and returns a\n            list of results in the same order.</p>\n\n</div>\n", ["ALL", "AND", "COMPUTATIONS", "EVALUATION", "LIST", "ORDER", "PERFOMS", "RESULTS", "RETURNS", "SAME", "THE", "UNSPECIFIED"]);
add_ocaml_element("filter_map", "Std.Monad.Collection.S2.filter_map", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> ('b option, 'e) Std.Monad.Collection.S2.m) ->\n  ('b Std.Monad.Collection.S2.t, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;xs&nbsp;~f</code> is a partial mapping from <code class=\"code\">xs</code> to a\n            collection <code class=\"code\">ys</code>, such that all the elements of <code class=\"code\">xs</code> for which\n            <code class=\"code\">f</code> returned <code class=\"code\"><span class=\"constructor\">Some</span></code> value are mapped, while the rest are\n            omitted.</p>\n\n</div>\n", ["ALL", "ARE", "COLLECTION", "ELEMENTS", "FILTER_MAP", "FOR", "FROM", "MAPPED", "MAPPING", "OMITTED", "PARTIAL", "REST", "RETURNED", "SOME", "SUCH", "THAT", "THE", "VALUE", "WHICH", "WHILE"]);
add_ocaml_element("filter", "Std.Monad.Collection.S2.filter", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> (bool, 'e) Std.Monad.Collection.S2.m) ->\n  ('a Std.Monad.Collection.S2.t, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;xs&nbsp;~f</code> returns a computation that contains all\n            the elements of <code class=\"code\">xs</code> for which <code class=\"code\">f</code> evaluated to <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["ALL", "COMPUTATION", "CONTAINS", "ELEMENTS", "EVALUATED", "FILTER", "FOR", "ORDER", "RETURNS", "SAME", "THAT", "THE", "TRUE", "WHICH"]);
add_ocaml_element("find_map", "Std.Monad.Collection.S2.find_map", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> ('b option, 'e) Std.Monad.Collection.S2.m) ->\n  ('b option, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfind_map", "<div class=\"info\">\n<p><code class=\"code\">find_map&nbsp;xs&nbsp;~f</code> returns the first computation <code class=\"code\">f&nbsp;x</code> for\n            <code class=\"code\">x</code> in <code class=\"code\">xs</code> which will result in non <code class=\"code\"><span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["COMPUTATION", "FIND_MAP", "FIRST", "FOR", "NON", "NONE", "RESULT", "RETURNS", "THE", "WHICH", "WILL"]);
add_ocaml_element("find", "Std.Monad.Collection.S2.find", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> (bool, 'e) Std.Monad.Collection.S2.m) ->\n  ('a option, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;xs&nbsp;~f</code> returns the first element <code class=\"code\">x</code> of <code class=\"code\">xs</code> for\n            wich <code class=\"code\">f&nbsp;x</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["ELEMENT", "EVALUATES", "FIND", "FIRST", "FOR", "RETURNS", "THE", "TRUE", "WICH"]);
add_ocaml_element("map_reduce", "Std.Monad.Collection.S2.map_reduce", "value", "(module Std.Monoid.S with type t = 'a) ->\n  'b Std.Monad.Collection.S2.t ->\n  f:('b -> ('a, 'e) Std.Monad.Collection.S2.m) ->\n  ('a, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALmap_reduce", "<div class=\"info\">\n<p><code class=\"code\">map_reduce&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">Monoid</span>)&nbsp;xs&nbsp;~f</code> a composition of <code class=\"code\">map</code>\n            and <code class=\"code\">reduce</code>.</p>\n\n</div>\n", ["AND", "ARE", "COLLECTIONS", "COMPOSITION", "CREATED", "EFFECTIVELY", "EXCEPT", "INTERMEDIATE", "MAP", "MAP_REDUCE", "MODULE", "MONOID", "REDUCE", "SAME", "THAT", "THE", "THEN"]);
add_ocaml_element("count", "Std.Monad.Collection.S2.count", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> (bool, 'e) Std.Monad.Collection.S2.m) ->\n  (int, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALcount", "<div class=\"info\">\n<p><code class=\"code\">count&nbsp;xs&nbsp;~f</code> returns a computation that results to a\n            number of elements of <code class=\"code\">xs</code> for which <code class=\"code\">f</code> evaluates to\n            <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["APPLICATION", "COMPUTATION", "COUNT", "ELEMENTS", "EVALUATES", "FOR", "NUMBER", "ORDER", "RESULTS", "RETURNS", "THAT", "THE", "TRUE", "UNSPECIFIED", "WHICH"]);
add_ocaml_element("for_all", "Std.Monad.Collection.S2.for_all", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> (bool, 'e) Std.Monad.Collection.S2.m) ->\n  (bool, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfor_all", "<div class=\"info\">\n<p><code class=\"code\">for_all&nbsp;xs&nbsp;~f</code> returns a computation that results in\n            <code class=\"code\"><span class=\"keyword\">true</span></code> iff for all <code class=\"code\">x</code> in <code class=\"code\">xs</code> <code class=\"code\">f&nbsp;x</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["ALL", "COMPUTATION", "EVALUATES", "FOR", "FOR_ALL", "IFF", "RESULTS", "RETURNS", "THAT", "TRUE"]);
add_ocaml_element("exists", "Std.Monad.Collection.S2.exists", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> (bool, 'e) Std.Monad.Collection.S2.m) ->\n  (bool, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALexists", "<div class=\"info\">\n<p><code class=\"code\">exists&nbsp;xs&nbsp;~f</code> returns a computation that results in\n            <code class=\"code\"><span class=\"keyword\">true</span></code> iff there exists an element <code class=\"code\">x</code> in <code class=\"code\">xs</code> such that\n            <code class=\"code\">f&nbsp;x</code> evaluates to <code class=\"code\"><span class=\"keyword\">true</span></code></p>\n\n</div>\n", ["COMPUTATION", "ELEMENT", "EVALUATES", "EXISTS", "IFF", "RESULTS", "RETURNS", "SUCH", "THAT", "THERE", "TRUE"]);
add_ocaml_element("reduce", "Std.Monad.Collection.S2.reduce", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> 'a -> ('a, 'e) Std.Monad.Collection.S2.m) ->\n  ('a option, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALreduce", "<div class=\"info\">\n<p><code class=\"code\">reduce&nbsp;xs&nbsp;~f</code> same as <code class=\"code\">fold</code> except that the initial\n            state is obtained from the first element of the\n            container, i.e., computes a sequence</p>\n\n</div>\n", ["COMPUTES", "CONTAINER", "ELEMENT", "EXCEPT", "FIRST", "FOLD", "FROM", "FUN", "INITIAL", "OBTAINED", "REDUCE", "SAME", "SEQUENCE", "STATE", "THAT", "THE"]);
add_ocaml_element("fold_right", "Std.Monad.Collection.S2.fold_right", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> 'b -> ('b, 'e) Std.Monad.Collection.S2.m) ->\n  init:'b -> ('b, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfold_right", "<div class=\"info\">\n<p><code class=\"code\">fold_right&nbsp;xs&nbsp;~f&nbsp;~init:s0</code> folds <code class=\"code\">f</code> over <code class=\"code\">xs</code> from right to\n            left in the given monad.</p>\n\n</div>\n", ["CHAIN", "COMPUTATION", "COMPUTES", "CONSTANT", "EFFECTIVELY", "EXCEPT", "FOLDS", "FOLD_RIGHT", "FROM", "FUN", "GIVEN", "INIT", "LEFT", "MONAD", "OVER", "RIGHT", "SIZE", "STACK", "S_N", "THAT", "THE", "USES", "X_N"]);
add_ocaml_element("fold_left", "Std.Monad.Collection.S2.fold_left", "value", "'a Std.Monad.Collection.S2.t ->\n  init:'b ->\n  f:('b -> 'a -> ('b, 'e) Std.Monad.Collection.S2.m) ->\n  ('b, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfold_left", "<div class=\"info\">\n<p><code class=\"code\">fold_left</code> is a synonym for <code class=\"code\">fold</code>.</p>\n\n</div>\n", ["FOLD", "FOLD_LEFT", "FOR", "SYNONYM"]);
add_ocaml_element("fold", "Std.Monad.Collection.S2.fold", "value", "'a Std.Monad.Collection.S2.t ->\n  init:'b ->\n  f:('b -> 'a -> ('b, 'e) Std.Monad.Collection.S2.m) ->\n  ('b, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALfold", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;xs&nbsp;~init:s0&nbsp;~f</code> folds <code class=\"code\">f</code> over <code class=\"code\">xs</code> in the given monad.</p>\n\n</div>\n", ["CHAIN", "COMPUTATION", "COMPUTES", "CONSTANT", "EFFECTIVELY", "EXCEPT", "FOLD", "FOLDS", "FUN", "GIVEN", "INIT", "MONAD", "OVER", "SIZE", "STACK", "THAT", "THE", "USES"]);
add_ocaml_element("iter", "Std.Monad.Collection.S2.iter", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> (unit, 'e) Std.Monad.Collection.S2.m) ->\n  (unit, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALiter", "<div class=\"info\">\n<p><code class=\"code\">iter&nbsp;xs&nbsp;~f</code> performs <code class=\"code\">f&nbsp;x</code> for each <code class=\"code\">x</code> in <code class=\"code\">xs</code> in the\n            left to right order.</p>\n\n</div>\n", ["EACH", "FOR", "ITER", "LEFT", "ORDER", "PERFORMS", "RIGHT", "THE"]);
add_ocaml_element("map", "Std.Monad.Collection.S2.map", "value", "'a Std.Monad.Collection.S2.t ->\n  f:('a -> ('b, 'e) Std.Monad.Collection.S2.m) ->\n  ('b Std.Monad.Collection.S2.t, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;xs&nbsp;~f</code> returns a container where <code class=\"code\">n</code>'th element is a\n            result of computation <code class=\"code\">f&nbsp;x_n</code>, where <code class=\"code\">x_n</code> is the <code class=\"code\">n</code>'th\n            element of the input container.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "COMPUTATION", "COMPUTATIONS", "CONTAINER", "ELEMENT", "EVALUATED", "INPUT", "MAP", "ORDER", "PERFORMED", "RESULT", "RETURNS", "THE", "UNSPECIFIED", "WHERE", "WHETHER", "WHICH", "X_N"]);
add_ocaml_element("sequence", "Std.Monad.Collection.S2.sequence", "value", "(unit, 'e) Std.Monad.Collection.S2.m Std.Monad.Collection.S2.t ->\n  (unit, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALsequence", "<div class=\"info\">\n<p><code class=\"code\">sequence&nbsp;cs</code> performs all computations in <code class=\"code\">cs</code> from left\n            to right.</p>\n\n</div>\n", ["ALL", "COMPUTATIONS", "FROM", "LEFT", "PERFORMS", "RIGHT", "SEQUENCE"]);
add_ocaml_element("all_ignore", "Std.Monad.Collection.S2.all_ignore", "value", "('a, 'e) Std.Monad.Collection.S2.m Std.Monad.Collection.S2.t ->\n  (unit, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALall_ignore", "<div class=\"info\">\n<p><code class=\"code\">all_ignore&nbsp;cs</code> performs all computations in <code class=\"code\">cs</code> in an\n            unspecified order, and discards the results.</p>\n\n</div>\n", ["ALL", "ALL_IGNORE", "AND", "COMPUTATIONS", "DISCARDS", "ORDER", "PERFORMS", "RESULTS", "THE", "UNSPECIFIED"]);
add_ocaml_element("all", "Std.Monad.Collection.S2.all", "value", "('a, 'e) Std.Monad.Collection.S2.m Std.Monad.Collection.S2.t ->\n  ('a Std.Monad.Collection.S2.t, 'e) Std.Monad.Collection.S2.m", "Monads.Std.Monad.Collection.S2.html#VALall", "<div class=\"info\">\n<p><code class=\"code\">all&nbsp;cs</code> perfoms all computations in <code class=\"code\">cs</code> and returns a\n            list of results in the same order.</p>\n\n</div>\n", ["ALL", "AND", "COMPUTATIONS", "EVALUATION", "LIST", "ORDER", "PERFOMS", "RESULTS", "RETURNS", "SAME", "THE", "UNSPECIFIED"]);
add_ocaml_element("fold", "Std.Monad.Collection.Delay.fold", "value", "'a t -> init:'s -> f:('s -> 'a -> ('s -> 'r) -> 'r) -> ('s -> 'r) -> 'r", "Monads.Std.Monad.Collection.Delay.html#VALfold", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;xs&nbsp;~init:s&nbsp;~f</code> a delayed fold implementation.</p>\n\n</div>\n", ["ACCEPTS", "AND", "ARGUMENT", "CONTINUATION", "DELAYED", "EXCEPT", "EXPRESSION", "EXTRA", "FOLD", "FUNCTION", "IMPLEMENTATION", "INIT", "REGULAR", "RETURNS", "SAME", "THAT", "THE"]);
add_ocaml_element("fold", "Std.Monad.Collection.Eager.fold", "value", "'a t -> init:'s -> f:('s -> 'a -> 's) -> 's", "Monads.Std.Monad.Collection.Eager.html#VALfold", "<div class=\"info\">\n<p>fold implementation</p>\n\n</div>\n", ["FOLD", "IMPLEMENTATION"]);
add_ocaml_element("return", "Std.Monad.Collection.Basic.return", "value", "'a -> 'a Std.Monad.Collection.Basic.t", "Monads.Std.Monad.Collection.Basic.html#VALreturn", "<div class=\"info\">\n<p><code class=\"code\">return&nbsp;x</code> creates a singleton container holding <code class=\"code\">x</code></p>\n\n</div>\n", ["CONTAINER", "CREATES", "HOLDING", "RETURN", "SINGLETON"]);
add_ocaml_element("run", "Std.Monad.Trans.S2.run", "value", "('a, 'e) Std.Monad.Trans.S2.t -> ('a, 'e) Std.Monad.Trans.S2.e", "Monads.Std.Monad.Trans.S2.html#VALrun", "<div class=\"info\">\n<p>runs the computation</p>\n\n</div>\n", ["COMPUTATION", "RUNS", "THE"]);
add_ocaml_element("lift", "Std.Monad.Trans.S2.lift", "value", "('a, 'e) Std.Monad.Trans.S2.m -> ('a, 'e) Std.Monad.Trans.S2.t", "Monads.Std.Monad.Trans.S2.html#VALlift", "<div class=\"info\">\n<p>lifts inner monad into the resulting monad</p>\n\n</div>\n", ["INNER", "INTO", "LIFTS", "MONAD", "RESULTING", "THE"]);
add_ocaml_element("run", "Std.Monad.Trans.S1.run", "value", "('a, 'e) Std.Monad.Trans.S1.t -> ('a, 'e) Std.Monad.Trans.S1.e", "Monads.Std.Monad.Trans.S1.html#VALrun", "<div class=\"info\">\n<p>runs the computation</p>\n\n</div>\n", ["COMPUTATION", "RUNS", "THE"]);
add_ocaml_element("lift", "Std.Monad.Trans.S1.lift", "value", "'a Std.Monad.Trans.S1.m -> ('a, 'e) Std.Monad.Trans.S1.t", "Monads.Std.Monad.Trans.S1.html#VALlift", "<div class=\"info\">\n<p>lifts inner monad into the resulting monad</p>\n\n</div>\n", ["INNER", "INTO", "LIFTS", "MONAD", "RESULTING", "THE"]);
add_ocaml_element("run", "Std.Monad.Trans.S.run", "value", "'a Std.Monad.Trans.S.t -> 'a Std.Monad.Trans.S.e", "Monads.Std.Monad.Trans.S.html#VALrun", "<div class=\"info\">\n<p>runs the computation</p>\n\n</div>\n", ["COMPUTATION", "RUNS", "THE"]);
add_ocaml_element("lift", "Std.Monad.Trans.S.lift", "value", "'a Std.Monad.Trans.S.m -> 'a Std.Monad.Trans.S.t", "Monads.Std.Monad.Trans.S.html#VALlift", "<div class=\"info\">\n<p>lifts inner monad into the resulting monad</p>\n\n</div>\n", ["INNER", "INTO", "LIFTS", "MONAD", "RESULTING", "THE"]);
add_ocaml_element("zero", "Std.Monad.Choice.Basic2.zero", "value", "unit -> ('a, 'e) Std.Monad.Choice.Basic2.t", "Monads.Std.Monad.Choice.Basic2.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero&nbsp;()</code> creates a computation that has no result.</p>\n\n</div>\n", ["COMPUTATION", "CREATES", "HAS", "RESULT", "THAT", "ZERO"]);
add_ocaml_element("pure", "Std.Monad.Choice.Basic2.pure", "value", "'a -> ('a, 'e) Std.Monad.Choice.Basic2.t", "Monads.Std.Monad.Choice.Basic2.html#VALpure", "<div class=\"info\">\n<p><code class=\"code\">pure&nbsp;x</code> creates a computation that results in <code class=\"code\">x</code>.</p>\n\n</div>\n", ["COMPUTATION", "CREATES", "PURE", "RESULTS", "THAT"]);
add_ocaml_element("zero", "Std.Monad.Choice.Basic.zero", "value", "unit -> 'a Std.Monad.Choice.Basic.t", "Monads.Std.Monad.Choice.Basic.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero&nbsp;()</code> creates a computation that has no result.</p>\n\n</div>\n", ["COMPUTATION", "CREATES", "HAS", "RESULT", "THAT", "ZERO"]);
add_ocaml_element("pure", "Std.Monad.Choice.Basic.pure", "value", "'a -> 'a Std.Monad.Choice.Basic.t", "Monads.Std.Monad.Choice.Basic.html#VALpure", "<div class=\"info\">\n<p><code class=\"code\">pure&nbsp;x</code> creates a computation that results in <code class=\"code\">x</code>.</p>\n\n</div>\n", ["COMPUTATION", "CREATES", "PURE", "RESULTS", "THAT"]);
add_ocaml_element("unless", "Std.Monad.Choice.S2.unless", "value", "bool ->\n  (unit, 'e) Std.Monad.Choice.S2.t ->\n  (unit, 'e) Std.Monad.Choice.S2.t", "Monads.Std.Monad.Choice.S2.html#VALunless", "<div class=\"info\">\n<p><code class=\"code\">unless&nbsp;cond&nbsp;x</code> computes <code class=\"code\">x</code> unless <code class=\"code\">cond</code> is <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["COMPUTES", "COND", "TRUE", "UNLESS"]);
add_ocaml_element("on", "Std.Monad.Choice.S2.on", "value", "bool ->\n  (unit, 'e) Std.Monad.Choice.S2.t ->\n  (unit, 'e) Std.Monad.Choice.S2.t", "Monads.Std.Monad.Choice.S2.html#VALon", "<div class=\"info\">\n<p><code class=\"code\">on&nbsp;cond&nbsp;x</code> computes <code class=\"code\">x</code> only iff <code class=\"code\">cond</code> is <code class=\"code\"><span class=\"keyword\">true</span></code></p>\n\n</div>\n", ["COMPUTES", "COND", "IFF", "ONLY", "TRUE"]);
add_ocaml_element("guard", "Std.Monad.Choice.S2.guard", "value", "bool -> (unit, 'e) Std.Monad.Choice.S2.t", "Monads.Std.Monad.Choice.S2.html#VALguard", "<div class=\"info\">\n<p><code class=\"code\">guard&nbsp;cond</code> ensures <code class=\"code\">cond</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> in the rest of\n            computation.</p>\n\n</div>\n", ["COMPUTATION", "COND", "ENSURES", "GUARD", "OTHERWISE", "REJECTED", "REST", "THE", "TRUE"]);
add_ocaml_element("reject", "Std.Monad.Choice.S2.reject", "value", "unit -> ('a, 'e) Std.Monad.Choice.S2.t", "Monads.Std.Monad.Choice.S2.html#VALreject", "<div class=\"info\">\n<p><code class=\"code\">reject&nbsp;()</code> rejects the rest of computation sequence, and\n            terminate the computation with the <code class=\"code\">zero</code> result (Same as\n            <code class=\"code\">zero&nbsp;()</code></p>\n\n</div>\n", ["AND", "COMPUTATION", "REJECT", "REJECTS", "REST", "RESULT", "SAME", "SEQUENCE", "TERMINATE", "THE", "WITH", "ZERO"]);
add_ocaml_element("accept", "Std.Monad.Choice.S2.accept", "value", "'a -> ('a, 'e) Std.Monad.Choice.S2.t", "Monads.Std.Monad.Choice.S2.html#VALaccept", "<div class=\"info\">\n<p><code class=\"code\">accept&nbsp;x</code> accepts <code class=\"code\">x</code> as a result of computation.</p>\n\n</div>\n", ["ACCEPT", "ACCEPTS", "COMPUTATION", "PURE", "RESULT", "SAME"]);
add_ocaml_element("unless", "Std.Monad.Choice.S.unless", "value", "bool -> unit Std.Monad.Choice.S.t -> unit Std.Monad.Choice.S.t", "Monads.Std.Monad.Choice.S.html#VALunless", "<div class=\"info\">\n<p><code class=\"code\">unless&nbsp;cond&nbsp;x</code> computes <code class=\"code\">x</code> unless <code class=\"code\">cond</code> is <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["COMPUTES", "COND", "TRUE", "UNLESS"]);
add_ocaml_element("on", "Std.Monad.Choice.S.on", "value", "bool -> unit Std.Monad.Choice.S.t -> unit Std.Monad.Choice.S.t", "Monads.Std.Monad.Choice.S.html#VALon", "<div class=\"info\">\n<p><code class=\"code\">on&nbsp;cond&nbsp;x</code> computes <code class=\"code\">x</code> only iff <code class=\"code\">cond</code> is <code class=\"code\"><span class=\"keyword\">true</span></code></p>\n\n</div>\n", ["COMPUTES", "COND", "IFF", "ONLY", "TRUE"]);
add_ocaml_element("guard", "Std.Monad.Choice.S.guard", "value", "bool -> unit Std.Monad.Choice.S.t", "Monads.Std.Monad.Choice.S.html#VALguard", "<div class=\"info\">\n<p><code class=\"code\">guard&nbsp;cond</code> ensures <code class=\"code\">cond</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> in the rest of\n            computation.</p>\n\n</div>\n", ["COMPUTATION", "COND", "ENSURES", "GUARD", "OTHERWISE", "REJECTED", "REST", "THE", "TRUE"]);
add_ocaml_element("reject", "Std.Monad.Choice.S.reject", "value", "unit -> 'a Std.Monad.Choice.S.t", "Monads.Std.Monad.Choice.S.html#VALreject", "<div class=\"info\">\n<p><code class=\"code\">reject&nbsp;()</code> rejects the rest of computation sequence, and\n            terminate the computation with the <code class=\"code\">zero</code> result (Same as\n            <code class=\"code\">zero&nbsp;()</code></p>\n\n</div>\n", ["AND", "COMPUTATION", "REJECT", "REJECTS", "REST", "RESULT", "SAME", "SEQUENCE", "TERMINATE", "THE", "WITH", "ZERO"]);
add_ocaml_element("accept", "Std.Monad.Choice.S.accept", "value", "'a -> 'a Std.Monad.Choice.S.t", "Monads.Std.Monad.Choice.S.html#VALaccept", "<div class=\"info\">\n<p><code class=\"code\">accept&nbsp;x</code> accepts <code class=\"code\">x</code> as a result of computation.</p>\n\n</div>\n", ["ACCEPT", "ACCEPTS", "COMPUTATION", "PURE", "RESULT", "SAME"]);
add_ocaml_element("catch", "Std.Monad.Fail.S2.catch", "value", "('a, 'e) Std.Monad.Fail.S2.t ->\n  ('e Std.Monad.Fail.S2.error -> ('a, 'e) Std.Monad.Fail.S2.t) ->\n  ('a, 'e) Std.Monad.Fail.S2.t", "Monads.Std.Monad.Fail.S2.html#VALcatch", "<div class=\"info\">\n<p><code class=\"code\">catch&nbsp;m&nbsp;f</code> if <code class=\"code\">m</code> diverges with some bottom value <code class=\"code\">err</code>,\n            the <code class=\"code\">f&nbsp;err</code> is a result of the whole computation, otherwise\n            returns <code class=\"code\">m</code>.</p>\n\n</div>\n", ["BOTTOM", "CATCH", "COMPUTATION", "DIVERGES", "ERR", "OTHERWISE", "RESULT", "RETURNS", "SOME", "THE", "VALUE", "WHOLE", "WITH"]);
add_ocaml_element("fail", "Std.Monad.Fail.S2.fail", "value", "'e Std.Monad.Fail.S2.error -> ('a, 'e) Std.Monad.Fail.S2.t", "Monads.Std.Monad.Fail.S2.html#VALfail", "<div class=\"info\">\n<p><code class=\"code\">fail&nbsp;err</code> diverges the computation, possibly providing an\n            extra information in a value of type <code class=\"code\"><span class=\"keywordsign\">'</span>e&nbsp;error</code>.</p>\n\n</div>\n", ["COMPUTATION", "DIVERGES", "ERR", "ERROR", "EXTRA", "FAIL", "INFORMATION", "POSSIBLY", "PROVIDING", "THE", "TYPE", "VALUE"]);
add_ocaml_element("catch", "Std.Monad.Fail.S.catch", "value", "'a Std.Monad.Fail.S.t ->\n  ('b Std.Monad.Fail.S.error -> 'a Std.Monad.Fail.S.t) ->\n  'a Std.Monad.Fail.S.t", "Monads.Std.Monad.Fail.S.html#VALcatch", "<div class=\"info\">\n<p><code class=\"code\">catch&nbsp;m&nbsp;f</code> if <code class=\"code\">m</code> diverges with some bottom value <code class=\"code\">err</code>,\n            the <code class=\"code\">f&nbsp;err</code> is a result of the whole computation, otherwise\n            returns <code class=\"code\">m</code>.</p>\n\n</div>\n", ["BOTTOM", "CATCH", "COMPUTATION", "DIVERGES", "ERR", "OTHERWISE", "RESULT", "RETURNS", "SOME", "THE", "VALUE", "WHOLE", "WITH"]);
add_ocaml_element("fail", "Std.Monad.Fail.S.fail", "value", "'b Std.Monad.Fail.S.error -> 'a Std.Monad.Fail.S.t", "Monads.Std.Monad.Fail.S.html#VALfail", "<div class=\"info\">\n<p><code class=\"code\">fail&nbsp;err</code> diverges the computation, possibly providing an\n            extra information in a value of type <code class=\"code\">_&nbsp;error</code>.</p>\n\n</div>\n", ["COMPUTATION", "DIVERGES", "ERR", "ERROR", "EXTRA", "FAIL", "INFORMATION", "POSSIBLY", "PROVIDING", "THE", "TYPE", "VALUE"]);
add_ocaml_element("plus", "Std.Monad.Plus.S2.plus", "value", "('a, 'e) Std.Monad.Plus.S2.t ->\n  ('a, 'e) Std.Monad.Plus.S2.t -> ('a, 'e) Std.Monad.Plus.S2.t", "Monads.Std.Monad.Plus.S2.html#VALplus", "<div class=\"info\">\n<p><code class=\"code\">plus&nbsp;x&nbsp;y</code> an associative operation.</p>\n\n</div>\n", ["ASSOCIATIVE", "OPERATION", "PLUS"]);
add_ocaml_element("zero", "Std.Monad.Plus.S2.zero", "value", "unit -> ('a, 'e) Std.Monad.Plus.S2.t", "Monads.Std.Monad.Plus.S2.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero&nbsp;()</code> constructs a zero element</p>\n\n</div>\n", ["CONSTRUCTS", "ELEMENT", "ZERO"]);
add_ocaml_element("plus", "Std.Monad.Plus.S.plus", "value", "'a Std.Monad.Plus.S.t ->\n  'a Std.Monad.Plus.S.t -> 'a Std.Monad.Plus.S.t", "Monads.Std.Monad.Plus.S.html#VALplus", "<div class=\"info\">\n<p><code class=\"code\">plus&nbsp;x&nbsp;y</code> an associative operation.</p>\n\n</div>\n", ["ASSOCIATIVE", "OPERATION", "PLUS"]);
add_ocaml_element("zero", "Std.Monad.Plus.S.zero", "value", "unit -> 'a Std.Monad.Plus.S.t", "Monads.Std.Monad.Plus.S.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero&nbsp;()</code> constructs a zero element</p>\n\n</div>\n", ["CONSTRUCTS", "ELEMENT", "ZERO"]);
add_ocaml_element("plus", "Std.Monoid.Base.plus", "value", "Std.Monoid.Base.t ->\n  Std.Monoid.Base.t -> Std.Monoid.Base.t", "Monads.Std.Monoid.Base.html#VALplus", "<div class=\"info\">\n<p><code class=\"code\">plus&nbsp;x&nbsp;y</code> an associative operation.</p>\n\n</div>\n", ["ASSOCIATIVE", "OPERATION", "PLUS"]);
add_ocaml_element("zero", "Std.Monoid.Base.zero", "value", "Std.Monoid.Base.t", "Monads.Std.Monoid.Base.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero</code> an element that is neutral to <code class=\"code\">plus</code></p>\n\n</div>\n", ["ELEMENT", "NEUTRAL", "PLUS", "THAT", "ZERO"]);
add_ocaml_element("(@@)", "Std.Monoid.S.(@@)", "value", "t -> t -> t", "Monads.Std.Monoid.S.html#VAL(@@)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;@@&nbsp;y</code> is <code class=\"code\">plus&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["PLUS"]);
add_ocaml_element("concat", "Std.Monoid.S.concat", "value", "t list -> t", "Monads.Std.Monoid.S.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat&nbsp;xs</code> reduces <code class=\"code\">xs</code> to using <code class=\"code\">plus</code></p>\n\n</div>\n", ["CONCAT", "PLUS", "REDUCES", "USING"]);
add_ocaml_element("of_string", "Std.Bytes.Unsafe.of_string", "value", "string -> Std.Bytes.t", "Regular.Std.Bytes.Unsafe.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;s</code> - unsafely converts a shared string to a byte\n          sequence that should not be mutated.</p>\n\n</div>\n", ["ABOUT", "ALSO", "ALWAYS", "AND", "APPLIES", "ARE", "ASSUME", "ASSUMING", "BECAUSE", "BUG", "BUILT", "BUT", "BYTE", "BYTES", "CASE", "COMPILER", "CONFIDENCE", "CONVERTS", "COPY", "CORRECT", "CORRECTLY", "COULD", "DECLARATION", "DIFFICULT", "DISCIPLINE", "EXAMPLE", "EXTREMELY", "FIRST", "FOO", "FOR", "FROM", "FROM_BYTES", "FUNCTIONS", "GENERALLY", "HAVE", "HELLO", "IMMUTABLE", "IMPLICITLY", "INCORRECT", "INCREMENTAL", "LET", "LEVEL", "LIKE", "LITERAL", "LITERALS", "LOW", "MAKES", "MANIPULATE", "MARSHAL", "MAY", "MIGRATION", "MODE", "MORE", "MUST", "MUTATE", "MUTATED", "MUTATING", "NEVER", "NOT", "OF_STRING", "ONLY", "OPERATING", "OTHER", "OWN", "OWNED", "OWNER", "OWNERSHIP", "PARTLY", "PARTS", "PERFORMS", "POSSIBLY", "PRACTICE", "PRESERVE", "PREVIOUSLY", "PRODUCED", "PROGRAM", "PROGRAMS", "PURPOSE", "REASON", "REASONABLE", "REPRESENTATION", "RESULT", "RETURN", "ROPE", "SAFE", "SAME", "SECOND", "SEQUENCE", "SEQUENCES", "SHARED", "SHOULD", "STRING", "STRINGS", "THAT", "THE", "THEM", "THEY", "THIS", "THUS", "TO_STRING", "TYPE", "UNIQUE", "UNIQUELY", "UNSAFE", "UNSAFELY", "USE", "USED", "USEFUL", "VALUE", "VALUES", "VERSION", "WERE", "WHICH", "WILL", "WITH", "YOU"]);
add_ocaml_element("to_string", "Std.Bytes.Unsafe.to_string", "value", "Std.Bytes.t -> string", "Regular.Std.Bytes.Unsafe.html#VALto_string", "<div class=\"info\">\n<p><code class=\"code\">to_string&nbsp;b</code> - unsafely converts a byte sequence into a string.</p>\n\n</div>\n", ["ABOUT", "ACCESS", "ACCESSED", "ADDITIONAL", "AFFECTS", "AFTER", "AGAIN", "ALSO", "AND", "ANOTHER", "APPLICABLE", "APPLIED", "ARE", "ARGUMENT", "ASSUME", "BACK", "BECAUSE", "BECOME", "BORROWED", "BORROWS", "BUILDING", "BUT", "BYTE", "BYTES", "BYTES_LENGTH", "CALL", "CALLED", "CALLER", "CAN", "CANNOT", "CAPTURE", "CASE", "CASES", "CHANGED", "CHANNEL", "CLOSURE", "CODE", "COMBINATOR", "CONCURRENT", "CONSIDER", "CONVENIENT", "CONVERTS", "CORRECT", "COULD", "COVER", "CREATE", "CREATING", "DATA", "DECIDE", "DISCIPLINE", "DISJOINT", "DOES", "DONE", "EITHER", "ENDED", "ESCAPE", "EXPECTS", "FOR", "FULLY", "FUNCTION", "FUNCTIONS", "FUTURE", "GAINS", "GIVE", "GIVEN", "GIVES", "GIVING", "HAS", "HAVE", "HIGHER", "IMMUTABLE", "INCLUDING", "INIT", "INITIALIZATION", "INITIALIZING", "INTO", "ITS", "KNOW", "LATER", "LEN", "LENGTH", "LET", "LINEAR", "MAKE", "MANIPULATES", "MAP", "MAPI", "MAY", "MEANS", "MEMOIZATION", "MODES", "MOST", "MUTATE", "MUTATED", "MUTATING", "MUTATION", "NEVER", "NEW", "NOT", "NOTE", "ONLY", "ORDER", "OVER", "OWNED", "OWNER", "OWNERS", "OWNERSHIP", "OWNS", "PARAMETER", "PASS", "PASSED", "PASSING", "PERFORMED", "PIECE", "PREFER", "PROGRAMS", "PROMISE", "PROVIDED", "REASON", "RESPECT", "RESULTING", "RETURNED", "RETURNS", "RIGHTS", "SAFE", "SAFELY", "SEES", "SEQUENCE", "SET", "SEVERAL", "SHARED", "SHOULD", "SIDE", "SOME", "STILL", "STRING", "STRINGS", "STRING_INIT", "SUCH", "TEMPORARILY", "THAT", "THE", "THERE", "THIS", "THOSE", "TO_STRING", "TWO", "UNIQUE", "UNIQUELY", "UNSAFE", "UNSAFELY", "UNTIL", "USE", "USED", "VALID", "WAS", "WAY", "WHEN", "WHENEVER", "WHICH", "WHILE", "WILL", "WOULD", "WRITE", "YOU"]);
add_ocaml_element("subo", "Std.Bytes.To_string.subo", "value", "(Std.Bytes.t, string) Blit.subo", "Regular.Std.Bytes.To_string.html#VALsubo", "", []);
add_ocaml_element("sub", "Std.Bytes.To_string.sub", "value", "(Std.Bytes.t, string) Blit.sub", "Regular.Std.Bytes.To_string.html#VALsub", "", []);
add_ocaml_element("unsafe_blit", "Std.Bytes.To_string.unsafe_blit", "value", "(Std.Bytes.t, Std.Bytes.t) Blit.blit", "Regular.Std.Bytes.To_string.html#VALunsafe_blit", "<div class=\"info\">\n<span class=\"deprecated\"></span></div>\n", ["BYTES", "DEPRECATED", "INSTEAD", "THE", "UNSAFE_BLIT", "USE"]);
add_ocaml_element("blito", "Std.Bytes.To_string.blito", "value", "(Std.Bytes.t, Std.Bytes.t) Blit.blito", "Regular.Std.Bytes.To_string.html#VALblito", "<div class=\"info\">\n<span class=\"deprecated\"></span></div>\n", ["BLITO", "BYTES", "DEPRECATED", "INSTEAD", "THE", "USE"]);
add_ocaml_element("blit", "Std.Bytes.To_string.blit", "value", "(Std.Bytes.t, Std.Bytes.t) Blit.blit", "Regular.Std.Bytes.To_string.html#VALblit", "<div class=\"info\">\n<span class=\"deprecated\"></span></div>\n", ["BLIT", "BYTES", "DEPRECATED", "INSTEAD", "THE", "USE"]);
add_ocaml_element("uncapitalize", "Std.Bytes.uncapitalize", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALuncapitalize", "<div class=\"info\">\n<p><code class=\"code\">uncapitalize&nbsp;t</code> returns a copy of <code class=\"code\">t</code>, with the first byte set\n        to lowercase.</p>\n\n</div>\n", ["BYTE", "COPY", "FIRST", "LOWERCASE", "RETURNS", "SET", "THE", "UNCAPITALIZE", "WITH"]);
add_ocaml_element("capitalize", "Std.Bytes.capitalize", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALcapitalize", "<div class=\"info\">\n<p><code class=\"code\">capitalize&nbsp;t</code> returns a copy of <code class=\"code\">t</code>, with the first byte set\n        to uppercase.</p>\n\n</div>\n", ["BYTE", "CAPITALIZE", "COPY", "FIRST", "RETURNS", "SET", "THE", "UPPERCASE", "WITH"]);
add_ocaml_element("lowercase", "Std.Bytes.lowercase", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALlowercase", "<div class=\"info\">\n<p><code class=\"code\">lowercase&nbsp;t</code> returns a copy of <code class=\"code\">t</code>, with all uppercase letters\n        translated to lowercase, including accented letters of the ISO\n        Latin-1 (8859-1) character set.</p>\n\n</div>\n", ["8859", "ACCENTED", "ALL", "CHARACTER", "COPY", "INCLUDING", "ISO", "LATIN", "LETTERS", "LOWERCASE", "RETURNS", "SET", "THE", "TRANSLATED", "UPPERCASE", "WITH"]);
add_ocaml_element("uppercase", "Std.Bytes.uppercase", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALuppercase", "<div class=\"info\">\n<p><code class=\"code\">uppercase&nbsp;t</code> returns a copy of <code class=\"code\">t</code>, with all lowercase letters\n        translated to uppercase, including accented letters of the ISO\n        Latin-1 (8859-1) character set.</p>\n\n</div>\n", ["8859", "ACCENTED", "ALL", "CHARACTER", "COPY", "INCLUDING", "ISO", "LATIN", "LETTERS", "LOWERCASE", "RETURNS", "SET", "THE", "TRANSLATED", "UPPERCASE", "WITH"]);
add_ocaml_element("rcontains_from", "Std.Bytes.rcontains_from", "value", "Std.Bytes.t -> int -> char -> bool", "Regular.Std.Bytes.html#VALrcontains_from", "<div class=\"info\">\n<p><code class=\"code\">rcontains_from&nbsp;s&nbsp;stop&nbsp;c</code> tests if byte <code class=\"code\">c</code> appears in <code class=\"code\">s</code> before\n        position <code class=\"code\">stop+1</code>.</p>\n\n</div>\n", ["APPEARS", "BEFORE", "BYTE", "INVALID_ARGUMENT", "NOT", "POSITION", "RAISE", "RCONTAINS_FROM", "STOP", "TESTS", "VALID"]);
add_ocaml_element("contains_from", "Std.Bytes.contains_from", "value", "Std.Bytes.t -> int -> char -> bool", "Regular.Std.Bytes.html#VALcontains_from", "<div class=\"info\">\n<p><code class=\"code\">contains_from&nbsp;s&nbsp;start&nbsp;c</code> tests if byte <code class=\"code\">c</code> appears in <code class=\"code\">s</code> after\n        position <code class=\"code\">start</code>.</p>\n\n</div>\n", ["AFTER", "APPEARS", "BYTE", "CONTAINS", "CONTAINS_FROM", "EQUIVALENT", "INVALID_ARGUMENT", "NOT", "POSITION", "RAISE", "START", "TESTS", "VALID"]);
add_ocaml_element("contains", "Std.Bytes.contains", "value", "Std.Bytes.t -> char -> bool", "Regular.Std.Bytes.html#VALcontains", "<div class=\"info\">\n<p><code class=\"code\">contains&nbsp;s&nbsp;c</code> tests if byte <code class=\"code\">c</code> appears in <code class=\"code\">s</code>.</p>\n\n</div>\n", ["APPEARS", "BYTE", "CONTAINS", "TESTS"]);
add_ocaml_element("rindex_from", "Std.Bytes.rindex_from", "value", "Std.Bytes.t -> int -> char -> int", "Regular.Std.Bytes.html#VALrindex_from", "<div class=\"info\">\n<p><code class=\"code\">rindex_from&nbsp;s&nbsp;i&nbsp;c</code> returns the index of the last occurrence of\n        byte <code class=\"code\">c</code> in <code class=\"code\">s</code> before position <code class=\"code\">i+1</code>.</p>\n\n</div>\n", ["BEFORE", "BYTE", "DOES", "EQUIVALENT", "INDEX", "INVALID_ARGUMENT", "LAST", "LENGTH", "NOT", "NOT_FOUND", "OCCUR", "OCCURRENCE", "POSITION", "RAISE", "RETURNS", "RINDEX", "RINDEX_FROM", "THE", "VALID"]);
add_ocaml_element("index_from", "Std.Bytes.index_from", "value", "Std.Bytes.t -> int -> char -> int", "Regular.Std.Bytes.html#VALindex_from", "<div class=\"info\">\n<p><code class=\"code\">index_from&nbsp;s&nbsp;i&nbsp;c</code> returns the index of the first occurrence of\n        byte <code class=\"code\">c</code> in <code class=\"code\">s</code> after position <code class=\"code\">i</code>.</p>\n\n</div>\n", ["AFTER", "BYTE", "DOES", "EQUIVALENT", "FIRST", "INDEX", "INDEX_FROM", "INVALID_ARGUMENT", "NOT", "NOT_FOUND", "OCCUR", "OCCURRENCE", "POSITION", "RAISE", "RETURNS", "THE", "VALID"]);
add_ocaml_element("rindex", "Std.Bytes.rindex", "value", "Std.Bytes.t -> char -> int", "Regular.Std.Bytes.html#VALrindex", "<div class=\"info\">\n<p><code class=\"code\">rindex&nbsp;s&nbsp;c</code> returns the index of the last occurrence of byte <code class=\"code\">c</code>\n        in <code class=\"code\">s</code>.</p>\n\n</div>\n", ["BYTE", "DOES", "INDEX", "LAST", "NOT", "NOT_FOUND", "OCCUR", "OCCURRENCE", "RAISE", "RETURNS", "RINDEX", "THE"]);
add_ocaml_element("index", "Std.Bytes.index", "value", "Std.Bytes.t -> char -> int", "Regular.Std.Bytes.html#VALindex", "<div class=\"info\">\n<p><code class=\"code\">index&nbsp;s&nbsp;c</code> returns the index of the first occurrence of byte <code class=\"code\">c</code>\n        in <code class=\"code\">s</code>.</p>\n\n</div>\n", ["BYTE", "DOES", "FIRST", "INDEX", "NOT", "NOT_FOUND", "OCCUR", "OCCURRENCE", "RAISE", "RETURNS", "THE"]);
add_ocaml_element("escaped", "Std.Bytes.escaped", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALescaped", "<div class=\"info\">\n<p><code class=\"code\">escaped&nbsp;t</code> returns a copy of <code class=\"code\">t</code>, with special characters\n        represented by escape sequences, following the lexical\n        conventions of OCaml.</p>\n\n</div>\n", ["BYTES", "CHARACTERS", "CONVENTIONS", "COPY", "ESCAPE", "ESCAPED", "FOLLOWING", "INVALID_ARGUMENT", "LEXICAL", "LONGER", "MAX_STRING_LENGTH", "OCAML", "RAISE", "REPRESENTED", "RESULT", "RETURNS", "SEQUENCES", "SPECIAL", "SYS", "THAN", "THE", "WITH"]);
add_ocaml_element("trim", "Std.Bytes.trim", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALtrim", "<div class=\"info\">\n<p><code class=\"code\">trim&nbsp;t</code> returns a copy of <code class=\"code\">t</code>, without leading and trailing\n        whitespace.</p>\n\n</div>\n", ["012", "AND", "ARE", "ASCII", "BYTES", "CHARACTERS", "COPY", "LEADING", "REGARDED", "RETURNS", "THE", "TRAILING", "TRIM", "WHITESPACE", "WITHOUT"]);
add_ocaml_element("mapi", "Std.Bytes.mapi", "value", "Std.Bytes.t -> f:(int -> char -> char) -> Std.Bytes.t", "Regular.Std.Bytes.html#VALmapi", "<div class=\"info\">\n<p><code class=\"code\">mapi&nbsp;s&nbsp;~f</code> calls <code class=\"code\">f</code> with each character of <code class=\"code\">s</code> and its\n        index (in increasing index order) and stores the resulting bytes\n        in a new sequence that is returned as the result.</p>\n\n</div>\n", ["AND", "BYTES", "CALLS", "CHARACTER", "EACH", "INCREASING", "INDEX", "ITS", "MAPI", "NEW", "ORDER", "RESULT", "RESULTING", "RETURNED", "SEQUENCE", "STORES", "THAT", "THE", "WITH"]);
add_ocaml_element("map", "Std.Bytes.map", "value", "Std.Bytes.t -> f:(char -> char) -> Std.Bytes.t", "Regular.Std.Bytes.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;s&nbsp;~f</code> applies function <code class=\"code\">f</code> in turn to all the bytes of <code class=\"code\">s</code>\n        (in increasing index order) and stores the resulting bytes in\n        a new sequence that is returned as the result.</p>\n\n</div>\n", ["ALL", "AND", "APPLIES", "BYTES", "FUNCTION", "INCREASING", "INDEX", "MAP", "NEW", "ORDER", "RESULT", "RESULTING", "RETURNED", "SEQUENCE", "STORES", "THAT", "THE", "TURN"]);
add_ocaml_element("iteri", "Std.Bytes.iteri", "value", "Std.Bytes.t -> f:(int -> char -> unit) -> unit", "Regular.Std.Bytes.html#VALiteri", "<div class=\"info\">\n<p><code class=\"code\">iteri&nbsp;t&nbsp;~f</code> same as <code class=\"code\">iter</code>, but the function is\n        applied to the index of the byte as first argument and the\n        byte itself as second argument.</p>\n\n</div>\n", ["AND", "APPLIED", "ARGUMENT", "BUT", "BYTE", "FIRST", "FUNCTION", "INDEX", "ITER", "ITERI", "ITSELF", "SAME", "SECOND", "THE"]);
add_ocaml_element("cat", "Std.Bytes.cat", "value", "Std.Bytes.t -> Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALcat", "<div class=\"info\">\n<p><code class=\"code\">cat&nbsp;s1&nbsp;s2</code> concatenates <code class=\"code\">s1</code> and <code class=\"code\">s2</code> and returns the result\n         as new byte sequence.</p>\n\n</div>\n", ["AND", "BYTE", "BYTES", "CAT", "CONCATENATES", "INVALID_ARGUMENT", "LONGER", "MAX_STRING_LENGTH", "NEW", "RAISE", "RESULT", "RETURNS", "SEQUENCE", "SYS", "THAN", "THE"]);
add_ocaml_element("concat", "Std.Bytes.concat", "value", "Std.Bytes.t -> Std.Bytes.t list -> Std.Bytes.t", "Regular.Std.Bytes.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat&nbsp;sep&nbsp;sl</code> concatenates the list of byte sequences <code class=\"code\">sl</code>,\n        inserting the separator byte sequence <code class=\"code\">sep</code> between each, and\n        returns the result as a new byte sequence.</p>\n\n</div>\n", ["AND", "BETWEEN", "BYTE", "BYTES", "CONCAT", "CONCATENATES", "EACH", "INSERTING", "INVALID_ARGUMENT", "LIST", "LONGER", "MAX_STRING_LENGTH", "NEW", "RAISE", "RESULT", "RETURNS", "SEP", "SEPARATOR", "SEQUENCE", "SEQUENCES", "SYS", "THAN", "THE"]);
add_ocaml_element("fill", "Std.Bytes.fill", "value", "Std.Bytes.t -> int -> int -> char -> unit", "Regular.Std.Bytes.html#VALfill", "<div class=\"info\">\n<p><code class=\"code\">fill&nbsp;s&nbsp;start&nbsp;len&nbsp;c</code> modifies <code class=\"code\">s</code> in place, replacing <code class=\"code\">len</code>\n        characters with <code class=\"code\">c</code>, starting at <code class=\"code\">start</code>.</p>\n\n</div>\n", ["AND", "CHARACTERS", "DESIGNATE", "FILL", "INVALID_ARGUMENT", "LEN", "MODIFIES", "NOT", "PLACE", "RAISE", "RANGE", "REPLACING", "START", "STARTING", "VALID", "WITH"]);
add_ocaml_element("extend", "Std.Bytes.extend", "value", "Std.Bytes.t -> int -> int -> Std.Bytes.t", "Regular.Std.Bytes.html#VALextend", "<div class=\"info\">\n<p><code class=\"code\">extend&nbsp;s&nbsp;left&nbsp;right</code> returns a new byte sequence that contains\n        the bytes of <code class=\"code\">s</code>, with <code class=\"code\">left</code> uninitialized bytes prepended and\n        <code class=\"code\">right</code> uninitialized bytes appended to it.</p>\n\n</div>\n", ["AND", "APPENDED", "ARE", "BYTE", "BYTES", "CONTAINS", "CORRESPONDING", "EXTEND", "FROM", "INSTEAD", "INVALID_ARGUMENT", "LEFT", "LENGTH", "LONGER", "MAX_STRING_LENGTH", "NEGATIVE", "NEW", "PREPENDED", "RAISE", "REMOVED", "RESULT", "RETURNS", "RIGHT", "SEQUENCE", "SIDE", "SYS", "THAN", "THAT", "THE", "THEN", "UNINITIALIZED", "WITH"]);
add_ocaml_element("to_string", "Std.Bytes.to_string", "value", "Std.Bytes.t -> string", "Regular.Std.Bytes.html#VALto_string", "<div class=\"info\">\n<p><code class=\"code\">to_string&nbsp;t</code> returns a new string that contains the same\n        bytes as the given byte sequence.</p>\n\n</div>\n", ["BYTE", "BYTES", "CONTAINS", "GIVEN", "NEW", "RETURNS", "SAME", "SEQUENCE", "STRING", "THAT", "THE", "TO_STRING"]);
add_ocaml_element("of_string", "Std.Bytes.of_string", "value", "string -> Std.Bytes.t", "Regular.Std.Bytes.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;s</code> returns a new byte sequence that contains the\n        same bytes as the given string.</p>\n\n</div>\n", ["BYTE", "BYTES", "CONTAINS", "GIVEN", "NEW", "OF_STRING", "RETURNS", "SAME", "SEQUENCE", "STRING", "THAT", "THE"]);
add_ocaml_element("copy", "Std.Bytes.copy", "value", "Std.Bytes.t -> Std.Bytes.t", "Regular.Std.Bytes.html#VALcopy", "<div class=\"info\">\n<p><code class=\"code\">copy&nbsp;t</code> returns a new byte sequence that contains the same\n        bytes as <code class=\"code\">t</code>.</p>\n\n</div>\n", ["BYTE", "BYTES", "CONTAINS", "COPY", "NEW", "RETURNS", "SAME", "SEQUENCE", "THAT", "THE"]);
add_ocaml_element("set", "Std.Bytes.set", "value", "Std.Bytes.t -> int -> char -> unit", "Regular.Std.Bytes.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;s&nbsp;n&nbsp;c</code> modifies <code class=\"code\">s</code> in place, replacing the byte at index <code class=\"code\">n</code>\n        with <code class=\"code\">c</code>.</p>\n\n</div>\n", ["BYTE", "INDEX", "INVALID_ARGUMENT", "MODIFIES", "NOT", "PLACE", "RAISE", "REPLACING", "SET", "THE", "VALID", "WITH"]);
add_ocaml_element("get", "Std.Bytes.get", "value", "Std.Bytes.t -> int -> char", "Regular.Std.Bytes.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;s&nbsp;n</code> returns the byte at index <code class=\"code\">n</code> in <code class=\"code\">s</code>.</p>\n\n</div>\n", ["BYTE", "GET", "INDEX", "INVALID_ARGUMENT", "NOT", "RAISE", "RETURNS", "THE", "VALID"]);
add_ocaml_element("length", "Std.Bytes.length", "value", "Std.Bytes.t -> int", "Regular.Std.Bytes.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;t</code> returns the length (number of bytes) of <code class=\"code\">t</code>.</p>\n\n</div>\n", ["BYTES", "LENGTH", "NUMBER", "RETURNS", "THE"]);
add_ocaml_element("empty", "Std.Bytes.empty", "value", "Std.Bytes.t", "Regular.Std.Bytes.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty</code> a byte sequence of size 0.</p>\n\n</div>\n", ["BYTE", "EMPTY", "SEQUENCE", "SIZE"]);
add_ocaml_element("init", "Std.Bytes.init", "value", "int -> f:(int -> char) -> Std.Bytes.t", "Regular.Std.Bytes.html#VALinit", "<div class=\"info\">\n<p><code class=\"code\">init&nbsp;n&nbsp;~f</code> returns a fresh byte sequence of length <code class=\"code\">n</code>, with\n        character <code class=\"code\">i</code> initialized to the result of <code class=\"code\">f&nbsp;i</code> (in increasing\n        index order).</p>\n\n</div>\n", ["BYTE", "CHARACTER", "FRESH", "INCREASING", "INDEX", "INIT", "INITIALIZED", "INVALID_ARGUMENT", "LENGTH", "MAX_STRING_LENGTH", "ORDER", "RAISE", "RESULT", "RETURNS", "SEQUENCE", "SYS", "THE", "WITH"]);
add_ocaml_element("make", "Std.Bytes.make", "value", "int -> char -> Std.Bytes.t", "Regular.Std.Bytes.html#VALmake", "<div class=\"info\">\n<p><code class=\"code\">make&nbsp;n&nbsp;c</code> returns a new byte sequence of length <code class=\"code\">n</code>, filled with\n        the byte <code class=\"code\">c</code>.</p>\n\n</div>\n", ["BYTE", "FILLED", "INVALID_ARGUMENT", "LENGTH", "MAKE", "MAX_STRING_LENGTH", "NEW", "RAISE", "RETURNS", "SEQUENCE", "SYS", "THE", "WITH"]);
add_ocaml_element("create", "Std.Bytes.create", "value", "int -> Std.Bytes.t", "Regular.Std.Bytes.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;n</code> returns a new byte sequence of length <code class=\"code\">n</code>.</p>\n\n</div>\n", ["AND", "ARBITRARY", "BYTE", "BYTES", "CONTAINS", "CREATE", "INVALID_ARGUMENT", "LENGTH", "MAX_STRING_LENGTH", "NEW", "RAISE", "RETURNS", "SEQUENCE", "SYS", "THE", "UNINITIALIZED"]);
add_ocaml_element("module_name", "Std.Minimal.module_name", "value", "string option", "Regular.Std.Regular.Minimal.html#VALmodule_name", "", []);
add_ocaml_element("hash", "Std.Minimal.hash", "value", "Std.Minimal.t -> int", "Regular.Std.Regular.Minimal.html#VALhash", "", []);
add_ocaml_element("request", "Std.Data.Cache.Service.request", "value", "'a Std.reader -> 'a Std.writer -> 'a Std.Data.Cache.t", "Regular.Std.Data.Cache.Service.html#VALrequest", "<div class=\"info\">\n<p><code class=\"code\">request&nbsp;reader&nbsp;writer</code> returns a caching service for\n            type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code>.</p>\n\n</div>\n", ["CACHING", "FOR", "READER", "REQUEST", "RETURNS", "SERVICE", "TYPE", "WRITER"]);
add_ocaml_element("provide", "Std.Data.Cache.Service.provide", "value", "Std.Data.Cache.service -> unit", "Regular.Std.Data.Cache.Service.html#VALprovide", "<div class=\"info\">\n<p><code class=\"code\">provide&nbsp;service</code> will substitute current caching service\n            with a new <code class=\"code\">service</code>.</p>\n\n</div>\n", ["CACHING", "CURRENT", "NEW", "PROVIDE", "SERVICE", "SUBSTITUTE", "WILL", "WITH"]);
add_ocaml_element("add_sexp", "Std.Data.Cache.Digest.add_sexp", "value", "Std.Data.Cache.t ->\n  ('a -> Sexp.t) -> 'a -> Std.Data.Cache.t", "Regular.Std.Data.Cache.Digest.html#VALadd_sexp", "<div class=\"info\">\n<p><code class=\"code\">add_sexp&nbsp;d&nbsp;sexp_of&nbsp;x</code> is <code class=\"code\">add&nbsp;d&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;<span class=\"constructor\">Sexp</span>.pp&nbsp;(sexp_of&nbsp;x)</code></p>\n\n</div>\n", ["ADD", "ADD_SEXP", "SEXP", "SEXP_OF"]);
add_ocaml_element("add", "Std.Data.Cache.Digest.add", "value", "Std.Data.Cache.t ->\n  ('a, Stdlib.Format.formatter, unit, Std.Data.Cache.t)\n  format4 -> 'a", "Regular.Std.Data.Cache.Digest.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;digest&nbsp;fmt&nbsp;x&nbsp;y&nbsp;z&nbsp;...</code> is a variadic function that\n            builds a string from arguments <code class=\"code\">x&nbsp;y&nbsp;z&nbsp;...</code> using specified\n            format <code class=\"code\">fmt</code> and adds this string to the digest.</p>\n\n</div>\n", ["ADD", "ADDS", "AND", "ARGUMENTS", "BUILDS", "DIGEST", "FMT", "FORMAT", "FROM", "FUNCTION", "SPECIFIED", "STRING", "THAT", "THE", "THIS", "USING", "VARIADIC"]);
add_ocaml_element("create", "Std.Data.Cache.Digest.create", "value", "namespace:string -> Std.Data.Cache.t", "Regular.Std.Data.Cache.Digest.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;~namespace</code> create a digest initialized with the\n            given <code class=\"code\">namespace</code>.</p>\n\n</div>\n", ["BUILD", "CACHING", "CANDIDATE", "CREATE", "DATA", "DIFFERENT", "DIGEST", "DIGESTS", "DISTINGUISH", "FLAT", "FOR", "FUNCTIONS", "GIVEN", "GOOD", "HAVE", "INITIALIZED", "KEYS", "MODULE", "NAME", "NAMESPACE", "PARAMETER", "PARAMETERS", "SAME", "SERVICE", "SINCE", "THAT", "THE", "USED", "USING", "WITH"]);
add_ocaml_element("save", "Std.Data.Cache.save", "value", "'a Std.Data.Cache.t -> Std.digest -> 'a -> unit", "Regular.Std.Data.Cache.html#VALsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;cls&nbsp;digest&nbsp;x</code> stores entry <code class=\"code\">x</code> with a given <code class=\"code\">digest</code>\n          to the cache.</p>\n\n</div>\n", ["CACHE", "CLS", "DIGEST", "ENTRY", "FUNCTION", "GENERIC", "GIVEN", "NOTE", "SAVE", "STORE", "STORES", "THE", "THIS", "TYPE", "USE", "VALUE", "WANT", "WITH", "YOU"]);
add_ocaml_element("load", "Std.Data.Cache.load", "value", "'a Std.Data.Cache.t -> Std.digest -> 'a option", "Regular.Std.Data.Cache.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;cls&nbsp;digest</code> loads entry with a given <code class=\"code\">digest</code> from the\n          cache.</p>\n\n</div>\n", ["CACHE", "CLS", "DIGEST", "ENTRY", "FROM", "FUNCTION", "GENERIC", "GIVEN", "LOAD", "LOADS", "NOTE", "THE", "THIS", "TYPE", "USE", "VALUE", "WANT", "WITH", "YOU"]);
add_ocaml_element("digest", "Std.Data.Cache.digest", "value", "namespace:string ->\n  ('a, Stdlib.Format.formatter, unit, Std.digest) format4 ->\n  'a", "Regular.Std.Data.Cache.html#VALdigest", "<div class=\"info\">\n<p><code class=\"code\">digest&nbsp;~namespace&nbsp;fmt&nbsp;x&nbsp;y&nbsp;z&nbsp;...</code> a variadic function to\n          create data digests.</p>\n\n</div>\n", ["ALL", "AND", "ASSUMED", "BIG", "BUILD", "BUILDING", "CACHE", "CACHED", "COMPLEXITY", "COMPUTATION", "CONSTITUTING", "CONVERT", "CREATE", "CREATED", "DATA", "DIGEST", "DIGESTS", "EAGERLY", "ELEMENTS", "EXAMPLE", "FIELD", "FIRST", "FMT", "FOR", "FUNCTION", "HAS", "HUNDREDS", "IGNORE", "INCREMENTALLY", "LANG", "LET", "LIKE", "MEGABYTES", "MODULE", "NAME", "NAMESPACE", "NOTE", "PARENT", "PRINTF", "SIZE", "SPACE", "STRING", "STUDENT", "THAT", "THE", "THEN", "TIME", "TOO", "TOTAL", "TRANSPARENT", "TYPE", "USE", "VARIADIC", "WHERE", "WHOLE", "WILL"]);
add_ocaml_element("create", "Std.Data.Cache.create", "value", "load:(Std.digest -> 'a option) ->\n  save:(Std.digest -> 'a -> unit) -> 'a Std.Data.Cache.t", "Regular.Std.Data.Cache.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;~load&nbsp;~save</code> creates a cache provider.</p>\n\n</div>\n", ["CACHE", "CREATE", "CREATES", "LOAD", "PROVIDER", "SAVE"]);
add_ocaml_element("blit_to_bigstring", "Std.Data.Write.blit_to_bigstring", "value", "'a Std.Data.Write.t -> bigstring -> 'a -> int -> unit", "Regular.Std.Data.Write.html#VALblit_to_bigstring", "<div class=\"info\">\n<p><code class=\"code\">blit_to_bigstring&nbsp;writeable&nbsp;buf&nbsp;value&nbsp;pos</code> copies a\n          serialized representation of the <code class=\"code\">value</code> into existing\n          bigstring <code class=\"code\">buf</code>, starting from the given position.</p>\n\n</div>\n", ["BEHAVIOR", "BIGSTRING", "BLIT_TO_BIGSTRING", "BUF", "COPIES", "DOESN", "EXISTING", "FIT", "FROM", "GIVEN", "INTO", "POS", "POSITION", "REPRESENTATION", "SERIALIZED", "STARTING", "STRING", "THE", "UNDEFINED", "VALUE", "WRITEABLE"]);
add_ocaml_element("blit_to_bytes", "Std.Data.Write.blit_to_bytes", "value", "'a Std.Data.Write.t -> Std.bytes -> 'a -> int -> unit", "Regular.Std.Data.Write.html#VALblit_to_bytes", "<div class=\"info\">\n<p><code class=\"code\">blit_to_bytes&nbsp;writeable&nbsp;buf&nbsp;value&nbsp;pos</code> copies a serialized\n          representation of the <code class=\"code\">value</code> into existing buffer <code class=\"code\">buf</code>,\n          starting from the given position.</p>\n\n</div>\n", ["BEHAVIOR", "BLIT_TO_BYTES", "BUF", "BUFFER", "COPIES", "DOESN", "EXISTING", "FIT", "FROM", "GIVEN", "INTO", "POS", "POSITION", "REPRESENTATION", "SERIALIZED", "STARTING", "THE", "UNDEFINED", "VALUE", "WRITEABLE"]);
add_ocaml_element("blit_to_string", "Std.Data.Write.blit_to_string", "value", "'a Std.Data.Write.t -> Std.bytes -> 'a -> int -> unit", "Regular.Std.Data.Write.html#VALblit_to_string", "<div class=\"info\">\n<span class=\"deprecated\"><p><code class=\"code\">blit_to_string&nbsp;writeable&nbsp;buf&nbsp;value&nbsp;pos</code> copies a serialized\n          representation of the <code class=\"code\">value</code> into existing string <code class=\"code\">buf</code>,\n          starting from the given position.</p>\n\n</span></div>\n", ["BEHAVIOR", "BLIT_TO_BYTES", "BLIT_TO_STRING", "BUF", "COPIES", "DEPRECATED", "DOESN", "EXISTING", "FIT", "FROM", "GIVEN", "INSTEAD", "INTO", "POS", "POSITION", "REPRESENTATION", "SERIALIZED", "STARTING", "STRING", "THE", "UNDEFINED", "USE", "VALUE", "WRITEABLE"]);
add_ocaml_element("to_bigstring", "Std.Data.Write.to_bigstring", "value", "'a Std.Data.Write.t -> 'a -> bigstring", "Regular.Std.Data.Write.html#VALto_bigstring", "<div class=\"info\">\n<p><code class=\"code\">to_bigstring&nbsp;writeable&nbsp;value</code> serializes the <code class=\"code\">value</code> into\n          <code class=\"code\">bigstring</code> data type.</p>\n\n</div>\n", ["BIGSTRING", "DATA", "INTO", "SERIALIZES", "THE", "TO_BIGSTRING", "TYPE", "VALUE", "WRITEABLE"]);
add_ocaml_element("to_bytes", "Std.Data.Write.to_bytes", "value", "'a Std.Data.Write.t -> 'a -> Std.bytes", "Regular.Std.Data.Write.html#VALto_bytes", "<div class=\"info\">\n<p><code class=\"code\">to_bytes&nbsp;writeable&nbsp;value</code> serializes the <code class=\"code\">value</code> into\n          <code class=\"code\">bytes</code> data type.</p>\n\n</div>\n", ["BYTES", "DATA", "INTO", "SERIALIZES", "THE", "TO_BYTES", "TYPE", "VALUE", "WRITEABLE"]);
add_ocaml_element("to_formatter", "Std.Data.Write.to_formatter", "value", "'a Std.Data.Write.t -> Stdlib.Format.formatter -> 'a -> unit", "Regular.Std.Data.Write.html#VALto_formatter", "<div class=\"info\">\n<p><code class=\"code\">to_formatter&nbsp;writeable&nbsp;ppf&nbsp;value</code> outputs the value\n          into the formatter <code class=\"code\">ppf</code></p>\n\n</div>\n", ["FORMATTER", "INTO", "OUTPUTS", "PPF", "THE", "TO_FORMATTER", "VALUE", "WRITEABLE"]);
add_ocaml_element("to_channel", "Std.Data.Write.to_channel", "value", "'a Std.Data.Write.t -> Out_channel.t -> 'a -> unit", "Regular.Std.Data.Write.html#VALto_channel", "<div class=\"info\">\n<p><code class=\"code\">to_channel&nbsp;writeable&nbsp;out&nbsp;value</code> writes the <code class=\"code\">writable</code>\n          <code class=\"code\">value</code> into the channel <code class=\"code\">chan</code></p>\n\n</div>\n", ["CHAN", "CHANNEL", "INTO", "OUT", "THE", "TO_CHANNEL", "VALUE", "WRITABLE", "WRITEABLE", "WRITES"]);
add_ocaml_element("size", "Std.Data.Write.size", "value", "'a Std.Data.Write.t -> 'a -> int", "Regular.Std.Data.Write.html#VALsize", "<div class=\"info\">\n<p><code class=\"code\">size&nbsp;writebale&nbsp;value</code> returns a size in bytes that\n          <code class=\"code\">writeable</code> will use to write <code class=\"code\">value</code></p>\n\n</div>\n", ["BYTES", "RETURNS", "SIZE", "THAT", "USE", "VALUE", "WILL", "WRITE", "WRITEABLE", "WRITEBALE"]);
add_ocaml_element("create", "Std.Data.Write.create", "value", "?to_bytes:('a -> Std.bytes) ->\n  ?to_bigstring:('a -> bigstring) ->\n  ?dump:(Out_channel.t -> 'a -> unit) ->\n  ?pp:(Stdlib.Format.formatter -> 'a -> unit) ->\n  ?size:('a -> int) ->\n  ?blit_to_string:('a, Std.bytes) Std.Data.copy ->\n  ?blit_to_bigstring:('a, bigstring) Std.Data.copy ->\n  unit -> 'a Std.Data.Write.t", "Regular.Std.Data.Write.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;&lt;minimal-implementation&gt;</code> creates a writable\n          instance from a provided minimal implementation.</p>\n\n</div>\n", ["CREATE", "CREATES", "EITHER", "FROM", "IMPLEMENTATION", "INSTANCE", "MINIMAL", "PROVIDED", "THE", "TO_BIGSTRING", "TO_BYTES", "WRITABLE"]);
add_ocaml_element("of_bigstring", "Std.Data.Read.of_bigstring", "value", "'a Std.Data.Read.t -> bigstring -> 'a", "Regular.Std.Data.Read.html#VALof_bigstring", "<div class=\"info\">\n<p><code class=\"code\">of_bigstring&nbsp;readable&nbsp;buf</code> deserializes a <code class=\"code\">readable</code> value\n          from the bigstring.</p>\n\n</div>\n", ["BIGSTRING", "BUF", "DESERIALIZES", "FROM", "OF_BIGSTRING", "READABLE", "THE", "VALUE"]);
add_ocaml_element("of_channel", "Std.Data.Read.of_channel", "value", "'a Std.Data.Read.t -> In_channel.t -> 'a", "Regular.Std.Data.Read.html#VALof_channel", "<div class=\"info\">\n<p><code class=\"code\">of_channel&nbsp;readable&nbsp;channel</code> inputs a value from a\n          channel.</p>\n\n</div>\n", ["ANY", "ARE", "BUFFER", "BYTES", "CHANNEL", "CONTENT", "CREATED", "DISCARDED", "FROM", "FUNCTION", "INPUTS", "INTERMEDIATE", "INTO", "IN_CHANNEL", "LATER", "LEFTOVER", "OF_CHANNEL", "PROVIDED", "READ", "READABLE", "THAT", "THE", "THEN", "VALUE", "WAS", "WASN", "WHEN", "WHOLE"]);
add_ocaml_element("of_bytes", "Std.Data.Read.of_bytes", "value", "'a Std.Data.Read.t -> Std.bytes -> 'a", "Regular.Std.Data.Read.html#VALof_bytes", "<div class=\"info\">\n<p><code class=\"code\">of_bytes&nbsp;readable&nbsp;bytes</code> reads a value from <code class=\"code\">bytes</code></p>\n\n</div>\n", ["BYTES", "FROM", "OF_BYTES", "READABLE", "READS", "VALUE"]);
add_ocaml_element("create", "Std.Data.Read.create", "value", "?of_channel:(In_channel.t -> 'a) ->\n  ?of_lexbuf:(Std.Data.lexbuf -> 'a) ->\n  ?of_scanbuf:(Std.Data.scanbuf -> 'a) ->\n  ?of_bigstring:(bigstring -> 'a) ->\n  ?of_bytes:(Std.bytes -> 'a) -> unit -> 'a Std.Data.Read.t", "Regular.Std.Data.Read.html#VALcreate", "<div class=\"info\">\n<p>A minimal complete definition is any method except\n          <code class=\"code\">of_channel</code> (that is not sufficient).</p>\n\n</div>\n", ["ALL", "AND", "ANY", "CLASS", "COMPLETE", "CONSUME", "CORRESPONDINGS", "DEFINED", "DEFINITION", "EXCEPT", "FROM_BIGSTRING", "FROM_BYTES", "FROM_CHANNEL", "FUNCTION", "INPUT", "METHOD", "MINIMAL", "NOT", "OF_CHANNEL", "ONLY", "PASS", "SUFFICIENT", "THAT", "THE", "THEN", "WILL", "WITH"]);
add_ocaml_element("save", "Std.Data.S.Cache.save", "value", "Std.digest -> Std.Data.S.t -> unit", "Regular.Std.Data.S.Cache.html#VALsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;id&nbsp;data</code> store data under given <code class=\"code\">id</code>.</p>\n\n</div>\n", ["ALREADY", "DATA", "GIVEN", "OVERWRITTEN", "SAVE", "SOMETHING", "STORE", "STORED", "THEN", "UNDER", "WILL"]);
add_ocaml_element("load", "Std.Data.S.Cache.load", "value", "Std.digest -> Std.Data.S.t option", "Regular.Std.Data.S.Cache.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;id</code> load data previously stored under give <code class=\"code\">id</code></p>\n\n</div>\n", ["DATA", "GIVE", "LOAD", "PREVIOUSLY", "STORED", "UNDER"]);
add_ocaml_element("print", "Std.Data.S.Io.print", "value", "?ver:string ->\n  ?fmt:string -> Stdlib.Format.formatter -> Std.Data.S.t -> unit", "Regular.Std.Data.S.Io.html#VALprint", "<div class=\"info\">\n<p><code class=\"code\">print&nbsp;?ver&nbsp;?fmt&nbsp;ppf</code> prints datum to a given formatter, using\n            a <code class=\"code\">default_printer</code> if <code class=\"code\">fmt</code> is left unspecified.</p>\n\n</div>\n", ["DATUM", "DEFAULT_PRINTER", "FMT", "FORMATTER", "GIVEN", "LEFT", "PPF", "PRINT", "PRINTS", "UNSPECIFIED", "USING", "VER"]);
add_ocaml_element("show", "Std.Data.S.Io.show", "value", "?ver:string -> ?fmt:string -> Std.Data.S.t -> unit", "Regular.Std.Data.S.Io.html#VALshow", "<div class=\"info\">\n<p><code class=\"code\">show&nbsp;?ver&nbsp;?fmt&nbsp;datum</code> saves datum to standard output\n            channel, using a <code class=\"code\">default_printer</code> if <code class=\"code\">fmt</code> is not\n            specified.</p>\n\n</div>\n", ["CHANNEL", "DATUM", "DEFAULT_PRINTER", "DOES", "FMT", "NOT", "NOTHING", "OUTPUT", "PRINTER", "SAVES", "SET", "SHOW", "SPECIFIED", "STANDARD", "THE", "USING", "VER"]);
add_ocaml_element("dump", "Std.Data.S.Io.dump", "value", "?ver:string ->\n  ?fmt:string ->\n  Out_channel.t -> (unit -> Std.Data.S.t option) -> unit", "Regular.Std.Data.S.Io.html#VALdump", "<div class=\"info\">\n<p><code class=\"code\">dump&nbsp;?ver&nbsp;?fmt&nbsp;chan&nbsp;stream</code> dumps a <code class=\"code\">stream</code> (represented\n            by a <code class=\"code\">next</code> function) into channel.</p>\n\n</div>\n", ["CHAN", "CHANNEL", "DUMP", "DUMPS", "FMT", "FUNCTION", "INTO", "NEXT", "REPRESENTED", "STREAM", "VER"]);
add_ocaml_element("save_all", "Std.Data.S.Io.save_all", "value", "?ver:string ->\n  ?fmt:string -> Out_channel.t -> Std.Data.S.t list -> unit", "Regular.Std.Data.S.Io.html#VALsave_all", "<div class=\"info\">\n<p><code class=\"code\">save_all&nbsp;?ver&nbsp;?fmt&nbsp;data&nbsp;channel</code> saves a list of data into\n            a <code class=\"code\">channel</code></p>\n\n</div>\n", ["CHANNEL", "DATA", "FMT", "INTO", "LIST", "SAVES", "SAVE_ALL", "VER"]);
add_ocaml_element("save", "Std.Data.S.Io.save", "value", "?ver:string ->\n  ?fmt:string -> Out_channel.t -> Std.Data.S.t -> unit", "Regular.Std.Data.S.Io.html#VALsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;?ver&nbsp;?fmt&nbsp;channel&nbsp;datum</code> saves the <code class=\"code\">datum</code> to the <code class=\"code\">channel</code></p>\n\n</div>\n", ["CHANNEL", "DATUM", "FMT", "SAVE", "SAVES", "THE", "VER"]);
add_ocaml_element("write", "Std.Data.S.Io.write", "value", "?ver:string -> ?fmt:string -> string -> Std.Data.S.t -> unit", "Regular.Std.Data.S.Io.html#VALwrite", "<div class=\"info\">\n<p><code class=\"code\">write&nbsp;?ver&nbsp;?fmt&nbsp;file&nbsp;datum</code> writes the <code class=\"code\">datum</code> to the <code class=\"code\">file</code></p>\n\n</div>\n", ["DATUM", "FILE", "FMT", "THE", "VER", "WRITE", "WRITES"]);
add_ocaml_element("scan", "Std.Data.S.Io.scan", "value", "?ver:string ->\n  ?fmt:string ->\n  In_channel.t -> unit -> Std.Data.S.t option", "Regular.Std.Data.S.Io.html#VALscan", "<div class=\"info\">\n<p><code class=\"code\">scan&nbsp;?ver&nbsp;?fmt&nbsp;channel</code> creates a stream of data, that\n            are loaded consequently from the channel</p>\n\n</div>\n", ["ARE", "CHANNEL", "CONSEQUENTLY", "CREATES", "DATA", "FMT", "FROM", "LOADED", "SCAN", "STREAM", "THAT", "THE", "VER"]);
add_ocaml_element("load_all", "Std.Data.S.Io.load_all", "value", "?ver:string ->\n  ?fmt:string ->\n  ?rev:bool -> In_channel.t -> Std.Data.S.t list", "Regular.Std.Data.S.Io.html#VALload_all", "<div class=\"info\">\n<p><code class=\"code\">read_all&nbsp;?ver&nbsp;?fmt&nbsp;?rev&nbsp;channel</code> reads a sequence of datums\n            stored in the storage accessed via <code class=\"code\">channel</code> and returns it as a\n            list.</p>\n\n</div>\n", ["ACCESSED", "AND", "CHANNEL", "DATUMS", "DEFAULTS", "FALSE", "FASTER", "FMT", "LIST", "READS", "READ_ALL", "RETURNS", "REV", "REVERSED", "SEQUENCE", "SLIGHTLY", "STORAGE", "STORED", "THE", "THEN", "TRUE", "VER", "VIA", "WILL"]);
add_ocaml_element("load", "Std.Data.S.Io.load", "value", "?ver:string ->\n  ?fmt:string -> In_channel.t -> Std.Data.S.t", "Regular.Std.Data.S.Io.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;?ver&nbsp;?fmt&nbsp;channel</code> loads datum from the input channel</p>\n\n</div>\n", ["CHANNEL", "DATUM", "FMT", "FROM", "INPUT", "LOAD", "LOADS", "THE", "VER"]);
add_ocaml_element("read", "Std.Data.S.Io.read", "value", "?ver:string -> ?fmt:string -> string -> Std.Data.S.t", "Regular.Std.Data.S.Io.html#VALread", "<div class=\"info\">\n<p><code class=\"code\">read&nbsp;?ver&nbsp;?fmt&nbsp;file</code> reads datum from a <code class=\"code\">file</code></p>\n\n</div>\n", ["DATUM", "FILE", "FMT", "FROM", "READ", "READS", "VER"]);
add_ocaml_element("find_writer", "Std.Data.S.find_writer", "value", "?ver:string -> string -> Std.Data.S.t Std.writer option", "Regular.Std.Data.S.html#VALfind_writer", "<div class=\"info\">\n<p><code class=\"code\">find_writer&nbsp;?ver&nbsp;name</code> lookups a writer with a given name.</p>\n\n</div>\n", ["FIND_WRITER", "GIVEN", "LOOKUPS", "MAXIMUM", "NAME", "NOT", "RETURNED", "SPECIFIED", "THEN", "VER", "VERSION", "WITH", "WRITER"]);
add_ocaml_element("find_reader", "Std.Data.S.find_reader", "value", "?ver:string -> string -> Std.Data.S.t Std.reader option", "Regular.Std.Data.S.html#VALfind_reader", "<div class=\"info\">\n<p><code class=\"code\">find_reader&nbsp;?ver&nbsp;name</code> lookups a reader with a given name.</p>\n\n</div>\n", ["FIND_READER", "GIVEN", "LOOKUPS", "MAXIMUM", "NAME", "NOT", "READER", "RETURNED", "SPECIFIED", "THEN", "VER", "VERSION", "WITH"]);
add_ocaml_element("with_printer", "Std.Data.S.with_printer", "value", "?ver:string -> string -> (unit -> 'a) -> 'a", "Regular.Std.Data.S.html#VALwith_printer", "<div class=\"info\">\n<p><code class=\"code\">with_printer&nbsp;?ver&nbsp;name&nbsp;operation</code> temporary sets a default\n          printer to a printer with a specified name and version.</p>\n\n</div>\n", ["AFTER", "AND", "DEFAULT", "FINISHED", "NAME", "OPERATION", "PRINTER", "RESTORED", "SETS", "SPECIFIED", "TEMPORARY", "THE", "VER", "VERSION", "WITH", "WITH_PRINTER"]);
add_ocaml_element("set_default_printer", "Std.Data.S.set_default_printer", "value", "?ver:string -> string -> unit", "Regular.Std.Data.S.html#VALset_default_printer", "<div class=\"info\">\n<p><code class=\"code\">set_default_printer&nbsp;?ver&nbsp;name</code> sets new default printer.</p>\n\n</div>\n", ["AVAILABLE", "DEFAULT", "DOESN", "EXCEPTION", "EXIST", "GIVEN", "LATEST", "NAME", "NEW", "NOT", "PRINTER", "RAISES", "SETS", "SET_DEFAULT_PRINTER", "SPECIFED", "THE", "THEN", "USED", "VER", "VERSION", "WITH"]);
add_ocaml_element("default_printer", "Std.Data.S.default_printer", "value", "unit -> Std.Data.S.info option", "Regular.Std.Data.S.html#VALdefault_printer", "<div class=\"info\">\n<p><code class=\"code\">default_writer</code> optionally returns an information about\n          default printer</p>\n\n</div>\n", ["ABOUT", "DEFAULT", "DEFAULT_WRITER", "INFORMATION", "OPTIONALLY", "PRINTER", "RETURNS"]);
add_ocaml_element("with_writer", "Std.Data.S.with_writer", "value", "?ver:string -> string -> (unit -> 'a) -> 'a", "Regular.Std.Data.S.html#VALwith_writer", "<div class=\"info\">\n<p><code class=\"code\">with_writer&nbsp;?ver&nbsp;name&nbsp;operation</code> temporary sets a default\n          writer to a writer with a specified name and version.</p>\n\n</div>\n", ["AFTER", "AND", "DEFAULT", "FINISHED", "NAME", "OPERATION", "RESTORED", "SETS", "SPECIFIED", "TEMPORARY", "THE", "VER", "VERSION", "WITH", "WITH_WRITER", "WRITER"]);
add_ocaml_element("set_default_writer", "Std.Data.S.set_default_writer", "value", "?ver:string -> string -> unit", "Regular.Std.Data.S.html#VALset_default_writer", "<div class=\"info\">\n<p><code class=\"code\">set_default_writer&nbsp;?ver&nbsp;name</code> sets new default writer.</p>\n\n</div>\n", ["AVAILABLE", "DEFAULT", "DOESN", "EXCEPTION", "EXIST", "GIVEN", "LATEST", "NAME", "NEW", "NOT", "RAISES", "SETS", "SET_DEFAULT_WRITER", "SPECIFED", "THE", "THEN", "USED", "VER", "VERSION", "WITH", "WRITER"]);
add_ocaml_element("default_writer", "Std.Data.S.default_writer", "value", "unit -> Std.Data.S.info", "Regular.Std.Data.S.html#VALdefault_writer", "<div class=\"info\">\n<p><code class=\"code\">default_writer</code> returns information about the default writer</p>\n\n</div>\n", ["ABOUT", "DEFAULT", "DEFAULT_WRITER", "INFORMATION", "RETURNS", "THE", "WRITER"]);
add_ocaml_element("available_writers", "Std.Data.S.available_writers", "value", "unit -> Std.Data.S.info list", "Regular.Std.Data.S.html#VALavailable_writers", "<div class=\"info\">\n<p><code class=\"code\">available_writer&nbsp;()</code> lists available writers for the data type</p>\n\n</div>\n", ["AVAILABLE", "AVAILABLE_WRITER", "DATA", "FOR", "LISTS", "THE", "TYPE", "WRITERS"]);
add_ocaml_element("with_reader", "Std.Data.S.with_reader", "value", "?ver:string -> string -> (unit -> 'a) -> 'a", "Regular.Std.Data.S.html#VALwith_reader", "<div class=\"info\">\n<p><code class=\"code\">with_reader&nbsp;?ver&nbsp;name&nbsp;operation</code> temporary sets a default\n          reader to a reader with a specified name and version.</p>\n\n</div>\n", ["AFTER", "AND", "DEFAULT", "FINISHED", "NAME", "OPERATION", "READER", "RESTORED", "SETS", "SPECIFIED", "TEMPORARY", "THE", "VER", "VERSION", "WITH", "WITH_READER"]);
add_ocaml_element("set_default_reader", "Std.Data.S.set_default_reader", "value", "?ver:string -> string -> unit", "Regular.Std.Data.S.html#VALset_default_reader", "<div class=\"info\">\n<p><code class=\"code\">set_default_reader&nbsp;?ver&nbsp;name</code> sets new default reader.</p>\n\n</div>\n", ["AVAILABLE", "DEFAULT", "DOESN", "EXCEPTION", "EXIST", "GIVEN", "LATEST", "NAME", "NEW", "NOT", "RAISES", "READER", "SETS", "SET_DEFAULT_READER", "SPECIFED", "THE", "THEN", "USED", "VER", "VERSION", "WITH"]);
add_ocaml_element("default_reader", "Std.Data.S.default_reader", "value", "unit -> Std.Data.S.info", "Regular.Std.Data.S.html#VALdefault_reader", "<div class=\"info\">\n<p><code class=\"code\">default_reader</code> returns information about default reader</p>\n\n</div>\n", ["ABOUT", "DEFAULT", "DEFAULT_READER", "INFORMATION", "READER", "RETURNS"]);
add_ocaml_element("available_readers", "Std.Data.S.available_readers", "value", "unit -> Std.Data.S.info list", "Regular.Std.Data.S.html#VALavailable_readers", "<div class=\"info\">\n<p><code class=\"code\">available_reader&nbsp;()</code> lists available readers for the data type</p>\n\n</div>\n", ["AVAILABLE", "AVAILABLE_READER", "DATA", "FOR", "LISTS", "READERS", "THE", "TYPE"]);
add_ocaml_element("add_writer", "Std.Data.S.add_writer", "value", "?desc:string ->\n  ver:string -> string -> Std.Data.S.t Std.writer -> unit", "Regular.Std.Data.S.html#VALadd_writer", "<div class=\"info\">\n<p><code class=\"code\">add_writer&nbsp;?desc&nbsp;~ver&nbsp;name&nbsp;writer</code> registers a new <code class=\"code\">writer</code>\n          with a provided <code class=\"code\">name</code>, version <code class=\"code\">ver</code> and optional description\n          <code class=\"code\">desc</code></p>\n\n</div>\n", ["ADD_WRITER", "AND", "DESC", "DESCRIPTION", "NAME", "NEW", "OPTIONAL", "PROVIDED", "REGISTERS", "VER", "VERSION", "WITH", "WRITER"]);
add_ocaml_element("add_reader", "Std.Data.S.add_reader", "value", "?desc:string ->\n  ver:string -> string -> Std.Data.S.t Std.reader -> unit", "Regular.Std.Data.S.html#VALadd_reader", "<div class=\"info\">\n<p><code class=\"code\">add_reader&nbsp;?desc&nbsp;~ver&nbsp;name&nbsp;reader</code> registers a new <code class=\"code\">reader</code>\n          with a provided <code class=\"code\">name</code>, version <code class=\"code\">ver</code> and optional description\n          <code class=\"code\">desc</code></p>\n\n</div>\n", ["ADD_READER", "AND", "DESC", "DESCRIPTION", "NAME", "NEW", "OPTIONAL", "PROVIDED", "READER", "REGISTERS", "VER", "VERSION", "WITH"]);
add_ocaml_element("blit_to_bigstring", "Std.Data.S.blit_to_bigstring", "value", "?ver:string ->\n  ?fmt:string -> bigstring -> Std.Data.S.t -> int -> unit", "Regular.Std.Data.S.html#VALblit_to_bigstring", "<div class=\"info\">\n<p><code class=\"code\">blit_to_bigstring&nbsp;?ver&nbsp;?fmt&nbsp;buffer&nbsp;datum&nbsp;offset</code> copies a\n          serialized representation of datum into a <code class=\"code\">buffer</code>, starting from\n          <code class=\"code\">offset</code>.</p>\n\n</div>\n", ["BLIT_TO_BIGSTRING", "BUFFER", "COPIES", "DATUM", "FMT", "FROM", "INTO", "OFFSET", "REPRESENTATION", "SERIALIZED", "STARTING", "VER"]);
add_ocaml_element("to_bigstring", "Std.Data.S.to_bigstring", "value", "?ver:string -> ?fmt:string -> Std.Data.S.t -> bigstring", "Regular.Std.Data.S.html#VALto_bigstring", "<div class=\"info\">\n<p><code class=\"code\">of_bigstring&nbsp;?ver&nbsp;?fmt&nbsp;datum</code> serializes a datum to a sequence of\n          bytes represented as bigstring</p>\n\n</div>\n", ["BIGSTRING", "BYTES", "DATUM", "FMT", "OF_BIGSTRING", "REPRESENTED", "SEQUENCE", "SERIALIZES", "VER"]);
add_ocaml_element("of_bigstring", "Std.Data.S.of_bigstring", "value", "?ver:string -> ?fmt:string -> bigstring -> Std.Data.S.t", "Regular.Std.Data.S.html#VALof_bigstring", "<div class=\"info\">\n<p><code class=\"code\">of_bigstring&nbsp;?ver&nbsp;?fmt&nbsp;buf</code> deserializes a datum from bigstring</p>\n\n</div>\n", ["BIGSTRING", "BUF", "DATUM", "DESERIALIZES", "FMT", "FROM", "OF_BIGSTRING", "VER"]);
add_ocaml_element("blit_to_bytes", "Std.Data.S.blit_to_bytes", "value", "?ver:string ->\n  ?fmt:string -> Std.bytes -> Std.Data.S.t -> int -> unit", "Regular.Std.Data.S.html#VALblit_to_bytes", "<div class=\"info\">\n<p><code class=\"code\">blit_to_bytes&nbsp;?ver&nbsp;?fmt&nbsp;buffer&nbsp;datum&nbsp;offset</code> copies a\n          serialized representation of datum into a <code class=\"code\">buffer</code>, starting from\n          the <code class=\"code\">offset</code>.</p>\n\n</div>\n", ["BLIT_TO_BYTES", "BUFFER", "COPIES", "DATUM", "FMT", "FROM", "INTO", "OFFSET", "REPRESENTATION", "SERIALIZED", "STARTING", "THE", "VER"]);
add_ocaml_element("to_bytes", "Std.Data.S.to_bytes", "value", "?ver:string -> ?fmt:string -> Std.Data.S.t -> Std.bytes", "Regular.Std.Data.S.html#VALto_bytes", "<div class=\"info\">\n<p><code class=\"code\">to_bytes&nbsp;?ver&nbsp;?fmt&nbsp;datum</code> serializes a <code class=\"code\">datum</code> to a sequence of\n          bytes.</p>\n\n</div>\n", ["BYTES", "DATUM", "FMT", "SEQUENCE", "SERIALIZES", "TO_BYTES", "VER"]);
add_ocaml_element("of_bytes", "Std.Data.S.of_bytes", "value", "?ver:string -> ?fmt:string -> Std.bytes -> Std.Data.S.t", "Regular.Std.Data.S.html#VALof_bytes", "<div class=\"info\">\n<p><code class=\"code\">of_bytes&nbsp;?ver&nbsp;?fmt&nbsp;bytes</code> deserializes a value from bytes.</p>\n\n</div>\n", ["BYTES", "DESERIALIZES", "FMT", "FROM", "OF_BYTES", "VALUE", "VER"]);
add_ocaml_element("size_in_bytes", "Std.Data.S.size_in_bytes", "value", "?ver:string -> ?fmt:string -> Std.Data.S.t -> int", "Regular.Std.Data.S.html#VALsize_in_bytes", "<div class=\"info\">\n<p><code class=\"code\">size_in_bytes&nbsp;?ver&nbsp;?fmt&nbsp;datum</code> returns the amount of bytes\n          that is needed to represent <code class=\"code\">datum</code> in the given format\n          and version</p>\n\n</div>\n", ["AMOUNT", "AND", "BYTES", "DATUM", "FMT", "FORMAT", "GIVEN", "NEEDED", "REPRESENT", "RETURNS", "SIZE_IN_BYTES", "THAT", "THE", "VER", "VERSION"]);
add_ocaml_element("version", "Std.Data.S.version", "value", "string", "Regular.Std.Data.S.html#VALversion", "<div class=\"info\">\n<p>Data representation version.</p>\n\n</div>\n", ["ACCEPTABLE", "ACTUALLY", "ADDED", "AFTER", "ALSO", "AND", "ANY", "ARE", "ASSUMED", "CAN", "CASE", "CHANGE", "COMPATIBLE", "CURRENT", "DATA", "DERIVED", "EQUALITY", "FROM", "HAS", "HAVE", "INCREASED", "INDEPENDENT", "INFORMATION", "ITS", "KIND", "LOST", "MUST", "NAME", "NOT", "ONLY", "OTHER", "POSSIBLE", "READ", "READABLE", "READER", "RECOMMENDED", "REPRESENTATION", "REQUIRED", "ROUND", "SAME", "SEMANTIC", "SERIALIZER", "SERIALIZERS", "SET", "SHOULD", "SHOULDN", "SIMPLY", "SOME", "STORE", "STRUCTURE", "THAT", "THE", "THEN", "THIS", "THUS", "TRIP", "USE", "VERSION", "VERSIONING", "WAS", "WHATEVER", "WHICH", "WRITE", "WRITER", "WRITTEN"]);
add_ocaml_element("version", "Std.Data.Versioned.S.version", "value", "string", "Regular.Std.Data.Versioned.S.html#VALversion", "<div class=\"info\">\n<p>version of data representation</p>\n\n</div>\n", ["DATA", "REPRESENTATION", "VERSION"]);
add_ocaml_element("pretty_writer", "Std.Data.pretty_writer", "value", "(module Pretty_printer.S with type t = 'a) ->\n  'a Std.writer", "Regular.Std.Data.html#VALpretty_writer", "<div class=\"info\">\n<p><code class=\"code\">pretty_printer&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span></code> creates a writer that uses <code class=\"code\"><span class=\"constructor\">T</span>.pp</code>\n        function for outputting.</p>\n\n</div>\n", ["CREATES", "FOR", "FUNCTION", "MODULE", "OUTPUTTING", "PRETTY_PRINTER", "THAT", "USES", "WRITER"]);
add_ocaml_element("bin_writer", "Std.Data.bin_writer", "value", "(module Binable with type t = 'a) -> 'a Std.writer", "Regular.Std.Data.html#VALbin_writer", "<div class=\"info\">\n<p><code class=\"code\">bin_writer&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span>)</code> returns a writer in  binprot format.</p>\n\n</div>\n", ["BINPROT", "BIN_WRITER", "FORMAT", "MODULE", "RETURNS", "WRITER"]);
add_ocaml_element("bin_reader", "Std.Data.bin_reader", "value", "(module Binable with type t = 'a) -> 'a Std.reader", "Regular.Std.Data.html#VALbin_reader", "<div class=\"info\">\n<p><code class=\"code\">bin_reader&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span>)</code> returns a reader in  binprot format.</p>\n\n</div>\n", ["BINPROT", "BIN_READER", "FORMAT", "MODULE", "READER", "RETURNS"]);
add_ocaml_element("sexp_writer", "Std.Data.sexp_writer", "value", "(module Sexpable with type t = 'a) -> 'a Std.writer", "Regular.Std.Data.html#VALsexp_writer", "", []);
add_ocaml_element("sexp_reader", "Std.Data.sexp_reader", "value", "(module Sexpable with type t = 'a) -> 'a Std.reader", "Regular.Std.Data.html#VALsexp_reader", "<div class=\"info\">\n<p><code class=\"code\">sexp_reader&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span>)</code> returns a reader in  sexp format.</p>\n\n</div>\n", ["FORMAT", "MODULE", "READER", "RETURNS", "SEXP", "SEXP_READER", "SEXP_WRITER", "WRITER"]);
add_ocaml_element("marshal_writer", "Std.Data.marshal_writer", "value", "(module T with type t = 'a) -> 'a Std.writer", "Regular.Std.Data.html#VALmarshal_writer", "<div class=\"info\">\n<p><code class=\"code\">marshal_writer&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span>)</code> returns a writer in OCaml\n        <code class=\"code\"><span class=\"constructor\">Marshal</span></code> format.</p>\n\n</div>\n", ["FORMAT", "MARSHAL", "MARSHAL_WRITER", "MODULE", "OCAML", "RETURNS", "WRITER"]);
add_ocaml_element("marshal_reader", "Std.Data.marshal_reader", "value", "(module T with type t = 'a) -> 'a Std.reader", "Regular.Std.Data.html#VALmarshal_reader", "<div class=\"info\">\n<p><code class=\"code\">marshal_reader&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span>)</code> returns a reader in OCaml\n        <code class=\"code\"><span class=\"constructor\">Marshal</span></code> format.</p>\n\n</div>\n", ["FORMAT", "MARSHAL", "MARSHAL_READER", "MODULE", "OCAML", "READER", "RETURNS"]);
add_ocaml_element("pp", "Std.Seq.pp", "value", "'a Std.printer -> 'a Std.Seq.t Std.printer", "Regular.Std.Seq.html#VALpp", "", []);
add_ocaml_element("is_empty", "Std.Seq.is_empty", "value", "'a Std.Seq.t -> bool", "Regular.Std.Seq.html#VALis_empty", "", []);
add_ocaml_element("cons", "Std.Seq.cons", "value", "'a -> 'a Std.Seq.t -> 'a Std.Seq.t", "Regular.Std.Seq.html#VALcons", "", []);
add_ocaml_element("of_array", "Std.Seq.of_array", "value", "'a array -> 'a Std.Seq.t", "Regular.Std.Seq.html#VALof_array", "", []);
add_ocaml_element("compare", "Std.Seq.compare", "value", "('a -> 'b -> int) -> 'a Std.Seq.t -> 'b Std.Seq.t -> int", "Regular.Std.Seq.html#VALcompare", "", []);
add_ocaml_element("filter", "Std.Seq.filter", "value", "'a Std.Seq.t -> f:('a -> bool) -> 'a Std.Seq.t", "Regular.Std.Seq.html#VALfilter", "<div class=\"info\">\n<p>for compatibility with Core &lt;= 111.28</p>\n\n</div>\n", ["111", "COMPATIBILITY", "CORE", "FOR", "WITH"]);
add_ocaml_element("pp_seq", "Std.Printable.S.pp_seq", "value", "Stdlib.Format.formatter ->\n  Std.Printable.S.t Sequence.t -> unit", "Regular.Std.Printable.S.html#VALpp_seq", "<div class=\"info\">\n<p>prints a sequence of values of type <code class=\"code\">t</code></p>\n\n</div>\n", ["PRINTS", "SEQUENCE", "TYPE", "VALUES"]);
add_ocaml_element("ppo", "Std.Printable.S.ppo", "value", "Out_channel.t -> Std.Printable.S.t -> unit", "Regular.Std.Printable.S.html#VALppo", "<div class=\"info\">\n<p>will print to a standard <code class=\"code\">output_channel</code>, useful for using in\n          <code class=\"code\">printf</code>, <code class=\"code\">fprintf</code>, etc.</p>\n\n</div>\n", ["ETC", "FOR", "FPRINTF", "OUTPUT_CHANNEL", "PRINT", "PRINTF", "STANDARD", "USEFUL", "USING", "WILL"]);
add_ocaml_element("pps", "Std.Printable.S.pps", "value", "unit -> Std.Printable.S.t -> string", "Regular.Std.Printable.S.html#VALpps", "<div class=\"info\">\n<p>synonym for <code class=\"code\">str</code></p>\n\n</div>\n", ["FOR", "STR", "SYNONYM"]);
add_ocaml_element("str", "Std.Printable.S.str", "value", "unit -> Std.Printable.S.t -> string", "Regular.Std.Printable.S.html#VALstr", "<div class=\"info\">\n<p><code class=\"code\">str&nbsp;()&nbsp;t</code> is formatted output function that matches \"%a\"\n          conversion format specifier in functions, that prints to string,\n          e.g., <code class=\"code\">sprintf</code>, <code class=\"code\">failwithf</code>, <code class=\"code\">errorf</code> and, suprisingly all\n          <code class=\"code\"><span class=\"constructor\">Lwt</span></code> printing function, including <code class=\"code\"><span class=\"constructor\">Lwt_io</span>.printf</code> and logging\n          (or any other function with type ('a,unit,string,...)\n          formatN`.</p>\n\n</div>\n", ["ALL", "AND", "ANY", "CONVERSION", "ERRORF", "EXAMPLE", "EXP", "FAILWITHF", "FOR", "FORMAT", "FORMATN", "FORMATTED", "FUNCTION", "FUNCTIONS", "INCLUDING", "LOGGING", "LWT", "LWT_IO", "MATCHES", "NOT", "OR_ERROR", "OTHER", "OUTPUT", "PRINTF", "PRINTING", "PRINTS", "SPECIFIER", "SPRINTF", "STR", "STRING", "SUPRISINGLY", "THAT", "TYPE", "UNIT", "VALID", "WITH"]);
add_ocaml_element("to_string", "Std.Printable.S.to_string", "value", "Std.Printable.S.t -> string", "Regular.Std.Printable.S.html#VALto_string", "<div class=\"info\">\n<p><code class=\"code\">to_string&nbsp;x</code> returns a human-readable representation of <code class=\"code\">x</code></p>\n\n</div>\n", ["HUMAN", "READABLE", "REPRESENTATION", "RETURNS", "TO_STRING"]);
add_ocaml_element("(^::)", "Std.(^::)", "value", "'a -> 'a Std.seq -> 'a Std.seq", "Regular.Std.html#VAL(^::)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;^::&nbsp;xs</code> is a consing operator for sequences</p>\n\n</div>\n", ["CONSING", "FOR", "OPERATOR", "SEQUENCES"]);
add_ocaml_element("loaded", "Bap_plugins.Std.Plugins.loaded", "value", "unit Bap_future.Std.future", "Bap_plugins.Std.Plugins.html#VALloaded", "<div class=\"info\">\n<p><code class=\"code\">loaded</code> occurs when all plugins are loaded</p>\n\n</div>\n", ["ALL", "ARE", "LOADED", "OCCURS", "PLUGINS", "WHEN"]);
add_ocaml_element("events", "Bap_plugins.Std.Plugins.events", "value", "Bap_plugins.Std.Plugins.event Bap_future.Std.stream", "Bap_plugins.Std.Plugins.html#VALevents", "<div class=\"info\">\n<p>plugin subsystem event stream.</p>\n\n</div>\n", ["EVENT", "PLUGIN", "STREAM", "SUBSYSTEM"]);
add_ocaml_element("load", "Bap_plugins.Std.Plugins.load", "value", "?argv:string array ->\n  ?env:string list ->\n  ?provides:string list ->\n  ?library:string list ->\n  ?exclude:string list ->\n  unit ->\n  (Bap_plugins.Std.plugin, string * Error.t) Result.t\n  list", "Bap_plugins.Std.Plugins.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;?env&nbsp;?provides&nbsp;?library&nbsp;?exclude</code> is like <code class=\"code\">run</code>, but will not setup\n        handlers, and will return a result of loading.</p>\n\n</div>\n", ["AND", "BUT", "EACH", "EITHER", "ELEMENT", "ENV", "ERROR", "EXCLUDE", "FAILED", "GIVEN", "HANDLERS", "LIBRARY", "LIKE", "LIST", "LOAD", "LOADED", "LOADING", "NAME", "NOT", "PLUGIN", "PROVIDES", "RESULT", "RETURN", "RUN", "SETUP", "SUCCESSFULLY", "THE", "WAS", "WILL", "WITH"]);
add_ocaml_element("run", "Bap_plugins.Std.Plugins.run", "value", "?argv:string array ->\n  ?env:string list ->\n  ?provides:string list ->\n  ?don't_setup_handlers:bool ->\n  ?library:string list -> ?exclude:string list -> unit -> unit", "Bap_plugins.Std.Plugins.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;?env&nbsp;?provides&nbsp;?library&nbsp;?exclude</code> load and execute all plugins that can\n        be found in the <code class=\"code\">library</code> paths, and are not in the <code class=\"code\">exclude</code>\n        list.</p>\n\n</div>\n", ["ABORT", "ALL", "AND", "ANY", "ARE", "CAN", "CHOSEN", "DEFAULT", "DON", "ENV", "ERROR", "ERRORED", "EVENT", "EVENTS", "EXCLUDE", "EXECUTE", "FINE", "FOUND", "GRANULAR", "HANDLER", "HANDLING", "HOST", "LIBRARY", "LIST", "LOAD", "MAY", "MESSAGE", "MORE", "NOT", "OCCURS", "OPTION", "OUTPUT", "PATHS", "PLUGINS", "PRINTED", "PROGRAM", "PROVIDES", "RUN", "SETUP", "STANDARD", "THAT", "THE", "THEN", "THERE", "TREATED", "T_SETUP_HANDLERS", "WILL"]);
add_ocaml_element("list", "Bap_plugins.Std.Plugins.list", "value", "?env:string list ->\n  ?provides:string list ->\n  ?library:string list -> unit -> Bap_plugins.Std.plugin list", "Bap_plugins.Std.Plugins.html#VALlist", "<div class=\"info\">\n<p><code class=\"code\">list&nbsp;?env&nbsp;~provides:features&nbsp;?library&nbsp;()</code> scans a list of directories, provided by a\n        <code class=\"code\">library</code> parameter, and, finally, <code class=\"code\"><span class=\"constructor\">Config</span>.libdir</code> for files with\n        a <code class=\"code\">plugin</code> extension.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "CONFIG", "CONSTRAINS", "DIRECTORIES", "ENV", "EXTENSION", "FEATURES", "FILES", "FINALLY", "FOR", "HAS", "LIBDIR", "LIBRARY", "LIST", "PARAMETER", "PLUGIN", "PLUGINS", "PROVIDE", "PROVIDED", "PROVIDES", "RETURNS", "SCANS", "SUBSET", "SUPERSET", "THAT", "WITH"]);
add_ocaml_element("argv", "Bap_plugins.Std.Plugin.argv", "value", "unit -> string array", "Bap_plugins.Std.Plugin.html#VALargv", "", []);
add_ocaml_element("loaded", "Bap_plugins.Std.Plugin.loaded", "value", "Bap_plugins.Std.Plugin.t -> unit Bap_future.Std.future", "Bap_plugins.Std.Plugin.html#VALloaded", "<div class=\"info\">\n<p>loaded event happens when a pass is succesfully loaded</p>\n\n</div>\n", ["EVENT", "HAPPENS", "LOADED", "PASS", "SUCCESFULLY", "WHEN"]);
add_ocaml_element("load", "Bap_plugins.Std.Plugin.load", "value", "?argv:string array -> Bap_plugins.Std.Plugin.t -> unit Or_error.t", "Bap_plugins.Std.Plugin.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;plugin</code> load all unsatisfied dependencies of a <code class=\"code\">plugin</code>,\n        and then load the <code class=\"code\">plugin</code> itself.</p>\n\n</div>\n", ["ALL", "ALREADY", "AND", "CAN", "COMPILATION", "CONFLICT", "DEPENDENCIES", "DEPENDENCY", "ERROR", "ITSELF", "LINKED", "LOAD", "LOADED", "LOADER", "MALFORMED", "NAME", "NOTHING", "OTHER", "PACKAGE", "PLUGIN", "RAISED", "RETURN", "RETURNS", "SATISFIED", "SOME", "SYSTEM", "THE", "THEN", "THERE", "UNDERLYING", "UNIT", "UNSATISFIED", "WITH"]);
add_ocaml_element("bundle", "Bap_plugins.Std.Plugin.bundle", "value", "Bap_plugins.Std.Plugin.t -> Bap_bundle.Std.bundle", "Bap_plugins.Std.Plugin.html#VALbundle", "<div class=\"info\">\n<p><code class=\"code\">bundle&nbsp;plugin</code> returns a plugin's bundle</p>\n\n</div>\n", ["BUNDLE", "PLUGIN", "RETURNS"]);
add_ocaml_element("desc", "Bap_plugins.Std.Plugin.desc", "value", "Bap_plugins.Std.Plugin.t -> string", "Bap_plugins.Std.Plugin.html#VALdesc", "<div class=\"info\">\n<p><code class=\"code\">desc&nbsp;plugin</code> returns plugin description</p>\n\n</div>\n", ["DESC", "DESCRIPTION", "PLUGIN", "RETURNS"]);
add_ocaml_element("name", "Bap_plugins.Std.Plugin.name", "value", "Bap_plugins.Std.Plugin.t -> string", "Bap_plugins.Std.Plugin.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;plugin</code> is a plugin's name</p>\n\n</div>\n", ["NAME", "PLUGIN"]);
add_ocaml_element("path", "Bap_plugins.Std.Plugin.path", "value", "Bap_plugins.Std.Plugin.t -> string", "Bap_plugins.Std.Plugin.html#VALpath", "<div class=\"info\">\n<p><code class=\"code\">path&nbsp;plugin</code> is a plugin's path</p>\n\n</div>\n", ["PATH", "PLUGIN"]);
add_ocaml_element("of_path", "Bap_plugins.Std.Plugin.of_path", "value", "string -> Bap_plugins.Std.Plugin.t", "Bap_plugins.Std.Plugin.html#VALof_path", "<div class=\"info\">\n<p><code class=\"code\">of_path&nbsp;path</code> creates a plugin of a give <code class=\"code\">path</code></p>\n\n</div>\n", ["CREATES", "GIVE", "OF_PATH", "PATH", "PLUGIN"]);
add_ocaml_element("setup_dynamic_loader", "Bap_plugins.Std.setup_dynamic_loader", "value", "(string -> unit) -> unit", "Bap_plugins.Std.html#VALsetup_dynamic_loader", "<div class=\"info\">\n<p><code class=\"code\">setup_dynamic_loader&nbsp;loader</code> installs <code class=\"code\">loader</code> program.</p>\n\n</div>\n", ["AND", "BYTE", "DIFFERENT", "EXECUTION", "FILENAME", "FOR", "FUNCTION", "INSTALLS", "INTERNALLY", "LOADER", "LOADS", "MODES", "NATIVE", "PROGRAM", "SETUP_DYNAMIC_LOADER", "TAKES", "THE", "THIS", "TOPLEVE", "USED"]);
add_ocaml_element("list_loaded_units", "Bap_plugins.Std.list_loaded_units", "value", "unit -> string list", "Bap_plugins.Std.html#VALlist_loaded_units", "<div class=\"info\">\n<p><code class=\"code\">list_loaded_units&nbsp;()</code> evaluates to a list of compilation unit\n      names currently loaded into the system.</p>\n\n</div>\n", ["AND", "BOTH", "COMPILATION", "CURRENTLY", "DYNAMICALLY", "EVALUATES", "HOST", "INCLUDES", "INTO", "LINKED", "LIST", "LIST_LOADED_UNITS", "LOADED", "NAMES", "PROGRAM", "STATICALLY", "SYSTEM", "THAT", "THE", "THOSE", "UNIT", "UNITS", "WERE"]);
add_ocaml_element("install", "Core_printers.install", "value", "string -> unit", "Core_printers.html#VALinstall", "", []);
add_ocaml_element("pp_blang", "Core_printers.pp_blang", "value", "(Stdlib.Format.formatter -> 'a -> unit) ->\n  Stdlib.Format.formatter -> 'a Blang.t -> unit", "Core_printers.html#VALpp_blang", "", []);
add_ocaml_element("pp_hashtbl", "Core_printers.pp_hashtbl", "value", "(Stdlib.Format.formatter -> 'a Hashtbl.key -> unit) ->\n  (Stdlib.Format.formatter -> 'b -> unit) ->\n  Stdlib.Format.formatter -> ('a, 'b) Hashtbl.t -> unit", "Core_printers.html#VALpp_hashtbl", "", []);
add_ocaml_element("pp_hashset", "Core_printers.pp_hashset", "value", "'a Hash_set.elt Std.printer ->\n  Stdlib.Format.formatter -> 'a Hash_set.t -> unit", "Core_printers.html#VALpp_hashset", "", []);
add_ocaml_element("pp_fdeque", "Core_printers.pp_fdeque", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Fdeque.t -> unit", "Core_printers.html#VALpp_fdeque", "", []);
add_ocaml_element("pp_deque", "Core_printers.pp_deque", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Deque.t -> unit", "Core_printers.html#VALpp_deque", "", []);
add_ocaml_element("pp_fqueue", "Core_printers.pp_fqueue", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Fqueue.t -> unit", "Core_printers.html#VALpp_fqueue", "", []);
add_ocaml_element("pp_queue", "Core_printers.pp_queue", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Queue.t -> unit", "Core_printers.html#VALpp_queue", "", []);
add_ocaml_element("pp_bag", "Core_printers.pp_bag", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Bag.t -> unit", "Core_printers.html#VALpp_bag", "", []);
add_ocaml_element("pp_fheap", "Core_printers.pp_fheap", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Fheap.t -> unit", "Core_printers.html#VALpp_fheap", "", []);
add_ocaml_element("pp_heap", "Core_printers.pp_heap", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Heap.t -> unit", "Core_printers.html#VALpp_heap", "", []);
add_ocaml_element("pp_stack", "Core_printers.pp_stack", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Stack.t -> unit", "Core_printers.html#VALpp_stack", "", []);
add_ocaml_element("pp_doubly_linked", "Core_printers.pp_doubly_linked", "value", "'a Std.printer ->\n  Stdlib.Format.formatter -> 'a Doubly_linked.t -> unit", "Core_printers.html#VALpp_doubly_linked", "", []);
add_ocaml_element("enum", "Core_printers.enum", "value", "('a -> 'b list) -> 'a -> 'b Std.Seq.t", "Core_printers.html#VALenum", "", []);
add_ocaml_element("pp_set", "Core_printers.pp_set", "value", "'a Std.printer ->\n  'b -> Stdlib.Format.formatter -> ('a, 'c) Set.t -> unit", "Core_printers.html#VALpp_set", "", []);
add_ocaml_element("pp_map", "Core_printers.pp_map", "value", "(Stdlib.Format.formatter -> 'a -> unit) ->\n  (Stdlib.Format.formatter -> 'b -> unit) ->\n  'c -> Stdlib.Format.formatter -> ('a, 'b, 'd) Map.t -> unit", "Core_printers.html#VALpp_map", "", []);
add_ocaml_element("pair", "Core_printers.pair", "value", "(Stdlib.Format.formatter -> 'a -> unit) ->\n  (Stdlib.Format.formatter -> 'b -> unit) ->\n  Stdlib.Format.formatter -> 'a * 'b -> unit", "Core_printers.html#VALpair", "", []);
add_ocaml_element("pp_comma", "Core_printers.pp_comma", "value", "Stdlib.Format.formatter -> unit -> unit", "Core_printers.html#VALpp_comma", "", []);
add_ocaml_element("standard_library", "Bap_config.standard_library", "value", "string", "Bap_config.html#VALstandard_library", "", []);
add_ocaml_element("profile", "Bap_config.profile", "value", "string", "Bap_config.html#VALprofile", "", []);
add_ocaml_element("debug", "Bap_config.debug", "value", "string", "Bap_config.html#VALdebug", "", []);
add_ocaml_element("suffix_program", "Bap_config.suffix_program", "value", "string", "Bap_config.html#VALsuffix_program", "", []);
add_ocaml_element("psdir", "Bap_config.psdir", "value", "string", "Bap_config.html#VALpsdir", "", []);
add_ocaml_element("pdfdir", "Bap_config.pdfdir", "value", "string", "Bap_config.html#VALpdfdir", "", []);
add_ocaml_element("dvidir", "Bap_config.dvidir", "value", "string", "Bap_config.html#VALdvidir", "", []);
add_ocaml_element("htmldir", "Bap_config.htmldir", "value", "string", "Bap_config.html#VALhtmldir", "", []);
add_ocaml_element("docdir", "Bap_config.docdir", "value", "string", "Bap_config.html#VALdocdir", "", []);
add_ocaml_element("mandir", "Bap_config.mandir", "value", "string", "Bap_config.html#VALmandir", "", []);
add_ocaml_element("localedir", "Bap_config.localedir", "value", "string", "Bap_config.html#VALlocaledir", "", []);
add_ocaml_element("infodir", "Bap_config.infodir", "value", "string", "Bap_config.html#VALinfodir", "", []);
add_ocaml_element("datadir", "Bap_config.datadir", "value", "string", "Bap_config.html#VALdatadir", "", []);
add_ocaml_element("datarootdir", "Bap_config.datarootdir", "value", "string", "Bap_config.html#VALdatarootdir", "", []);
add_ocaml_element("plugindir", "Bap_config.plugindir", "value", "string", "Bap_config.html#VALplugindir", "", []);
add_ocaml_element("libdir", "Bap_config.libdir", "value", "string", "Bap_config.html#VALlibdir", "", []);
add_ocaml_element("localstatedir", "Bap_config.localstatedir", "value", "string", "Bap_config.html#VALlocalstatedir", "", []);
add_ocaml_element("sharedstatedir", "Bap_config.sharedstatedir", "value", "string", "Bap_config.html#VALsharedstatedir", "", []);
add_ocaml_element("confdir", "Bap_config.confdir", "value", "string", "Bap_config.html#VALconfdir", "", []);
add_ocaml_element("libexecdir", "Bap_config.libexecdir", "value", "string", "Bap_config.html#VALlibexecdir", "", []);
add_ocaml_element("sbindir", "Bap_config.sbindir", "value", "string", "Bap_config.html#VALsbindir", "", []);
add_ocaml_element("bindir", "Bap_config.bindir", "value", "string", "Bap_config.html#VALbindir", "", []);
add_ocaml_element("exec_prefix", "Bap_config.exec_prefix", "value", "string", "Bap_config.html#VALexec_prefix", "", []);
add_ocaml_element("prefix", "Bap_config.prefix", "value", "string", "Bap_config.html#VALprefix", "", []);
add_ocaml_element("ocaml_version", "Bap_config.ocaml_version", "value", "string", "Bap_config.html#VALocaml_version", "", []);
add_ocaml_element("architecture", "Bap_config.architecture", "value", "string", "Bap_config.html#VALarchitecture", "", []);
add_ocaml_element("system", "Bap_config.system", "value", "string", "Bap_config.html#VALsystem", "", []);
add_ocaml_element("os_type", "Bap_config.os_type", "value", "string", "Bap_config.html#VALos_type", "", []);
add_ocaml_element("version", "Bap_config.version", "value", "string", "Bap_config.html#VALversion", "", []);
add_ocaml_element("name", "Bap_config.name", "value", "string", "Bap_config.html#VALname", "", []);
add_ocaml_element("(/)", "Bap_config.(/)", "value", "string -> string -> string", "Bap_config.html#VAL(/)", "", []);
add_ocaml_element("flush", "Bap_bundle.Std.Bundle.Builder.flush", "value", "Bap_bundle.Std.Bundle.Builder.t -> Uri.t -> unit", "Bap_bundle.Std.Bundle.Builder.html#VALflush", "<div class=\"info\">\n<p><code class=\"code\">flush&nbsp;builder&nbsp;output</code> finish the building and output the\n          resulting bundle into the file <code class=\"code\">output</code>.</p>\n\n</div>\n", ["AND", "BUILDER", "BUILDING", "BUNDLE", "FILE", "FINISH", "FLUSH", "INTO", "OUTPUT", "RESULTING", "THE"]);
add_ocaml_element("embed_manifest", "Bap_bundle.Std.Bundle.Builder.embed_manifest", "value", "Bap_bundle.Std.Bundle.Builder.t -> Bap_bundle.Std.manifest -> unit", "Bap_bundle.Std.Bundle.Builder.html#VALembed_manifest", "<div class=\"info\">\n<p><code class=\"code\">embed_manifest&nbsp;builder&nbsp;manifest</code> embeds a manifest.</p>\n\n</div>\n", ["ALREADY", "BUILDER", "EMBEDDED", "EMBEDS", "EMBED_MANIFEST", "MANIFEST", "OLD", "ONE", "OVERWRITTEN", "THEN", "WAS", "WILL"]);
add_ocaml_element("put_data", "Bap_bundle.Std.Bundle.Builder.put_data", "value", "Bap_bundle.Std.Bundle.Builder.t -> name:string -> data:string -> unit", "Bap_bundle.Std.Bundle.Builder.html#VALput_data", "<div class=\"info\">\n<p><code class=\"code\">put_data&nbsp;builder&nbsp;~name&nbsp;~data</code> insert <code class=\"code\">data</code> at path\n          <code class=\"code\">name</code>.</p>\n\n</div>\n", ["BUILDER", "DATA", "INSERT", "NAME", "PATH", "PUT_DATA"]);
add_ocaml_element("put_file", "Bap_bundle.Std.Bundle.Builder.put_file", "value", "?name:string -> Bap_bundle.Std.Bundle.Builder.t -> Uri.t -> unit", "Bap_bundle.Std.Bundle.Builder.html#VALput_file", "<div class=\"info\">\n<p><code class=\"code\">put_file&nbsp;?name&nbsp;builder&nbsp;uri</code> insert a file specified by the\n          <code class=\"code\">uri</code>.</p>\n\n</div>\n", ["BUILDER", "BUNDLE", "FILE", "INSERT", "NAME", "PUT_FILE", "SPECIFIED", "STORED", "THE", "THEN", "UNDER", "URI", "WILL"]);
add_ocaml_element("create", "Bap_bundle.Std.Bundle.Builder.create", "value", "unit -> Bap_bundle.Std.Bundle.Builder.t", "Bap_bundle.Std.Bundle.Builder.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates a builder.</p>\n\n</div>\n", ["BUILDER", "CREATE", "CREATES"]);
add_ocaml_element("update", "Bap_bundle.Std.Bundle.update", "value", "Bap_bundle.Std.Bundle.t ->\n  f:(string ->\n     [ `Copy | `Drop | `Map of string -> string | `Proc of string -> unit ]) ->\n  unit", "Bap_bundle.Std.Bundle.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;bundle&nbsp;~f:action</code> add, remove or update data in the\n        bundle.</p>\n\n</div>\n", ["ACCEPTS", "ACTION", "ADD", "AND", "APPLICATION", "ARBITRARY", "ASSOCIATED", "BACK", "BAP_BUNDLE", "BEHAVIOR", "BUILDING", "BUNDLE", "CALLED", "CAN", "CONTENTS", "COPY", "CREATED", "DATA", "DROP", "EACH", "EASIER", "EXTRACT", "EXTRACTED", "FILE", "FOLLOWING", "FOR", "FROM", "FUNCTION", "GET_DATA", "GET_FILE", "INSERT_DATA", "INSERT_FILE", "INSERT_FILES", "INSTALLED", "INTENDED", "INTERFACE", "KEEP", "KNIFE", "LEAD", "MADE", "MAP", "MAY", "MODIFICATION", "MUST", "NAME", "NEW", "ONCE", "ONE", "PATH", "PLUGIN", "PROC", "PROCESS", "PUT", "READONLY", "REMOVE", "RETURN", "SEALED", "SEE", "STD", "SWISS", "TEMPORARY", "THAT", "THE", "THIS", "UNDEFINED", "UNTOUCHED", "UPDATE", "USE", "WARNING", "WHERE", "WILL", "WITH"]);
add_ocaml_element("insert_data", "Bap_bundle.Std.Bundle.insert_data", "value", "Bap_bundle.Std.Bundle.t -> name:string -> data:string -> unit", "Bap_bundle.Std.Bundle.html#VALinsert_data", "<div class=\"info\">\n<p><code class=\"code\">insert_data&nbsp;bundle&nbsp;~name&nbsp;~data</code> insert <code class=\"code\">data</code> at path <code class=\"code\">name</code>.</p>\n\n</div>\n", ["BUNDLE", "DATA", "INSERT", "INSERT_DATA", "NAME", "PATH"]);
add_ocaml_element("insert_file", "Bap_bundle.Std.Bundle.insert_file", "value", "?name:string -> Bap_bundle.Std.Bundle.t -> Uri.t -> unit", "Bap_bundle.Std.Bundle.html#VALinsert_file", "<div class=\"info\">\n<p><code class=\"code\">insert_file&nbsp;?name&nbsp;bundle&nbsp;uri</code> insert a file specified by the\n        <code class=\"code\">uri</code>.</p>\n\n</div>\n", ["BUNDLE", "FILE", "INSERT", "INSERT_FILE", "NAME", "SPECIFIED", "STORED", "THE", "THEN", "UNDER", "URI", "WILL"]);
add_ocaml_element("insert_files", "Bap_bundle.Std.Bundle.insert_files", "value", "Bap_bundle.Std.Bundle.t -> (string option * Uri.t) list -> unit", "Bap_bundle.Std.Bundle.html#VALinsert_files", "<div class=\"info\">\n<p><code class=\"code\">insert_files&nbsp;bundle&nbsp;spec</code> bundle files.</p>\n\n</div>\n", ["AND", "BUNDLE", "CONSTITUENT", "DESIRED", "ELEMENT", "FILE", "FILES", "FIRST", "INSERTED", "INSERT_FILES", "LIST", "NONE", "PAIR", "PAIRS", "PATH", "SAME", "SECOND", "SHOULD", "SPEC", "SYSTEM", "THAT", "THE", "THEN", "UNDER", "URI", "WAS", "WHERE", "WILL"]);
add_ocaml_element("update_manifest", "Bap_bundle.Std.Bundle.update_manifest", "value", "Bap_bundle.Std.Bundle.t ->\n  f:(Bap_bundle.Std.manifest -> Bap_bundle.Std.manifest) -> unit", "Bap_bundle.Std.Bundle.html#VALupdate_manifest", "<div class=\"info\">\n<p><code class=\"code\">update_manifest&nbsp;bundle&nbsp;~f</code> update program manifest with\n        function <code class=\"code\">f</code>.</p>\n\n</div>\n", ["BUNDLE", "FUNCTION", "MANIFEST", "PROGRAM", "UPDATE", "UPDATE_MANIFEST", "WITH"]);
add_ocaml_element("list", "Bap_bundle.Std.Bundle.list", "value", "Bap_bundle.Std.Bundle.t -> string list", "Bap_bundle.Std.Bundle.html#VALlist", "<div class=\"info\">\n<p><code class=\"code\">list&nbsp;bundle</code> returns a list of paths, that are accessible in\n        the <code class=\"code\">bundle</code>.</p>\n\n</div>\n", ["ACCESSIBLE", "ARE", "BUNDLE", "LIST", "PATHS", "RETURNS", "THAT", "THE"]);
add_ocaml_element("get_data", "Bap_bundle.Std.Bundle.get_data", "value", "Bap_bundle.Std.Bundle.t -> string -> string option", "Bap_bundle.Std.Bundle.html#VALget_data", "<div class=\"info\">\n<p><code class=\"code\">get_data&nbsp;bundle&nbsp;path</code> extracts data specified by a <code class=\"code\">path</code> as\n        a string.</p>\n\n</div>\n", ["BUNDLE", "DATA", "EXTRACTS", "GET_DATA", "PATH", "SPECIFIED", "STRING"]);
add_ocaml_element("get_file", "Bap_bundle.Std.Bundle.get_file", "value", "?name:string -> Bap_bundle.Std.Bundle.t -> Uri.t -> Uri.t option", "Bap_bundle.Std.Bundle.html#VALget_file", "<div class=\"info\">\n<p><code class=\"code\">get_file&nbsp;?name&nbsp;bundle&nbsp;uri</code> extracts a file.</p>\n\n</div>\n", ["ALLOWS", "AND", "BUNDLE", "DESIRED", "EXTRACTED", "EXTRACTION", "EXTRACTS", "FILE", "FILENAME", "FOR", "FOUND", "FROM", "GET_FILE", "NAME", "OPTIONAL", "PARAMETER", "POINTING", "RETURNS", "SPECIFIED", "SPECIFY", "THE", "URI", "WAS"]);
add_ocaml_element("manifest", "Bap_bundle.Std.Bundle.manifest", "value", "Bap_bundle.Std.Bundle.t -> Bap_bundle.Std.manifest", "Bap_bundle.Std.Bundle.html#VALmanifest", "<div class=\"info\">\n<p><code class=\"code\">manifest&nbsp;bundle</code> extracts program manifest from the <code class=\"code\">bundle</code></p>\n\n</div>\n", ["BUNDLE", "EXTRACTS", "FROM", "MANIFEST", "PROGRAM", "THE"]);
add_ocaml_element("of_uri", "Bap_bundle.Std.Bundle.of_uri", "value", "Uri.t -> Bap_bundle.Std.Bundle.t", "Bap_bundle.Std.Bundle.html#VALof_uri", "<div class=\"info\">\n<p>creates new bundle or opens existing</p>\n\n</div>\n", ["BUNDLE", "CREATES", "EXISTING", "NEW", "OPENS"]);
add_ocaml_element("create", "Bap_bundle.Std.Manifest.create", "value", "?author:string ->\n  ?version:string ->\n  ?main:string ->\n  ?date:float ->\n  ?desc:string ->\n  ?requires:string list ->\n  ?provides:string list ->\n  ?url:string ->\n  ?license:string ->\n  ?copyrights:string ->\n  ?tags:string list -> ?cons:string list -> string -> Bap_bundle.Std.Manifest.t", "Bap_bundle.Std.Manifest.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;name</code> create a bundle for a program with a given <code class=\"code\">name</code></p>\n\n</div>\n", ["BUNDLE", "CREATE", "FOR", "GIVEN", "NAME", "PROGRAM", "WITH"]);
add_ocaml_element("main_bundle", "Bap_bundle.Std.main_bundle", "value", "unit -> Bap_bundle.Std.bundle", "Bap_bundle.Std.html#VALmain_bundle", "<div class=\"info\">\n<p><code class=\"code\">main_bundle&nbsp;()</code> returns a program's bundle if the program is\n      bundled, otherwise creates a fresh new bundle in current working\n      directory.</p>\n\n</div>\n", ["BASENAME", "BUNDLE", "BUNDLED", "CREATES", "CURRENT", "DIRECTORY", "EXECUTABLE_NAME", "EXTENSION", "FRESH", "MAIN_BUNDLE", "NAME", "NEW", "OTHERWISE", "PROGRAM", "RETURNS", "SYS", "THE", "WITH", "WORKING"]);
add_ocaml_element("lift", "Std.Target.lift", "value", "Std.lifter", "Bap.Std.Target.html#VALlift", "<div class=\"info\">\n<p><code class=\"code\">lift&nbsp;mem&nbsp;insn</code> lifts provided instruction to BIL.</p>\n\n</div>\n", ["BIL", "CALL", "CODE", "DIRECTLY", "DISASSEMBLE", "FUNCTION", "INSN", "INSTRUCTION", "LIFT", "LIFTING", "LIFTS", "MEM", "NEED", "NOT", "POSTCONDITION", "PROVIDED", "RETURNED", "THE", "THIS", "TYPED", "USUALLY", "WELL", "WILL", "YOU"]);
add_ocaml_element("is_mem", "Std.CPU.is_mem", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_mem", "<div class=\"info\">\n<p><code class=\"code\">is_mem&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Var</span>.same&nbsp;x&nbsp;mem</code></p>\n\n</div>\n", ["IS_MEM", "MEM", "SAME", "VAR"]);
add_ocaml_element("is_nf", "Std.CPU.is_nf", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_nf", "<div class=\"info\">\n<p><code class=\"code\">is_nf&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Var</span>.same&nbsp;x&nbsp;nf</code></p>\n\n</div>\n", ["IS_NF", "SAME", "VAR"]);
add_ocaml_element("is_vf", "Std.CPU.is_vf", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_vf", "<div class=\"info\">\n<p><code class=\"code\">is_vf&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Var</span>.same&nbsp;x&nbsp;vf</code></p>\n\n</div>\n", ["IS_VF", "SAME", "VAR"]);
add_ocaml_element("is_cf", "Std.CPU.is_cf", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_cf", "<div class=\"info\">\n<p><code class=\"code\">is_cf&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Var</span>.same&nbsp;x&nbsp;cf</code></p>\n\n</div>\n", ["IS_CF", "SAME", "VAR"]);
add_ocaml_element("is_zf", "Std.CPU.is_zf", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_zf", "<div class=\"info\">\n<p><code class=\"code\">is_zf&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Var</span>.same&nbsp;x&nbsp;zf</code></p>\n\n</div>\n", ["IS_ZF", "SAME", "VAR"]);
add_ocaml_element("is_bp", "Std.CPU.is_bp", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_bp", "<div class=\"info\">\n<p><code class=\"code\">is_bp&nbsp;x</code> is true if <code class=\"code\">x</code> can be possibly used as a base\n        pointer register.</p>\n\n</div>\n", ["BASE", "CAN", "IS_BP", "POINTER", "POSSIBLY", "REGISTER", "TRUE", "USED"]);
add_ocaml_element("is_sp", "Std.CPU.is_sp", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_sp", "<div class=\"info\">\n<p><code class=\"code\">is_sp&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">Var</span>.same&nbsp;x&nbsp;sp</code></p>\n\n</div>\n", ["IS_SP", "SAME", "VAR"]);
add_ocaml_element("is_flag", "Std.CPU.is_flag", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_flag", "<div class=\"info\">\n<p><code class=\"code\">is_flag&nbsp;reg</code> is true if <code class=\"code\">reg</code> is a flag register</p>\n\n</div>\n", ["FLAG", "IS_FLAG", "REG", "REGISTER", "TRUE"]);
add_ocaml_element("is_reg", "Std.CPU.is_reg", "value", "Std.var -> bool", "Bap.Std.CPU.html#VALis_reg", "<div class=\"info\">\n<p><code class=\"code\">is_reg&nbsp;var</code> true if <code class=\"code\">var</code> is a processor register</p>\n\n</div>\n", ["IS_REG", "PROCESSOR", "REGISTER", "TRUE", "VAR"]);
add_ocaml_element("nf", "Std.CPU.nf", "value", "Std.var", "Bap.Std.CPU.html#VALnf", "<div class=\"info\">\n<p>negative flag</p>\n\n</div>\n", ["FLAG", "NEGATIVE"]);
add_ocaml_element("vf", "Std.CPU.vf", "value", "Std.var", "Bap.Std.CPU.html#VALvf", "<div class=\"info\">\n<p>overflow flag</p>\n\n</div>\n", ["FLAG", "OVERFLOW"]);
add_ocaml_element("cf", "Std.CPU.cf", "value", "Std.var", "Bap.Std.CPU.html#VALcf", "<div class=\"info\">\n<p>carry flag</p>\n\n</div>\n", ["CARRY", "FLAG"]);
add_ocaml_element("zf", "Std.CPU.zf", "value", "Std.var", "Bap.Std.CPU.html#VALzf", "<div class=\"info\">\n<p>zero flag</p>\n\n</div>\n", ["FLAG", "ZERO"]);
add_ocaml_element("sp", "Std.CPU.sp", "value", "Std.var", "Bap.Std.CPU.html#VALsp", "<div class=\"info\">\n<p>Stack pointer</p>\n\n</div>\n", ["POINTER", "STACK"]);
add_ocaml_element("mem", "Std.CPU.mem", "value", "Std.var", "Bap.Std.CPU.html#VALmem", "<div class=\"info\">\n<p>Memory</p>\n\n</div>\n", ["MEMORY"]);
add_ocaml_element("gpr", "Std.CPU.gpr", "value", "Std.Var.Set.t", "Bap.Std.CPU.html#VALgpr", "<div class=\"info\">\n<p>A set of general purpose registers</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTERS", "SET"]);
add_ocaml_element("start", "Std.Log.start", "value", "?logdir:string -> unit -> unit", "Bap.Std.Log.html#VALstart", "<div class=\"info\">\n<p>Starts event logging.</p>\n\n</div>\n", ["ALL", "ALREADY", "ALSO", "AND", "ARE", "BAP", "CREATE", "CREATED", "DESTINATION", "DISCARDED", "DUPLICATED", "ENVIRONMENT", "ERROR", "EVENT", "EVENTS", "EXISTING", "EXISTS", "FILE", "FILES", "FOLDER", "FOR", "HOME", "INITATED", "INTO", "LEVEL", "LOCAL", "LOG", "LOGDIR", "LOGGED", "LOGGING", "LOOKED", "MORE", "NAMED", "NOT", "OTHERWISE", "OUTPUT", "PERFORMED", "POSSIBLE", "PRESENT", "PRINTED", "REACHED", "RENAME", "RENAMED", "ROTATION", "SPECIFIED", "STARTS", "STATE", "STDERR", "SUCH", "SYSTEM", "TEMPORARY", "THE", "THEN", "THERE", "THIS", "TYPE", "UNLINKED", "UNTIL", "USED", "VARIABLE", "WASN", "WHICH", "WILL", "XDG_STATE_HOME"]);
add_ocaml_element("some", "Std.Self.Config.some", "value", "?none:string ->\n  'a Std.Self.Config.converter -> 'a option Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALsome", "<div class=\"info\">\n<p><code class=\"code\">some&nbsp;none&nbsp;c</code> is like the converter <code class=\"code\">c</code> except it returns\n          <code class=\"code\"><span class=\"constructor\">Some</span></code> value.</p>\n\n</div>\n", ["ABSENCE", "ABSENT", "ARGUMENTS", "COMMAND", "CONVERTER", "DEFAULT", "DEFAULTS", "DOCUMENT", "EXCEPT", "FOR", "LIKE", "LINE", "NONE", "PRINT", "RETURNS", "SOME", "THAT", "THE", "USED", "VALUE", "WHAT", "WHEN"]);
add_ocaml_element("t4", "Std.Self.Config.t4", "value", "?sep:char ->\n  'a Std.Self.Config.converter ->\n  'b Std.Self.Config.converter ->\n  'c Std.Self.Config.converter ->\n  'd Std.Self.Config.converter ->\n  ('a * 'b * 'c * 'd) Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALt4", "<div class=\"info\">\n<p><code class=\"code\">t4&nbsp;sep&nbsp;c0&nbsp;c1&nbsp;c2&nbsp;c3</code> splits the argument at the <em>first</em> three <code class=\"code\">sep</code>\n          characters (defaults to <code class=\"code\"><span class=\"string\">','</span></code>) respectively converts the substrings\n          with <code class=\"code\">c0</code>, <code class=\"code\">c1</code>, <code class=\"code\">c2</code> and <code class=\"code\">c3</code>.</p>\n\n</div>\n", ["AND", "ARGUMENT", "CHARACTERS", "CONVERTS", "DEFAULTS", "FIRST", "RESPECTIVELY", "SEP", "SPLITS", "SUBSTRINGS", "THE", "THREE", "WITH"]);
add_ocaml_element("t3", "Std.Self.Config.t3", "value", "?sep:char ->\n  'a Std.Self.Config.converter ->\n  'b Std.Self.Config.converter ->\n  'c Std.Self.Config.converter ->\n  ('a * 'b * 'c) Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALt3", "<div class=\"info\">\n<p><code class=\"code\">t3&nbsp;sep&nbsp;c0&nbsp;c1&nbsp;c2</code> splits the argument at the <em>first</em> two <code class=\"code\">sep</code>\n          characters (defaults to <code class=\"code\"><span class=\"string\">','</span></code>) and respectively converts the\n          substrings with <code class=\"code\">c0</code>, <code class=\"code\">c1</code> and <code class=\"code\">c2</code>.</p>\n\n</div>\n", ["AND", "ARGUMENT", "CHARACTERS", "CONVERTS", "DEFAULTS", "FIRST", "RESPECTIVELY", "SEP", "SPLITS", "SUBSTRINGS", "THE", "TWO", "WITH"]);
add_ocaml_element("t2", "Std.Self.Config.t2", "value", "?sep:char ->\n  'a Std.Self.Config.converter ->\n  'b Std.Self.Config.converter -> ('a * 'b) Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALt2", "<div class=\"info\">\n<p><a href=\"Bap.Std.Self.Config.html#VALt2\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Self</span>.<span class=\"constructor\">Config</span>.t2</code></a> is <a href=\"Bap.Std.Self.Config.html#VALpair\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Self</span>.<span class=\"constructor\">Config</span>.pair</code></a>.</p>\n\n</div>\n", ["BAP", "CONFIG", "PAIR", "SELF", "STD"]);
add_ocaml_element("pair", "Std.Self.Config.pair", "value", "?sep:char ->\n  'a Std.Self.Config.converter ->\n  'b Std.Self.Config.converter -> ('a * 'b) Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALpair", "<div class=\"info\">\n<p><code class=\"code\">pair&nbsp;sep&nbsp;c0&nbsp;c1</code> splits the argument at the <em>first</em> <code class=\"code\">sep</code> character\n          (defaults to <code class=\"code\"><span class=\"string\">','</span></code>) and respectively converts the substrings with\n          <code class=\"code\">c0</code> and <code class=\"code\">c1</code>.</p>\n\n</div>\n", ["AND", "ARGUMENT", "CHARACTER", "CONVERTS", "DEFAULTS", "FIRST", "PAIR", "RESPECTIVELY", "SEP", "SPLITS", "SUBSTRINGS", "THE", "WITH"]);
add_ocaml_element("array", "Std.Self.Config.array", "value", "?sep:char ->\n  'a Std.Self.Config.converter -> 'a array Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALarray", "<div class=\"info\">\n<p><code class=\"code\">array&nbsp;sep&nbsp;c</code> splits the argument at each <code class=\"code\">sep</code> (defaults to <code class=\"code\"><span class=\"string\">','</span></code>)\n          character and converts each substring with <code class=\"code\">c</code>.</p>\n\n</div>\n", ["AND", "ARGUMENT", "ARRAY", "CHARACTER", "CONVERTS", "DEFAULTS", "EACH", "SEP", "SPLITS", "SUBSTRING", "THE", "WITH"]);
add_ocaml_element("list", "Std.Self.Config.list", "value", "?sep:char ->\n  'a Std.Self.Config.converter -> 'a list Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALlist", "<div class=\"info\">\n<p><code class=\"code\">list&nbsp;sep&nbsp;c</code> splits the argument at each <code class=\"code\">sep</code> (defaults to <code class=\"code\"><span class=\"string\">','</span></code>)\n          character and converts each substrings with <code class=\"code\">c</code>.</p>\n\n</div>\n", ["AND", "ARGUMENT", "CHARACTER", "CONVERTS", "DEFAULTS", "EACH", "LIST", "SEP", "SPLITS", "SUBSTRINGS", "THE", "WITH"]);
add_ocaml_element("non_dir_file", "Std.Self.Config.non_dir_file", "value", "string Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALnon_dir_file", "<div class=\"info\">\n<p><code class=\"code\">non_dir_file</code> converts a value with the identity function and checks\n          with <code class=\"code\"><span class=\"constructor\">Sys</span>.file_exists</code> and <code class=\"code\"><span class=\"constructor\">Sys</span>.is_directory</code>\n          that a non directory file with that name exists.</p>\n\n</div>\n", ["AND", "CHECKS", "CONVERTS", "DIRECTORY", "EXISTS", "FILE", "FILE_EXISTS", "FUNCTION", "IDENTITY", "IS_DIRECTORY", "NAME", "NON", "NON_DIR_FILE", "SYS", "THAT", "THE", "VALUE", "WITH"]);
add_ocaml_element("dir", "Std.Self.Config.dir", "value", "string Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALdir", "<div class=\"info\">\n<p><code class=\"code\">dir</code> converts a value with the identity function and checks\n          with <code class=\"code\"><span class=\"constructor\">Sys</span>.file_exists</code> and <code class=\"code\"><span class=\"constructor\">Sys</span>.is_directory</code>\n          that a directory with that name exists.</p>\n\n</div>\n", ["AND", "CHECKS", "CONVERTS", "DIR", "DIRECTORY", "EXISTS", "FILE_EXISTS", "FUNCTION", "IDENTITY", "IS_DIRECTORY", "NAME", "SYS", "THAT", "THE", "VALUE", "WITH"]);
add_ocaml_element("file", "Std.Self.Config.file", "value", "string Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALfile", "<div class=\"info\">\n<p><code class=\"code\">file</code> converts a value with the identity function and\n          checks with <code class=\"code\"><span class=\"constructor\">Sys</span>.file_exists</code> that a file with that name exists.</p>\n\n</div>\n", ["AND", "CHECKS", "CONVERTS", "EXISTS", "FILE", "FILE_EXISTS", "FUNCTION", "IDENTITY", "NAME", "SYS", "THAT", "THE", "VALUE", "WITH"]);
add_ocaml_element("doc_enum", "Std.Self.Config.doc_enum", "value", "?quoted:bool -> (string * 'a) list -> string", "Bap.Std.Self.Config.html#VALdoc_enum", "<div class=\"info\">\n<p><code class=\"code\">doc_enum&nbsp;l</code> documents the possible string names in the <code class=\"code\">l</code>\n          map according to the number of alternatives.</p>\n\n</div>\n", ["ACCORDING", "ALTERNATIVES", "ARE", "CAN", "DEFAULT", "DOCUMENTS", "DOCV", "DOC_ENUM", "FORM", "MAP", "MUST", "NAMES", "NUMBER", "POSSIBLE", "QUOTED", "RESULTING", "SENTENCES", "STRING", "THE", "TOKENS", "TRUE", "USED"]);
add_ocaml_element("enum", "Std.Self.Config.enum", "value", "(string * 'a) list -> 'a Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALenum", "<div class=\"info\">\n<p><code class=\"code\">enum&nbsp;l</code> converts values such that unambiguous prefixes of\n          string names in <code class=\"code\">l</code> map to the corresponding value of type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code>.</p>\n\n</div>\n", ["COMPARABLE", "COMPARE", "CONVERTS", "CORRESPONDING", "EMPTY", "ENUM", "INVALID_ARGUMENT", "MAP", "MUST", "NAMES", "PERVASIVES", "PREFIXES", "RAISES", "STRING", "SUCH", "THAT", "THE", "TYPE", "UNAMBIGUOUS", "VALUE", "VALUES", "WARNING", "WITH"]);
add_ocaml_element("string", "Std.Self.Config.string", "value", "string Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALstring", "<div class=\"info\">\n<p><code class=\"code\">string</code> converts values with the identity function.</p>\n\n</div>\n", ["CONVERTS", "FUNCTION", "IDENTITY", "STRING", "THE", "VALUES", "WITH"]);
add_ocaml_element("float", "Std.Self.Config.float", "value", "float Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALfloat", "<div class=\"info\">\n<p><code class=\"code\">float</code> converts values with <code class=\"code\">float_of_string</code>.</p>\n\n</div>\n", ["CONVERTS", "FLOAT", "FLOAT_OF_STRING", "VALUES", "WITH"]);
add_ocaml_element("int64", "Std.Self.Config.int64", "value", "int64 Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALint64", "<div class=\"info\">\n<p><code class=\"code\">int64</code> converts values with <code class=\"code\"><span class=\"constructor\">Int64</span>.of_string</code>.</p>\n\n</div>\n", ["CONVERTS", "INT64", "OF_STRING", "VALUES", "WITH"]);
add_ocaml_element("int32", "Std.Self.Config.int32", "value", "int32 Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALint32", "<div class=\"info\">\n<p><code class=\"code\">int32</code> converts values with <code class=\"code\"><span class=\"constructor\">Int32</span>.of_string</code>.</p>\n\n</div>\n", ["CONVERTS", "INT32", "OF_STRING", "VALUES", "WITH"]);
add_ocaml_element("nativeint", "Std.Self.Config.nativeint", "value", "nativeint Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALnativeint", "<div class=\"info\">\n<p><code class=\"code\">nativeint</code> converts values with <code class=\"code\"><span class=\"constructor\">Nativeint</span>.of_string</code>.</p>\n\n</div>\n", ["CONVERTS", "NATIVEINT", "OF_STRING", "VALUES", "WITH"]);
add_ocaml_element("int", "Std.Self.Config.int", "value", "int Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALint", "<div class=\"info\">\n<p><code class=\"code\">int</code> converts values with <code class=\"code\">int_of_string</code>.</p>\n\n</div>\n", ["CONVERTS", "INT", "INT_OF_STRING", "VALUES", "WITH"]);
add_ocaml_element("char", "Std.Self.Config.char", "value", "char Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALchar", "<div class=\"info\">\n<p><code class=\"code\">char</code> converts values by ensuring the argument has a single char.</p>\n\n</div>\n", ["ARGUMENT", "CHAR", "CONVERTS", "ENSURING", "HAS", "SINGLE", "THE", "VALUES"]);
add_ocaml_element("bool", "Std.Self.Config.bool", "value", "bool Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALbool", "<div class=\"info\">\n<p><code class=\"code\">bool</code> converts values with <code class=\"code\">bool_of_string</code>.</p>\n\n</div>\n", ["BOOL", "BOOL_OF_STRING", "CONVERTS", "VALUES", "WITH"]);
add_ocaml_element("manpage", "Std.Self.Config.manpage", "value", "Std.Self.Config.manpage_block list -> unit", "Bap.Std.Self.Config.html#VALmanpage", "<div class=\"info\">\n<p>Create a manpage for the plugin</p>\n\n</div>\n", ["CREATE", "FOR", "MANPAGE", "PLUGIN", "THE"]);
add_ocaml_element("when_ready", "Std.Self.Config.when_ready", "value", "(Std.Self.Config.reader -> unit) -> unit", "Bap.Std.Self.Config.html#VALwhen_ready", "<div class=\"info\">\n<p><code class=\"code\">when_ready&nbsp;f</code> requests the system to call function <code class=\"code\">f</code> once\n          configuration parameters are  established and stabilized.</p>\n\n</div>\n", ["ACCESS", "AND", "ARE", "CALL", "CAN", "CONFIGURATION", "DEREFERENCE", "ESTABLISHED", "FUNCTION", "ONCE", "PARAMETERS", "PASSED", "REQUESTS", "SAFELY", "STABILIZED", "SYSTEM", "THAT", "THE", "USED", "WHEN_READY", "WILL"]);
add_ocaml_element("determined", "Std.Self.Config.determined", "value", "'a Std.Self.Config.param -> 'a Bap_future.Std.future", "Bap.Std.Self.Config.html#VALdetermined", "<div class=\"info\">\n<p>Provides a future determined on when the config can be read</p>\n\n</div>\n", ["CAN", "CONFIG", "DETERMINED", "FUTURE", "PROVIDES", "READ", "THE", "WHEN"]);
add_ocaml_element("flag", "Std.Self.Config.flag", "value", "?deprecated:string ->\n  ?docv:string ->\n  ?doc:string ->\n  ?synonyms:string list -> string -> bool Std.Self.Config.param", "Bap.Std.Self.Config.html#VALflag", "<div class=\"info\">\n<p>Create a boolean parameter that is set to true if user\n          mentions it in the command line arguments</p>\n\n</div>\n", ["ARGUMENTS", "BOOLEAN", "COMMAND", "CREATE", "LINE", "MENTIONS", "PARAMETER", "SET", "THAT", "THE", "TRUE", "USER"]);
add_ocaml_element("param_all", "Std.Self.Config.param_all", "value", "'a Std.Self.Config.converter ->\n  ?deprecated:string ->\n  ?default:'a list ->\n  ?as_flag:'a ->\n  ?docv:string ->\n  ?doc:string ->\n  ?synonyms:string list -> string -> 'a list Std.Self.Config.param", "Bap.Std.Self.Config.html#VALparam_all", "<div class=\"info\">\n<p>Create a parameter which accepts a list at command line by\n          repetition of argument.</p>\n\n</div>\n", ["ACCEPTS", "ALL", "ARGUMENT", "COMMAND", "CREATE", "DEFAULTS", "EMPTY", "LINE", "LIST", "OTHER", "PARAM", "PARAMETER", "REPETITION", "RESPECTS", "SIMILAR", "UNSPECIFIED", "WHICH"]);
add_ocaml_element("param", "Std.Self.Config.param", "value", "'a Std.Self.Config.converter ->\n  ?deprecated:string ->\n  ?default:'a ->\n  ?as_flag:'a ->\n  ?docv:string ->\n  ?doc:string ->\n  ?synonyms:string list -> string -> 'a Std.Self.Config.param", "Bap.Std.Self.Config.html#VALparam", "<div class=\"info\">\n<p><code class=\"code\">param&nbsp;conv&nbsp;~default&nbsp;~docv&nbsp;~doc&nbsp;name</code> creates a parameter\n          which is referred to on the command line, environment\n          variable, and config file using the value of <code class=\"code\">name</code>, with\n          the type defined by <code class=\"code\">conv</code>, using the <code class=\"code\">default</code> value if\n          unspecified by user.</p>\n\n</div>\n", ["ADD", "ADDED", "ADDITIONALLY", "ALLOW", "ALSO", "AND", "ARGUMENT", "ARGUMENTS", "AS_FLAG", "BACK", "BEHAVIOUR", "BETTER", "BUT", "CAN", "CAUSE", "CAUSES", "COMMAND", "CONFIG", "CONSIDER", "CONSIDERED", "CONV", "CREATES", "DEFAULT", "DEFINED", "DEPRECATED", "DEVELOPER", "DISCOURAGED", "DOC", "DOCV", "EMIT", "ENVIRONMENT", "EXAMPLE", "FALLS", "FILE", "FLAG", "FOLLOWING", "FOR", "FROM", "HAVE", "HERE", "HOWEVER", "INFORMATION", "INT", "INVOCATIONS", "LIKE", "LINE", "MAN", "MULTIPLE", "NAME", "NONE", "NORMAL", "OLD", "ONLY", "OPTIONAL", "OPTIONALLY", "PAGE", "PARAM", "PARAMETER", "PARAMETERS", "POSSIBLE", "PROPER", "RARE", "REFER", "REFERRED", "REFERRING", "RESULTS", "SAME", "SCENARIOS", "SOME", "SOON", "SPECIFICALLY", "SPECIFY", "STAND", "SYNONYMS", "TAKES", "THAT", "THE", "THEIR", "THEY", "THIS", "THROUGH", "TRY", "TYPE", "UNDERSTOOD", "UNSPECIFIED", "USABLE", "USAGE", "USE", "USED", "USER", "USING", "USUALLY", "VALUE", "VARIABLE", "WARNING", "WHICH", "WILL", "WITH"]);
add_ocaml_element("deprecated", "Std.Self.Config.deprecated", "value", "string", "Bap.Std.Self.Config.html#VALdeprecated", "<div class=\"info\">\n<p>Default deprecation warning message, for easy deprecation of\n          parameters.</p>\n\n</div>\n", ["DEFAULT", "DEPRECATION", "EASY", "FOR", "MESSAGE", "PARAMETERS", "WARNING"]);
add_ocaml_element("converter", "Std.Self.Config.converter", "value", "'a Std.Self.Config.parser ->\n  'a Std.printer -> 'a -> 'a Std.Self.Config.converter", "Bap.Std.Self.Config.html#VALconverter", "", []);
add_ocaml_element("confdir", "Std.Self.Config.confdir", "value", "string", "Bap.Std.Self.Config.html#VALconfdir", "<div class=\"info\">\n<p>A directory for bap specific configuration files</p>\n\n</div>\n", ["BAP", "CONFIGURATION", "DIRECTORY", "FILES", "FOR", "SPECIFIC"]);
add_ocaml_element("libdir", "Std.Self.Config.libdir", "value", "string", "Bap.Std.Self.Config.html#VALlibdir", "<div class=\"info\">\n<p>A directory for bap specific object files, libraries, and\n          internal binaries that are not intended to be executed directly\n          by users or shell scripts</p>\n\n</div>\n", ["AND", "ARE", "BAP", "BINARIES", "DIRECTLY", "DIRECTORY", "EXECUTED", "FILES", "FOR", "INTENDED", "INTERNAL", "LIBRARIES", "NOT", "OBJECT", "SCRIPTS", "SHELL", "SPECIFIC", "THAT", "USERS"]);
add_ocaml_element("datadir", "Std.Self.Config.datadir", "value", "string", "Bap.Std.Self.Config.html#VALdatadir", "<div class=\"info\">\n<p>A directory for bap specific read-only architecture\n          independent data files.</p>\n\n</div>\n", ["ARCHITECTURE", "BAP", "DATA", "DIRECTORY", "FILES", "FOR", "INDEPENDENT", "ONLY", "READ", "SPECIFIC"]);
add_ocaml_element("version", "Std.Self.Config.version", "value", "string", "Bap.Std.Self.Config.html#VALversion", "<div class=\"info\">\n<p>Version number</p>\n\n</div>\n", ["NUMBER", "VERSION"]);
add_ocaml_element("report_progress", "Std.Self.report_progress", "value", "?task:string -> ?note:string -> ?stage:int -> ?total:int -> unit -> unit", "Bap.Std.Self.html#VALreport_progress", "<div class=\"info\">\n<p><code class=\"code\">report_progress&nbsp;~task:t&nbsp;~note:n&nbsp;~state:s&nbsp;~total:s'&nbsp;()</code> reports\n        a progress of the task <code class=\"code\">t</code>.</p>\n\n</div>\n", ["ADDITIONAL", "ALL", "AND", "APPROACH", "ARE", "BEFORE", "BUT", "COMPUTATION", "CONVINIENT", "CURRENT", "DEFAULT", "DOESN", "DURING", "ELEMENT", "ELEMENTS", "ENTERED", "EXPECT", "EXPLANATION", "FINE", "FINISHED", "FOLLOWING", "FOR", "FUNCTIONAL", "HAVE", "INDEX", "INDEXED", "ITERATING", "ITERATION", "LAST", "LESS", "MADE", "MAY", "MEAN", "MORE", "NOT", "NOTE", "NUMBER", "ONE", "OPTIONAL", "OUT", "PARAMETERS", "PROGRAMMING", "PROGRESS", "PROVIDE", "RATHER", "RECIEVE", "REPORT", "REPORTS", "REPORT_PROGRESS", "SPECIFIED", "STAGE", "STAGES", "STATE", "TASK", "TEXTUAL", "THAN", "THAT", "THE", "THIS", "THUS", "TOTAL", "VALUES", "WITH", "WORKS"]);
add_ocaml_element("error_formatter", "Std.Self.error_formatter", "value", "Stdlib.Format.formatter", "Bap.Std.Self.html#VALerror_formatter", "<div class=\"info\">\n<p>formatter that sends error messages</p>\n\n</div>\n", ["ERROR", "FORMATTER", "MESSAGES", "SENDS", "THAT"]);
add_ocaml_element("warning_formatter", "Std.Self.warning_formatter", "value", "Stdlib.Format.formatter", "Bap.Std.Self.html#VALwarning_formatter", "<div class=\"info\">\n<p>formatter that sends warning messages</p>\n\n</div>\n", ["FORMATTER", "MESSAGES", "SENDS", "THAT", "WARNING"]);
add_ocaml_element("info_formatter", "Std.Self.info_formatter", "value", "Stdlib.Format.formatter", "Bap.Std.Self.html#VALinfo_formatter", "<div class=\"info\">\n<p>formatter that sends info messages</p>\n\n</div>\n", ["FORMATTER", "INFO", "MESSAGES", "SENDS", "THAT"]);
add_ocaml_element("debug_formatter", "Std.Self.debug_formatter", "value", "Stdlib.Format.formatter", "Bap.Std.Self.html#VALdebug_formatter", "<div class=\"info\">\n<p>formatter that sends debug messages</p>\n\n</div>\n", ["DEBUG", "FORMATTER", "MESSAGES", "SENDS", "THAT"]);
add_ocaml_element("error", "Std.Self.error", "value", "('a, Stdlib.Format.formatter, unit) format -> 'a", "Bap.Std.Self.html#VALerror", "<div class=\"info\">\n<p><code class=\"code\">error&nbsp;fmt&nbsp;...</code> send an error message</p>\n\n</div>\n", ["ERROR", "FMT", "MESSAGE", "SEND"]);
add_ocaml_element("warning", "Std.Self.warning", "value", "('a, Stdlib.Format.formatter, unit) format -> 'a", "Bap.Std.Self.html#VALwarning", "<div class=\"info\">\n<p><code class=\"code\">warning&nbsp;fmt&nbsp;...</code> send a warning message</p>\n\n</div>\n", ["FMT", "MESSAGE", "SEND", "WARNING"]);
add_ocaml_element("info", "Std.Self.info", "value", "('a, Stdlib.Format.formatter, unit) format -> 'a", "Bap.Std.Self.html#VALinfo", "<div class=\"info\">\n<p><code class=\"code\">info&nbsp;fmt&nbsp;...</code> send an info message</p>\n\n</div>\n", ["FMT", "INFO", "MESSAGE", "SEND"]);
add_ocaml_element("debug", "Std.Self.debug", "value", "('a, Stdlib.Format.formatter, unit) format -> 'a", "Bap.Std.Self.html#VALdebug", "<div class=\"info\">\n<p><code class=\"code\">debug&nbsp;fmt&nbsp;...</code> send a debug message</p>\n\n</div>\n", ["DEBUG", "FMT", "MESSAGE", "SEND"]);
add_ocaml_element("argv", "Std.Self.argv", "value", "string array", "Bap.Std.Self.html#VALargv", "<div class=\"info\">\n<p><code class=\"code\">args&nbsp;name</code> returns an array of arguments designated for a\n        plugin with a given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ACCEPT", "ALL", "ANONYMOUS", "ARE", "ARGS", "ARGUMENTS", "ARGV", "ARRAY", "BAP", "CALLGRAPH", "CAN", "COMMAND", "CONTAINED", "DESIGNATED", "DOESN", "EXAMPLE", "EXTRACTED", "FOLLOWING", "FOR", "FROM", "GIVEN", "HELP", "ITSELF", "LCALLGRAPH", "LEFT", "MEANS", "NAME", "OPTIONS", "PASS", "PLUGIN", "PLUGINS", "PREFIX", "RECEIVE", "REGISTERED", "REMOVING", "RETURNS", "SHORT", "START", "SUBSTITUTED", "SYS", "THAT", "THE", "THEN", "UNDER", "WILL", "WITH"]);
add_ocaml_element("doc", "Std.Self.doc", "value", "string", "Bap.Std.Self.html#VALdoc", "<div class=\"info\">\n<p>A short, one-line description</p>\n\n</div>\n", ["DESCRIPTION", "LINE", "ONE", "SHORT"]);
add_ocaml_element("version", "Std.Self.version", "value", "string", "Bap.Std.Self.html#VALversion", "<div class=\"info\">\n<p><code class=\"code\">version&nbsp;number</code></p>\n\n</div>\n", ["NUMBER", "VERSION"]);
add_ocaml_element("name", "Std.Self.name", "value", "string", "Bap.Std.Self.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;<span class=\"keyword\">of</span>&nbsp;a&nbsp;plugin</code></p>\n\n</div>\n", ["NAME", "PLUGIN"]);
add_ocaml_element("autorun", "Std.Project.Pass.autorun", "value", "Std.Project.Pass.t -> bool", "Bap.Std.Project.Pass.html#VALautorun", "<div class=\"info\">\n<p><code class=\"code\">autorun&nbsp;pass</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if a <code class=\"code\">pass</code> was created with\n          autorun option</p>\n\n</div>\n", ["AUTORUN", "CREATED", "OPTION", "PASS", "TRUE", "WAS", "WITH"]);
add_ocaml_element("name", "Std.Project.Pass.name", "value", "Std.Project.Pass.t -> string", "Bap.Std.Project.Pass.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;pass</code> is a pass name</p>\n\n</div>\n", ["NAME", "PASS"]);
add_ocaml_element("run_exn", "Std.Project.Pass.run_exn", "value", "Std.Project.Pass.t -> Std.project -> Std.project", "Bap.Std.Project.Pass.html#VALrun_exn", "<div class=\"info\">\n<p><code class=\"code\">run_pass_exn&nbsp;proj</code> is the same as <code class=\"code\">run_pass</code>, but raises an\n          exception on error.</p>\n\n</div>\n", ["BUT", "CUSTOM", "ERROR", "EXCEPTION", "FAILED", "HANDLING", "LOAD", "PASS_FAILED", "PLUGIN", "PRINTING", "PROJ", "PROVIDE", "RAISES", "RUNTIME", "RUN_PASS", "RUN_PASS_EXN", "SAME", "THE", "USEFUL"]);
add_ocaml_element("run", "Std.Project.Pass.run", "value", "Std.Project.Pass.t ->\n  Std.project ->\n  (Std.project, Std.Project.Pass.error) Result.t", "Bap.Std.Project.Pass.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run_pass&nbsp;project&nbsp;pass</code> applies <code class=\"code\">pass</code> to a <code class=\"code\">project</code>.</p>\n\n</div>\n", ["APPLIES", "BEFORE", "DEPENDENCIES", "HAS", "ORDER", "PASS", "PROJECT", "RUN", "RUN_PASS", "SOME", "THE", "THEN", "THEY", "TOPOLOGICAL", "WILL"]);
add_ocaml_element("available_loaders", "Std.Project.Input.available_loaders", "value", "unit -> string list", "Bap.Std.Project.Input.html#VALavailable_loaders", "<div class=\"info\">\n<p><code class=\"code\">available_loaders&nbsp;()</code> returns a list of names of currently known loaders.</p>\n\n</div>\n", ["AVAILABLE_LOADERS", "CURRENTLY", "KNOWN", "LIST", "LOADERS", "NAMES", "RETURNS"]);
add_ocaml_element("register_loader", "Std.Project.Input.register_loader", "value", "string -> (string -> Std.Project.Input.t) -> unit", "Bap.Std.Project.Input.html#VALregister_loader", "<div class=\"info\">\n<p><code class=\"code\">register_loader&nbsp;name&nbsp;load</code> register a loader under provided\n          <code class=\"code\">name</code>.</p>\n\n</div>\n", ["AND", "CALLED", "FILENAME", "FUNCTION", "INPUT", "LOAD", "LOADER", "MUST", "NAME", "PROVIDED", "REGISTER", "REGISTER_LOADER", "RETURN", "THE", "UNDER", "VALUE", "WILL"]);
add_ocaml_element("create", "Std.Project.Input.create", "value", "?finish:(Std.project -> Std.project) ->\n  Std.arch ->\n  string ->\n  code:Std.value Std.memmap ->\n  data:Std.value Std.memmap -> Std.Project.Input.t", "Bap.Std.Project.Input.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;arch&nbsp;filename&nbsp;~code&nbsp;~data</code> creates an input from a\n          file, using two memory maps.</p>\n\n</div>\n", ["ADDITIONAL", "AND", "ANY", "ARCH", "AVAILABLE", "CAN", "CODE", "CREATE", "CREATES", "DATA", "DEFAULTS", "FILE", "FILENAME", "FINISH", "FROM", "FUNCTION", "IDENT", "INFORMATION", "INPUT", "LOADER", "MAPS", "MEMMAP", "MEMORY", "OPTIONAL", "PROJECT", "PROPAGATE", "SPANS", "THAT", "THE", "TWO", "USED", "USING"]);
add_ocaml_element("binary", "Std.Project.Input.binary", "value", "?base:Std.addr ->\n  Std.arch -> filename:string -> Std.Project.Input.t", "Bap.Std.Project.Input.html#VALbinary", "<div class=\"info\">\n<p><code class=\"code\">binary&nbsp;?base&nbsp;arch&nbsp;~filename</code> create an input from a binary\n          file, that is a pure code.</p>\n\n</div>\n", ["ARCH", "BASE", "BINARY", "CODE", "CREATE", "FILE", "FILENAME", "FROM", "INPUT", "PURE", "THAT"]);
add_ocaml_element("file", "Std.Project.Input.file", "value", "?loader:string -> filename:string -> Std.Project.Input.t", "Bap.Std.Project.Input.html#VALfile", "<div class=\"info\">\n<p><code class=\"code\">file&nbsp;?loader&nbsp;~filename</code> input data from a file, using the\n          specified loader.</p>\n\n</div>\n", ["AND", "AVAILABLE_BACKENDS", "AVAILABLE_LOADERS", "BAP", "DATA", "EXISTING", "FILE", "FILENAME", "FIRST", "FOUND", "FROM", "IMAGE", "INPUT", "LOADER", "LOOKED", "NOT", "SOME", "SPECIFIED", "STD", "THE", "THEN", "USED", "USING", "WILL"]);
add_ocaml_element("spec", "Std.Project.Info.spec", "value", "Ogre.Doc.t Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALspec", "<div class=\"info\">\n<p>occurs once image spec is known</p>\n\n</div>\n", ["IMAGE", "KNOWN", "OCCURS", "ONCE", "SPEC"]);
add_ocaml_element("program", "Std.Project.Info.program", "value", "Std.program Std.term Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALprogram", "<div class=\"info\">\n<p>occurs every time a program term is changed during the\n          project reconstruction process.</p>\n\n</div>\n", ["CHANGED", "DURING", "EVERY", "OCCURS", "PROCESS", "PROGRAM", "PROJECT", "RECONSTRUCTION", "TERM", "THE", "TIME"]);
add_ocaml_element("symtab", "Std.Project.Info.symtab", "value", "Std.symtab Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALsymtab", "<div class=\"info\">\n<p>occurs everytime a symbol table is changed</p>\n\n</div>\n", ["CHANGED", "EVERYTIME", "OCCURS", "SYMBOL", "TABLE"]);
add_ocaml_element("cfg", "Std.Project.Info.cfg", "value", "Std.cfg Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALcfg", "<div class=\"info\">\n<p>occurs everytime a whole program control flow graph is changed</p>\n\n</div>\n", ["CHANGED", "CONTROL", "EVERYTIME", "FLOW", "GRAPH", "OCCURS", "PROGRAM", "WHOLE"]);
add_ocaml_element("code", "Std.Project.Info.code", "value", "Std.value Std.memmap Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALcode", "<div class=\"info\">\n<p>occurs once code segment is discovered</p>\n\n</div>\n", ["CODE", "DISCOVERED", "OCCURS", "ONCE", "SEGMENT"]);
add_ocaml_element("data", "Std.Project.Info.data", "value", "Std.value Std.memmap Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALdata", "<div class=\"info\">\n<p>occurs once input memory is loaded</p>\n\n</div>\n", ["INPUT", "LOADED", "MEMORY", "OCCURS", "ONCE"]);
add_ocaml_element("arch", "Std.Project.Info.arch", "value", "Std.arch Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALarch", "<div class=\"info\">\n<p>occurs once input architecture is known</p>\n\n</div>\n", ["ARCHITECTURE", "INPUT", "KNOWN", "OCCURS", "ONCE"]);
add_ocaml_element("file", "Std.Project.Info.file", "value", "string Bap_future.Std.stream", "Bap.Std.Project.Info.html#VALfile", "<div class=\"info\">\n<p>occurs everytime a new file is opened.</p>\n\n</div>\n", ["EVERYTIME", "FILE", "FILENAME", "NEW", "OCCURS", "OPENED", "THE", "VALUE"]);
add_ocaml_element("find_pass", "Std.Project.find_pass", "value", "string -> Std.Project.pass option", "Bap.Std.Project.html#VALfind_pass", "<div class=\"info\">\n<p><code class=\"code\">find_pass&nbsp;name</code> returns a pass with the given name.</p>\n\n</div>\n", ["FIND_PASS", "GIVEN", "NAME", "PASS", "RETURNS", "THE", "WITH"]);
add_ocaml_element("passes", "Std.Project.passes", "value", "unit -> Std.Project.pass list", "Bap.Std.Project.html#VALpasses", "<div class=\"info\">\n<p><code class=\"code\">passes&nbsp;()</code> returns all currently registered passes.</p>\n\n</div>\n", ["ALL", "CURRENTLY", "PASSES", "REGISTERED", "RETURNS"]);
add_ocaml_element("register_pass'", "Std.Project.register_pass'", "value", "?autorun:bool ->\n  ?runonce:bool ->\n  ?deps:string list -> ?name:string -> (Std.Project.t -> unit) -> unit", "Bap.Std.Project.html#VALregister_pass'", "<div class=\"info\">\n<p><code class=\"code\">register_pass'&nbsp;pass</code> registers <code class=\"code\">pass</code> that doesn't modify\n        the project effect and is run only for side effect.</p>\n\n</div>\n", ["AND", "BAP", "DOESN", "EFFECT", "FOR", "MODIFY", "ONLY", "PASS", "PROJECT", "REGISTERS", "REGISTER_PASS", "RUN", "SEE", "SIDE", "STD", "THAT", "THE"]);
add_ocaml_element("register_pass", "Std.Project.register_pass", "value", "?autorun:bool ->\n  ?runonce:bool ->\n  ?deps:string list ->\n  ?name:string -> (Std.Project.t -> Std.Project.t) -> unit", "Bap.Std.Project.html#VALregister_pass", "<div class=\"info\">\n<p><code class=\"code\">register_pass&nbsp;?autorun&nbsp;?runonce&nbsp;?deps&nbsp;?name&nbsp;pass</code> registers a\n        <code class=\"code\">pass</code> over a project.</p>\n\n</div>\n", ["ACCESS", "AND", "ARGUMENTS", "ARGV", "ATTEMPTS", "AUTOMATICALLY", "AUTORUN", "BEFORE", "COMMAND", "DEFAULTS", "DEPENDENCIES", "DEPENDENCY", "DEPS", "EACH", "EVERY", "FALSE", "FOR", "GET", "GIVEN", "HOST", "IGNORED", "LINE", "LIST", "NAME", "ONCE", "ONLY", "ORDER", "OTHERWISE", "OVER", "PARAMETER", "PASS", "PLUGIN", "PROGRAM", "PROJECT", "REGISTERS", "REGISTER_PASS", "REPEATING", "RUN", "RUNONCE", "SHOULD", "SPECIFIED", "THAT", "THE", "THEN", "THIS", "TIME", "TRUE", "USE", "WHEN", "WILL"]);
add_ocaml_element("del", "Std.Project.del", "value", "Std.Project.t -> 'a Std.tag -> Std.Project.t", "Bap.Std.Project.html#VALdel", "<div class=\"info\">\n<p><code class=\"code\">del&nbsp;project&nbsp;attr</code> removes an attribute from a project</p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "DEL", "FROM", "PROJECT", "REMOVES"]);
add_ocaml_element("has", "Std.Project.has", "value", "Std.Project.t -> 'a Std.tag -> bool", "Bap.Std.Project.html#VALhas", "<div class=\"info\">\n<p><code class=\"code\">has&nbsp;project&nbsp;field</code> checks whether field exists or not.</p>\n\n</div>\n", ["ACTUALLY", "BOOL", "CHECKS", "EXISTS", "FIELD", "FIELDS", "FOR", "HAS", "ISOMORPHIC", "MARK", "NOT", "PROJECT", "THAT", "TYPE", "UNIT", "USEFUL", "WHETHER"]);
add_ocaml_element("get", "Std.Project.get", "value", "Std.Project.t -> 'a Std.tag -> 'a option", "Bap.Std.Project.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;project&nbsp;field</code> returns the value of the <code class=\"code\">field</code> if it\n        exists</p>\n\n</div>\n", ["EXISTS", "FIELD", "GET", "PROJECT", "RETURNS", "THE", "VALUE"]);
add_ocaml_element("set", "Std.Project.set", "value", "Std.Project.t -> 'a Std.tag -> 'a -> Std.Project.t", "Bap.Std.Project.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;project&nbsp;field&nbsp;value</code> sets a <code class=\"code\">field</code> to a give value.</p>\n\n</div>\n", ["ADDED", "ALREADY", "FIELD", "GIVE", "NEW", "OLD", "ONE", "OTHERWISE", "OVERRIDES", "PROJECT", "SET", "SETS", "THE", "THEN", "VALUE", "WAS"]);
add_ocaml_element("with_memory", "Std.Project.with_memory", "value", "Std.Project.t -> Std.value Std.memmap -> Std.Project.t", "Bap.Std.Project.html#VALwith_memory", "<div class=\"info\">\n<p><code class=\"code\">with_memory&nbsp;project</code> updates project memory.</p>\n\n</div>\n", ["AND", "BAP", "FUNCTION", "INSTEAD", "MEMORY", "POSSIBLE", "PROJECT", "RECOMMENDED", "STD", "SUBSTITUTE", "TAG_MEMORY", "THIS", "UPDATES", "USE", "WITH_MEMORY"]);
add_ocaml_element("substitute", "Std.Project.substitute", "value", "Std.Project.t ->\n  Std.mem -> string Std.tag -> string -> Std.Project.t", "Bap.Std.Project.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;p&nbsp;region&nbsp;tag&nbsp;value</code> is like\n        <a href=\"Bap.Std.Project.html#VALtag_memory\">tag_memory</a>, but it will also apply\n        substitutions in the provided string value, as per OCaml\n        standard library's <code class=\"code\"><span class=\"constructor\">Buffer</span>.add_substitute</code> function.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "ADD_SUBSTITUTE", "ALSO", "APPLY", "ARE", "ASM", "ASSEMBLER", "BASIC", "BELONGS", "BIL", "BLOCK", "BUFFER", "BUT", "BYTE", "CODE", "COMMENT", "CORRESPOND", "ELF", "EXAMPLE", "FILE", "FOLLOWING", "FOR", "FUNCTION", "LAST", "LIBRARY", "LIKE", "LISTING", "MAX_ADDR", "MEMORY", "MIN_ADDR", "NAME", "OCAML", "PER", "PROJECT", "PROVIDED", "REGION", "SECTION", "STANDARD", "STARTING", "STARTS", "STRING", "SUBSTITUTE", "SUBSTITUTIONS", "SUPPORTED", "SYMBOL", "SYMBOL_ADDR", "TAG", "TAGGED", "TAG_MEMORY", "THE", "THIS", "VALUE", "WHICH", "WILL"]);
add_ocaml_element("tag_memory", "Std.Project.tag_memory", "value", "Std.Project.t -> Std.mem -> 'a Std.tag -> 'a -> Std.Project.t", "Bap.Std.Project.html#VALtag_memory", "<div class=\"info\">\n<p><code class=\"code\">tag_memory&nbsp;project&nbsp;region&nbsp;tag&nbsp;value</code> tags a given <code class=\"code\">region</code> of\n        memory in <code class=\"code\">project</code> with a given <code class=\"code\">tag</code> and <code class=\"code\">value</code>.</p>\n\n</div>\n", ["AND", "COLOR", "EXAMPLE", "GIVEN", "MEMORY", "PROJECT", "RED", "REGION", "TAG", "TAGS", "TAG_MEMORY", "TAINED", "VALUE", "WITH"]);
add_ocaml_element("memory", "Std.Project.memory", "value", "Std.Project.t -> Std.value Std.memmap", "Bap.Std.Project.html#VALmemory", "<div class=\"info\">\n<p><code class=\"code\">memory&nbsp;t</code> returns the memory as an interval tree marked with\n        arbitrary values.</p>\n\n</div>\n", ["ARBITRARY", "INTERVAL", "MARKED", "MEMORY", "RETURNS", "THE", "TREE", "VALUES", "WITH"]);
add_ocaml_element("with_storage", "Std.Project.with_storage", "value", "Std.Project.t -> Std.dict -> Std.Project.t", "Bap.Std.Project.html#VALwith_storage", "<div class=\"info\">\n<p>updates the attribute storage</p>\n\n</div>\n", ["ATTRIBUTE", "STORAGE", "THE", "UPDATES"]);
add_ocaml_element("storage", "Std.Project.storage", "value", "Std.Project.t -> Std.dict", "Bap.Std.Project.html#VALstorage", "<div class=\"info\">\n<p>returns an attribute storage of the project</p>\n\n</div>\n", ["ATTRIBUTE", "PROJECT", "RETURNS", "STORAGE", "THE"]);
add_ocaml_element("with_symbols", "Std.Project.with_symbols", "value", "Std.Project.t -> Std.symtab -> Std.Project.t", "Bap.Std.Project.html#VALwith_symbols", "<div class=\"info\">\n<p><code class=\"code\">with_symbols&nbsp;project&nbsp;symbols</code> updates <code class=\"code\">project</code> symbols</p>\n\n</div>\n", ["PROJECT", "SYMBOLS", "UPDATES", "WITH_SYMBOLS"]);
add_ocaml_element("symbols", "Std.Project.symbols", "value", "Std.Project.t -> Std.symtab", "Bap.Std.Project.html#VALsymbols", "<div class=\"info\">\n<p><code class=\"code\">symbols&nbsp;t</code> returns reconstructed symbol table</p>\n\n</div>\n", ["RECONSTRUCTED", "RETURNS", "SYMBOL", "SYMBOLS", "TABLE"]);
add_ocaml_element("with_program", "Std.Project.with_program", "value", "Std.Project.t -> Std.program Std.term -> Std.Project.t", "Bap.Std.Project.html#VALwith_program", "<div class=\"info\">\n<p><code class=\"code\">with_program&nbsp;project&nbsp;program</code> updates a project program</p>\n\n</div>\n", ["PROGRAM", "PROJECT", "UPDATES", "WITH_PROGRAM"]);
add_ocaml_element("program", "Std.Project.program", "value", "Std.Project.t -> Std.program Std.term", "Bap.Std.Project.html#VALprogram", "<div class=\"info\">\n<p><code class=\"code\">program&nbsp;project</code> returns a program lifted into <a href=\"Bap.Std.html#sema\">IR</a></p>\n\n</div>\n", ["INTO", "LIFTED", "PROGRAM", "PROJECT", "RETURNS"]);
add_ocaml_element("disasm", "Std.Project.disasm", "value", "Std.Project.t -> Std.disasm", "Bap.Std.Project.html#VALdisasm", "<div class=\"info\">\n<p><code class=\"code\">disasm&nbsp;project</code> returns results of disassembling</p>\n\n</div>\n", ["DISASM", "DISASSEMBLING", "PROJECT", "RESULTS", "RETURNS"]);
add_ocaml_element("arch", "Std.Project.arch", "value", "Std.Project.t -> Std.arch", "Bap.Std.Project.html#VALarch", "<div class=\"info\">\n<p><code class=\"code\">arch&nbsp;project</code> reveals the architecture of a loaded file</p>\n\n</div>\n", ["ARCH", "ARCHITECTURE", "FILE", "LOADED", "PROJECT", "REVEALS", "THE"]);
add_ocaml_element("create", "Std.Project.create", "value", "?disassembler:string ->\n  ?brancher:Std.brancher Std.source ->\n  ?symbolizer:Std.symbolizer Std.source ->\n  ?rooter:Std.rooter Std.source ->\n  ?reconstructor:Std.reconstructor Std.source ->\n  Std.Project.input -> Std.Project.t Or_error.t", "Bap.Std.Project.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">from_file&nbsp;filename</code> creates a project from a provided input\n        source.</p>\n\n</div>\n", ["ABOVE", "ACHIEVED", "ACTUALLY", "ALGORITHM", "ALL", "ALLOWED", "AND", "ANY", "APPLY", "ARCH", "ARCHITECTURE", "ARCHITECTURES", "ARE", "ARGS", "ARGUMENTS", "ASSUME", "BAP", "BASICALLY", "BEFORE", "BEHAVIOR", "BOTH", "BOTTOM", "BOXES", "BRANCHER", "BUILT", "BUT", "CALL", "CALLING", "CAN", "CASE", "CELLS", "CFG", "CHANGE", "CHANGED", "CHANGES", "CIRCULAR", "CODE", "COMBINATORS", "COMBINE", "COMPILER", "COMPLEX", "COMPUTATION", "CONSTANT", "CONTAINS", "CONTROL", "CREATE", "CREATED", "CREATES", "CREATE_SOURCE", "CRITERIUM", "DATA", "DECIDED", "DECIDES", "DEFINE", "DEFINED", "DENOTE", "DEPEND", "DEPENDENCIES", "DEPENDS", "DEPICTED", "DIARGRAM", "DIFFERENT", "DISASM", "DRIVEN", "DURING", "EASILY", "EASY", "EITHER", "EMPTY", "EVERY", "EXAMPLE", "EXAMPLES", "EXPECTED", "FILE", "FILENAME", "FIRST", "FIXPOINT", "FLOW", "FOLLOWING", "FOR", "FROM", "FROM_FILE", "FUN", "FUNCTION", "GENERALIZATION", "GOOD", "GRAPHS", "GUARANTEED", "INCREMENTALLY", "INFO", "INFORMATION", "INIT", "INITIAL", "INPUT", "INPUTS", "INSTRUCTION", "ITERATIVELY", "ITS", "JUST", "KNOWN", "LET", "LIFT", "LIST", "MAP", "MAY", "MERGE", "MIXING", "MODULE", "MORE", "MULTI", "MUST", "NAME", "NAMES", "NEED", "NEEDS", "NEW", "NIL", "NON", "NONE", "NOT", "NOW", "OF_STRING", "OR_ERROR", "OUR", "OVALS", "OVERALL", "PARSE", "PASS", "PASSED", "PROCESS", "PROCESSES", "PROGRAM", "PROJECT", "PROOF", "PROVIDE", "PROVIDED", "PROVIDES", "REACHED", "RECOMPUTED", "RECONSTR", "RECONSTRUCTION", "RECONSTRUCTOR", "RECREATE", "REPRESENTED", "REQUIRES", "RESPECT", "RETURN", "ROOTER", "RUN", "SECOND", "SEVERAL", "SINCE", "SOME", "SOURCE", "SOURCES", "SPECIFIED", "START", "STARTED", "STARTS", "STATE", "STD", "STILL", "STOPS", "STREAM", "STREAMS", "STRING", "SUCCESSORS", "SUPPOSE", "SYMBOLIZER", "SYMTAB", "TERM", "THAN", "THAT", "THE", "THEM", "THEN", "THEY", "THIS", "THREE", "TIME", "TWO", "TYPE", "UNTIL", "USED", "USER", "USING", "VALUE", "VALUES", "VARIABLES", "VARIADIC", "VIEWED", "WHEN", "WHERE", "WILL", "WITH"]);
add_ocaml_element("progress", "Std.Event.Log.progress", "value", "?note:string -> ?stage:int -> ?total:int -> string -> unit", "Bap.Std.Event.Log.html#VALprogress", "<div class=\"info\">\n<p><code class=\"code\">progress&nbsp;?note&nbsp;?stage&nbsp;?total&nbsp;name</code> sends a progress report.</p>\n\n</div>\n", ["ALL", "COMPONENTS", "DEFAULTS", "FROM", "FUNCTION", "INTERFACE", "MAIN", "NAME", "NONE", "NOTE", "ONLY", "PARAMETERS", "PLUGINS", "PROGRESS", "REPORT", "REPORT_PROGRESS", "SELF", "SENDS", "SHOULD", "STAGE", "THE", "THIS", "TOTAL", "USE", "USED", "WHILE"]);
add_ocaml_element("message", "Std.Event.Log.message", "value", "Std.Event.Log.level ->\n  section:string ->\n  ('a, Stdlib.Format.formatter, unit) format -> 'a", "Bap.Std.Event.Log.html#VALmessage", "<div class=\"info\">\n<p><code class=\"code\">message&nbsp;level&nbsp;~section&nbsp;fmt&nbsp;...</code> send a message of the\n          specified <code class=\"code\">level</code> and <code class=\"code\">section</code>.</p>\n\n</div>\n", ["AND", "CORRESPONDING", "CREATED", "DIRECTLY", "FMT", "FUNCTION", "FUNCTIONS", "FUNCTOR", "INCLUDE", "INFO", "INSTANTIATION", "INSTEAD", "LEVEL", "LOGGING", "MESSAGE", "NOT", "SECTION", "SELF", "SEND", "SOME", "SPECIFIED", "THE", "THING", "THIS", "USE"]);
add_ocaml_element("register_printer", "Std.Event.register_printer", "value", "(Std.Event.t -> string option) -> unit", "Bap.Std.Event.html#VALregister_printer", "<div class=\"info\">\n<p><code class=\"code\">register_printer&nbsp;f</code> when event <code class=\"code\">e</code> is printed, <code class=\"code\">f&nbsp;e</code> must be\n        <code class=\"code\"><span class=\"constructor\">None</span></code> if <code class=\"code\">f</code> is not a subset of events, that is intended to be\n        printed by an <code class=\"code\">f</code>.</p>\n\n</div>\n", ["EVENT", "EVENTS", "FOR", "HAS", "INTENDED", "LAST", "MORE", "MUST", "NONE", "NOT", "ONE", "OUT", "PRECEDENCE", "PRINTED", "PRINTER", "REGISTERED", "REGISTER_PRINTER", "RETURNS", "SAME", "SOME", "STR", "SUBSET", "THAN", "THAT", "THE", "THEN", "THING", "WHEN"]);
add_ocaml_element("send", "Std.Event.send", "value", "Std.Event.t -> unit", "Bap.Std.Event.html#VALsend", "<div class=\"info\">\n<p><code class=\"code\">send&nbsp;event</code> to the <a href=\"Bap.Std.Event.html#VALstream\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Event</span>.stream</code></a></p>\n\n</div>\n", ["BAP", "EVENT", "SEND", "STD", "STREAM", "THE"]);
add_ocaml_element("stream", "Std.Event.stream", "value", "Std.Event.t Bap_future.Std.stream", "Bap.Std.Event.html#VALstream", "<div class=\"info\">\n<p>global <code class=\"code\">stream</code> of events</p>\n\n</div>\n", ["EVENTS", "GLOBAL", "STREAM"]);
add_ocaml_element("run", "Std.Reconstructor.run", "value", "Std.Reconstructor.t -> Std.cfg -> Std.symtab", "Bap.Std.Reconstructor.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;reconstructor&nbsp;cfg</code> reconstructs a symbol table from a\n        given cfg</p>\n\n</div>\n", ["CFG", "FROM", "GIVEN", "RECONSTRUCTOR", "RECONSTRUCTS", "RUN", "SYMBOL", "TABLE"]);
add_ocaml_element("of_blocks", "Std.Reconstructor.of_blocks", "value", "(string * Std.addr * Std.addr) Std.seq -> Std.Reconstructor.t", "Bap.Std.Reconstructor.html#VALof_blocks", "<div class=\"info\">\n<p><code class=\"code\">of_blocks</code> produces a reconstructor from a serialized\n        sequence of blocks.</p>\n\n</div>\n", ["ADDRESS", "AND", "BLOCK", "BLOCKS", "DECONSTRUCTED", "EACH", "ELEMENT", "END", "FROM", "NAME", "OF_BLOCKS", "PRODUCES", "RECONSTRUCTOR", "SEQUENCE", "SERIALIZED", "START", "SUBROUTINE", "THE", "VIRTUAL", "WHERE"]);
add_ocaml_element("default", "Std.Reconstructor.default", "value", "(Std.word -> string) -> Std.word list -> Std.Reconstructor.t", "Bap.Std.Reconstructor.html#VALdefault", "<div class=\"info\">\n<p><code class=\"code\">default&nbsp;name&nbsp;roots</code> builds a reconstructor from a given\n        function, that maps addresses to function names (see\n        <a href=\"Bap.Std.Symbolizer.html\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Symbolizer</span></code></a>) and a list of known function starts.</p>\n\n</div>\n", ["ADDRESSES", "ALSO", "AND", "BAP", "BLOCK", "BUILDS", "BUILT", "CALL", "CALLS", "CFG", "DEFAULT", "DEFINITION", "DESTINATIONS", "EACH", "EDGES", "ENTRY", "EVERY", "EXTEND", "FOLLOWING", "FOR", "FOUND", "FROM", "FUNCTION", "GIVEN", "INPUT", "INSTRUCTIONS", "KNOWN", "LIST", "MAPS", "NAME", "NAMES", "NODE", "REACHABLE", "RECONSTRUCTOR", "ROOTS", "SEE", "START", "STARTS", "STD", "SYMBOLIZER", "THAT", "THE", "TREATS", "USING", "WILL", "WITH", "WITHOUT"]);
add_ocaml_element("create", "Std.Reconstructor.create", "value", "(Std.cfg -> Std.symtab) -> Std.Reconstructor.t", "Bap.Std.Reconstructor.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;f</code> creates a reconstructor from a given function <code class=\"code\">f</code></p>\n\n</div>\n", ["CREATE", "CREATES", "FROM", "FUNCTION", "GIVEN", "RECONSTRUCTOR"]);
add_ocaml_element("resolve", "Std.Brancher.resolve", "value", "Std.Brancher.t ->\n  Std.mem ->\n  Std.Disasm_expert.Basic.full_insn -> Std.Brancher.dests", "Bap.Std.Brancher.html#VALresolve", "<div class=\"info\">\n<p><code class=\"code\">resolve&nbsp;brancher&nbsp;mem&nbsp;insn</code> returns a list of destinations of\n        the instruction <code class=\"code\">insn</code>, that occupies memory region <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["BRANCHER", "DESTINATIONS", "INSN", "INSTRUCTION", "LIST", "MEM", "MEMORY", "OCCUPIES", "REGION", "RESOLVE", "RETURNS", "THAT", "THE"]);
add_ocaml_element("of_bil", "Std.Brancher.of_bil", "value", "Std.arch -> Std.Brancher.t", "Bap.Std.Brancher.html#VALof_bil", "<div class=\"info\">\n<p><code class=\"code\">of_bil&nbsp;arch</code> creates a brancher that will use a BIL code to\n        statically deduce the instruction destinations.</p>\n\n</div>\n", ["ARCH", "BIL", "BRANCHER", "CODE", "CREATES", "DEDUCE", "DESTINATIONS", "INSTRUCTION", "OF_BIL", "STATICALLY", "THAT", "THE", "USE", "WILL"]);
add_ocaml_element("create", "Std.Brancher.create", "value", "(Std.mem ->\n   Std.Disasm_expert.Basic.full_insn -> Std.Brancher.dests) ->\n  Std.Brancher.t", "Bap.Std.Brancher.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;resolve</code> creates a brancher from <code class=\"code\">resolve</code> function,\n        that accepts a memory region, occupied by an instruction, the\n        instruction itself and returns a list of destination.</p>\n\n</div>\n", ["ACCEPTS", "AND", "BRANCHER", "CREATE", "CREATES", "DESTINATION", "FROM", "FUNCTION", "INSTRUCTION", "ITSELF", "LIST", "MEMORY", "OCCUPIED", "REGION", "RESOLVE", "RETURNS", "THAT", "THE"]);
add_ocaml_element("union", "Std.Rooter.union", "value", "Std.Rooter.t -> Std.Rooter.t -> Std.Rooter.t", "Bap.Std.Rooter.html#VALunion", "<div class=\"info\">\n<p><code class=\"code\">union&nbsp;r1&nbsp;r2</code> joins roots from rooters <code class=\"code\">r1</code> and <code class=\"code\">r2</code></p>\n\n</div>\n", ["AND", "FROM", "JOINS", "ROOTERS", "ROOTS", "UNION"]);
add_ocaml_element("roots", "Std.Rooter.roots", "value", "Std.Rooter.t -> Std.addr Std.seq", "Bap.Std.Rooter.html#VALroots", "<div class=\"info\">\n<p><code class=\"code\">roots&nbsp;r</code> enumerates roots found by rooter <code class=\"code\">r</code></p>\n\n</div>\n", ["ENUMERATES", "FOUND", "ROOTER", "ROOTS"]);
add_ocaml_element("of_blocks", "Std.Rooter.of_blocks", "value", "(string * Std.addr * Std.addr) Std.seq -> Std.Rooter.t", "Bap.Std.Rooter.html#VALof_blocks", "<div class=\"info\">\n<p><code class=\"code\">of_blocks</code> produces a rooter from a serialized\n        sequence of blocks.</p>\n\n</div>\n", ["ADDRESS", "AND", "BLOCK", "BLOCKS", "DECONSTRUCTED", "EACH", "ELEMENT", "END", "FROM", "NAME", "OF_BLOCKS", "PRODUCES", "ROOTER", "SEQUENCE", "SERIALIZED", "START", "SUBROUTINE", "THE", "VIRTUAL", "WHERE"]);
add_ocaml_element("of_image", "Std.Rooter.of_image", "value", "Std.image -> Std.Rooter.t", "Bap.Std.Rooter.html#VALof_image", "<div class=\"info\">\n<p><code class=\"code\">of_image&nbsp;img</code> create a rooter that will use existing symbol\n        information inside the image, to find roots.</p>\n\n</div>\n", ["CREATE", "EXISTING", "FIND", "IMAGE", "IMG", "INFORMATION", "INSIDE", "OF_IMAGE", "ROOTER", "ROOTS", "SYMBOL", "THAT", "THE", "USE", "WILL"]);
add_ocaml_element("create", "Std.Rooter.create", "value", "Std.addr Std.seq -> Std.Rooter.t", "Bap.Std.Rooter.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;seq</code> creates a rooter from a given sequence of addresses</p>\n\n</div>\n", ["ADDRESSES", "CREATE", "CREATES", "FROM", "GIVEN", "ROOTER", "SEQ", "SEQUENCE"]);
add_ocaml_element("empty", "Std.Symbolizer.empty", "value", "Std.Symbolizer.t", "Bap.Std.Symbolizer.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty</code> is a symbolizer that knows nothing.</p>\n\n</div>\n", ["EMPTY", "KNOWS", "NOTHING", "SYMBOLIZER", "THAT"]);
add_ocaml_element("chain", "Std.Symbolizer.chain", "value", "Std.Symbolizer.t list -> Std.Symbolizer.t", "Bap.Std.Symbolizer.html#VALchain", "<div class=\"info\">\n<p><code class=\"code\">chain&nbsp;ss</code> creates a symbolizer, that will try to resolve\n        an address using each symbolizer in order.</p>\n\n</div>\n", ["ADDRESS", "CHAIN", "CREATES", "EACH", "ORDER", "RESOLVE", "SYMBOLIZER", "THAT", "TRY", "USING", "WILL"]);
add_ocaml_element("resolve", "Std.Symbolizer.resolve", "value", "Std.Symbolizer.t -> Std.addr -> string", "Bap.Std.Symbolizer.html#VALresolve", "<div class=\"info\">\n<p><code class=\"code\">resolve&nbsp;symbolizer&nbsp;addr</code> returns a name of function,\n        to which a given address belongs.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "BELONGS", "CONSTRUCTED", "FROM", "FUNCTION", "GIVEN", "KNOW", "NAME", "NOT", "RESOLVE", "RETURNS", "SYMBOLIZER", "THE", "THEN", "WHICH"]);
add_ocaml_element("of_blocks", "Std.Symbolizer.of_blocks", "value", "(string * Std.addr * Std.addr) Std.seq -> Std.Symbolizer.t", "Bap.Std.Symbolizer.html#VALof_blocks", "<div class=\"info\">\n<p><code class=\"code\">of_blocks</code> produces a symbolizer from a serialized\n        sequence of blocks.</p>\n\n</div>\n", ["ADDRESS", "AND", "BLOCK", "BLOCKS", "DECONSTRUCTED", "EACH", "ELEMENT", "END", "FROM", "NAME", "OF_BLOCKS", "PRODUCES", "SEQUENCE", "SERIALIZED", "START", "SUBROUTINE", "SYMBOLIZER", "THE", "VIRTUAL", "WHERE"]);
add_ocaml_element("create", "Std.Symbolizer.create", "value", "(Std.addr -> string option) -> Std.Symbolizer.t", "Bap.Std.Symbolizer.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;fn</code> creates a symbolizer for a given function</p>\n\n</div>\n", ["CREATE", "CREATES", "FOR", "FUNCTION", "GIVEN", "SYMBOLIZER"]);
add_ocaml_element("pp_map", "Std.Taint.pp_map", "value", "Std.Taint.map Std.printer", "Bap.Std.Taint.html#VALpp_map", "<div class=\"info\">\n<p>print a taint map</p>\n\n</div>\n", ["MAP", "PRINT", "TAINT"]);
add_ocaml_element("pp_set", "Std.Taint.pp_set", "value", "Std.Taint.set Std.printer", "Bap.Std.Taint.html#VALpp_set", "<div class=\"info\">\n<p>print a set of taints</p>\n\n</div>\n", ["PRINT", "SET", "TAINTS"]);
add_ocaml_element("merge", "Std.Taint.merge", "value", "Std.Taint.map -> Std.Taint.map -> Std.Taint.map", "Bap.Std.Taint.html#VALmerge", "<div class=\"info\">\n<p><code class=\"code\">merge&nbsp;t1&nbsp;t2</code> merge taint maps</p>\n\n</div>\n", ["MAPS", "MERGE", "TAINT"]);
add_ocaml_element("ptrs", "Std.Taint.ptrs", "value", "Std.Taint.map Std.tag", "Bap.Std.Taint.html#VALptrs", "<div class=\"info\">\n<p>maps each variable that is used in a term to a set of pointer taints</p>\n\n</div>\n", ["EACH", "MAPS", "POINTER", "SET", "TAINTS", "TERM", "THAT", "USED", "VARIABLE"]);
add_ocaml_element("regs", "Std.Taint.regs", "value", "Std.Taint.map Std.tag", "Bap.Std.Taint.html#VALregs", "<div class=\"info\">\n<p>maps each variable that is used in a term to a set of register taints</p>\n\n</div>\n", ["EACH", "MAPS", "REGISTER", "SET", "TAINTS", "TERM", "THAT", "USED", "VARIABLE"]);
add_ocaml_element("ptr", "Std.Taint.ptr", "value", "Std.Taint.t Std.tag", "Bap.Std.Taint.html#VALptr", "<div class=\"info\">\n<p>value stored at memory location, that is stored\n        in the register is tainted.</p>\n\n</div>\n", ["LOCATION", "MEMORY", "REGISTER", "STORED", "TAINTED", "THAT", "THE", "VALUE"]);
add_ocaml_element("reg", "Std.Taint.reg", "value", "Std.Taint.t Std.tag", "Bap.Std.Taint.html#VALreg", "<div class=\"info\">\n<p>value stored in register is source of taint</p>\n\n</div>\n", ["REGISTER", "SOURCE", "STORED", "TAINT", "VALUE"]);
add_ocaml_element("register", "Std.Source.Factory.S.register", "value", "string -> Std.Source.Factory.S.t Std.Source.source -> unit", "Bap.Std.Source.Factory.S.html#VALregister", "<div class=\"info\">\n<p><code class=\"code\">register&nbsp;name&nbsp;cons</code> registers a method that creates a given\n            source of information.</p>\n\n</div>\n", ["ALREADY", "CONS", "CREATES", "EXISTS", "GIVEN", "INFORMATION", "METHOD", "NAME", "NEW", "ONE", "REGISTER", "REGISTERS", "SOURCE", "SUPERCEEDED", "THAT", "THE", "THEN", "WILL", "WITH"]);
add_ocaml_element("find", "Std.Source.Factory.S.find", "value", "string -> Std.Source.Factory.S.t Std.Source.source option", "Bap.Std.Source.Factory.S.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;name&nbsp;args</code> finds a source provider with the\n            given name and creates it</p>\n\n</div>\n", ["AND", "ARGS", "CREATE", "CREATES", "FINDS", "GIVEN", "NAME", "PROVIDER", "SOURCE", "THE", "WITH"]);
add_ocaml_element("list", "Std.Source.Factory.S.list", "value", "unit -> string list", "Bap.Std.Source.Factory.S.html#VALlist", "<div class=\"info\">\n<p><code class=\"code\">list&nbsp;source</code> is a list of names of source providers</p>\n\n</div>\n", ["LIST", "NAMES", "PROVIDERS", "SOURCE"]);
add_ocaml_element("change", "Std.Label.change", "value", "?direct:(Std.tid -> Std.tid) ->\n  ?indirect:(Std.exp -> Std.exp) -> Std.Label.t -> Std.Label.t", "Bap.Std.Label.html#VALchange", "<div class=\"info\">\n<p>updates the label</p>\n\n</div>\n", ["LABEL", "THE", "UPDATES"]);
add_ocaml_element("indirect", "Std.Label.indirect", "value", "Std.exp -> Std.Label.t", "Bap.Std.Label.html#VALindirect", "<div class=\"info\">\n<p><code class=\"code\">indirect&nbsp;exp</code> creates a label that is resolved to an\n        expression <code class=\"code\">exp</code></p>\n\n</div>\n", ["CREATES", "EXP", "EXPRESSION", "INDIRECT", "LABEL", "RESOLVED", "THAT"]);
add_ocaml_element("direct", "Std.Label.direct", "value", "Std.tid -> Std.Label.t", "Bap.Std.Label.html#VALdirect", "<div class=\"info\">\n<p><code class=\"code\">direct&nbsp;label</code> creates a direct label with a given identifier.</p>\n\n</div>\n", ["CREATES", "DIRECT", "GIVEN", "IDENTIFIER", "LABEL", "WITH"]);
add_ocaml_element("create", "Std.Label.create", "value", "unit -> Std.Label.t", "Bap.Std.Label.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates a new label with a freshly generated\n        identifier.</p>\n\n</div>\n", ["CREATE", "CREATES", "FRESHLY", "GENERATED", "IDENTIFIER", "LABEL", "NEW", "WITH"]);
add_ocaml_element("with_noreturn", "Std.Call.with_noreturn", "value", "Std.Call.t -> Std.Call.t", "Bap.Std.Call.html#VALwith_noreturn", "<div class=\"info\">\n<p>marks call as a \"noreturn\"</p>\n\n</div>\n", ["CALL", "MARKS", "NORETURN"]);
add_ocaml_element("with_return", "Std.Call.with_return", "value", "Std.Call.t -> Std.label -> Std.Call.t", "Bap.Std.Call.html#VALwith_return", "<div class=\"info\">\n<p>updates return continuation</p>\n\n</div>\n", ["CONTINUATION", "RETURN", "UPDATES"]);
add_ocaml_element("with_target", "Std.Call.with_target", "value", "Std.Call.t -> Std.label -> Std.Call.t", "Bap.Std.Call.html#VALwith_target", "<div class=\"info\">\n<p>updates target</p>\n\n</div>\n", ["TARGET", "UPDATES"]);
add_ocaml_element("return", "Std.Call.return", "value", "Std.Call.t -> Std.label option", "Bap.Std.Call.html#VALreturn", "<div class=\"info\">\n<p>returns call continuation</p>\n\n</div>\n", ["CALL", "CONTINUATION", "RETURNS"]);
add_ocaml_element("target", "Std.Call.target", "value", "Std.Call.t -> Std.label", "Bap.Std.Call.html#VALtarget", "<div class=\"info\">\n<p>returns the target of the call</p>\n\n</div>\n", ["CALL", "RETURNS", "TARGET", "THE"]);
add_ocaml_element("create", "Std.Call.create", "value", "?return:Std.label -> target:Std.label -> unit -> Std.Call.t", "Bap.Std.Call.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?return&nbsp;~target&nbsp;()</code> creates a call to the <code class=\"code\">target</code>\n        subroutine.</p>\n\n</div>\n", ["ASSUMED", "CALL", "CREATE", "CREATES", "DOESN", "NOT", "PROVIDED", "RETURN", "SUBROUTINE", "TARGET", "THAT", "THE"]);
add_ocaml_element("nonnull", "Std.Arg.nonnull", "value", "unit Std.tag", "Bap.Std.Arg.html#VALnonnull", "<div class=\"info\">\n<p>a contract requirement that this argument is not NULL.</p>\n\n</div>\n", ["ARGUMENT", "CONTRACT", "NOT", "NULL", "REQUIREMENT", "THAT", "THIS"]);
add_ocaml_element("format", "Std.Arg.format", "value", "string Std.tag", "Bap.Std.Arg.html#VALformat", "<div class=\"info\">\n<p>format(DSL) the specified argument of a subroutine is\n        actually a format string written in a corresponding DSL.</p>\n\n</div>\n", ["ACTUALLY", "ARGUMENT", "CORRESPONDING", "DSL", "FORMAT", "SPECIFIED", "STRING", "SUBROUTINE", "THE", "WRITTEN"]);
add_ocaml_element("alloc_size", "Std.Arg.alloc_size", "value", "unit Std.tag", "Bap.Std.Arg.html#VALalloc_size", "<div class=\"info\">\n<p>the size of allocated memory is the product of arguments\n        marked with <code class=\"code\">alloc_size</code> attribute</p>\n\n</div>\n", ["ALLOCATED", "ALLOC_SIZE", "ARGUMENTS", "ATTRIBUTE", "MARKED", "MEMORY", "PRODUCT", "SIZE", "THE", "WITH"]);
add_ocaml_element("warn_unused", "Std.Arg.warn_unused", "value", "unit Std.tag", "Bap.Std.Arg.html#VALwarn_unused", "<div class=\"info\">\n<p>a caller of the subroutine must use an argument tagged with\n        this attribute.</p>\n\n</div>\n", ["ALWAYS", "ARGUMENT", "ATTRIBUTE", "BUG", "CALLER", "CHECKING", "EITHER", "FOR", "MUST", "NOT", "PROBLEM", "REALLOC", "RESULT", "SECURITY", "SUBROUTINE", "SUBROUTINES", "SUCH", "TAGGED", "THE", "THIS", "USE", "USEFUL", "WHERE", "WITH"]);
add_ocaml_element("with_unknown_intent", "Std.Arg.with_unknown_intent", "value", "Std.Arg.t -> Std.Arg.t", "Bap.Std.Arg.html#VALwith_unknown_intent", "<div class=\"info\">\n<p>removes the intent from an argument</p>\n\n</div>\n", ["ARGUMENT", "FROM", "INTENT", "REMOVES", "THE"]);
add_ocaml_element("with_intent", "Std.Arg.with_intent", "value", "Std.Arg.t -> Std.intent -> Std.Arg.t", "Bap.Std.Arg.html#VALwith_intent", "<div class=\"info\">\n<p><code class=\"code\">with_intent&nbsp;intent&nbsp;arg</code> updates argument intent</p>\n\n</div>\n", ["ARG", "ARGUMENT", "INTENT", "UPDATES", "WITH_INTENT"]);
add_ocaml_element("intent", "Std.Arg.intent", "value", "Std.Arg.t -> Std.intent option", "Bap.Std.Arg.html#VALintent", "<div class=\"info\">\n<p><code class=\"code\">intent&nbsp;arg</code> returns the argument intent.</p>\n\n</div>\n", ["ARG", "ARGUMENT", "DENONTES", "INTENT", "NONE", "RETURNS", "THE", "UNKNOWN", "VALUE"]);
add_ocaml_element("rhs", "Std.Arg.rhs", "value", "Std.Arg.t -> Std.exp", "Bap.Std.Arg.html#VALrhs", "<div class=\"info\">\n<p><code class=\"code\">rhs&nbsp;arg</code> returns an expression to which argument is\n        bound.</p>\n\n</div>\n", ["ARG", "ARGUMENT", "BOUND", "EXPRESSION", "RETURNS", "RHS", "WHICH"]);
add_ocaml_element("lhs", "Std.Arg.lhs", "value", "Std.Arg.t -> Std.var", "Bap.Std.Arg.html#VALlhs", "<div class=\"info\">\n<p><code class=\"code\">lhs&nbsp;arg</code> returns a variable associated with the argument.</p>\n\n</div>\n", ["ARG", "ARGUMENT", "ASSOCIATED", "LHS", "RETURNS", "THE", "VARIABLE", "WITH"]);
add_ocaml_element("create", "Std.Arg.create", "value", "?tid:Std.tid ->\n  ?intent:Std.intent -> Std.var -> Std.exp -> Std.Arg.t", "Bap.Std.Arg.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?intent&nbsp;var&nbsp;exp</code> creates an argument.</p>\n\n</div>\n", ["ARGUMENT", "CREATE", "CREATES", "EXP", "INTENT", "LEFT", "NOT", "SPECIFIED", "UNKNOWN", "VAR"]);
add_ocaml_element("remove", "Std.Phi.remove", "value", "Std.Phi.t -> Std.tid -> Std.Phi.t", "Bap.Std.Phi.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;def&nbsp;id</code> removes definition with a given <code class=\"code\">id</code></p>\n\n</div>\n", ["DEF", "DEFINITION", "GIVEN", "REMOVE", "REMOVES", "WITH"]);
add_ocaml_element("select_or_unknown", "Std.Phi.select_or_unknown", "value", "Std.Phi.t -> Std.tid -> Std.exp", "Bap.Std.Phi.html#VALselect_or_unknown", "<div class=\"info\">\n<p><code class=\"code\">select_or_unknown&nbsp;phi&nbsp;label</code> is <code class=\"code\">exp</code> if\n        <code class=\"code\">select&nbsp;phi&nbsp;label&nbsp;=&nbsp;<span class=\"constructor\">Some</span>&nbsp;exp</code>, otherwise returns a\n        <code class=\"code\"><span class=\"constructor\">Bil</span>.unknown</code> expression.</p>\n\n</div>\n", ["BIL", "EXP", "EXPRESSION", "LABEL", "OTHERWISE", "PHI", "RETURNS", "SELECT", "SELECT_OR_UNKNOWN", "SOME", "UNKNOWN"]);
add_ocaml_element("select", "Std.Phi.select", "value", "Std.Phi.t -> Std.tid -> Std.exp option", "Bap.Std.Phi.html#VALselect", "<div class=\"info\">\n<p><code class=\"code\">select&nbsp;phi&nbsp;label</code> takes the value corresponding to a control\n        flow path marked with <code class=\"code\">label</code>.</p>\n\n</div>\n", ["CONTROL", "CORRESPONDING", "FLOW", "LABEL", "MARKED", "PATH", "PHI", "SELECT", "TAKES", "THE", "VALUE", "WITH"]);
add_ocaml_element("update", "Std.Phi.update", "value", "Std.Phi.t -> Std.tid -> Std.exp -> Std.Phi.t", "Bap.Std.Phi.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;phi&nbsp;label&nbsp;exp</code> associates expression <code class=\"code\">exp</code> with a\n        control flow path labeled with <code class=\"code\">label</code>.</p>\n\n</div>\n", ["ASSOCIATES", "CONTROL", "EXP", "EXPRESSION", "FLOW", "LABEL", "LABELED", "PATH", "PHI", "UPDATE", "WITH"]);
add_ocaml_element("substitute", "Std.Phi.substitute", "value", "Std.Phi.t -> Std.exp -> Std.exp -> Std.Phi.t", "Bap.Std.Phi.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;phi&nbsp;x&nbsp;y</code> substitutes <code class=\"code\">x</code> by <code class=\"code\">y</code> in all right\n        hand-side expressions of the <code class=\"code\">phi</code> node.</p>\n\n</div>\n", ["ALL", "EXPRESSIONS", "HAND", "NODE", "PHI", "RIGHT", "SIDE", "SUBSTITUTE", "SUBSTITUTES", "THE"]);
add_ocaml_element("map_exp", "Std.Phi.map_exp", "value", "Std.Phi.t -> f:(Std.exp -> Std.exp) -> Std.Phi.t", "Bap.Std.Phi.html#VALmap_exp", "<div class=\"info\">\n<p><code class=\"code\">map_exp&nbsp;t&nbsp;~f</code> applies <code class=\"code\">f</code> to all expressions on the right\n        hand side of a phi-node <code class=\"code\">t</code></p>\n\n</div>\n", ["ALL", "APPLIES", "EXPRESSIONS", "HAND", "MAP_EXP", "NODE", "PHI", "RIGHT", "SIDE", "THE"]);
add_ocaml_element("with_lhs", "Std.Phi.with_lhs", "value", "Std.Phi.t -> Std.var -> Std.Phi.t", "Bap.Std.Phi.html#VALwith_lhs", "<div class=\"info\">\n<p><code class=\"code\">with_lhs&nbsp;phi&nbsp;var</code> updates a left hand side of <code class=\"code\">phi</code> with\n        <code class=\"code\">var</code></p>\n\n</div>\n", ["HAND", "LEFT", "PHI", "SIDE", "UPDATES", "VAR", "WITH", "WITH_LHS"]);
add_ocaml_element("lhs", "Std.Phi.lhs", "value", "Std.Phi.t -> Std.var", "Bap.Std.Phi.html#VALlhs", "<div class=\"info\">\n<p><code class=\"code\">lhs&nbsp;phi</code> returns a variable associated with a phi node</p>\n\n</div>\n", ["ASSOCIATED", "LHS", "NODE", "PHI", "RETURNS", "VARIABLE", "WITH"]);
add_ocaml_element("free_vars", "Std.Phi.free_vars", "value", "Std.Phi.t -> Std.Var.Set.t", "Bap.Std.Phi.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;t</code> returns a set of variables that occur free on\n        the right hand side of the phi-node.</p>\n\n</div>\n", ["ARE", "CLARIFICATION", "CONSIDERED", "FOR", "FREE", "FREE_VARS", "HAND", "NODE", "OCCUR", "PHI", "RETURNS", "RIGHT", "SEE", "SET", "SIDE", "THAT", "THE", "VARIABLES", "WHAT"]);
add_ocaml_element("values", "Std.Phi.values", "value", "Std.Phi.t -> (Std.tid * Std.exp) Std.seq", "Bap.Std.Phi.html#VALvalues", "<div class=\"info\">\n<p><code class=\"code\">values&nbsp;phi</code> enumerate all possible values.</p>\n\n</div>\n", ["ALL", "ENUMERATE", "PHI", "POSSIBLE", "VALUES"]);
add_ocaml_element("of_list", "Std.Phi.of_list", "value", "?tid:Std.tid ->\n  Std.var -> (Std.tid * Std.exp) list -> Std.Phi.t", "Bap.Std.Phi.html#VALof_list", "<div class=\"info\">\n<p><code class=\"code\">of_list&nbsp;var&nbsp;bindings</code> creates a phi-node, that for each pair\n        of <code class=\"code\">label,exp</code> in the <code class=\"code\">bindings</code> list associates variable <code class=\"code\">var</code>\n        with expression <code class=\"code\">exp</code> if control flow reaches this point via block\n        labeled with <code class=\"code\">label</code>.</p>\n\n</div>\n", ["ASSOCIATES", "BINDINGS", "BLOCK", "CONTROL", "CREATES", "EACH", "EXP", "EXPRESSION", "FLOW", "FOR", "LABEL", "LABELED", "LIST", "NODE", "OF_LIST", "PAIR", "PHI", "POINT", "REACHES", "THAT", "THE", "THIS", "VAR", "VARIABLE", "VIA", "WITH"]);
add_ocaml_element("create", "Std.Phi.create", "value", "?tid:Std.tid ->\n  Std.var -> Std.tid -> Std.exp -> Std.Phi.t", "Bap.Std.Phi.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;var&nbsp;label&nbsp;exp</code> creates a phi-node that associates a\n        variable <code class=\"code\">var</code> with an expression <code class=\"code\">exp</code>.</p>\n\n</div>\n", ["ASSOCIATES", "BLOCK", "CONTROL", "CREATE", "CREATES", "ENTERS", "EXAMPLE", "EXP", "EXPRESSION", "FLOW", "FROM", "LABEL", "LABELED", "LOOP_HEADER", "NODE", "OWNS", "PHI", "SELECTED", "SHOULD", "THAT", "THIS", "VAR", "VARIABLE", "WITH"]);
add_ocaml_element("with_kind", "Std.Jmp.with_kind", "value", "Std.Jmp.t -> Std.jmp_kind -> Std.Jmp.t", "Bap.Std.Jmp.html#VALwith_kind", "<div class=\"info\">\n<p>updated jump's kind</p>\n\n</div>\n", ["JUMP", "KIND", "UPDATED"]);
add_ocaml_element("with_cond", "Std.Jmp.with_cond", "value", "Std.Jmp.t -> Std.exp -> Std.Jmp.t", "Bap.Std.Jmp.html#VALwith_cond", "<div class=\"info\">\n<p>updated jump's guard condition</p>\n\n</div>\n", ["CONDITION", "GUARD", "JUMP", "UPDATED"]);
add_ocaml_element("substitute", "Std.Jmp.substitute", "value", "Std.Jmp.t -> Std.exp -> Std.exp -> Std.Jmp.t", "Bap.Std.Jmp.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;jmp&nbsp;x&nbsp;y</code> substitutes <code class=\"code\">x</code> by <code class=\"code\">y</code> in all expressions\n        that occur in jump <code class=\"code\">jmp</code> expressions.</p>\n\n</div>\n", ["ALL", "EXPRESSIONS", "JMP", "JUMP", "OCCUR", "SUBSTITUTE", "SUBSTITUTES", "THAT"]);
add_ocaml_element("map_exp", "Std.Jmp.map_exp", "value", "Std.Jmp.t -> f:(Std.exp -> Std.exp) -> Std.Jmp.t", "Bap.Std.Jmp.html#VALmap_exp", "<div class=\"info\">\n<p><code class=\"code\">map_exp&nbsp;jmp&nbsp;~f</code> applies <code class=\"code\">f</code> to each expression in a <code class=\"code\">jmp</code>,\n        e.g., conditions and indirect labels.</p>\n\n</div>\n", ["AND", "APPLIES", "CONDITIONS", "EACH", "EXPRESSION", "INDIRECT", "JMP", "LABELS", "MAP_EXP"]);
add_ocaml_element("free_vars", "Std.Jmp.free_vars", "value", "Std.Jmp.t -> Std.Var.Set.t", "Bap.Std.Jmp.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;jmp</code> returns a set of all variables that are free\n        in some expression in the jump <code class=\"code\">jmp</code>.</p>\n\n</div>\n", ["ALL", "ARE", "EXPRESSION", "FREE", "FREE_VARS", "JMP", "JUMP", "RETURNS", "SET", "SOME", "THAT", "THE", "VARIABLES"]);
add_ocaml_element("exps", "Std.Jmp.exps", "value", "Std.Jmp.t -> Std.exp Std.seq", "Bap.Std.Jmp.html#VALexps", "<div class=\"info\">\n<p><code class=\"code\">exps&nbsp;jmp</code> returns a sequence of expressions occurring in\n        different positions of a jump <code class=\"code\">jmp</code>, e.g., in <code class=\"code\">cond</code>,\n        <code class=\"code\">target</code>, etc.</p>\n\n</div>\n", ["COND", "DIFFERENT", "ETC", "EXPRESSIONS", "EXPS", "JMP", "JUMP", "OCCURRING", "POSITIONS", "RETURNS", "SEQUENCE", "TARGET"]);
add_ocaml_element("cond", "Std.Jmp.cond", "value", "Std.Jmp.t -> Std.exp", "Bap.Std.Jmp.html#VALcond", "<div class=\"info\">\n<p><code class=\"code\">cond&nbsp;jmp</code> returns the jump guard condition</p>\n\n</div>\n", ["COND", "CONDITION", "GUARD", "JMP", "JUMP", "RETURNS", "THE"]);
add_ocaml_element("kind", "Std.Jmp.kind", "value", "Std.Jmp.t -> Std.jmp_kind", "Bap.Std.Jmp.html#VALkind", "<div class=\"info\">\n<p><code class=\"code\">kind&nbsp;jmp</code> evaluates to a kind of jump</p>\n\n</div>\n", ["EVALUATES", "JMP", "JUMP", "KIND"]);
add_ocaml_element("create_int", "Std.Jmp.create_int", "value", "?tid:Std.tid -> ?cond:Std.exp -> int -> Std.tid -> Std.Jmp.t", "Bap.Std.Jmp.html#VALcreate_int", "<div class=\"info\">\n<p><code class=\"code\">create_int&nbsp;?cond&nbsp;int_number&nbsp;return</code> call interrupt subroutine</p>\n\n</div>\n", ["CALL", "COND", "CREATE_INT", "INTERRUPT", "INT_NUMBER", "RETURN", "SUBROUTINE"]);
add_ocaml_element("create_ret", "Std.Jmp.create_ret", "value", "?tid:Std.tid -> ?cond:Std.exp -> Std.label -> Std.Jmp.t", "Bap.Std.Jmp.html#VALcreate_ret", "<div class=\"info\">\n<p><code class=\"code\">create_ret&nbsp;?cond&nbsp;label</code> return from a procedure</p>\n\n</div>\n", ["COND", "CREATE_RET", "FROM", "LABEL", "PROCEDURE", "RETURN"]);
add_ocaml_element("create_goto", "Std.Jmp.create_goto", "value", "?tid:Std.tid -> ?cond:Std.exp -> Std.label -> Std.Jmp.t", "Bap.Std.Jmp.html#VALcreate_goto", "<div class=\"info\">\n<p><code class=\"code\">create_goto&nbsp;?cond&nbsp;label</code> local jump</p>\n\n</div>\n", ["COND", "CREATE_GOTO", "JUMP", "LABEL", "LOCAL"]);
add_ocaml_element("create_call", "Std.Jmp.create_call", "value", "?tid:Std.tid -> ?cond:Std.exp -> Std.call -> Std.Jmp.t", "Bap.Std.Jmp.html#VALcreate_call", "<div class=\"info\">\n<p><code class=\"code\">create_call&nbsp;?cond&nbsp;target</code> transfer control to subroutine\n        <code class=\"code\">target</code></p>\n\n</div>\n", ["COND", "CONTROL", "CREATE_CALL", "SUBROUTINE", "TARGET", "TRANSFER"]);
add_ocaml_element("create", "Std.Jmp.create", "value", "?tid:Std.tid -> ?cond:Std.exp -> Std.jmp_kind -> Std.Jmp.t", "Bap.Std.Jmp.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?cond&nbsp;kind</code> creates a jump of a given kind</p>\n\n</div>\n", ["COND", "CREATE", "CREATES", "GIVEN", "JUMP", "KIND"]);
add_ocaml_element("free_vars", "Std.Def.free_vars", "value", "Std.Def.t -> Std.Var.Set.t", "Bap.Std.Def.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;def</code> returns a set of free variables, that occurs\n        on the right hand side of definition <code class=\"code\">def</code>.</p>\n\n</div>\n", ["BAP", "DEF", "DEFINITION", "EXP", "FOR", "FREE", "FREE_VARS", "HAND", "INFORMATION", "MORE", "OCCURS", "RETURNS", "RIGHT", "SEE", "SET", "SIDE", "STD", "THAT", "THE", "VARIABLES"]);
add_ocaml_element("substitute", "Std.Def.substitute", "value", "Std.Def.t -> Std.exp -> Std.exp -> Std.Def.t", "Bap.Std.Def.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;def&nbsp;x&nbsp;y</code> substitutes <code class=\"code\">x</code> by <code class=\"code\">y</code> in the right hand\n        side of a definition <code class=\"code\">def</code></p>\n\n</div>\n", ["DEF", "DEFINITION", "HAND", "RIGHT", "SIDE", "SUBSTITUTE", "SUBSTITUTES", "THE"]);
add_ocaml_element("map_exp", "Std.Def.map_exp", "value", "Std.Def.t -> f:(Std.exp -> Std.exp) -> Std.Def.t", "Bap.Std.Def.html#VALmap_exp", "<div class=\"info\">\n<p><code class=\"code\">map_exp&nbsp;def&nbsp;f</code> applies <code class=\"code\">f</code> to a <code class=\"code\">rhs</code> of <code class=\"code\">def</code> and returns\n        an updated definition.</p>\n\n</div>\n", ["AND", "APPLIES", "DEF", "DEFINITION", "MAP_EXP", "RETURNS", "RHS", "UPDATED"]);
add_ocaml_element("with_rhs", "Std.Def.with_rhs", "value", "Std.Def.t -> Std.exp -> Std.Def.t", "Bap.Std.Def.html#VALwith_rhs", "<div class=\"info\">\n<p>updates the right hand side of a definition</p>\n\n</div>\n", ["DEFINITION", "HAND", "RIGHT", "SIDE", "THE", "UPDATES"]);
add_ocaml_element("with_lhs", "Std.Def.with_lhs", "value", "Std.Def.t -> Std.var -> Std.Def.t", "Bap.Std.Def.html#VALwith_lhs", "<div class=\"info\">\n<p>updates the lhs of definition</p>\n\n</div>\n", ["DEFINITION", "LHS", "THE", "UPDATES"]);
add_ocaml_element("rhs", "Std.Def.rhs", "value", "Std.Def.t -> Std.exp", "Bap.Std.Def.html#VALrhs", "<div class=\"info\">\n<p>returns the right hand side of a definition</p>\n\n</div>\n", ["DEFINITION", "HAND", "RETURNS", "RIGHT", "SIDE", "THE"]);
add_ocaml_element("lhs", "Std.Def.lhs", "value", "Std.Def.t -> Std.var", "Bap.Std.Def.html#VALlhs", "<div class=\"info\">\n<p>returns the left hand side of a definition</p>\n\n</div>\n", ["DEFINITION", "HAND", "LEFT", "RETURNS", "SIDE", "THE"]);
add_ocaml_element("create", "Std.Def.create", "value", "?tid:Std.tid -> Std.var -> Std.exp -> Std.Def.t", "Bap.Std.Def.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?tid&nbsp;x&nbsp;exp</code> creates definition <code class=\"code\">x&nbsp;:=&nbsp;exp</code></p>\n\n</div>\n", ["CREATE", "CREATES", "DEFINITION", "EXP", "TID"]);
add_ocaml_element("result", "Std.Blk.Builder.result", "value", "Std.Blk.Builder.t -> Std.blk Std.term", "Bap.Std.Blk.Builder.html#VALresult", "<div class=\"info\">\n<p>returns current result</p>\n\n</div>\n", ["CURRENT", "RESULT", "RETURNS"]);
add_ocaml_element("add_elt", "Std.Blk.Builder.add_elt", "value", "Std.Blk.Builder.t -> Std.Blk.elt -> unit", "Bap.Std.Blk.Builder.html#VALadd_elt", "<div class=\"info\">\n<p>appends generic element</p>\n\n</div>\n", ["APPENDS", "ELEMENT", "GENERIC"]);
add_ocaml_element("add_phi", "Std.Blk.Builder.add_phi", "value", "Std.Blk.Builder.t -> Std.phi Std.term -> unit", "Bap.Std.Blk.Builder.html#VALadd_phi", "<div class=\"info\">\n<p>appends a phi node</p>\n\n</div>\n", ["APPENDS", "NODE", "PHI"]);
add_ocaml_element("add_jmp", "Std.Blk.Builder.add_jmp", "value", "Std.Blk.Builder.t -> Std.jmp Std.term -> unit", "Bap.Std.Blk.Builder.html#VALadd_jmp", "<div class=\"info\">\n<p>appends a jump</p>\n\n</div>\n", ["APPENDS", "JUMP"]);
add_ocaml_element("add_def", "Std.Blk.Builder.add_def", "value", "Std.Blk.Builder.t -> Std.def Std.term -> unit", "Bap.Std.Blk.Builder.html#VALadd_def", "<div class=\"info\">\n<p>appends a definition</p>\n\n</div>\n", ["APPENDS", "DEFINITION"]);
add_ocaml_element("init", "Std.Blk.Builder.init", "value", "?same_tid:bool ->\n  ?copy_phis:bool ->\n  ?copy_defs:bool ->\n  ?copy_jmps:bool -> Std.blk Std.term -> Std.Blk.Builder.t", "Bap.Std.Blk.Builder.html#VALinit", "<div class=\"info\">\n<p><code class=\"code\">init&nbsp;blk</code> creates a builder based on an existing\n          block.</p>\n\n</div>\n", ["BASED", "BLK", "BLOCK", "BUILDER", "COPY_DEFS", "COPY_JMPS", "COPY_PHIS", "CORRESPONDING", "CREATED", "CREATES", "DEFAULT", "DEFAULTS", "EXISTING", "FALSE", "FRESH", "FROM", "HAVE", "INIT", "NEW", "OTHERWISE", "PREPOPULATE", "RESULTING", "SAME", "SAME_TID", "TERMS", "THE", "THEN", "TID", "TRUE", "WILL", "WITH"]);
add_ocaml_element("create", "Std.Blk.Builder.create", "value", "?tid:Std.tid ->\n  ?phis:int -> ?defs:int -> ?jmps:int -> unit -> Std.Blk.Builder.t", "Bap.Std.Blk.Builder.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;~tid&nbsp;~phis&nbsp;~defs&nbsp;~jmp&nbsp;()</code> creates a block builder.</p>\n\n</div>\n", ["ACTUAL", "AMOUNT", "ANY", "ARE", "BLOCK", "BUILDER", "CAN", "CORRESPONDING", "CREATE", "CREATES", "DEFS", "ENTRIES", "EXPECTED", "HAVE", "HINT", "JMP", "JMPS", "MISMATCH", "MUST", "NEW", "NUMBER", "PARAMETER", "PARAMETERS", "PHIS", "POSITIVE", "PROVTIDED", "SINCE", "SIZE", "SPECIFIED", "THE", "THEN", "THIS", "TID", "USED", "WILL", "WITH", "WOULD"]);
add_ocaml_element("occurs", "Std.Blk.occurs", "value", "Std.Blk.t -> after:Std.tid -> Std.tid -> bool", "Bap.Std.Blk.html#VALoccurs", "<div class=\"info\">\n<p><code class=\"code\">occurs&nbsp;blk&nbsp;after:x&nbsp;def</code> if <code class=\"code\">def</code> is occurs after definition\n        <code class=\"code\">def</code> in <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["AFTER", "BLK", "DEF", "DEFINITION", "OCCURS"]);
add_ocaml_element("uses_var", "Std.Blk.uses_var", "value", "Std.Blk.t -> Std.var -> bool", "Bap.Std.Blk.html#VALuses_var", "<div class=\"info\">\n<p><code class=\"code\">uses_var&nbsp;blk&nbsp;x</code> true if variable <code class=\"code\">x</code> is in <code class=\"code\">free_vars&nbsp;blk</code>.</p>\n\n</div>\n", ["AND", "BETTER", "BLK", "CALL", "COMPUTE", "EXPLICITLY", "FREE_VARS", "FUNCTION", "MEM", "NEED", "SET", "SEVERAL", "THIS", "TRUE", "USE", "USES_VAR", "VARIABLE", "VARIABLES", "YOU"]);
add_ocaml_element("free_vars", "Std.Blk.free_vars", "value", "Std.Blk.t -> Std.Var.Set.t", "Bap.Std.Blk.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;blk</code> returns a set of variables that occurs free\n        in block <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["AND", "BLK", "BLOCK", "DEFINITION", "EXPRESSION", "FREE", "FREE_VARS", "OCCURS", "PRECEDING", "RETURNS", "SET", "THAT", "THE", "THERE", "THIS", "UNBOUND", "VARIABLE", "VARIABLES"]);
add_ocaml_element("defines_var", "Std.Blk.defines_var", "value", "Std.Blk.t -> Std.var -> bool", "Bap.Std.Blk.html#VALdefines_var", "<div class=\"info\">\n<p><code class=\"code\">defines_var&nbsp;blk&nbsp;x</code> true if there exists such phi term or def\n        term with left hand side equal to <code class=\"code\">x</code></p>\n\n</div>\n", ["BLK", "DEF", "DEFINES_VAR", "EQUAL", "EXISTS", "HAND", "LEFT", "PHI", "SIDE", "SUCH", "TERM", "THERE", "TRUE", "WITH"]);
add_ocaml_element("find_var", "Std.Blk.find_var", "value", "Std.Blk.t ->\n  Std.var ->\n  [ `Def of Std.def Std.term | `Phi of Std.phi Std.term ]\n  option", "Bap.Std.Blk.html#VALfind_var", "<div class=\"info\">\n<p><code class=\"code\">find_var&nbsp;blk&nbsp;var</code> finds a last definition of a variable <code class=\"code\">var</code>\n        in a block <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["BLK", "BLOCK", "DEFINITION", "FINDS", "FIND_VAR", "LAST", "VAR", "VARIABLE"]);
add_ocaml_element("map_lhs", "Std.Blk.map_lhs", "value", "?skip:[ `def | `phi ] list ->\n  Std.Blk.t -> f:(Std.var -> Std.var) -> Std.Blk.t", "Bap.Std.Blk.html#VALmap_lhs", "<div class=\"info\">\n<p><code class=\"code\">map_lhs&nbsp;blk&nbsp;~f</code> applies <code class=\"code\">f</code> to every left hand side variable\n        in def and phi subterms of <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["AND", "APPLIES", "BLK", "CORRESPONDING", "DEF", "DEFINITIONS", "EVERY", "HAND", "IGNORE", "KIND", "LEFT", "MAP_LHS", "NODES", "ONLY", "PARAMETER", "PERFORM", "PHI", "SIDE", "SKIP", "SPECIFIED", "SUBSTITUTE", "SUBSTITUTION", "SUBTERMS", "TERMS", "THEN", "UNTOUCHED", "VARIABLE", "VARS", "WILL"]);
add_ocaml_element("substitute", "Std.Blk.substitute", "value", "?skip:[ `def | `jmp | `phi ] list ->\n  Std.Blk.t -> Std.exp -> Std.exp -> Std.Blk.t", "Bap.Std.Blk.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;?skip&nbsp;blk&nbsp;x&nbsp;y</code> substitutes each occurrence of\n        expression <code class=\"code\">x</code> with expression <code class=\"code\">y</code> in block <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["BLK", "BLOCK", "CORRESPONDING", "DEEPLY", "EACH", "EXPRESSION", "KIND", "LEFT", "OCCURRENCE", "PARAMETER", "PERFORMED", "SKIP", "SPECIFIED", "SUBSTITUTE", "SUBSTITUTES", "SUBSTITUTION", "TERMS", "THE", "THEN", "UNTOUCHED", "WILL", "WITH"]);
add_ocaml_element("map_elts", "Std.Blk.map_elts", "value", "?phi:(Std.phi Std.term -> Std.phi Std.term) ->\n  ?def:(Std.def Std.term -> Std.def Std.term) ->\n  ?jmp:(Std.jmp Std.term -> Std.jmp Std.term) ->\n  Std.blk Std.term -> Std.blk Std.term", "Bap.Std.Blk.html#VALmap_elts", "<div class=\"info\">\n<p><code class=\"code\">map_elt&nbsp;?phi&nbsp;?def&nbsp;?jmp&nbsp;blk</code> applies provided functions to the\n        terms of corresponding classes.</p>\n\n</div>\n", ["ALL", "APPLIES", "BLK", "CLASSES", "CORRESPONDING", "DEF", "DEFAULT", "FUNCTION", "FUNCTIONS", "IDENTITY", "JMP", "MAP_ELT", "PHI", "PROVIDED", "TERMS", "THE"]);
add_ocaml_element("map_exp", "Std.Blk.map_exp", "value", "?skip:[ `def | `jmp | `phi ] list ->\n  Std.Blk.t -> f:(Std.exp -> Std.exp) -> Std.Blk.t", "Bap.Std.Blk.html#VALmap_exp", "<div class=\"info\">\n<p><code class=\"code\">map_exp&nbsp;b&nbsp;~f</code> applies function <code class=\"code\">f</code> for each expression in\n        block <code class=\"code\">b</code>.</p>\n\n</div>\n", ["ALL", "AND", "APPLIED", "APPLIES", "BLOCK", "CONDITIONS", "CORRESPONDING", "DEFAULT", "DEFINITIONS", "EACH", "EXP", "EXPRESSION", "FOR", "FUNCTION", "HAND", "INCLUDING", "JUMP", "KIND", "MAP_EXP", "NODES", "NOT", "PARAMETER", "PHI", "RIGHT", "SIDES", "SKIP", "SKIPPED", "SPECIFIED", "TARGETS", "TERMS", "THEM", "THEN", "TYPE", "VALUES", "WILL"]);
add_ocaml_element("elts", "Std.Blk.elts", "value", "?rev:bool -> Std.Blk.t -> Std.Blk.elt Std.seq", "Bap.Std.Blk.html#VALelts", "<div class=\"info\">\n<p><code class=\"code\">elts&nbsp;~rev&nbsp;blk</code> return all elements of the <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "BLK", "DEFINITIONS", "DEFS", "ELEMENTS", "ELTS", "FALSE", "FINALLY", "FOLLOWING", "JMPS", "JUMPS", "LEFT", "NODES", "NORMAL", "OPPOSITE", "ORDER", "PHI", "RETURN", "RETURNED", "REV", "TAKEN", "THE", "THEN", "THEY", "TRUE", "UNSPECIFIED", "WHICH", "WILL"]);
add_ocaml_element("split_bot", "Std.Blk.split_bot", "value", "Std.Blk.t -> Std.Blk.t * Std.Blk.t", "Bap.Std.Blk.html#VALsplit_bot", "<div class=\"info\">\n<p><code class=\"code\">split_top&nbsp;blk</code> returns two blocks, where first block shares\n        the same tid as <code class=\"code\">blk</code>, has all $\\Phi$-nodes and definitions\n        from <code class=\"code\">blk</code>, but has only one destination, namely the second\n        block.</p>\n\n</div>\n", ["ALL", "AND", "BLK", "BLOCK", "BLOCKS", "BUT", "DEFINITIONS", "DESTINATION", "FIRST", "FROM", "HAS", "JUMPS", "NAMELY", "NEW", "NODES", "ONE", "ONLY", "PHI", "RETURNS", "SAME", "SECOND", "SHARES", "SPLIT_TOP", "THE", "TID", "TIDENTITY", "TWO", "WHERE"]);
add_ocaml_element("split_top", "Std.Blk.split_top", "value", "Std.Blk.t -> Std.Blk.t * Std.Blk.t", "Bap.Std.Blk.html#VALsplit_top", "<div class=\"info\">\n<p><code class=\"code\">split_top&nbsp;blk</code> returns two blocks, where first block shares\n        the same tid as <code class=\"code\">blk</code> and has all $\\Phi$-nodes of <code class=\"code\">blk</code>, but\n        has only one destination, namely the second block.</p>\n\n</div>\n", ["ALL", "AND", "BLK", "BLOCK", "BLOCKS", "BUT", "DEFINITIONS", "DESTINATION", "FIRST", "FROM", "HAS", "INHERITS", "JUMPS", "NAMELY", "NEW", "NODES", "ONE", "ONLY", "PHI", "RETURNS", "SAME", "SECOND", "SHARES", "SPLIT_TOP", "THE", "TID", "TIDENTITY", "TWO", "WHERE"]);
add_ocaml_element("split_before", "Std.Blk.split_before", "value", "Std.Blk.t -> Std.def Std.term -> Std.Blk.t * Std.Blk.t", "Bap.Std.Blk.html#VALsplit_before", "<div class=\"info\">\n<p><code class=\"code\">split_before&nbsp;blk&nbsp;def</code> is like <a href=\"Bap.Std.Blk.html#VALsplit_after\">split_after</a> but\n        <code class=\"code\">def</code> will fall into the second <code class=\"code\">blk</code></p>\n\n</div>\n", ["BLK", "BUT", "DEF", "FALL", "INTO", "LIKE", "SECOND", "SPLIT_AFTER", "SPLIT_BEFORE", "THE", "WILL"]);
add_ocaml_element("split_after", "Std.Blk.split_after", "value", "Std.Blk.t -> Std.def Std.term -> Std.Blk.t * Std.Blk.t", "Bap.Std.Blk.html#VALsplit_after", "<div class=\"info\">\n<p><code class=\"code\">split_after&nbsp;blk&nbsp;def</code> creates two new blocks, where the first\n        block contains all defintions up to <code class=\"code\">def</code> inclusive, the\n        second contains the rest.</p>\n\n</div>\n", ["ALL", "AND", "BLK", "BLOCK", "BLOCKS", "CONTAIN", "CONTAINS", "CREATES", "DEF", "DEFINTIONS", "EMPTY", "FIRST", "INCLUSIVE", "NEW", "NOT", "NOTE", "REST", "SECOND", "SPLIT_AFTER", "THE", "THEN", "TWO", "WHERE", "WILL"]);
add_ocaml_element("split_while", "Std.Blk.split_while", "value", "Std.Blk.t ->\n  f:(Std.def Std.term -> bool) -> Std.Blk.t * Std.Blk.t", "Bap.Std.Blk.html#VALsplit_while", "<div class=\"info\">\n<p><code class=\"code\">split_while&nbsp;blk&nbsp;~f</code> splits <code class=\"code\">blk</code> into two block: the first\n        block holds all definitions for which <code class=\"code\">f&nbsp;p</code> is true and has\n        the same tid as <code class=\"code\">blk</code>.</p>\n\n</div>\n", ["ALL", "AND", "ANY", "BECOME", "BECOMES", "BLK", "BLOCK", "BLOCKS", "CONTAIN", "CREATED", "DEF", "DEFINITIONS", "FIRST", "FOR", "FRESHLY", "FUNCTION", "HAS", "HOLDS", "INTO", "NOT", "NOTE", "REST", "RESULT", "SAME", "SECOND", "SPLITS", "SPLIT_BOT", "SPLIT_WHILE", "SUCCESSOR", "SUCCESSORS", "THE", "THEN", "TID", "TRUE", "TWO", "WHICH", "WILL", "WOULD"]);
add_ocaml_element("from_insn", "Std.Blk.from_insn", "value", "Std.insn -> Std.blk Std.term list", "Bap.Std.Blk.html#VALfrom_insn", "<div class=\"info\">\n<p><code class=\"code\">from_insn&nbsp;insn</code> creates an IR representation of a single\n        machine instruction <code class=\"code\">insn</code>.</p>\n\n</div>\n", ["CREATES", "FROM_INSN", "INSN", "INSTRUCTION", "MACHINE", "REPRESENTATION", "SINGLE"]);
add_ocaml_element("lift", "Std.Blk.lift", "value", "Std.cfg -> Std.block -> Std.blk Std.term list", "Bap.Std.Blk.html#VALlift", "<div class=\"info\">\n<p><code class=\"code\">lift&nbsp;block</code> takes a basic block of assembly instructions and\n        lifts it to a list of blk terms.</p>\n\n</div>\n", ["AND", "ASSEMBLY", "BASIC", "BLK", "BLOCK", "ENTRY", "FIRST", "INSTRUCTIONS", "LIFT", "LIFTS", "LIST", "TAKES", "TERM", "TERMS", "THE"]);
add_ocaml_element("create", "Std.Blk.create", "value", "?tid:Std.tid -> unit -> Std.Blk.t", "Bap.Std.Blk.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates a new empty block.</p>\n\n</div>\n", ["BLOCK", "CREATE", "CREATES", "EMPTY", "NEW"]);
add_ocaml_element("result", "Std.Sub.Builder.result", "value", "Std.Sub.Builder.t -> Std.sub Std.term", "Bap.Std.Sub.Builder.html#VALresult", "<div class=\"info\">\n<p>returns current result</p>\n\n</div>\n", ["CURRENT", "RESULT", "RETURNS"]);
add_ocaml_element("add_arg", "Std.Sub.Builder.add_arg", "value", "Std.Sub.Builder.t -> Std.arg Std.term -> unit", "Bap.Std.Sub.Builder.html#VALadd_arg", "<div class=\"info\">\n<p>appends an argument</p>\n\n</div>\n", ["APPENDS", "ARGUMENT"]);
add_ocaml_element("add_blk", "Std.Sub.Builder.add_blk", "value", "Std.Sub.Builder.t -> Std.blk Std.term -> unit", "Bap.Std.Sub.Builder.html#VALadd_blk", "<div class=\"info\">\n<p>appends a block to a subroutine</p>\n\n</div>\n", ["APPENDS", "BLOCK", "SUBROUTINE"]);
add_ocaml_element("create", "Std.Sub.Builder.create", "value", "?tid:Std.tid ->\n  ?args:int -> ?blks:int -> ?name:string -> unit -> Std.Sub.Builder.t", "Bap.Std.Sub.Builder.html#VALcreate", "<div class=\"info\">\n<p>initializes empty subroutine builder.</p>\n\n</div>\n", ["BUILDER", "EMPTY", "INITIALIZES", "SUBROUTINE"]);
add_ocaml_element("entry_point", "Std.Sub.entry_point", "value", "unit Std.tag", "Bap.Std.Sub.html#VALentry_point", "<div class=\"info\">\n<p>a subroutine is the binary entry point</p>\n\n</div>\n", ["BINARY", "ENTRY", "POINT", "SUBROUTINE", "THE"]);
add_ocaml_element("nothrow", "Std.Sub.nothrow", "value", "unit Std.tag", "Bap.Std.Sub.html#VALnothrow", "<div class=\"info\">\n<p>A subroutine doesn't throw exceptions</p>\n\n</div>\n", ["DOESN", "EXCEPTIONS", "SUBROUTINE", "THROW"]);
add_ocaml_element("returns_twice", "Std.Sub.returns_twice", "value", "unit Std.tag", "Bap.Std.Sub.html#VALreturns_twice", "<div class=\"info\">\n<p>A subroutine may return more than one time.</p>\n\n</div>\n", ["AND", "ARE", "EXAMPLES", "FUNCTIONS", "MAY", "MORE", "ONE", "RETURN", "SETJMP", "SUBROUTINE", "SUCH", "THAN", "TIME", "VFORK"]);
add_ocaml_element("noreturn", "Std.Sub.noreturn", "value", "unit Std.tag", "Bap.Std.Sub.html#VALnoreturn", "<div class=\"info\">\n<p>A subroutine will not return (either loop infinitely or abort\n        a program)</p>\n\n</div>\n", ["ABORT", "EITHER", "INFINITELY", "LOOP", "NOT", "PROGRAM", "RETURN", "SUBROUTINE", "WILL"]);
add_ocaml_element("malloc", "Std.Sub.malloc", "value", "unit Std.tag", "Bap.Std.Sub.html#VALmalloc", "<div class=\"info\">\n<p>A subroutine is malloc-like, i.e., the pointer P returned\n        by the subroutine cannot alias any other pointer valid when the\n        function returns, and moreover no pointers to valid objects occur\n        in any storage addressed by P.</p>\n\n</div>\n", ["ADDRESSED", "ALIAS", "AND", "ANY", "CANNOT", "FUNCTION", "LIKE", "MALLOC", "MOREOVER", "OBJECTS", "OCCUR", "OTHER", "POINTER", "POINTERS", "RETURNED", "RETURNS", "STORAGE", "SUBROUTINE", "THE", "VALID", "WHEN"]);
add_ocaml_element("leaf", "Std.Sub.leaf", "value", "unit Std.tag", "Bap.Std.Sub.html#VALleaf", "<div class=\"info\">\n<p>a subroutine doesn't contain any calls in any disguise, i.e.,\n        no longjmps, indirect calls, exceptions, etc.</p>\n\n</div>\n", ["ANY", "CALLS", "CONTAIN", "DISGUISE", "DOESN", "ETC", "EXCEPTIONS", "INDIRECT", "LONGJMPS", "SUBROUTINE"]);
add_ocaml_element("extern", "Std.Sub.extern", "value", "unit Std.tag", "Bap.Std.Sub.html#VALextern", "<div class=\"info\">\n<p>A subroutine is visible outside of the compilation unit</p>\n\n</div>\n", ["COMPILATION", "OUTSIDE", "SUBROUTINE", "THE", "UNIT", "VISIBLE"]);
add_ocaml_element("stub", "Std.Sub.stub", "value", "unit Std.tag", "Bap.Std.Sub.html#VALstub", "<div class=\"info\">\n<p>A subroutine is a stub</p>\n\n</div>\n", ["STUB", "SUBROUTINE"]);
add_ocaml_element("pure", "Std.Sub.pure", "value", "unit Std.tag", "Bap.Std.Sub.html#VALpure", "<div class=\"info\">\n<p>A subroutine have no effects except the return value and their\n        return value depends only on the parameters and/or global\n        variables.</p>\n\n</div>\n", ["AND", "DEPENDS", "EFFECTS", "EXCEPT", "GLOBAL", "HAVE", "ONLY", "PARAMETERS", "RETURN", "SUBROUTINE", "THE", "THEIR", "VALUE", "VARIABLES"]);
add_ocaml_element("const", "Std.Sub.const", "value", "unit Std.tag", "Bap.Std.Sub.html#VALconst", "<div class=\"info\">\n<p>A subroutine doesn't examine any values except its arguments,\n        and have no effects except the return value.</p>\n\n</div>\n", ["ALLOWED", "AND", "ANY", "ARGUMENTS", "ATTRIBUTE", "BASICALLY", "BELOW", "CALLS", "CLASS", "CONST", "DATA", "DOES", "DOESN", "EFFECTS", "EXAMINE", "EXAMINES", "EXCEPT", "FOR", "FUNCTION", "GLOBAL", "HAS", "HAVE", "ITS", "JUST", "LIKEWISE", "MAKE", "MEMORY", "MORE", "NON", "NOT", "NOTE", "POINTED", "POINTER", "PURE", "READ", "RETURN", "SENSE", "SINCE", "SLIGHTLY", "STRICT", "SUBROUTINE", "THAN", "THAT", "THE", "THIS", "USUALLY", "VALUE", "VALUES", "VOID"]);
add_ocaml_element("aliases", "Std.Sub.aliases", "value", "string list Std.tag", "Bap.Std.Sub.html#VALaliases", "<div class=\"info\">\n<p>other names for the given subroutine.</p>\n\n</div>\n", ["FOR", "GIVEN", "NAMES", "OTHER", "SUBROUTINE", "THE"]);
add_ocaml_element("of_cfg", "Std.Sub.of_cfg", "value", "Std.Graphs.Ir.t -> Std.Sub.t", "Bap.Std.Sub.html#VALof_cfg", "<div class=\"info\">\n<p><code class=\"code\">of_cfg&nbsp;cfg</code> extracts a <code class=\"code\">sub&nbsp;term</code> from a given graph <code class=\"code\">cfg</code>.</p>\n\n</div>\n", ["BUILDS", "CFG", "COMPLEXITY", "EXTRACTS", "FROM", "GIVEN", "GRAPH", "GRAPHLIB", "HAS", "INCREMENTALLY", "JUST", "MODULE", "OF_CFG", "OPERATION", "PROJECTION", "SINCE", "SUB", "TERM", "THIS"]);
add_ocaml_element("to_cfg", "Std.Sub.to_cfg", "value", "Std.Sub.t -> Std.Graphs.Ir.t", "Bap.Std.Sub.html#VALto_cfg", "<div class=\"info\">\n<p><code class=\"code\">to_cfg&nbsp;sub</code> builds a graph representation of a subroutine\n        <code class=\"code\">sub</code>.</p>\n\n</div>\n", ["ALL", "ARE", "BUILDS", "CORRESPONDING", "FOR", "GRAPH", "GRAPHLIB", "INFORMATION", "MAPPED", "MORE", "OPERATIONS", "REPRESENTATION", "SEE", "SUB", "SUBROUTINE", "TERM", "TO_CFG"]);
add_ocaml_element("to_graph", "Std.Sub.to_graph", "value", "Std.Sub.t -> Std.Graphs.Tid.t", "Bap.Std.Sub.html#VALto_graph", "<div class=\"info\">\n<p><code class=\"code\">to_graph&nbsp;sub</code> builds a graph of subroutine <code class=\"code\">sub</code>.</p>\n\n</div>\n", ["AND", "ARE", "BLOCK", "BUILDS", "COMPUTE", "CORRESPONDS", "EDGE", "EDGES", "GRAPH", "IDENTIFIERS", "INCREMENTAL", "ITS", "JMP", "LABELED", "LATER", "NEED", "NODES", "PERFORM", "RELATION", "REPRESENTATION", "SOME", "SUB", "SUBROUTINE", "TERM", "TERMS", "THAT", "THE", "THIS", "TO_GRAPH", "TRANSFORMATION", "USED", "USEFUL", "WILL", "WITH", "YOU"]);
add_ocaml_element("free_vars", "Std.Sub.free_vars", "value", "Std.Sub.t -> Std.Var.Set.t", "Bap.Std.Sub.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;sub</code> computes a set of variables that are free in\n        a given subroutine <code class=\"code\">sub</code>.</p>\n\n</div>\n", ["ARE", "BEFORE", "BFS", "BOUND", "COMPUTED", "COMPUTES", "CONSIDERED", "DEFINED", "DOMINATORS", "FORM", "FREE", "FREE_VARS", "GIVEN", "LOCALLY", "NAMING", "NOT", "PROGRAM", "SCHEME", "SET", "SSA", "SUB", "SUBROUTINE", "THANKS", "THAT", "THE", "THEN", "TREE", "TRIVIALLY", "USED", "VARIABLE", "VARIABLES"]);
add_ocaml_element("is_ssa", "Std.Sub.is_ssa", "value", "Std.Sub.t -> bool", "Bap.Std.Sub.html#VALis_ssa", "<div class=\"info\">\n<p><code class=\"code\">is_ssa&nbsp;sub</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">sub</code> was transformed into an SSA\n        form.</p>\n\n</div>\n", ["ANY", "CHECK", "DOESN", "FORM", "INTO", "IS_SSA", "PREDICATE", "PRESERVE", "REALLY", "RESPONSIBILITY", "SSA", "SUB", "SUBROUTINE", "THAT", "THE", "THIS", "TRANSFORMATION", "TRANSFORMED", "TRUE", "USER", "WAS"]);
add_ocaml_element("ssa", "Std.Sub.ssa", "value", "Std.Sub.t -> Std.Sub.t", "Bap.Std.Sub.html#VALssa", "<div class=\"info\">\n<p><code class=\"code\">ssa&nbsp;sub</code> returns <code class=\"code\">sub</code> in SSA form.</p>\n\n</div>\n", ["ALGORITHM", "ALREADY", "ALSO", "ANY", "BAP", "BEFORE", "DEFINED", "DEFINITION", "DIFFERENT", "FIRST", "FOR", "FORM", "INCREASES", "IS_SSA", "ITS", "NOTHING", "NUMBER", "PRODUCES", "PROGRAM", "PRUNED", "REPRESENT", "RESERVED", "RETURNS", "SAME", "SEE", "SEMI", "SSA", "STD", "SUB", "THAT", "THE", "THEN", "UNDERLYING", "USE", "VARIABLE", "VARIABLES", "VERSION", "VERSIONS", "WEREN", "ZERO"]);
add_ocaml_element("with_name", "Std.Sub.with_name", "value", "Std.Sub.t -> string -> Std.Sub.t", "Bap.Std.Sub.html#VALwith_name", "<div class=\"info\">\n<p>updates subroutine name</p>\n\n</div>\n", ["NAME", "SUBROUTINE", "UPDATES"]);
add_ocaml_element("name", "Std.Sub.name", "value", "Std.Sub.t -> string", "Bap.Std.Sub.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;sub</code> returns a subroutine name</p>\n\n</div>\n", ["NAME", "RETURNS", "SUB", "SUBROUTINE"]);
add_ocaml_element("lift", "Std.Sub.lift", "value", "Std.block -> Std.cfg -> Std.sub Std.term", "Bap.Std.Sub.html#VALlift", "<div class=\"info\">\n<p><code class=\"code\">lift&nbsp;entry</code> takes an basic block of assembler instructions,\n        as an entry and lifts it to the subroutine term.</p>\n\n</div>\n", ["AND", "ASSEMBLER", "BASIC", "BLOCK", "ENTRY", "INSTRUCTIONS", "LIFT", "LIFTS", "SUBROUTINE", "TAKES", "TERM", "THE"]);
add_ocaml_element("create", "Std.Sub.create", "value", "?tid:Std.tid -> ?name:string -> unit -> Std.Sub.t", "Bap.Std.Sub.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?name&nbsp;()</code> creates an empty subroutine with an optional\n        name.</p>\n\n</div>\n", ["CREATE", "CREATES", "EMPTY", "NAME", "OPTIONAL", "SUBROUTINE", "WITH"]);
add_ocaml_element("result", "Std.Program.Builder.result", "value", "Std.Program.Builder.t -> Std.program Std.term", "Bap.Std.Program.Builder.html#VALresult", "<div class=\"info\">\n<p>fixes the result</p>\n\n</div>\n", ["FIXES", "RESULT", "THE"]);
add_ocaml_element("add_sub", "Std.Program.Builder.add_sub", "value", "Std.Program.Builder.t -> Std.sub Std.term -> unit", "Bap.Std.Program.Builder.html#VALadd_sub", "<div class=\"info\">\n<p><code class=\"code\">add_sub&nbsp;builder&nbsp;sub</code> appends a subroutine term to the\n          program.</p>\n\n</div>\n", ["ADD_SUB", "APPENDS", "BUILDER", "PROGRAM", "SUB", "SUBROUTINE", "TERM", "THE"]);
add_ocaml_element("create", "Std.Program.Builder.create", "value", "?tid:Std.tid -> ?subs:int -> unit -> Std.Program.Builder.t", "Bap.Std.Program.Builder.html#VALcreate", "", []);
add_ocaml_element("parent", "Std.Program.parent", "value", "('a, 'b) Std.cls ->\n  Std.Program.t -> Std.tid -> 'a Std.term option", "Bap.Std.Program.html#VALparent", "<div class=\"info\">\n<p><code class=\"code\">parent&nbsp;t&nbsp;program&nbsp;id</code> is <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;p</code> iff <code class=\"code\">find&nbsp;t&nbsp;p&nbsp;id&nbsp;&lt;&gt;&nbsp;<span class=\"constructor\">None</span></code></p>\n\n</div>\n", ["FIND", "IFF", "NONE", "PARENT", "PROGRAM", "SOME"]);
add_ocaml_element("lookup", "Std.Program.lookup", "value", "('a, 'b) Std.cls ->\n  Std.Program.t -> Std.tid -> 'b Std.term option", "Bap.Std.Program.html#VALlookup", "<div class=\"info\">\n<p><code class=\"code\">lookup&nbsp;t&nbsp;program&nbsp;id</code> is like find but performs deep\n        lookup in the whole <code class=\"code\">program</code> for a term with a given <code class=\"code\">id</code>.</p>\n\n</div>\n", ["AMORTIZED", "AMOUNT", "BUT", "COMPLEXITY", "DEEP", "FIND", "FOR", "FUNCTION", "GIVEN", "HAS", "LIKE", "LOOKUP", "MEMOIZED", "PERFORMS", "PROGRAM", "TERM", "TERMS", "THE", "THIS", "TOTAL", "WHERE", "WHOLE", "WITH", "WOSTCASE"]);
add_ocaml_element("to_graph", "Std.Program.to_graph", "value", "Std.Program.t -> Std.Graphs.Callgraph.t", "Bap.Std.Program.html#VALto_graph", "<div class=\"info\">\n<p><code class=\"code\">to_graph&nbsp;program</code> creates a callgraph of a <code class=\"code\">program</code></p>\n\n</div>\n", ["CALLGRAPH", "CREATES", "PROGRAM", "TO_GRAPH"]);
add_ocaml_element("lift", "Std.Program.lift", "value", "Std.symtab -> Std.program Std.term", "Bap.Std.Program.html#VALlift", "<div class=\"info\">\n<p><code class=\"code\">lift&nbsp;symbols</code> takes a table of functions and return a whole\n        program lifted into IR</p>\n\n</div>\n", ["AND", "FUNCTIONS", "INTO", "LIFT", "LIFTED", "PROGRAM", "RETURN", "SYMBOLS", "TABLE", "TAKES", "WHOLE"]);
add_ocaml_element("create", "Std.Program.create", "value", "?tid:Std.tid -> unit -> Std.Program.t", "Bap.Std.Program.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?tid&nbsp;()</code> creates an empty program.</p>\n\n</div>\n", ["CREATE", "CREATES", "EMPTY", "PROGRAM", "TID"]);
add_ocaml_element("cata", "Std.Term.cata", "value", "('p, 't) Std.cls ->\n  init:'a ->\n  ?program:(Std.program Std.term -> 'a) ->\n  ?sub:(Std.sub Std.term -> 'a) ->\n  ?arg:(Std.arg Std.term -> 'a) ->\n  ?blk:(Std.blk Std.term -> 'a) ->\n  ?phi:(Std.phi Std.term -> 'a) ->\n  ?def:(Std.def Std.term -> 'a) ->\n  ?jmp:(Std.jmp Std.term -> 'a) -> 't Std.term -> 'a", "Bap.Std.Term.html#VALcata", "<div class=\"info\">\n<p><code class=\"code\">cata&nbsp;cls&nbsp;~init&nbsp;t&nbsp;?case</code> performs a pattern matching.</p>\n\n</div>\n", ["ALL", "CASE", "CATA", "CATAMORPHISM", "CLS", "DEFAULT", "FOR", "INIT", "MATCHING", "METHODS", "NOTE", "PATTERN", "PERFORMS", "RETURNS", "STANDS"]);
add_ocaml_element("proj", "Std.Term.proj", "value", "('p, 't) Std.cls ->\n  ?program:(Std.program Std.term -> 'a option) ->\n  ?sub:(Std.sub Std.term -> 'a option) ->\n  ?arg:(Std.arg Std.term -> 'a option) ->\n  ?blk:(Std.blk Std.term -> 'a option) ->\n  ?phi:(Std.phi Std.term -> 'a option) ->\n  ?def:(Std.def Std.term -> 'a option) ->\n  ?jmp:(Std.jmp Std.term -> 'a option) -> 't Std.term -> 'a option", "Bap.Std.Term.html#VALproj", "<div class=\"info\">\n<p><code class=\"code\">proj&nbsp;cls&nbsp;t&nbsp;?case</code> a special case of pattern matching,\n        where all cases by default returns <code class=\"code\"><span class=\"constructor\">None</span></code></p>\n\n</div>\n", ["ALL", "CASE", "CASES", "CLS", "DEFAULT", "MATCHING", "NONE", "PATTERN", "PROJ", "RETURNS", "SPECIAL", "WHERE"]);
add_ocaml_element("switch", "Std.Term.switch", "value", "('p, 't) Std.cls ->\n  program:(Std.program Std.term -> 'a) ->\n  sub:(Std.sub Std.term -> 'a) ->\n  arg:(Std.arg Std.term -> 'a) ->\n  blk:(Std.blk Std.term -> 'a) ->\n  phi:(Std.phi Std.term -> 'a) ->\n  def:(Std.def Std.term -> 'a) ->\n  jmp:(Std.jmp Std.term -> 'a) -> 't Std.term -> 'a", "Bap.Std.Term.html#VALswitch", "<div class=\"info\">\n<p><code class=\"code\">switch&nbsp;cls&nbsp;t&nbsp;~program&nbsp;~sub&nbsp;..&nbsp;~jmp</code> performs a pattern\n        matching over a term <code class=\"code\">t</code> based on its type class <code class=\"code\">cls</code>.</p>\n\n</div>\n", ["BASED", "CALLED", "CLASS", "CLS", "FOR", "FUNCTION", "GUARANTEED", "ITS", "JMP", "MATCHING", "ONE", "ONLY", "OVER", "PATTERN", "PERFORMS", "PROGRAM", "SUB", "SWITCH", "TERM", "THAT", "TYPE", "WILL"]);
add_ocaml_element("postcondition", "Std.Term.postcondition", "value", "Std.exp Std.tag", "Bap.Std.Term.html#VALpostcondition", "<div class=\"info\">\n<p>must hold just after the term is left</p>\n\n</div>\n", ["AFTER", "HOLD", "JUST", "LEFT", "MUST", "TERM", "THE"]);
add_ocaml_element("invariant", "Std.Term.invariant", "value", "Std.exp Std.tag", "Bap.Std.Term.html#VALinvariant", "<div class=\"info\">\n<p>invariant must be always true while the term is evaluated</p>\n\n</div>\n", ["ALWAYS", "EVALUATED", "INVARIANT", "MUST", "TERM", "THE", "TRUE", "WHILE"]);
add_ocaml_element("precondition", "Std.Term.precondition", "value", "Std.exp Std.tag", "Bap.Std.Term.html#VALprecondition", "<div class=\"info\">\n<p>precondition must on the entrance to the subroutine</p>\n\n</div>\n", ["ENTRANCE", "MUST", "PRECONDITION", "SUBROUTINE", "THE"]);
add_ocaml_element("visited", "Std.Term.visited", "value", "unit Std.tag", "Bap.Std.Term.html#VALvisited", "<div class=\"info\">\n<p>to mark a term as visited by some algorithm</p>\n\n</div>\n", ["ALGORITHM", "MARK", "SOME", "TERM", "VISITED"]);
add_ocaml_element("dead", "Std.Term.dead", "value", "unit Std.tag", "Bap.Std.Term.html#VALdead", "<div class=\"info\">\n<p>a term is identified as dead</p>\n\n</div>\n", ["DEAD", "IDENTIFIED", "TERM"]);
add_ocaml_element("live", "Std.Term.live", "value", "unit Std.tag", "Bap.Std.Term.html#VALlive", "<div class=\"info\">\n<p>a term is identified as always non dead</p>\n\n</div>\n", ["ALWAYS", "DEAD", "IDENTIFIED", "NON", "TERM"]);
add_ocaml_element("synthetic", "Std.Term.synthetic", "value", "unit Std.tag", "Bap.Std.Term.html#VALsynthetic", "<div class=\"info\">\n<p>a term was introduced artificially by an analysis.</p>\n\n</div>\n", ["ANALYSIS", "ARTIFICIALLY", "INTRODUCED", "TERM", "WAS"]);
add_ocaml_element("origin", "Std.Term.origin", "value", "Std.tid Std.tag", "Bap.Std.Term.html#VALorigin", "<div class=\"info\">\n<p>a term was artificially produced from a term with a given tid.</p>\n\n</div>\n", ["ARTIFICIALLY", "FROM", "GIVEN", "PRODUCED", "TERM", "TID", "WAS", "WITH"]);
add_ocaml_element("del_attr", "Std.Term.del_attr", "value", "'a Std.Term.t -> 'b Std.tag -> 'a Std.Term.t", "Bap.Std.Term.html#VALdel_attr", "<div class=\"info\">\n<p><code class=\"code\">del_attr&nbsp;term&nbsp;attr</code> deletes attribute <code class=\"code\">attr</code> from <code class=\"code\">term</code></p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "DELETES", "DEL_ATTR", "FROM", "TERM"]);
add_ocaml_element("has_attr", "Std.Term.has_attr", "value", "'a Std.Term.t -> 'b Std.tag -> bool", "Bap.Std.Term.html#VALhas_attr", "<div class=\"info\">\n<p><code class=\"code\">has_attr&nbsp;term&nbsp;attr</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">term</code> has attribute <code class=\"code\">attr</code></p>\n\n</div>\n", ["ATTR", "ATTRIBUTE", "HAS", "HAS_ATTR", "TERM", "TRUE"]);
add_ocaml_element("get_attr", "Std.Term.get_attr", "value", "'a Std.Term.t -> 'b Std.tag -> 'b option", "Bap.Std.Term.html#VALget_attr", "<div class=\"info\">\n<p><code class=\"code\">get_attr&nbsp;term&nbsp;attr</code> returns a value of the a given <code class=\"code\">attr</code> in\n        <code class=\"code\">term</code></p>\n\n</div>\n", ["ATTR", "GET_ATTR", "GIVEN", "RETURNS", "TERM", "THE", "VALUE"]);
add_ocaml_element("with_attrs", "Std.Term.with_attrs", "value", "'a Std.Term.t -> Std.Dict.t -> 'a Std.Term.t", "Bap.Std.Term.html#VALwith_attrs", "<div class=\"info\">\n<p><code class=\"code\">with_attrs&nbsp;term&nbsp;attributes</code> returns a term with a new set of <code class=\"code\">attributes</code></p>\n\n</div>\n", ["ATTRIBUTES", "NEW", "RETURNS", "SET", "TERM", "WITH", "WITH_ATTRS"]);
add_ocaml_element("attrs", "Std.Term.attrs", "value", "'a Std.Term.t -> Std.Dict.t", "Bap.Std.Term.html#VALattrs", "<div class=\"info\">\n<p><code class=\"code\">attrs&nbsp;term&nbsp;attrs</code> returns the set of <code class=\"code\">attributes</code> associated\n        with a <code class=\"code\">term</code></p>\n\n</div>\n", ["ASSOCIATED", "ATTRIBUTES", "ATTRS", "RETURNS", "SET", "TERM", "THE", "WITH"]);
add_ocaml_element("set_attr", "Std.Term.set_attr", "value", "'a Std.Term.t -> 'b Std.tag -> 'b -> 'a Std.Term.t", "Bap.Std.Term.html#VALset_attr", "<div class=\"info\">\n<p><code class=\"code\">set_attr&nbsp;term&nbsp;attr&nbsp;value</code> attaches an <code class=\"code\">value</code> to attribute\n        <code class=\"code\">attr</code> in <code class=\"code\">term</code></p>\n\n</div>\n", ["ATTACHES", "ATTR", "ATTRIBUTE", "SET_ATTR", "TERM", "VALUE"]);
add_ocaml_element("nth_exn", "Std.Term.nth_exn", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> int -> 'b Std.Term.t", "Bap.Std.Term.html#VALnth_exn", "<div class=\"info\">\n<p><code class=\"code\">nth_exn&nbsp;t&nbsp;p&nbsp;n</code> same as <code class=\"code\">nth</code>, but raises exception if <code class=\"code\">n</code> is\n        not a valid position number.</p>\n\n</div>\n", ["BUT", "EXCEPTION", "NOT", "NTH", "NTH_EXN", "NUMBER", "POSITION", "RAISES", "SAME", "VALID"]);
add_ocaml_element("nth", "Std.Term.nth", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> int -> 'b Std.Term.t option", "Bap.Std.Term.html#VALnth", "<div class=\"info\">\n<p><code class=\"code\">nth&nbsp;t&nbsp;p&nbsp;n</code> returns <code class=\"code\">n</code>'th <code class=\"code\">t</code>-term of parent <code class=\"code\">p</code>.</p>\n\n</div>\n", ["NTH", "PARENT", "RETURNS", "TERM"]);
add_ocaml_element("prepend", "Std.Term.prepend", "value", "('a, 'b) Std.cls ->\n  ?before:Std.tid ->\n  'a Std.Term.t -> 'b Std.Term.t -> 'a Std.Term.t", "Bap.Std.Term.html#VALprepend", "<div class=\"info\">\n<p><code class=\"code\">prepend&nbsp;t&nbsp;~before:this&nbsp;p&nbsp;c</code> returns the <code class=\"code\">p</code> with <code class=\"code\">c</code> inserted\n        before <code class=\"code\">this</code> term.</p>\n\n</div>\n", ["ALL", "BEFORE", "BEGINNING", "BUT", "CASES", "DOESN", "HAS", "INSERT", "INSERTED", "JUST", "LEFT", "OCCUR", "OTHERWISE", "PREPEND", "RETURNED", "RETURNS", "SAME", "SEQUENCE", "SPECIFIED", "TERM", "THE", "THEN", "THIS", "TID", "UNSPECIFIED", "WITH"]);
add_ocaml_element("append", "Std.Term.append", "value", "('a, 'b) Std.cls ->\n  ?after:Std.tid ->\n  'a Std.Term.t -> 'b Std.Term.t -> 'a Std.Term.t", "Bap.Std.Term.html#VALappend", "<div class=\"info\">\n<p><code class=\"code\">append&nbsp;t&nbsp;~after:this&nbsp;p&nbsp;c</code> returns the <code class=\"code\">p</code> term with <code class=\"code\">c</code>\n        appended after <code class=\"code\">this</code> term.</p>\n\n</div>\n", ["ADDED", "AFTER", "APPEND", "APPENDED", "DEF", "DOESN", "END", "JUST", "MAKES", "NOT", "NOTHING", "OCCUR", "OTHERWISE", "PARENT", "PRESERVED", "RETURNS", "SENSE", "SPECIFIED", "TERM", "THE", "THEN", "THIS", "TID", "WITH"]);
add_ocaml_element("before", "Std.Term.before", "value", "('a, 'b) Std.cls ->\n  ?rev:bool ->\n  'a Std.Term.t -> Std.tid -> 'b Std.Term.t Std.seq", "Bap.Std.Term.html#VALbefore", "<div class=\"info\">\n<p><code class=\"code\">before&nbsp;t&nbsp;?rev&nbsp;p&nbsp;tid</code> returns all term that occurs before\n        defintion with a given <code class=\"code\">tid</code> in blk.</p>\n\n</div>\n", ["ALL", "BEFORE", "BLK", "DEFINITION", "DEFINTION", "EMPTY", "GIVEN", "OCCURS", "RETURNS", "REV", "SEQUENCE", "SUCH", "TERM", "THAT", "THE", "THEN", "THERE", "TID", "WILL", "WITH"]);
add_ocaml_element("after", "Std.Term.after", "value", "('a, 'b) Std.cls ->\n  ?rev:bool ->\n  'a Std.Term.t -> Std.tid -> 'b Std.Term.t Std.seq", "Bap.Std.Term.html#VALafter", "<div class=\"info\">\n<p><code class=\"code\">after&nbsp;t&nbsp;?rev&nbsp;p&nbsp;tid</code> returns all subterms in term <code class=\"code\">p</code> that\n        occur after a term with a given <code class=\"code\">tid</code>.</p>\n\n</div>\n", ["AFTER", "ALL", "ARE", "EMPTY", "EVALUATION", "GIVEN", "OCCUR", "OMITTED", "ORDER", "OTHERWISE", "RETURNED", "RETURNS", "REV", "REVERSED", "SEQUENCE", "SUBTERMS", "TERM", "TERMS", "THAT", "THE", "THEN", "THERE", "THEY", "TID", "TRUE", "WITH"]);
add_ocaml_element("prev", "Std.Term.prev", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t -> Std.tid -> 'b Std.Term.t option", "Bap.Std.Term.html#VALprev", "<div class=\"info\">\n<p><code class=\"code\">prev&nbsp;t&nbsp;p&nbsp;id</code> returns a term that preceeds a term with a given\n        <code class=\"code\">id</code>, if such exists.</p>\n\n</div>\n", ["EXISTS", "GIVEN", "PRECEEDS", "PREV", "RETURNS", "SUCH", "TERM", "THAT", "WITH"]);
add_ocaml_element("next", "Std.Term.next", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t -> Std.tid -> 'b Std.Term.t option", "Bap.Std.Term.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;t&nbsp;p&nbsp;id</code> returns a term that is after a term with a given\n        <code class=\"code\">id</code>, if such exists.</p>\n\n</div>\n", ["AFTER", "EXISTS", "GIVEN", "NEXT", "RETURNS", "SUCH", "TERM", "THAT", "WITH"]);
add_ocaml_element("last", "Std.Term.last", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> 'b Std.Term.t option", "Bap.Std.Term.html#VALlast", "<div class=\"info\">\n<p><code class=\"code\">last&nbsp;t&nbsp;p</code> returns a last subterm of type <code class=\"code\">t</code> of a given\n        parent <code class=\"code\">p</code></p>\n\n</div>\n", ["GIVEN", "LAST", "PARENT", "RETURNS", "SUBTERM", "TYPE"]);
add_ocaml_element("first", "Std.Term.first", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> 'b Std.Term.t option", "Bap.Std.Term.html#VALfirst", "<div class=\"info\">\n<p><code class=\"code\">first&nbsp;t&nbsp;p</code> returns the first subterm of type <code class=\"code\">t</code> of a given\n        parent <code class=\"code\">p</code></p>\n\n</div>\n", ["FIRST", "GIVEN", "PARENT", "RETURNS", "SUBTERM", "THE", "TYPE"]);
add_ocaml_element("filter", "Std.Term.filter", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t -> f:('b Std.Term.t -> bool) -> 'a Std.Term.t", "Bap.Std.Term.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;t&nbsp;p&nbsp;~f</code> returns a term <code class=\"code\">p</code> with subterms <code class=\"code\">c</code> for which\n        <code class=\"code\">f&nbsp;c&nbsp;=&nbsp;<span class=\"keyword\">false</span></code> removed.</p>\n\n</div>\n", ["FALSE", "FILTER", "FOR", "REMOVED", "RETURNS", "SUBTERMS", "TERM", "WHICH", "WITH"]);
add_ocaml_element("concat_map", "Std.Term.concat_map", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t ->\n  f:('b Std.Term.t -> 'b Std.Term.t list) -> 'a Std.Term.t", "Bap.Std.Term.html#VALconcat_map", "<div class=\"info\">\n<p><code class=\"code\">concat_map&nbsp;t&nbsp;p&nbsp;~f</code> substitute subterm <code class=\"code\">c</code> of type <code class=\"code\">t</code> in\n        parent term <code class=\"code\">p</code> with <code class=\"code\">f&nbsp;c</code>.</p>\n\n</div>\n", ["ARE", "CONCAT_MAP", "DOESN", "ELEMENTS", "EMPTY", "INSERTED", "LIKE", "LIST", "MAP", "NEW", "OCCUR", "PARENT", "PLACE", "SINGLETON", "SUBSTITUTE", "SUBSTITUTED", "SUBTERM", "TERM", "THE", "THEN", "THIS", "TYPE", "WITH"]);
add_ocaml_element("filter_map", "Std.Term.filter_map", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t ->\n  f:('b Std.Term.t -> 'b Std.Term.t option) -> 'a Std.Term.t", "Bap.Std.Term.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;t&nbsp;p&nbsp;~f</code> returns term <code class=\"code\">p</code> with all subterms of type\n        <code class=\"code\">t</code> filter_mapped with function <code class=\"code\">f</code>, i.e., all terms for which\n        function <code class=\"code\">f</code> returned <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;thing</code> are substituted by the\n        <code class=\"code\">thing</code>, otherwise they're removed from the parent term</p>\n\n</div>\n", ["ALL", "ARE", "FILTER_MAP", "FILTER_MAPPED", "FOR", "FROM", "FUNCTION", "OTHERWISE", "PARENT", "REMOVED", "RETURNED", "RETURNS", "SOME", "SUBSTITUTED", "SUBTERMS", "TERM", "TERMS", "THE", "THEY", "THING", "TYPE", "WHICH", "WITH"]);
add_ocaml_element("map", "Std.Term.map", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t ->\n  f:('b Std.Term.t -> 'b Std.Term.t) -> 'a Std.Term.t", "Bap.Std.Term.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;t&nbsp;p&nbsp;~f</code> returns term <code class=\"code\">p</code> with all subterms of type <code class=\"code\">t</code>\n        mapped with function <code class=\"code\">f</code></p>\n\n</div>\n", ["ALL", "FUNCTION", "MAP", "MAPPED", "RETURNS", "SUBTERMS", "TERM", "TYPE", "WITH"]);
add_ocaml_element("to_sequence", "Std.Term.to_sequence", "value", "?rev:bool ->\n  ('a, 'b) Std.cls -> 'a Std.Term.t -> 'b Std.Term.t Std.seq", "Bap.Std.Term.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;?rev&nbsp;t&nbsp;p</code> is a synonym for <code class=\"code\">enum</code>.</p>\n\n</div>\n", ["ENUM", "FOR", "REV", "SYNONYM", "TO_SEQUENCE"]);
add_ocaml_element("enum", "Std.Term.enum", "value", "?rev:bool ->\n  ('a, 'b) Std.cls -> 'a Std.Term.t -> 'b Std.Term.t Std.seq", "Bap.Std.Term.html#VALenum", "<div class=\"info\">\n<p><code class=\"code\">enum&nbsp;?rev&nbsp;t&nbsp;p</code> enumerate all subterms of type <code class=\"code\">t</code> of the\n        a given term <code class=\"code\">p</code></p>\n\n</div>\n", ["ALL", "ENUM", "ENUMERATE", "GIVEN", "REV", "SUBTERMS", "TERM", "THE", "TYPE"]);
add_ocaml_element("change", "Std.Term.change", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t ->\n  Std.tid ->\n  ('b Std.Term.t option -> 'b Std.Term.t option) -> 'a Std.Term.t", "Bap.Std.Term.html#VALchange", "<div class=\"info\">\n<p><code class=\"code\">change&nbsp;t&nbsp;p&nbsp;id&nbsp;f</code> if <code class=\"code\">p</code> contains subterm with of a given kind\n        <code class=\"code\">t</code> and identifier <code class=\"code\">id</code>, then apply <code class=\"code\">f</code> to this\n        subterm.</p>\n\n</div>\n", ["AND", "APPLY", "CHANGE", "CONTAINS", "DID", "EXIST", "GIVEN", "IDENTIFIER", "KIND", "NEW", "NONE", "OTHERWISE", "PARENT", "REMOVE", "RETURN", "SUBTERM", "THEN", "THIS", "UPDATE", "WITH"]);
add_ocaml_element("remove", "Std.Term.remove", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> Std.tid -> 'a Std.Term.t", "Bap.Std.Term.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;t&nbsp;p&nbsp;id</code> returns a term that doesn't contain element\n        with the a given <code class=\"code\">id</code></p>\n\n</div>\n", ["CONTAIN", "DOESN", "ELEMENT", "GIVEN", "REMOVE", "RETURNS", "TERM", "THAT", "THE", "WITH"]);
add_ocaml_element("update", "Std.Term.update", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t -> 'b Std.Term.t -> 'a Std.Term.t", "Bap.Std.Term.html#VALupdate", "<div class=\"info\">\n<p><code class=\"code\">update&nbsp;t&nbsp;p&nbsp;c</code> if term <code class=\"code\">p</code> contains a term with id equal to\n        <code class=\"code\">tid&nbsp;c</code> then return <code class=\"code\">p</code> with this term substituted with <code class=\"code\">p</code></p>\n\n</div>\n", ["CONTAINS", "EQUAL", "RETURN", "SUBSTITUTED", "TERM", "THEN", "THIS", "TID", "UPDATE", "WITH"]);
add_ocaml_element("find_exn", "Std.Term.find_exn", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> Std.tid -> 'b Std.Term.t", "Bap.Std.Term.html#VALfind_exn", "<div class=\"info\">\n<p><code class=\"code\">find_exn&nbsp;t&nbsp;p&nbsp;id</code> like <a href=\"Bap.Std.Term.html#VALfind\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Term</span>.find</code></a> but raises <code class=\"code\"><span class=\"constructor\">Not_found</span></code> if nothing\n        is found.</p>\n\n</div>\n", ["BAP", "BUT", "FIND", "FIND_EXN", "FOUND", "LIKE", "NOTHING", "NOT_FOUND", "RAISES", "STD", "TERM"]);
add_ocaml_element("find", "Std.Term.find", "value", "('a, 'b) Std.cls ->\n  'a Std.Term.t -> Std.tid -> 'b Std.Term.t option", "Bap.Std.Term.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;t&nbsp;p&nbsp;id</code> is <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;c</code> if term <code class=\"code\">p</code> has a subterm of type <code class=\"code\">t</code>\n        such that <code class=\"code\">tid&nbsp;c&nbsp;=&nbsp;id</code>.</p>\n\n</div>\n", ["FIND", "HAS", "SOME", "SUBTERM", "SUCH", "TERM", "THAT", "TID", "TYPE"]);
add_ocaml_element("length", "Std.Term.length", "value", "('a, 'b) Std.cls -> 'a Std.Term.t -> int", "Bap.Std.Term.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;t&nbsp;p</code> returns an amount of terms of <code class=\"code\">t</code> class in a\n        parent term <code class=\"code\">p</code></p>\n\n</div>\n", ["AMOUNT", "CLASS", "LENGTH", "PARENT", "RETURNS", "TERM", "TERMS"]);
add_ocaml_element("tid", "Std.Term.tid", "value", "'a Std.Term.t -> Std.tid", "Bap.Std.Term.html#VALtid", "<div class=\"info\">\n<p><code class=\"code\">tid&nbsp;entity</code> returns a unique identifier of the <code class=\"code\">entity</code></p>\n\n</div>\n", ["ENTITY", "IDENTIFIER", "RETURNS", "THE", "TID", "UNIQUE"]);
add_ocaml_element("name", "Std.Term.name", "value", "'a Std.Term.t -> string", "Bap.Std.Term.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;t</code> returns a string representation of a term <code class=\"code\">t</code> identity</p>\n\n</div>\n", ["IDENTITY", "NAME", "REPRESENTATION", "RETURNS", "STRING", "TERM"]);
add_ocaml_element("same", "Std.Term.same", "value", "'a Std.Term.t -> 'a Std.Term.t -> bool", "Bap.Std.Term.html#VALsame", "<div class=\"info\">\n<p><code class=\"code\">same&nbsp;x&nbsp;y</code> returns true if <code class=\"code\">x</code> and <code class=\"code\">y</code> represents the same\n        entity, i.e., <code class=\"code\"><span class=\"constructor\">Tid</span>.(tid&nbsp;x&nbsp;=&nbsp;tid&nbsp;y)</code></p>\n\n</div>\n", ["AND", "ENTITY", "REPRESENTS", "RETURNS", "SAME", "THE", "TID", "TRUE"]);
add_ocaml_element("clone", "Std.Term.clone", "value", "'a Std.Term.t -> 'a Std.Term.t", "Bap.Std.Term.html#VALclone", "<div class=\"info\">\n<p><code class=\"code\">clone&nbsp;term</code> creates an object with a fresh new identifier\n        that has the same contents as <code class=\"code\">term</code>, i.e., that is\n        syntactically the same.</p>\n\n</div>\n", ["ALL", "ARE", "CLONE", "CONTENTS", "CREATES", "FRESH", "HAS", "IDENTIFIER", "NEW", "OBJECT", "OPERATION", "SAME", "SHALLOW", "SUBTERMS", "SYNTACTICALLY", "TERM", "THAT", "THE", "UNCHANGED", "WITH"]);
add_ocaml_element("(!!)", "Std.Tid.(!!)", "value", "string -> Std.tid", "Bap.Std.Tid.html#VAL(!!)", "<div class=\"info\">\n<p>infix notation for <code class=\"code\">from_string_exn</code></p>\n\n</div>\n", ["FOR", "FROM_STRING_EXN", "INFIX", "NOTATION"]);
add_ocaml_element("from_string_exn", "Std.Tid.from_string_exn", "value", "string -> Std.tid", "Bap.Std.Tid.html#VALfrom_string_exn", "<div class=\"info\">\n<p><code class=\"code\">from_string_exn&nbsp;s</code> same as <code class=\"code\">from_string_exn</code> but throws\n        exception on error.</p>\n\n</div>\n", ["BUT", "ERROR", "EXCEPTION", "FROM_STRING_EXN", "SAME", "THROWS"]);
add_ocaml_element("from_string", "Std.Tid.from_string", "value", "string -> Std.tid Or_error.t", "Bap.Std.Tid.html#VALfrom_string", "<div class=\"info\">\n<p><code class=\"code\">from_string&nbsp;s</code> parses tid from string.</p>\n\n</div>\n", ["CHARACTERS", "EXPECTED", "FORMAT", "FROM", "FROM_STRING", "HEX", "HEXADECIMAL", "NUMBER", "OCAML", "PARSES", "REPRESENTATION", "SEQUENCE", "STRING", "SYMBOL", "THE", "TID"]);
add_ocaml_element("name", "Std.Tid.name", "value", "Std.tid -> string", "Bap.Std.Tid.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;tid</code> returns a term name: either a string name\n        with at-prefix, or number identifier.</p>\n\n</div>\n", ["EITHER", "IDENTIFIER", "NAME", "NUMBER", "PREFIX", "RETURNS", "STRING", "TERM", "TID", "WITH"]);
add_ocaml_element("set_name", "Std.Tid.set_name", "value", "Std.tid -> string -> unit", "Bap.Std.Tid.html#VALset_name", "<div class=\"info\">\n<p><code class=\"code\">set_name&nbsp;tid&nbsp;name</code> associates a <code class=\"code\">name</code> with a given\n        term identifier <code class=\"code\">tid</code>.</p>\n\n</div>\n", ["ANY", "ARE", "ASSOCIATES", "ASSOCIATIONS", "GIVEN", "IDENTIFIER", "NAME", "OVERRIDDEN", "PREVIOUS", "SET_NAME", "TERM", "TID", "WITH"]);
add_ocaml_element("create", "Std.Tid.create", "value", "unit -> Std.Tid.t", "Bap.Std.Tid.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates a fresh newly term identifier</p>\n\n</div>\n", ["CREATE", "CREATES", "FRESH", "IDENTIFIER", "NEWLY", "TERM"]);
add_ocaml_element("span", "Std.Symtab.span", "value", "Std.Symtab.fn -> unit Std.memmap", "Bap.Std.Symtab.html#VALspan", "<div class=\"info\">\n<p><code class=\"code\">span&nbsp;fn</code> returns a memory map of a region occupied by a\n        function <code class=\"code\">fn</code></p>\n\n</div>\n", ["FUNCTION", "MAP", "MEMORY", "OCCUPIED", "REGION", "RETURNS", "SPAN"]);
add_ocaml_element("to_sequence", "Std.Symtab.to_sequence", "value", "Std.Symtab.t -> Std.Symtab.fn Std.seq", "Bap.Std.Symtab.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;symtab</code> returns a sequence of functions</p>\n\n</div>\n", ["FUNCTIONS", "RETURNS", "SEQUENCE", "SYMTAB", "TO_SEQUENCE"]);
add_ocaml_element("intersecting", "Std.Symtab.intersecting", "value", "Std.Symtab.t -> Std.mem -> Std.Symtab.fn list", "Bap.Std.Symtab.html#VALintersecting", "<div class=\"info\">\n<p><code class=\"code\">intersecting_mem&nbsp;syms&nbsp;mem</code> returns a list of functions, that\n        resides in memory region <code class=\"code\">mem</code></p>\n\n</div>\n", ["FUNCTIONS", "INTERSECTING_MEM", "LIST", "MEM", "MEMORY", "REGION", "RESIDES", "RETURNS", "SYMS", "THAT"]);
add_ocaml_element("dominators", "Std.Symtab.dominators", "value", "Std.Symtab.t -> Std.mem -> Std.Symtab.fn list", "Bap.Std.Symtab.html#VALdominators", "<div class=\"info\">\n<p><code class=\"code\">dominators&nbsp;syms&nbsp;mem</code> returns a list of functions that\n        dominates over provided memory region <code class=\"code\">mem</code></p>\n\n</div>\n", ["DOMINATES", "DOMINATORS", "FUNCTIONS", "LIST", "MEM", "MEMORY", "OVER", "PROVIDED", "REGION", "RETURNS", "SYMS", "THAT"]);
add_ocaml_element("owners", "Std.Symtab.owners", "value", "Std.Symtab.t -> Std.addr -> Std.Symtab.fn list", "Bap.Std.Symtab.html#VALowners", "<div class=\"info\">\n<p><code class=\"code\">owners&nbsp;addr</code> return a list of functions that owns <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "FUNCTIONS", "LIST", "OWNERS", "OWNS", "RETURN", "THAT"]);
add_ocaml_element("find_by_start", "Std.Symtab.find_by_start", "value", "Std.Symtab.t -> Std.addr -> Std.Symtab.fn option", "Bap.Std.Symtab.html#VALfind_by_start", "<div class=\"info\">\n<p><code class=\"code\">find_by_start&nbsp;symbols&nbsp;addr</code> finds a symbol that starts from\n        a given address</p>\n\n</div>\n", ["ADDR", "ADDRESS", "FINDS", "FIND_BY_START", "FROM", "GIVEN", "STARTS", "SYMBOL", "SYMBOLS", "THAT"]);
add_ocaml_element("find_by_name", "Std.Symtab.find_by_name", "value", "Std.Symtab.t -> string -> Std.Symtab.fn option", "Bap.Std.Symtab.html#VALfind_by_name", "<div class=\"info\">\n<p><code class=\"code\">find_by_name&nbsp;symbols&nbsp;name</code> finds a symbol with a given namem</p>\n\n</div>\n", ["FINDS", "FIND_BY_NAME", "GIVEN", "NAME", "NAMEM", "SYMBOL", "SYMBOLS", "WITH"]);
add_ocaml_element("remove", "Std.Symtab.remove", "value", "Std.Symtab.t -> Std.Symtab.fn -> Std.Symtab.t", "Bap.Std.Symtab.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;table&nbsp;fn</code> removes symbol <code class=\"code\">fn</code> from <code class=\"code\">table</code></p>\n\n</div>\n", ["FROM", "REMOVE", "REMOVES", "SYMBOL", "TABLE"]);
add_ocaml_element("add_symbol", "Std.Symtab.add_symbol", "value", "Std.Symtab.t -> Std.Symtab.fn -> Std.Symtab.t", "Bap.Std.Symtab.html#VALadd_symbol", "<div class=\"info\">\n<p><code class=\"code\">add_symbol&nbsp;table&nbsp;name&nbsp;entry&nbsp;blocks</code> extends <code class=\"code\">table</code> with a\n        new symbol with a given <code class=\"code\">name</code>, <code class=\"code\">entry</code> block and body\n        <code class=\"code\">blocks</code>.</p>\n\n</div>\n", ["ADD_SYMBOL", "AND", "BLOCK", "BLOCKS", "BODY", "ENTRY", "EXTENDS", "GIVEN", "NAME", "NEW", "SYMBOL", "TABLE", "WITH"]);
add_ocaml_element("empty", "Std.Symtab.empty", "value", "Std.Symtab.t", "Bap.Std.Symtab.html#VALempty", "<div class=\"info\">\n<p>empty symbol table</p>\n\n</div>\n", ["EMPTY", "SYMBOL", "TABLE"]);
add_ocaml_element("of_file", "Std.Disasm.With_exn.of_file", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter -> ?loader:string -> string -> Std.Disasm.t", "Bap.Std.Disasm.With_exn.html#VALof_file", "<div class=\"info\">\n<p>see <a href=\"Bap.Std.Disasm.html#VALof_file\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Disasm</span>.of_file</code></a></p>\n\n</div>\n", ["BAP", "DISASM", "OF_FILE", "SEE", "STD"]);
add_ocaml_element("of_image", "Std.Disasm.With_exn.of_image", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter -> Std.image -> Std.Disasm.t", "Bap.Std.Disasm.With_exn.html#VALof_image", "", []);
add_ocaml_element("of_mem", "Std.Disasm.With_exn.of_mem", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter -> Std.arch -> Std.mem -> Std.Disasm.t", "Bap.Std.Disasm.With_exn.html#VALof_mem", "<div class=\"info\">\n<p>see <a href=\"Bap.Std.Disasm.html#VALof_mem\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Disasm</span>.of_mem</code></a></p>\n\n</div>\n", ["BAP", "DISASM", "OF_IMAGE", "OF_MEM", "SEE", "STD"]);
add_ocaml_element("insn", "Std.Disasm.insn", "value", "Std.insn Std.tag", "Bap.Std.Disasm.html#VALinsn", "<div class=\"info\">\n<p>machine instruction.</p>\n\n</div>\n", ["INSTRUCTION", "MACHINE"]);
add_ocaml_element("cfg", "Std.Disasm.cfg", "value", "Std.Disasm.t -> Std.cfg", "Bap.Std.Disasm.html#VALcfg", "<div class=\"info\">\n<p>A whole program CFG.</p>\n\n</div>\n", ["CFG", "PROGRAM", "WHOLE"]);
add_ocaml_element("insns", "Std.Disasm.insns", "value", "Std.Disasm.t -> (Std.mem * Std.insn) Std.seq", "Bap.Std.Disasm.html#VALinsns", "<div class=\"info\">\n<p>returns all instructions that was successfully decoded in an\n        ascending order of their addresses.</p>\n\n</div>\n", ["ACCOMPANIED", "ADDRESSES", "ALL", "ASCENDING", "BLOCK", "DECODED", "EACH", "INSTRUCTION", "INSTRUCTIONS", "ITS", "MEMORY", "ORDER", "RETURNS", "SUCCESSFULLY", "THAT", "THEIR", "WAS", "WITH"]);
add_ocaml_element("merge", "Std.Disasm.merge", "value", "Std.Disasm.t -> Std.Disasm.t -> Std.Disasm.t", "Bap.Std.Disasm.html#VALmerge", "<div class=\"info\">\n<p><code class=\"code\">merge&nbsp;d1&nbsp;d2</code> is a union of control flow graphs and erros of\n        the two disassemblers.</p>\n\n</div>\n", ["AND", "CONTROL", "DISASSEMBLERS", "ERROS", "FLOW", "GRAPHS", "MERGE", "THE", "TWO", "UNION"]);
add_ocaml_element("of_file", "Std.Disasm.of_file", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter ->\n  ?loader:string -> string -> Std.Disasm.t Or_error.t", "Bap.Std.Disasm.html#VALof_file", "<div class=\"info\">\n<p><code class=\"code\">disassemble_file&nbsp;?roots&nbsp;path</code> takes a path to a binary and\n        disassembles it</p>\n\n</div>\n", ["AND", "BINARY", "DISASSEMBLES", "DISASSEMBLE_FILE", "PATH", "ROOTS", "TAKES"]);
add_ocaml_element("of_image", "Std.Disasm.of_image", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter ->\n  Std.image -> Std.Disasm.t Or_error.t", "Bap.Std.Disasm.html#VALof_image", "<div class=\"info\">\n<p><code class=\"code\">disassemble_image&nbsp;image</code> disassemble a given image.</p>\n\n</div>\n", ["AND", "APPLYING", "ARE", "CONTAIN", "DISASSEMBLE", "DISASSEMBLE_IMAGE", "DOESN", "ENTRY", "EXECUTABLE", "FILE", "FUNCTION", "GIVEN", "IMAGE", "ONE", "POINT", "ROOTS", "SEGMENTS", "SOURCE", "SPECIFIED", "SYMBOL", "TABLE", "TAKE", "THE", "THEN", "USED", "WILL"]);
add_ocaml_element("of_mem", "Std.Disasm.of_mem", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter ->\n  Std.arch -> Std.mem -> Std.Disasm.t Or_error.t", "Bap.Std.Disasm.html#VALof_mem", "<div class=\"info\">\n<p><code class=\"code\">disassemble&nbsp;?roots&nbsp;arch&nbsp;mem</code> disassemble provided memory region\n        <code class=\"code\">mem</code> using best available algorithm and backend for the specified\n        <code class=\"code\">arch</code>.</p>\n\n</div>\n", ["ADDRESS", "ALGORITHM", "ALL", "AND", "ARCH", "ARE", "AVAILABLE", "BACKEND", "BELIEVED", "BEST", "CODE", "CONTAIN", "DISASSEMBLE", "FOR", "FROM", "FUNCTION", "GIVEN", "KNOWLEDGE", "LIST", "MEM", "MEMORY", "OUR", "POINT", "PROVIDED", "REACHABLE", "REGION", "REGIONS", "RETURNED", "ROOT", "ROOTS", "SET", "SHOULD", "SPECIFIED", "STARTING", "STARTS", "THAT", "THE", "THEN", "THIS", "USED", "USING", "VALUE", "WILL"]);
add_ocaml_element("create", "Std.Disasm.create", "value", "Std.cfg -> Std.Disasm.t", "Bap.Std.Disasm.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;cfg</code></p>\n\n</div>\n", ["CFG", "CREATE"]);
add_ocaml_element("cond", "Std.Graphs.Ir.Edge.cond", "value", "Std.Graphs.Ir.t -> graph -> Std.exp", "Bap.Std.Graphs.Ir.Edge.html#VALcond", "<div class=\"info\">\n<p><code class=\"code\">cond&nbsp;e&nbsp;g</code> computes a condition expression that is\n            asserted to be <code class=\"code\"><span class=\"keyword\">true</span></code> if this branch is taken.</p>\n\n</div>\n", ["ACCOUNT", "ALL", "ASSERTED", "ASSOCIATED", "BRANCH", "COMPUTES", "COND", "CONDITION", "CONDITIONS", "EDGE", "EXPRESSION", "INTO", "ITSELF", "JMP", "NOT", "NOTE", "PRECEDING", "SAME", "TAKEN", "TAKES", "TERM", "THAT", "THE", "THIS", "TRUE", "WITH"]);
add_ocaml_element("tid", "Std.Graphs.Ir.Edge.tid", "value", "Std.Graphs.Ir.t -> Std.tid", "Bap.Std.Graphs.Ir.Edge.html#VALtid", "<div class=\"info\">\n<p><code class=\"code\">tid&nbsp;e</code> returns a tid of a jmp term that is associated\n            with an edge <code class=\"code\">e</code></p>\n\n</div>\n", ["ASSOCIATED", "EDGE", "JMP", "RETURNS", "TERM", "THAT", "TID", "WITH"]);
add_ocaml_element("jmp", "Std.Graphs.Ir.Edge.jmp", "value", "Std.Graphs.Ir.t -> Std.jmp Std.term", "Bap.Std.Graphs.Ir.Edge.html#VALjmp", "<div class=\"info\">\n<p><code class=\"code\">jmp&nbsp;e</code> returns a jmp term associated with edge <code class=\"code\">e</code></p>\n\n</div>\n", ["ASSOCIATED", "EDGE", "JMP", "RETURNS", "TERM", "WITH"]);
add_ocaml_element("edges", "Std.Graphs.Ir.Edge.edges", "value", "[ `after | `before ] ->\n  Std.Graphs.Ir.t -> graph -> Std.Graphs.Ir.t Std.seq", "Bap.Std.Graphs.Ir.Edge.html#VALedges", "<div class=\"info\">\n<p><code class=\"code\">edges&nbsp;dir&nbsp;e&nbsp;g</code> enumerates all edges occurring before of\n            after an edge <code class=\"code\">e</code> in graph <code class=\"code\">g</code></p>\n\n</div>\n", ["AFTER", "ALL", "BEFORE", "DIR", "EDGE", "EDGES", "ENUMERATES", "GRAPH", "OCCURRING"]);
add_ocaml_element("jmps", "Std.Graphs.Ir.Edge.jmps", "value", "[ `after | `before ] ->\n  Std.Graphs.Ir.t -> graph -> Std.jmp Std.term Std.seq", "Bap.Std.Graphs.Ir.Edge.html#VALjmps", "<div class=\"info\">\n<p><code class=\"code\">jmps&nbsp;dir&nbsp;e&nbsp;g</code> enumerates all jumps (including calls,\n            interrupts, indirects, etc), that occurs before if\n            <code class=\"code\">dir&nbsp;=&nbsp;<span class=\"keywordsign\">`</span>before</code> or after if <code class=\"code\">dir&nbsp;=&nbsp;<span class=\"keywordsign\">`</span>after</code> an edge <code class=\"code\">e</code></p>\n\n</div>\n", ["AFTER", "ALL", "BEFORE", "CALLS", "DIR", "EDGE", "ENUMERATES", "ETC", "INCLUDING", "INDIRECTS", "INTERRUPTS", "JMPS", "JUMPS", "OCCURS", "THAT"]);
add_ocaml_element("insns", "Std.Block.insns", "value", "Std.Block.t -> (Std.mem * Std.insn) list", "Bap.Std.Block.html#VALinsns", "<div class=\"info\">\n<p><code class=\"code\">insns&nbsp;blk</code> returns a list of block instructions.</p>\n\n</div>\n", ["BLK", "BLOCK", "INSNS", "INSTRUCTIONS", "LIST", "RETURNS"]);
add_ocaml_element("terminator", "Std.Block.terminator", "value", "Std.Block.t -> Std.insn", "Bap.Std.Block.html#VALterminator", "<div class=\"info\">\n<p><code class=\"code\">terminator&nbsp;blk</code> last instruction of the block</p>\n\n</div>\n", ["BLK", "BLOCK", "INSTRUCTION", "LAST", "TERMINATOR", "THE"]);
add_ocaml_element("leader", "Std.Block.leader", "value", "Std.Block.t -> Std.insn", "Bap.Std.Block.html#VALleader", "<div class=\"info\">\n<p><code class=\"code\">leader&nbsp;blk</code> the first instruction</p>\n\n</div>\n", ["BLK", "FIRST", "INSTRUCTION", "LEADER", "THE"]);
add_ocaml_element("memory", "Std.Block.memory", "value", "Std.Block.t -> Std.mem", "Bap.Std.Block.html#VALmemory", "<div class=\"info\">\n<p><code class=\"code\">memory&nbsp;blk</code> a memory region, occupied by a block</p>\n\n</div>\n", ["BLK", "BLOCK", "MEMORY", "OCCUPIED", "REGION"]);
add_ocaml_element("addr", "Std.Block.addr", "value", "Std.Block.t -> Std.addr", "Bap.Std.Block.html#VALaddr", "<div class=\"info\">\n<p><code class=\"code\">addr&nbsp;block&nbsp;=&nbsp;<span class=\"constructor\">Memory</span>.min_addr&nbsp;(memory&nbsp;block)</code> address of the first instruction</p>\n\n</div>\n", ["ADDR", "ADDRESS", "BLOCK", "FIRST", "INSTRUCTION", "MEMORY", "MIN_ADDR", "THE"]);
add_ocaml_element("create", "Std.Block.create", "value", "Std.mem -> (Std.mem * Std.insn) list -> Std.Block.t", "Bap.Std.Block.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;mem&nbsp;insn</code> creates a block\n        Preconditions: <code class=\"code\">insns&nbsp;&lt;&gt;&nbsp;[]</code></p>\n\n</div>\n", ["BLOCK", "CREATE", "CREATES", "INSN", "INSNS", "MEM", "PRECONDITIONS"]);
add_ocaml_element("key_of_insns", "Std.Insn.Trie.key_of_insns", "value", "Std.Insn.t list -> Std.Insn.Trie.key", "Bap.Std.Insn.Trie.html#VALkey_of_insns", "<div class=\"info\">\n<p><code class=\"code\">key_of_insns&nbsp;insns</code> takes a list of instructions and transforms\n          it to <code class=\"code\">key</code></p>\n\n</div>\n", ["AND", "INSNS", "INSTRUCTIONS", "KEY", "KEY_OF_INSNS", "LIST", "TAKES", "TRANSFORMS"]);
add_ocaml_element("pp_adt", "Std.Insn.pp_adt", "value", "Std.Insn.t Std.printer", "Bap.Std.Insn.html#VALpp_adt", "<div class=\"info\">\n<p><code class=\"code\">pp_adt</code> prints instruction in ADT format, suitable for reading\n        by evaluating in many languages, e.g.</p>\n\n</div>\n", ["ADT", "ETC", "EVALUATING", "FOR", "FORMAT", "INSTRUCTION", "LANGUAGES", "MANY", "PP_ADT", "PRINTS", "PYTHON", "READING", "SUITABLE"]);
add_ocaml_element("shouldn't", "Std.Insn.shouldn't", "value", "Std.Insn.may Std.Insn.property -> Std.Insn.t -> Std.Insn.t", "Bap.Std.Insn.html#VALshouldn't", "<div class=\"info\">\n<p><code class=\"code\">must&nbsp;property&nbsp;insn</code> postulate that <code class=\"code\">insn</code> shouldn't have the <code class=\"code\">property</code></p>\n\n</div>\n", ["HAVE", "INSN", "MUST", "POSTULATE", "PROPERTY", "SHOULDN", "THAT", "THE"]);
add_ocaml_element("should", "Std.Insn.should", "value", "Std.Insn.may Std.Insn.property -> Std.Insn.t -> Std.Insn.t", "Bap.Std.Insn.html#VALshould", "<div class=\"info\">\n<p><code class=\"code\">must&nbsp;property&nbsp;insn</code> postulate that <code class=\"code\">insn</code> may have the <code class=\"code\">property</code></p>\n\n</div>\n", ["HAVE", "INSN", "MAY", "MUST", "POSTULATE", "PROPERTY", "THAT", "THE"]);
add_ocaml_element("mustn't", "Std.Insn.mustn't", "value", "Std.Insn.must Std.Insn.property -> Std.Insn.t -> Std.Insn.t", "Bap.Std.Insn.html#VALmustn't", "<div class=\"info\">\n<p><code class=\"code\">must&nbsp;property&nbsp;insn</code> postulate that <code class=\"code\">insn</code> must not have the <code class=\"code\">property</code></p>\n\n</div>\n", ["HAVE", "INSN", "MUST", "NOT", "POSTULATE", "PROPERTY", "THAT", "THE"]);
add_ocaml_element("must", "Std.Insn.must", "value", "Std.Insn.must Std.Insn.property -> Std.Insn.t -> Std.Insn.t", "Bap.Std.Insn.html#VALmust", "<div class=\"info\">\n<p><code class=\"code\">must&nbsp;property&nbsp;insn</code> postulate that <code class=\"code\">insn</code> must have the <code class=\"code\">property</code></p>\n\n</div>\n", ["HAVE", "INSN", "MUST", "POSTULATE", "PROPERTY", "THAT", "THE"]);
add_ocaml_element("may", "Std.Insn.may", "value", "Std.Insn.may Std.Insn.property -> Std.Insn.t -> bool", "Bap.Std.Insn.html#VALmay", "<div class=\"info\">\n<p><code class=\"code\">may&nbsp;propery&nbsp;insn</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">insn</code> has <code class=\"code\">property</code></p>\n\n</div>\n", ["HAS", "INSN", "MAY", "PROPERTY", "PROPERY", "TRUE"]);
add_ocaml_element("is", "Std.Insn.is", "value", "Std.Insn.must Std.Insn.property -> Std.Insn.t -> bool", "Bap.Std.Insn.html#VALis", "<div class=\"info\">\n<p><code class=\"code\">is&nbsp;property&nbsp;insn</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">insn</code> has <code class=\"code\">property</code></p>\n\n</div>\n", ["HAS", "INSN", "PROPERTY", "TRUE"]);
add_ocaml_element("store", "Std.Insn.store", "value", "Std.Insn.may Std.Insn.property", "Bap.Std.Insn.html#VALstore", "<div class=\"info\">\n<p>the instruction may store to memory</p>\n\n</div>\n", ["INSTRUCTION", "MAY", "MEMORY", "STORE", "THE"]);
add_ocaml_element("load", "Std.Insn.load", "value", "Std.Insn.may Std.Insn.property", "Bap.Std.Insn.html#VALload", "<div class=\"info\">\n<p>the instruction may load from memory</p>\n\n</div>\n", ["FROM", "INSTRUCTION", "LOAD", "MAY", "MEMORY", "THE"]);
add_ocaml_element("affect_control_flow", "Std.Insn.affect_control_flow", "value", "Std.Insn.may Std.Insn.property", "Bap.Std.Insn.html#VALaffect_control_flow", "<div class=\"info\">\n<p>the instruction may perform a non-regular control flow</p>\n\n</div>\n", ["CONTROL", "FLOW", "INSTRUCTION", "MAY", "NON", "PERFORM", "REGULAR", "THE"]);
add_ocaml_element("return", "Std.Insn.return", "value", "Std.Insn.must Std.Insn.property", "Bap.Std.Insn.html#VALreturn", "<div class=\"info\">\n<p>instruction is a return from a call</p>\n\n</div>\n", ["CALL", "FROM", "INSTRUCTION", "RETURN"]);
add_ocaml_element("call", "Std.Insn.call", "value", "Std.Insn.must Std.Insn.property", "Bap.Std.Insn.html#VALcall", "<div class=\"info\">\n<p>the instruction is a call to subroutine.</p>\n\n</div>\n", ["CALL", "INSTRUCTION", "SUBROUTINE", "THE"]);
add_ocaml_element("indirect", "Std.Insn.indirect", "value", "Std.Insn.must Std.Insn.property", "Bap.Std.Insn.html#VALindirect", "<div class=\"info\">\n<p>the instruction is jump with a target that is not a constant</p>\n\n</div>\n", ["CONSTANT", "INSTRUCTION", "JUMP", "NOT", "TARGET", "THAT", "THE", "WITH"]);
add_ocaml_element("conditional", "Std.Insn.conditional", "value", "Std.Insn.must Std.Insn.property", "Bap.Std.Insn.html#VALconditional", "<div class=\"info\">\n<p>under some dynamic condition the instruction may perform a\n        non-regular control flow</p>\n\n</div>\n", ["CONDITION", "CONTROL", "DYNAMIC", "FLOW", "INSTRUCTION", "MAY", "NON", "PERFORM", "REGULAR", "SOME", "THE", "UNDER"]);
add_ocaml_element("jump", "Std.Insn.jump", "value", "Std.Insn.must Std.Insn.property", "Bap.Std.Insn.html#VALjump", "<div class=\"info\">\n<p>the instruction performs a non-regular control flow</p>\n\n</div>\n", ["CONTROL", "FLOW", "INSTRUCTION", "NON", "PERFORMS", "REGULAR", "THE"]);
add_ocaml_element("new_property", "Std.Insn.new_property", "value", "'a -> string -> 'a Std.Insn.property", "Bap.Std.Insn.html#VALnew_property", "<div class=\"info\">\n<p><code class=\"code\">new_property&nbsp;must_or_may&nbsp;name</code> creates a new instruction\n        property with the specified name.</p>\n\n</div>\n", ["CREATES", "INSTRUCTION", "MUST_OR_MAY", "NAME", "NEW", "NEW_PROPERTY", "PROPERTY", "SPECIFIED", "THE", "WITH"]);
add_ocaml_element("ops", "Std.Insn.ops", "value", "Std.Insn.t -> Std.op array", "Bap.Std.Insn.html#VALops", "<div class=\"info\">\n<p>instruction operands</p>\n\n</div>\n", ["INSTRUCTION", "OPERANDS"]);
add_ocaml_element("bil", "Std.Insn.bil", "value", "Std.Insn.t -> Std.bil", "Bap.Std.Insn.html#VALbil", "<div class=\"info\">\n<p>returns BIL program specifying instruction semantics</p>\n\n</div>\n", ["BIL", "INSTRUCTION", "PROGRAM", "RETURNS", "SEMANTICS", "SPECIFYING"]);
add_ocaml_element("asm", "Std.Insn.asm", "value", "Std.Insn.t -> string", "Bap.Std.Insn.html#VALasm", "<div class=\"info\">\n<p>target-specific assembler string representing the instruction</p>\n\n</div>\n", ["ASSEMBLER", "INSTRUCTION", "REPRESENTING", "SPECIFIC", "STRING", "TARGET", "THE"]);
add_ocaml_element("name", "Std.Insn.name", "value", "Std.Insn.t -> string", "Bap.Std.Insn.html#VALname", "<div class=\"info\">\n<p>returns backend specific name of instruction</p>\n\n</div>\n", ["BACKEND", "INSTRUCTION", "NAME", "RETURNS", "SPECIFIC"]);
add_ocaml_element("of_basic", "Std.Insn.of_basic", "value", "?bil:Std.bil -> Std.Disasm_expert.Basic.full_insn -> Std.Insn.t", "Bap.Std.Insn.html#VALof_basic", "<div class=\"info\">\n<p>Creating\n        The following functions will create <code class=\"code\">insn</code> instances from a lower\n        level representation.</p>\n\n</div>\n", ["CREATE", "CREATING", "FOLLOWING", "FROM", "FUNCTIONS", "INSN", "INSTANCES", "LEVEL", "LOWER", "REPRESENTATION", "THE", "WILL"]);
add_ocaml_element("errors", "Std.Disasm_expert.Recursive.errors", "value", "Std.Disasm_expert.Recursive.t ->\n  Std.Disasm_expert.Recursive.error list", "Bap.Std.Disasm_expert.Recursive.html#VALerrors", "<div class=\"info\">\n<p><code class=\"code\">errors&nbsp;disasm</code> returns a list of non-critical errors, that\n          happened during the disassembly (e.g., unknown opcodes and\n          unlifted instructions.</p>\n\n</div>\n", ["AND", "CRITICAL", "DISASM", "DISASSEMBLY", "DURING", "ERRORS", "HAPPENED", "INSTRUCTIONS", "LIST", "NON", "OPCODES", "RETURNS", "THAT", "THE", "UNKNOWN", "UNLIFTED"]);
add_ocaml_element("cfg", "Std.Disasm_expert.Recursive.cfg", "value", "Std.Disasm_expert.Recursive.t -> Std.cfg", "Bap.Std.Disasm_expert.Recursive.html#VALcfg", "<div class=\"info\">\n<p><code class=\"code\">cfg&nbsp;t</code> returns a control flow graph, representing the code\n          in the input region of memory.</p>\n\n</div>\n", ["CFG", "CODE", "CONTROL", "FLOW", "GRAPH", "INPUT", "MEMORY", "NOT", "NOTE", "REGION", "REPRESENTING", "RETURNS", "SEGMENT", "SUBROUTINE", "THE", "THIS", "WHOLE"]);
add_ocaml_element("run", "Std.Disasm_expert.Recursive.run", "value", "?backend:string ->\n  ?brancher:Std.brancher ->\n  ?rooter:Std.rooter ->\n  Std.arch ->\n  Std.mem -> Std.Disasm_expert.Recursive.t Or_error.t", "Bap.Std.Disasm_expert.Recursive.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;?backend&nbsp;?brancher&nbsp;?rooter&nbsp;arch&nbsp;mem</code> disassemble and\n          reconstruct a CFG of the code in <code class=\"code\">mem</code>, assuming\n          architecture <code class=\"code\">arch</code>.</p>\n\n</div>\n", ["AND", "ARCH", "ARCHITECTURE", "ASSUMING", "BACKEND", "BRANCHER", "CFG", "CODE", "DISASSEMBLE", "MEM", "RECONSTRUCT", "ROOTER", "RUN", "THE"]);
add_ocaml_element("sweep", "Std.Disasm_expert.Linear.With_exn.sweep", "value", "?backend:string ->\n  Std.arch -> Std.mem -> Std.Disasm_expert.Linear.t", "Bap.Std.Disasm_expert.Linear.With_exn.html#VALsweep", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Linear</span>.<span class=\"constructor\">With_exn</span>.sweep</code> same as\n            <code class=\"code\"><span class=\"constructor\">Linear_sweep</span>.memory</code>, but raises an exception, instead of\n            returning <code class=\"code\"><span class=\"constructor\">Or_error</span></code> monad</p>\n\n</div>\n", ["BUT", "EXCEPTION", "INSTEAD", "LINEAR", "LINEAR_SWEEP", "MEMORY", "MONAD", "OR_ERROR", "RAISES", "RETURNING", "SAME", "SWEEP", "WITH_EXN"]);
add_ocaml_element("sweep", "Std.Disasm_expert.Linear.sweep", "value", "?backend:string ->\n  Std.arch ->\n  Std.mem -> Std.Disasm_expert.Linear.t Or_error.t", "Bap.Std.Disasm_expert.Linear.html#VALsweep", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Linear</span>.sweep&nbsp;arch&nbsp;mem</code> will perform a linear sweep\n          disassembly on the specified memory <code class=\"code\">mem</code></p>\n\n</div>\n", ["ARCH", "DISASSEMBLY", "LINEAR", "MEM", "MEMORY", "PERFORM", "SPECIFIED", "SWEEP", "THE", "WILL"]);
add_ocaml_element("key_of_first_insns", "Std.Disasm_expert.Basic.Trie.key_of_first_insns", "value", "('a, 'b, 'c, 'd) Std.Disasm_expert.Basic.state ->\n  len:int -> Std.Disasm_expert.Basic.Trie.key option", "Bap.Std.Disasm_expert.Basic.Trie.html#VALkey_of_first_insns", "<div class=\"info\">\n<p><code class=\"code\">key_of_first_insns&nbsp;state&nbsp;~len:n</code> creates a key from first <code class=\"code\">n</code>\n            instructions stored in the state if state contains such\n            amount of instructions</p>\n\n</div>\n", ["AMOUNT", "CONTAINS", "CREATES", "FIRST", "FROM", "INSTRUCTIONS", "KEY", "KEY_OF_FIRST_INSNS", "LEN", "STATE", "STORED", "SUCH", "THE"]);
add_ocaml_element("ops", "Std.Disasm_expert.Basic.Insn.ops", "value", "('a, 'k) Std.Disasm_expert.Basic.Insn.t -> Std.op array", "Bap.Std.Disasm_expert.Basic.Insn.html#VALops", "<div class=\"info\">\n<p><code class=\"code\">ops&nbsp;insn</code> gives an access to <code class=\"code\">insn</code>'s operands.</p>\n\n</div>\n", ["ACCESS", "GIVES", "INSN", "OPERANDS", "OPS"]);
add_ocaml_element("asm", "Std.Disasm_expert.Basic.Insn.asm", "value", "(Std.Disasm_expert.Basic.asm, 'k) Std.Disasm_expert.Basic.Insn.t ->\n  string", "Bap.Std.Disasm_expert.Basic.Insn.html#VALasm", "<div class=\"info\">\n<p><code class=\"code\">asm&nbsp;insn</code> returns assembly representation of the instruction</p>\n\n</div>\n", ["ASM", "ASSEMBLY", "INSN", "INSTRUCTION", "REPRESENTATION", "RETURNS", "THE"]);
add_ocaml_element("is", "Std.Disasm_expert.Basic.Insn.is", "value", "('a, Std.Disasm_expert.Basic.kinds) Std.Disasm_expert.Basic.Insn.t ->\n  Std.Kind.t -> bool", "Bap.Std.Disasm_expert.Basic.Insn.html#VALis", "<div class=\"info\">\n<p><code class=\"code\">is&nbsp;insn&nbsp;kind</code> checks whether instruction <code class=\"code\">insn</code> belongs\n            to the semantic <code class=\"code\">kind</code></p>\n\n</div>\n", ["BELONGS", "CHECKS", "INSN", "INSTRUCTION", "KIND", "SEMANTIC", "THE", "WHETHER"]);
add_ocaml_element("kinds", "Std.Disasm_expert.Basic.Insn.kinds", "value", "('a, Std.Disasm_expert.Basic.kinds) Std.Disasm_expert.Basic.Insn.t ->\n  Std.Kind.t list", "Bap.Std.Disasm_expert.Basic.Insn.html#VALkinds", "<div class=\"info\">\n<p><code class=\"code\">kinds&nbsp;insn</code> returns a high-level semantic information\n            about the instruction.</p>\n\n</div>\n", ["ABOUT", "BAP", "CODES", "DESCRIPTION", "FOR", "HIGH", "INFORMATION", "INSN", "INSTRUCTION", "KIND", "KINDS", "LEVEL", "RETURNS", "SEE", "SEMANTIC", "STD", "THE"]);
add_ocaml_element("name", "Std.Disasm_expert.Basic.Insn.name", "value", "('a, 'k) Std.Disasm_expert.Basic.Insn.t -> string", "Bap.Std.Disasm_expert.Basic.Insn.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;insn</code> returns a textual representation of the\n            instruction name.</p>\n\n</div>\n", ["AND", "BACKEND", "BIJECT", "CODE", "GUARANTEED", "INSN", "INSTRUCTION", "MIGHT", "MNEMONICS", "NAME", "OPCODE", "REPRESENTATION", "RETURNS", "SPECIFIC", "TEXTUAL", "THE", "THUS", "WITH"]);
add_ocaml_element("code", "Std.Disasm_expert.Basic.Insn.code", "value", "('a, 'k) Std.Disasm_expert.Basic.Insn.t -> int", "Bap.Std.Disasm_expert.Basic.Insn.html#VALcode", "<div class=\"info\">\n<p><code class=\"code\">code&nbsp;insn</code> returns an integer code, that is bijective\n            with instruction opcode.</p>\n\n</div>\n", ["ACTUAL", "ALSO", "AND", "BACKEND", "BACKENDS", "BETWEEN", "BIJECTIVE", "CHANGE", "CODE", "DIFFERENT", "INSN", "INSTRUCTION", "INTEGER", "MAY", "MIGHT", "NOT", "OPCODE", "RETURNS", "SAME", "THAT", "THE", "VERSIONS", "WITH"]);
add_ocaml_element("compare", "Std.Disasm_expert.Basic.Insn.compare", "value", "('a, 'k) Std.Disasm_expert.Basic.Insn.t ->\n  ('a, 'k) Std.Disasm_expert.Basic.Insn.t -> int", "Bap.Std.Disasm_expert.Basic.Insn.html#VALcompare", "<div class=\"info\">\n<p><code class=\"code\">compare&nbsp;i1&nbsp;i2</code> compares instruction <code class=\"code\">i1</code> and <code class=\"code\">i2</code></p>\n\n</div>\n", ["AND", "COMPARE", "COMPARES", "INSTRUCTION"]);
add_ocaml_element("sexp_of_t", "Std.Disasm_expert.Basic.Insn.sexp_of_t", "value", "('a, 'k) Std.Disasm_expert.Basic.Insn.t -> Sexp.t", "Bap.Std.Disasm_expert.Basic.Insn.html#VALsexp_of_t", "<div class=\"info\">\n<p><code class=\"code\">sexp_of_t&nbsp;insn</code> returns a sexp representation of <code class=\"code\">insn</code></p>\n\n</div>\n", ["INSN", "REPRESENTATION", "RETURNS", "SEXP", "SEXP_OF_T"]);
add_ocaml_element("available_backends", "Std.Disasm_expert.Basic.available_backends", "value", "unit -> string list", "Bap.Std.Disasm_expert.Basic.html#VALavailable_backends", "<div class=\"info\">\n<p>enumerates names of available disassembler backends.</p>\n\n</div>\n", ["AVAILABLE", "BACKENDS", "DISASSEMBLER", "ENUMERATES", "NAMES"]);
add_ocaml_element("back", "Std.Disasm_expert.Basic.back", "value", "('a, 'b, 's, 'r) Std.Disasm_expert.Basic.state -> 's -> 'r", "Bap.Std.Disasm_expert.Basic.html#VALback", "<div class=\"info\">\n<p>restarts last step.</p>\n\n</div>\n", ["LAST", "RESTARTS", "STEP"]);
add_ocaml_element("jump", "Std.Disasm_expert.Basic.jump", "value", "('a, 'b, 's, 'r) Std.Disasm_expert.Basic.state -> Std.mem -> 's -> 'r", "Bap.Std.Disasm_expert.Basic.html#VALjump", "<div class=\"info\">\n<p>jump to the specified memory and continue disassembly in it.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "AND", "CAN", "CONTINUE", "DATA", "DISASSEMBLY", "EXAMPLE", "FOR", "FROM", "FUN", "JUMP", "MEM", "MEMORY", "MONAD", "OR_ERROR", "SPECIFIED", "STATE", "THE", "THEN", "VIEW", "WANT", "WORKING", "YOU"]);
add_ocaml_element("step", "Std.Disasm_expert.Basic.step", "value", "('a, 'b, 's, 'r) Std.Disasm_expert.Basic.state -> 's -> 'r", "Bap.Std.Disasm_expert.Basic.html#VALstep", "<div class=\"info\">\n<p>continue disassembling from the current point.</p>\n\n</div>\n", ["ADDRESS", "BEFORE", "CAN", "CHANGE", "CONTINUE", "CURRENT", "DIFFERENT", "DISASSEMBLING", "FROM", "JUMP", "NEXT", "POINT", "PREDICATES", "SET", "STEPPING", "THE", "USE", "WANT", "YOU"]);
add_ocaml_element("stop", "Std.Disasm_expert.Basic.stop", "value", "('a, 'b, 's, 'r) Std.Disasm_expert.Basic.state -> 's -> 'r", "Bap.Std.Disasm_expert.Basic.html#VALstop", "<div class=\"info\">\n<p>stop the disassembly and return the provided value.</p>\n\n</div>\n", ["AND", "DISASSEMBLY", "PROVIDED", "RETURN", "STOP", "THE", "VALUE"]);
add_ocaml_element("memory", "Std.Disasm_expert.Basic.memory", "value", "('a, 'b, 'c, 'd) Std.Disasm_expert.Basic.state -> Std.mem", "Bap.Std.Disasm_expert.Basic.html#VALmemory", "<div class=\"info\">\n<p>the memory region we're currently working on</p>\n\n</div>\n", ["CURRENTLY", "MEMORY", "REGION", "THE", "WORKING"]);
add_ocaml_element("last", "Std.Disasm_expert.Basic.last", "value", "('a, 'k, 's, 'r) Std.Disasm_expert.Basic.state ->\n  int -> ('a, 'k) Std.Disasm_expert.Basic.insns", "Bap.Std.Disasm_expert.Basic.html#VALlast", "<div class=\"info\">\n<p><code class=\"code\">last&nbsp;s&nbsp;n</code> returns last <code class=\"code\">n</code> instructions disassembled in this\n          step.</p>\n\n</div>\n", ["ARE", "DISASSEMBLED", "INSTRUCTIONS", "LAST", "LESS", "LIST", "RETURNS", "SMALLER", "STEP", "THEN", "THERE", "THIS"]);
add_ocaml_element("insns", "Std.Disasm_expert.Basic.insns", "value", "('a, 'k, 'b, 'c) Std.Disasm_expert.Basic.state ->\n  ('a, 'k) Std.Disasm_expert.Basic.insns", "Bap.Std.Disasm_expert.Basic.html#VALinsns", "<div class=\"info\">\n<p>a queue of instructions disassembled in this step</p>\n\n</div>\n", ["DISASSEMBLED", "INSTRUCTIONS", "QUEUE", "STEP", "THIS"]);
add_ocaml_element("with_preds", "Std.Disasm_expert.Basic.with_preds", "value", "('a, 'k, 's, 'r) Std.Disasm_expert.Basic.state ->\n  Std.Disasm_expert.Basic.pred list ->\n  ('a, 'k, 's, 'r) Std.Disasm_expert.Basic.state", "Bap.Std.Disasm_expert.Basic.html#VALwith_preds", "<div class=\"info\">\n<p>updates the set of predicates, that rules the stop condition.</p>\n\n</div>\n", ["CONDITION", "PREDICATES", "RULES", "SET", "STOP", "THAT", "THE", "UPDATES"]);
add_ocaml_element("preds", "Std.Disasm_expert.Basic.preds", "value", "('a, 'b, 'c, 'd) Std.Disasm_expert.Basic.state ->\n  Std.Disasm_expert.Basic.pred list", "Bap.Std.Disasm_expert.Basic.html#VALpreds", "<div class=\"info\">\n<p>current set of predicates</p>\n\n</div>\n", ["CURRENT", "PREDICATES", "SET"]);
add_ocaml_element("addr", "Std.Disasm_expert.Basic.addr", "value", "('a, 'b, 'c, 'd) Std.Disasm_expert.Basic.state -> Std.addr", "Bap.Std.Disasm_expert.Basic.html#VALaddr", "<div class=\"info\">\n<p>current position of the disassembler</p>\n\n</div>\n", ["CURRENT", "DISASSEMBLER", "POSITION", "THE"]);
add_ocaml_element("insn_of_mem", "Std.Disasm_expert.Basic.insn_of_mem", "value", "('a, 'b) Std.Disasm_expert.Basic.t ->\n  Std.mem ->\n  (Std.mem *\n   (Std.Disasm_expert.Basic.asm, Std.Disasm_expert.Basic.kinds)\n   Std.Disasm_expert.Basic.insn option *\n   [ `finished | `left of Std.mem ])\n  Or_error.t", "Bap.Std.Disasm_expert.Basic.html#VALinsn_of_mem", "<div class=\"info\">\n<p><code class=\"code\">insn_of_mem&nbsp;dis&nbsp;mem</code> performes a disassembly of one instruction\n          from the a given memory region <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["AND", "CAN", "COMPLEMENTS", "CONSUMED", "DIS", "DISASSEMBLY", "FOR", "FROM", "GIVEN", "IMEM", "INS", "INSN", "INSN_OF_MEM", "INSTRUCTION", "LEFT", "MEM", "MEMORY", "NONE", "ONE", "ORIGINAL", "OTHERWISE", "OVER", "PERFORMES", "PIECE", "PROCESS", "REGION", "RETURNS", "SOME", "STANDS", "SUCCESSFUL", "THE", "TUPLE", "WAS", "WHERE"]);
add_ocaml_element("run", "Std.Disasm_expert.Basic.run", "value", "?backlog:int ->\n  ?stop_on:Std.Disasm_expert.Basic.pred list ->\n  ?invalid:(('a, 'k, 's, 'r) Std.Disasm_expert.Basic.state ->\n            Std.mem -> 's -> 'r) ->\n  ?stopped:(('a, 'k, 's, 'r) Std.Disasm_expert.Basic.state -> 's -> 'r) ->\n  ?hit:(('a, 'k, 's, 'r) Std.Disasm_expert.Basic.state ->\n        Std.mem ->\n        (Std.Disasm_expert.Basic.asm, Std.Disasm_expert.Basic.kinds)\n        Std.Disasm_expert.Basic.insn -> 's -> 'r) ->\n  ('a, 'k) Std.Disasm_expert.Basic.t ->\n  return:('s -> 'r) -> init:'s -> Std.mem -> 'r", "Bap.Std.Disasm_expert.Basic.html#VALrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;?stop_on&nbsp;?invalid&nbsp;?stopped&nbsp;dis&nbsp;mem&nbsp;~init&nbsp;~return&nbsp;~hit</code>\n          performs the recursive disassembly of the specified chunk of\n          memory <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["AND", "BACK", "CAN", "CHUNK", "DESCRIBED", "DIS", "DISASSEMBLY", "DRIVEN", "FUNCTIONS", "HIT", "INIT", "INVALID", "JUMP", "LATER", "MEM", "MEMORY", "PERFORMS", "PROCESS", "RECURSIVE", "RETURN", "RUN", "SPECIFIED", "STEP", "STOP", "STOPPED", "STOP_ON", "THE", "USING"]);
add_ocaml_element("store_kinds", "Std.Disasm_expert.Basic.store_kinds", "value", "('a, 'b) Std.Disasm_expert.Basic.t ->\n  ('a, Std.Disasm_expert.Basic.kinds) Std.Disasm_expert.Basic.t", "Bap.Std.Disasm_expert.Basic.html#VALstore_kinds", "<div class=\"info\">\n<p>enables storing instruction kinds information</p>\n\n</div>\n", ["ENABLES", "INFORMATION", "INSTRUCTION", "KINDS", "STORING"]);
add_ocaml_element("store_asm", "Std.Disasm_expert.Basic.store_asm", "value", "('a, 'k) Std.Disasm_expert.Basic.t ->\n  (Std.Disasm_expert.Basic.asm, 'k) Std.Disasm_expert.Basic.t", "Bap.Std.Disasm_expert.Basic.html#VALstore_asm", "<div class=\"info\">\n<p>enables storing assembler information</p>\n\n</div>\n", ["ASSEMBLER", "ENABLES", "INFORMATION", "STORING"]);
add_ocaml_element("close", "Std.Disasm_expert.Basic.close", "value", "('a, 'b) Std.Disasm_expert.Basic.t -> unit", "Bap.Std.Disasm_expert.Basic.html#VALclose", "<div class=\"info\">\n<p><code class=\"code\">close&nbsp;d</code> closes a disassembler <code class=\"code\">d</code>.</p>\n\n</div>\n", ["CLOSE", "CLOSES", "DISASSEMBLER"]);
add_ocaml_element("create", "Std.Disasm_expert.Basic.create", "value", "?debug_level:int ->\n  ?cpu:string ->\n  backend:string ->\n  string ->\n  (Std.Disasm_expert.Basic.empty, Std.Disasm_expert.Basic.empty)\n  Std.Disasm_expert.Basic.t Or_error.t", "Bap.Std.Disasm_expert.Basic.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?debug_level&nbsp;?cpu&nbsp;~backend&nbsp;target</code> creates a\n          disassembler for the specified <code class=\"code\">target</code>.</p>\n\n</div>\n", ["ALL", "ARE", "BACKEND", "CONCRETE", "CONSULT", "CPU", "CREATE", "CREATES", "DEBUG", "DEBUG_LEVEL", "DEFAULT", "DISASSEMBLER", "EXAMPLE", "FOR", "GENERAL", "GREATER", "INFORMATION", "LLVM", "MORE", "OUTPUTED", "PARAMETERS", "PROCESS", "SET", "SILENT", "SPECIFIC", "SPECIFIED", "TARGET", "THE", "THIS", "VALUE", "WILL", "X86_64"]);
add_ocaml_element("with_disasm", "Std.Disasm_expert.Basic.with_disasm", "value", "?debug_level:int ->\n  ?cpu:string ->\n  backend:string ->\n  string ->\n  f:((Std.Disasm_expert.Basic.empty, Std.Disasm_expert.Basic.empty)\n     Std.Disasm_expert.Basic.t -> 'a Or_error.t) ->\n  'a Or_error.t", "Bap.Std.Disasm_expert.Basic.html#VALwith_disasm", "<div class=\"info\">\n<p><code class=\"code\">with_disasm&nbsp;?debug_level&nbsp;?cpu&nbsp;~backend&nbsp;~f&nbsp;target</code> creates a\n          disassembler passing all options to <code class=\"code\">create</code> function and\n          applies function <code class=\"code\">f</code> to it.</p>\n\n</div>\n", ["ALL", "AND", "APPLIES", "BACKEND", "CLOSE", "CLOSED", "CPU", "CREATE", "CREATES", "DEBUG_LEVEL", "DISASSEMBLER", "EVALUATED", "FUNCTION", "ONCE", "OPTIONS", "PASSING", "TARGET", "THE", "WITH", "WITH_DISASM"]);
add_ocaml_element("compare_ops", "Std.Op.Normalized.compare_ops", "value", "Std.Op.t array -> Std.Op.t array -> int", "Bap.Std.Op.Normalized.html#VALcompare_ops", "", []);
add_ocaml_element("hash", "Std.Op.Normalized.hash", "value", "Std.Op.t -> int", "Bap.Std.Op.Normalized.html#VALhash", "", []);
add_ocaml_element("compare", "Std.Op.Normalized.compare", "value", "Std.Op.t -> Std.Op.t -> int", "Bap.Std.Op.Normalized.html#VALcompare", "", []);
add_ocaml_element("pp_adt", "Std.Op.pp_adt", "value", "Stdlib.Format.formatter -> Std.Op.t -> unit", "Bap.Std.Op.html#VALpp_adt", "", []);
add_ocaml_element("to_float", "Std.Fmm.to_float", "value", "Std.Fmm.t -> float", "Bap.Std.Fmm.html#VALto_float", "<div class=\"info\">\n<p><code class=\"code\">to_float&nbsp;x</code> maps floating point operans to the OCaml <code class=\"code\">float</code> type</p>\n\n</div>\n", ["FLOAT", "FLOATING", "MAPS", "OCAML", "OPERANS", "POINT", "THE", "TO_FLOAT", "TYPE"]);
add_ocaml_element("to_int", "Std.Imm.to_int", "value", "Std.Imm.t -> int option", "Bap.Std.Imm.html#VALto_int", "<div class=\"info\">\n<p><code class=\"code\">to_int&nbsp;x</code> projects immediates to the OCaml <code class=\"code\">int</code> type.</p>\n\n</div>\n", ["DOESN", "FIT", "IMMEDIATES", "INT", "NONE", "OCAML", "PROJECTS", "RETURNS", "THE", "TO_INT", "TYPE"]);
add_ocaml_element("to_int64", "Std.Imm.to_int64", "value", "Std.Imm.t -> int64", "Bap.Std.Imm.html#VALto_int64", "<div class=\"info\">\n<p><code class=\"code\">to_int64&nbsp;x</code> maps immediates to the OCaml <code class=\"code\">int64</code> type</p>\n\n</div>\n", ["IMMEDIATES", "INT64", "MAPS", "OCAML", "THE", "TO_INT64", "TYPE"]);
add_ocaml_element("to_word", "Std.Imm.to_word", "value", "Std.Imm.t -> width:int -> Std.word option", "Bap.Std.Imm.html#VALto_word", "<div class=\"info\">\n<p><code class=\"code\">to_word&nbsp;~width&nbsp;x</code> projects <code class=\"code\">x</code> to a word.</p>\n\n</div>\n", ["NON", "NONE", "ONLY", "POSITIVE", "PROJECTS", "RETURNS", "TO_WORD", "WIDTH", "WORD"]);
add_ocaml_element("name", "Std.Reg.name", "value", "Std.Reg.t -> string", "Bap.Std.Reg.html#VALname", "<div class=\"info\">\n<p>name of a register</p>\n\n</div>\n", ["NAME", "REGISTER"]);
add_ocaml_element("code", "Std.Reg.code", "value", "Std.Reg.t -> int", "Bap.Std.Reg.html#VALcode", "<div class=\"info\">\n<p>unique number representing a register</p>\n\n</div>\n", ["NUMBER", "REGISTER", "REPRESENTING", "UNIQUE"]);
add_ocaml_element("pp", "Std.Memmap.pp", "value", "'a Std.printer -> 'a Std.Memmap.t Std.printer", "Bap.Std.Memmap.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elem</code> constracts a printer for a memmap to the given element.</p>\n\n</div>\n", ["CONSTRACTS", "ELEMENT", "FOR", "GIVEN", "MEMMAP", "PP_ELEM", "PRINTER", "THE"]);
add_ocaml_element("to_sequence", "Std.Memmap.to_sequence", "value", "'a Std.Memmap.t -> (Std.mem * 'a) Std.seq", "Bap.Std.Memmap.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;map</code> converts the memmap <code class=\"code\"><span class=\"keywordsign\">'</span>a&nbsp;t</code> to a sequence of\n        key-value pairs</p>\n\n</div>\n", ["CONVERTS", "KEY", "MAP", "MEMMAP", "PAIRS", "SEQUENCE", "THE", "TO_SEQUENCE", "VALUE"]);
add_ocaml_element("remove_dominators", "Std.Memmap.remove_dominators", "value", "'a Std.Memmap.t -> Std.mem -> 'a Std.Memmap.t", "Bap.Std.Memmap.html#VALremove_dominators", "<div class=\"info\">\n<p><code class=\"code\">remove_dominators&nbsp;map&nbsp;mem</code> removes all bindings that are\n        dominators to <code class=\"code\">mem</code></p>\n\n</div>\n", ["ALL", "ARE", "BINDINGS", "DOMINATORS", "MAP", "MEM", "REMOVES", "REMOVE_DOMINATORS", "THAT"]);
add_ocaml_element("remove_intersections", "Std.Memmap.remove_intersections", "value", "'a Std.Memmap.t -> Std.mem -> 'a Std.Memmap.t", "Bap.Std.Memmap.html#VALremove_intersections", "<div class=\"info\">\n<p><code class=\"code\">remove_intersections&nbsp;map&nbsp;mem</code> removes all bindings that\n        that intersects with <code class=\"code\">mem</code></p>\n\n</div>\n", ["ALL", "BINDINGS", "INTERSECTS", "MAP", "MEM", "REMOVES", "REMOVE_INTERSECTIONS", "THAT", "WITH"]);
add_ocaml_element("remove", "Std.Memmap.remove", "value", "'a Std.Memmap.t -> Std.mem -> 'a Std.Memmap.t", "Bap.Std.Memmap.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;map&nbsp;mem</code> removes all bindings to <code class=\"code\">mem</code></p>\n\n</div>\n", ["ALL", "BINDINGS", "MAP", "MEM", "REMOVE", "REMOVES"]);
add_ocaml_element("filter_mapi", "Std.Memmap.filter_mapi", "value", "'a Std.Memmap.t ->\n  f:(Std.mem -> 'a -> 'b option) -> 'b Std.Memmap.t", "Bap.Std.Memmap.html#VALfilter_mapi", "<div class=\"info\">\n<p><code class=\"code\">filter_mapi</code> is like <code class=\"code\">filter_map</code> but use function also accepts\n        would assosiated memory region</p>\n\n</div>\n", ["ACCEPTS", "ALSO", "ASSOSIATED", "BUT", "FILTER_MAP", "FILTER_MAPI", "FUNCTION", "LIKE", "MEMORY", "REGION", "USE", "WOULD"]);
add_ocaml_element("filter_map", "Std.Memmap.filter_map", "value", "'a Std.Memmap.t -> f:('a -> 'b option) -> 'b Std.Memmap.t", "Bap.Std.Memmap.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;m&nbsp;f</code> creates a new map by applying a function <code class=\"code\">f</code> to\n        each tag.</p>\n\n</div>\n", ["APPLYING", "CREATES", "DROPPED", "EACH", "FILTER_MAP", "FUNCTION", "MAP", "MAPPED", "NEW", "OTHERWISE", "REGION", "RETURNS", "SOME", "TAG", "THEN", "THIS", "WILL"]);
add_ocaml_element("filter", "Std.Memmap.filter", "value", "'a Std.Memmap.t -> f:('a -> bool) -> 'a Std.Memmap.t", "Bap.Std.Memmap.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;map&nbsp;f</code> returns a map that contains only those elements\n        for which <code class=\"code\">f</code> evaluated to <code class=\"code\"><span class=\"keyword\">true</span></code></p>\n\n</div>\n", ["CONTAINS", "ELEMENTS", "EVALUATED", "FILTER", "FOR", "MAP", "ONLY", "RETURNS", "THAT", "THOSE", "TRUE", "WHICH"]);
add_ocaml_element("mapi", "Std.Memmap.mapi", "value", "'a Std.Memmap.t -> f:(Std.mem -> 'a -> 'b) -> 'b Std.Memmap.t", "Bap.Std.Memmap.html#VALmapi", "<div class=\"info\">\n<p><code class=\"code\">mapi&nbsp;m&nbsp;f</code> the same as <code class=\"code\">map</code>, but <code class=\"code\">f</code> is called with two\n        arguments: <code class=\"code\">mem</code> and <code class=\"code\">tag</code>, where <code class=\"code\">mem</code> is a memory region,\n        and <code class=\"code\">tag</code> is a <code class=\"code\">tag</code> assosiated with that region.</p>\n\n</div>\n", ["AND", "ARGUMENTS", "ASSOSIATED", "BUT", "CALLED", "MAP", "MAPI", "MEM", "MEMORY", "REGION", "SAME", "TAG", "THAT", "THE", "TWO", "WHERE", "WITH"]);
add_ocaml_element("map", "Std.Memmap.map", "value", "'a Std.Memmap.t -> f:('a -> 'b) -> 'b Std.Memmap.t", "Bap.Std.Memmap.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;m&nbsp;f</code> returns a new map with each tag mapped\n        with function <code class=\"code\">f</code></p>\n\n</div>\n", ["EACH", "FUNCTION", "MAP", "MAPPED", "NEW", "RETURNS", "TAG", "WITH"]);
add_ocaml_element("lookup", "Std.Memmap.lookup", "value", "'a Std.Memmap.t -> Std.addr -> (Std.mem * 'a) Std.seq", "Bap.Std.Memmap.html#VALlookup", "<div class=\"info\">\n<p><code class=\"code\">lookup&nbsp;map&nbsp;addr</code> returns an ordered sequence of all memory\n        containing the <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "ALL", "CONTAINING", "LOOKUP", "MAP", "MEMORY", "ORDERED", "RETURNS", "SEQUENCE", "THE"]);
add_ocaml_element("contains", "Std.Memmap.contains", "value", "'a Std.Memmap.t -> Std.addr -> bool", "Bap.Std.Memmap.html#VALcontains", "<div class=\"info\">\n<p><code class=\"code\">contains&nbsp;map&nbsp;addr</code> true if there exists such memory region <code class=\"code\">mem</code>,\n        that <code class=\"code\"><span class=\"constructor\">Memory</span>.contains&nbsp;mem&nbsp;addr</code></p>\n\n</div>\n", ["ADDR", "CONTAINS", "EXISTS", "MAP", "MEM", "MEMORY", "REGION", "SUCH", "THAT", "THERE", "TRUE"]);
add_ocaml_element("dominates", "Std.Memmap.dominates", "value", "'a Std.Memmap.t -> Std.mem -> bool", "Bap.Std.Memmap.html#VALdominates", "<div class=\"info\">\n<p><code class=\"code\">dominates&nbsp;map&nbsp;mem</code> if there is a non empty set of dominators</p>\n\n</div>\n", ["DOMINATES", "DOMINATORS", "EMPTY", "MAP", "MEM", "NON", "SET", "THERE"]);
add_ocaml_element("intersects", "Std.Memmap.intersects", "value", "'a Std.Memmap.t -> Std.mem -> bool", "Bap.Std.Memmap.html#VALintersects", "<div class=\"info\">\n<p><code class=\"code\">intersects&nbsp;map&nbsp;mem</code> is true if <code class=\"code\">intersections&nbsp;map&nbsp;mem</code> is not empty</p>\n\n</div>\n", ["EMPTY", "INTERSECTIONS", "INTERSECTS", "MAP", "MEM", "NOT", "TRUE"]);
add_ocaml_element("intersections", "Std.Memmap.intersections", "value", "'a Std.Memmap.t -> Std.mem -> (Std.mem * 'a) Std.seq", "Bap.Std.Memmap.html#VALintersections", "<div class=\"info\">\n<p><code class=\"code\">intersections&nbsp;map&nbsp;mem</code> an ordered sequence of all memory regions,\n        that intersects with <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["ALL", "BELONGS", "BOTH", "BYTE", "EXISTS", "IFF", "INTERSECTIONS", "INTERSECTS", "MAP", "MEM", "MEMORY", "ORDERED", "OTHER", "REGION", "REGIONS", "SEQUENCE", "SUCH", "THAT", "THERE", "WITH", "WORDS"]);
add_ocaml_element("dominators", "Std.Memmap.dominators", "value", "'a Std.Memmap.t -> Std.mem -> (Std.mem * 'a) Std.seq", "Bap.Std.Memmap.html#VALdominators", "<div class=\"info\">\n<p><code class=\"code\">dominators&nbsp;map&nbsp;mem</code> an ordered sequence of all memory regions,\n        containing <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["ALL", "ARE", "CLOSED", "CONTAINING", "CONTAINS", "DEPICTED", "DOMINATORS", "IFF", "INTERVALS", "MAP", "MEM", "MEMORY", "ORDERED", "REGION", "REGIONS", "SEQUENCE", "USING", "WHERE"]);
add_ocaml_element("add", "Std.Memmap.add", "value", "'a Std.Memmap.t -> Std.mem -> 'a -> 'a Std.Memmap.t", "Bap.Std.Memmap.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;map&nbsp;mem&nbsp;tag</code> adds a new memory region <code class=\"code\">mem</code> tagged with\n        <code class=\"code\">tag</code>.</p>\n\n</div>\n", ["ADD", "ADDS", "AGAIN", "ALREADY", "EVEN", "HAD", "HAS", "MAP", "MEM", "MEMORY", "NEW", "REGION", "SAME", "TAG", "TAGGED", "THE", "WAS", "WILL", "WITH"]);
add_ocaml_element("max_binding", "Std.Memmap.max_binding", "value", "'a Std.Memmap.t -> (Std.mem * 'a) option", "Bap.Std.Memmap.html#VALmax_binding", "<div class=\"info\">\n<p><code class=\"code\">max_binding&nbsp;map</code> is a maximum binding mapped in <code class=\"code\">map</code></p>\n\n</div>\n", ["BINDING", "MAP", "MAPPED", "MAXIMUM", "MAX_BINDING"]);
add_ocaml_element("min_binding", "Std.Memmap.min_binding", "value", "'a Std.Memmap.t -> (Std.mem * 'a) option", "Bap.Std.Memmap.html#VALmin_binding", "<div class=\"info\">\n<p><code class=\"code\">min_binding&nbsp;map</code> is a minimum binding mapped in <code class=\"code\">map</code></p>\n\n</div>\n", ["BINDING", "MAP", "MAPPED", "MINIMUM", "MIN_BINDING"]);
add_ocaml_element("max_addr", "Std.Memmap.max_addr", "value", "'a Std.Memmap.t -> Std.addr option", "Bap.Std.Memmap.html#VALmax_addr", "<div class=\"info\">\n<p><code class=\"code\">max_addr&nbsp;map</code> is a maximum addr mapped in <code class=\"code\">map</code></p>\n\n</div>\n", ["ADDR", "MAP", "MAPPED", "MAXIMUM", "MAX_ADDR"]);
add_ocaml_element("min_addr", "Std.Memmap.min_addr", "value", "'a Std.Memmap.t -> Std.addr option", "Bap.Std.Memmap.html#VALmin_addr", "<div class=\"info\">\n<p><code class=\"code\">min_addr&nbsp;map</code> is a minimum addr mapped in <code class=\"code\">map</code></p>\n\n</div>\n", ["ADDR", "MAP", "MAPPED", "MINIMUM", "MIN_ADDR"]);
add_ocaml_element("singleton", "Std.Memmap.singleton", "value", "Std.mem -> 'a -> 'a Std.Memmap.t", "Bap.Std.Memmap.html#VALsingleton", "<div class=\"info\">\n<p><code class=\"code\">singleton</code> a memory map containing only one memory region</p>\n\n</div>\n", ["CONTAINING", "MAP", "MEMORY", "ONE", "ONLY", "REGION", "SINGLETON"]);
add_ocaml_element("empty", "Std.Memmap.empty", "value", "'a Std.Memmap.t", "Bap.Std.Memmap.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty</code> map</p>\n\n</div>\n", ["EMPTY", "MAP"]);
add_ocaml_element("from_data", "Std.Image.Loader.from_data", "value", "Bigstring.t -> Ogre.doc option Or_error.t", "Bap.Std.Image.Loader.html#VALfrom_data", "<div class=\"info\">\n<p><code class=\"code\">from_data&nbsp;data</code> loads image from the specified array of bytes.</p>\n\n</div>\n", ["ARRAY", "BYTES", "DATA", "FROM", "FROM_DATA", "IMAGE", "LOADS", "SPECIFIED", "THE"]);
add_ocaml_element("from_file", "Std.Image.Loader.from_file", "value", "string -> Ogre.doc option Or_error.t", "Bap.Std.Image.Loader.html#VALfrom_file", "<div class=\"info\">\n<p><code class=\"code\">from_file&nbsp;name</code> loads a file with the given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["FILE", "FROM_FILE", "GIVEN", "LOADS", "NAME", "THE", "WITH"]);
add_ocaml_element("base_address", "Std.Image.Scheme.base_address", "value", "(Std.Image.Scheme.addr, (Std.Image.Scheme.addr -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALbase_address", "<div class=\"info\">\n<p><code class=\"code\">base_address&nbsp;addr</code> this is the base address of an image,\n          i.e., an address of a first byte of the image.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "BASE", "BASE_ADDRESS", "BYTE", "FIRST", "IMAGE", "THE", "THIS"]);
add_ocaml_element("external_reference", "Std.Image.Scheme.external_reference", "value", "(Std.Image.Scheme.addr * string,\n   (Std.Image.Scheme.addr -> string -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALexternal_reference", "<div class=\"info\">\n<p><code class=\"code\">extrenal_reference&nbsp;addr&nbsp;name</code> a piece of code at the\n          specified address <code class=\"code\">addr</code> references an external symbol with\n          the given <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "CODE", "EXTERNAL", "EXTRENAL_REFERENCE", "GIVEN", "NAME", "PIECE", "REFERENCES", "SPECIFIED", "SYMBOL", "THE", "WITH"]);
add_ocaml_element("relocation", "Std.Image.Scheme.relocation", "value", "(int64 * Std.Image.Scheme.addr,\n   (Std.Image.Scheme.addr -> Std.Image.Scheme.addr -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALrelocation", "<div class=\"info\">\n<p><code class=\"code\">relocation&nbsp;fixup&nbsp;addr</code> a value referenced at the code that\n          has the <code class=\"code\">fixup</code> address is relocated to the specified address\n          <code class=\"code\">addr</code>.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "CODE", "FIXUP", "HAS", "REFERENCED", "RELOCATED", "RELOCATION", "SPECIFIED", "THAT", "THE", "VALUE"]);
add_ocaml_element("mapped", "Std.Image.Scheme.mapped", "value", "(Std.Image.Scheme.off Std.Image.Scheme.region,\n   (Std.Image.Scheme.addr ->\n    Std.Image.Scheme.size -> Std.Image.Scheme.off -> 'a) ->\n   'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALmapped", "<div class=\"info\">\n<p><code class=\"code\">mapped&nbsp;addr&nbsp;size&nbsp;off</code> sequence of bytes in a file starting at\n          offset <code class=\"code\">off</code> and has the given <code class=\"code\">size</code> is mapped into memory at the\n          given address <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "ADDRESS", "AND", "BYTES", "FILE", "GIVEN", "HAS", "INTO", "MAPPED", "MEMORY", "OFF", "OFFSET", "SEQUENCE", "SIZE", "STARTING", "THE"]);
add_ocaml_element("named_symbol", "Std.Image.Scheme.named_symbol", "value", "(Std.Image.Scheme.addr * string,\n   (Std.Image.Scheme.addr -> string -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALnamed_symbol", "<div class=\"info\">\n<p><code class=\"code\">named_symbol&nbsp;addr&nbsp;name</code> a symbol that starts at this <code class=\"code\">addr</code>\n          has this <code class=\"code\">name</code>.</p>\n\n</div>\n", ["ADDR", "HAS", "NAME", "NAMED_SYMBOL", "STARTS", "SYMBOL", "THAT", "THIS"]);
add_ocaml_element("named_region", "Std.Image.Scheme.named_region", "value", "(string Std.Image.Scheme.region,\n   (Std.Image.Scheme.addr -> Std.Image.Scheme.size -> string -> 'a) ->\n   'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALnamed_region", "<div class=\"info\">\n<p><code class=\"code\">named_region&nbsp;addr&nbsp;size&nbsp;name</code> a region of memory has a <code class=\"code\">name</code></p>\n\n</div>\n", ["ADDR", "HAS", "MEMORY", "NAME", "NAMED_REGION", "REGION", "SIZE"]);
add_ocaml_element("symbol_chunk", "Std.Image.Scheme.symbol_chunk", "value", "(Std.Image.Scheme.addr Std.Image.Scheme.region,\n   (Std.Image.Scheme.addr ->\n    Std.Image.Scheme.size -> Std.Image.Scheme.addr -> 'a) ->\n   'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALsymbol_chunk", "<div class=\"info\">\n<p><code class=\"code\">symbol_chunk&nbsp;addr&nbsp;size&nbsp;root</code> a contiguous piece of a program\n          symbol, that can be a function or some data.</p>\n\n</div>\n", ["ADDR", "CAN", "CONTIGUOUS", "DATA", "FUNCTION", "PIECE", "PROGRAM", "ROOT", "SIZE", "SOME", "SYMBOL", "SYMBOL_CHUNK", "THAT"]);
add_ocaml_element("entry_point", "Std.Image.Scheme.entry_point", "value", "(Std.Image.Scheme.addr, (Std.Image.Scheme.addr -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALentry_point", "<div class=\"info\">\n<p><code class=\"code\">entry_point&nbsp;addr</code> an address is a program entry point</p>\n\n</div>\n", ["ADDR", "ADDRESS", "ENTRY", "ENTRY_POINT", "POINT", "PROGRAM"]);
add_ocaml_element("code_start", "Std.Image.Scheme.code_start", "value", "(Std.Image.Scheme.addr, (Std.Image.Scheme.addr -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALcode_start", "<div class=\"info\">\n<p><code class=\"code\">code_start&nbsp;addr</code> an address starts a code sequence</p>\n\n</div>\n", ["ADDR", "ADDRESS", "CODE", "CODE_START", "SEQUENCE", "STARTS"]);
add_ocaml_element("section", "Std.Image.Scheme.section", "value", "(unit Std.Image.Scheme.region,\n   (Std.Image.Scheme.addr -> Std.Image.Scheme.size -> 'a) -> 'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALsection", "<div class=\"info\">\n<p><code class=\"code\">section&nbsp;addr&nbsp;size</code> a memory region is a section</p>\n\n</div>\n", ["ADDR", "MEMORY", "REGION", "SECTION", "SIZE"]);
add_ocaml_element("segment", "Std.Image.Scheme.segment", "value", "((bool * bool * bool) Std.Image.Scheme.region,\n   (Std.Image.Scheme.addr ->\n    Std.Image.Scheme.size -> bool -> bool -> bool -> 'a) ->\n   'a)\n  Ogre.attribute", "Bap.Std.Image.Scheme.html#VALsegment", "<div class=\"info\">\n<p><code class=\"code\">segment&nbsp;addr&nbsp;size&nbsp;readable&nbsp;writable&nbsp;executable</code> a memory\n          region (addr,size) has the specified permissions.</p>\n\n</div>\n", ["ADDR", "EXECUTABLE", "HAS", "MEMORY", "PERMISSIONS", "READABLE", "REGION", "SEGMENT", "SIZE", "SPECIFIED", "THE", "WRITABLE"]);
add_ocaml_element("arch", "Std.Image.Scheme.arch", "value", "(string, (string -> 'a) -> 'a) Ogre.attribute", "Bap.Std.Image.Scheme.html#VALarch", "<div class=\"info\">\n<p><code class=\"code\">arch&nbsp;name</code> a file contains code for the <code class=\"code\">name</code> architecture.</p>\n\n</div>\n", ["ARCH", "ARCHITECTURE", "CODE", "CONTAINS", "FILE", "FOR", "NAME", "THE"]);
add_ocaml_element("fixup", "Std.Image.Scheme.fixup", "value", "Std.Image.Scheme.addr Ogre.field", "Bap.Std.Image.Scheme.html#VALfixup", "<div class=\"info\">\n<p>an address of a fixup</p>\n\n</div>\n", ["ADDRESS", "FIXUP"]);
add_ocaml_element("executable", "Std.Image.Scheme.executable", "value", "bool Ogre.field", "Bap.Std.Image.Scheme.html#VALexecutable", "<div class=\"info\">\n<p>is_executable</p>\n\n</div>\n", ["IS_EXECUTABLE"]);
add_ocaml_element("writable", "Std.Image.Scheme.writable", "value", "bool Ogre.field", "Bap.Std.Image.Scheme.html#VALwritable", "<div class=\"info\">\n<p>is_writable</p>\n\n</div>\n", ["IS_WRITABLE"]);
add_ocaml_element("readable", "Std.Image.Scheme.readable", "value", "bool Ogre.field", "Bap.Std.Image.Scheme.html#VALreadable", "<div class=\"info\">\n<p>is readable</p>\n\n</div>\n", ["READABLE"]);
add_ocaml_element("root", "Std.Image.Scheme.root", "value", "Std.Image.Scheme.addr Ogre.field", "Bap.Std.Image.Scheme.html#VALroot", "<div class=\"info\">\n<p>code root</p>\n\n</div>\n", ["CODE", "ROOT"]);
add_ocaml_element("name", "Std.Image.Scheme.name", "value", "string Ogre.field", "Bap.Std.Image.Scheme.html#VALname", "<div class=\"info\">\n<p>name</p>\n\n</div>\n", ["NAME"]);
add_ocaml_element("addr", "Std.Image.Scheme.addr", "value", "Std.Image.Scheme.addr Ogre.field", "Bap.Std.Image.Scheme.html#VALaddr", "<div class=\"info\">\n<p>address</p>\n\n</div>\n", ["ADDRESS"]);
add_ocaml_element("size", "Std.Image.Scheme.size", "value", "Std.Image.Scheme.size Ogre.field", "Bap.Std.Image.Scheme.html#VALsize", "<div class=\"info\">\n<p>size</p>\n\n</div>\n", ["SIZE"]);
add_ocaml_element("off", "Std.Image.Scheme.off", "value", "Std.Image.Scheme.off Ogre.field", "Bap.Std.Image.Scheme.html#VALoff", "<div class=\"info\">\n<p>offset</p>\n\n</div>\n", ["OFFSET"]);
add_ocaml_element("is_debug", "Std.Image.Symbol.is_debug", "value", "Std.Image.Symbol.t -> bool", "Bap.Std.Image.Symbol.html#VALis_debug", "<div class=\"info\">\n<p><code class=\"code\">is_debug&nbsp;sym</code> is true if <code class=\"code\">sym</code> is a debug symbol.</p>\n\n</div>\n", ["DEBUG", "IS_DEBUG", "SYM", "SYMBOL", "TRUE"]);
add_ocaml_element("is_function", "Std.Image.Symbol.is_function", "value", "Std.Image.Symbol.t -> bool", "Bap.Std.Image.Symbol.html#VALis_function", "<div class=\"info\">\n<p><code class=\"code\">is_function&nbsp;sym</code> is true if <code class=\"code\">sym</code> is a function.</p>\n\n</div>\n", ["FUNCTION", "IS_FUNCTION", "SYM", "TRUE"]);
add_ocaml_element("name", "Std.Image.Symbol.name", "value", "Std.Image.Symbol.t -> string", "Bap.Std.Image.Symbol.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;sym</code> symbol's name</p>\n\n</div>\n", ["NAME", "SYM", "SYMBOL"]);
add_ocaml_element("is_executable", "Std.Image.Segment.is_executable", "value", "Std.Image.Segment.t -> bool", "Bap.Std.Image.Segment.html#VALis_executable", "<div class=\"info\">\n<p><code class=\"code\">is_executable&nbsp;segment</code></p>\n\n</div>\n", ["IS_EXECUTABLE", "SEGMENT"]);
add_ocaml_element("is_readable", "Std.Image.Segment.is_readable", "value", "Std.Image.Segment.t -> bool", "Bap.Std.Image.Segment.html#VALis_readable", "<div class=\"info\">\n<p><code class=\"code\">is_readable&nbsp;segment</code></p>\n\n</div>\n", ["IS_READABLE", "SEGMENT"]);
add_ocaml_element("is_writable", "Std.Image.Segment.is_writable", "value", "Std.Image.Segment.t -> bool", "Bap.Std.Image.Segment.html#VALis_writable", "<div class=\"info\">\n<p><code class=\"code\">is_writable&nbsp;segment</code></p>\n\n</div>\n", ["IS_WRITABLE", "SEGMENT"]);
add_ocaml_element("name", "Std.Image.Segment.name", "value", "Std.Image.Segment.t -> string", "Bap.Std.Image.Segment.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;segment</code> a name associated with the segment (usually\n          meaningless).</p>\n\n</div>\n", ["ACROSS", "ASSOCIATED", "GUARANTEED", "IMAGE", "MEANINGLESS", "NAME", "OTHER", "SAME", "SEGMENT", "SEGMENTS", "THE", "UNIQUE", "USUALLY", "WITH"]);
add_ocaml_element("spec", "Std.Image.spec", "value", "Std.Image.t -> Ogre.doc", "Bap.Std.Image.html#VALspec", "<div class=\"info\">\n<p><code class=\"code\">spec&nbsp;image</code> returns the image specification.</p>\n\n</div>\n", ["IMAGE", "RETURNS", "SINCE", "SPEC", "SPECIFICATION", "THE"]);
add_ocaml_element("data", "Std.Image.data", "value", "Std.Image.t -> Bigstring.t", "Bap.Std.Image.html#VALdata", "<div class=\"info\">\n<p><code class=\"code\">data&nbsp;image</code> returns image data.</p>\n\n</div>\n", ["BIG", "DATA", "FILE", "IMAGE", "INPUT", "MAPPED", "MEMORY", "OF_", "PASSED", "RETURNS", "STRING", "USUALLY", "WAS", "WHATEVER"]);
add_ocaml_element("register_backend", "Std.Image.register_backend", "value", "name:string -> Std.Backend.t -> [ `Duplicate | `Ok ]", "Bap.Std.Image.html#VALregister_backend", "<div class=\"info\">\n<span class=\"deprecated\"><p><code class=\"code\">register_backend&nbsp;~name&nbsp;backend</code> tries to register <code class=\"code\">backend</code> under\n        the specified <code class=\"code\">name</code>.</p>\n\n</span></div>\n", ["BACKEND", "DEPRECATED", "INSTEAD", "NAME", "REGISTER", "REGISTER_BACKEND", "REGISTER_LOADER", "SPECIFIED", "THE", "TRIES", "UNDER", "USE"]);
add_ocaml_element("available_backends", "Std.Image.available_backends", "value", "unit -> string list", "Bap.Std.Image.html#VALavailable_backends", "<div class=\"info\">\n<p>lists all registered backends</p>\n\n</div>\n", ["ALL", "BACKENDS", "LISTS", "REGISTERED"]);
add_ocaml_element("register_loader", "Std.Image.register_loader", "value", "name:string -> (module Std.Image.Loader) -> unit", "Bap.Std.Image.html#VALregister_loader", "<div class=\"info\">\n<p><code class=\"code\">register_loader&nbsp;~name&nbsp;backend</code> registers new loader.</p>\n\n</div>\n", ["BACKEND", "LOADER", "NAME", "NEW", "REGISTERS", "REGISTER_LOADER"]);
add_ocaml_element("segment_of_symbol", "Std.Image.segment_of_symbol", "value", "Std.Image.t -> Std.Image.symbol -> Std.Image.segment", "Bap.Std.Image.html#VALsegment_of_symbol", "<div class=\"info\">\n<p><code class=\"code\">segment_of_symbol&nbsp;image&nbsp;sym</code> a segment to which <code class=\"code\">sym</code> belongs.</p>\n\n</div>\n", ["BELONGS", "IMAGE", "SEGMENT", "SEGMENT_OF_SYMBOL", "SYM", "WHICH"]);
add_ocaml_element("symbols_of_segment", "Std.Image.symbols_of_segment", "value", "Std.Image.t -> Std.Image.segment -> Std.Image.symbol Std.seq", "Bap.Std.Image.html#VALsymbols_of_segment", "<div class=\"info\">\n<p><code class=\"code\">symbols_of_segment&nbsp;img&nbsp;seg</code> all symbols that belong to the\n        <code class=\"code\">seg</code> segment.</p>\n\n</div>\n", ["ALL", "BELONG", "IMG", "SEG", "SEGMENT", "SYMBOLS", "SYMBOLS_OF_SEGMENT", "THAT", "THE"]);
add_ocaml_element("memory_of_symbol", "Std.Image.memory_of_symbol", "value", "Std.Image.t ->\n  Std.Image.symbol -> Std.mem * Std.mem Std.seq", "Bap.Std.Image.html#VALmemory_of_symbol", "<div class=\"info\">\n<p><code class=\"code\">memory_of_symbol&nbsp;sym</code> returns a sequence of memory regions\n        that belong to the <code class=\"code\">sym</code> symbol.</p>\n\n</div>\n", ["AND", "BELONG", "CASE", "CONTIGIOUS", "ELEMENT", "ELEMNT", "EMPTY", "FIRST", "MEMORY", "MEMORY_OF_SYMBOL", "NON", "OCCUPIES", "PAIR", "POSSIBLE", "REGION", "REGIONS", "REPRESENTED", "REST", "RETURNS", "SECOND", "SEQUENCE", "STARTING", "SYM", "SYMBOL", "THAT", "THE", "WHERE"]);
add_ocaml_element("memory_of_segment", "Std.Image.memory_of_segment", "value", "Std.Image.t -> Std.Image.segment -> Std.mem", "Bap.Std.Image.html#VALmemory_of_segment", "<div class=\"info\">\n<p><code class=\"code\">memory_of_segment&nbsp;img&nbsp;seg</code> returns a memory region occupied\n        by the segment <code class=\"code\">seg</code>.</p>\n\n</div>\n", ["IMG", "MEMORY", "MEMORY_OF_SEGMENT", "OCCUPIED", "REGION", "RETURNS", "SEG", "SEGMENT", "THE"]);
add_ocaml_element("memory", "Std.Image.memory", "value", "Std.Image.t -> Std.value Std.memmap", "Bap.Std.Image.html#VALmemory", "<div class=\"info\">\n<p>returns memory, annotated with tags</p>\n\n</div>\n", ["ANNOTATED", "MEMORY", "RETURNS", "TAGS", "WITH"]);
add_ocaml_element("specification", "Std.Image.specification", "value", "Ogre.doc Std.tag", "Bap.Std.Image.html#VALspecification", "<div class=\"info\">\n<p>an image specification in OGRE</p>\n\n</div>\n", ["IMAGE", "OGRE", "SPECIFICATION"]);
add_ocaml_element("section", "Std.Image.section", "value", "string Std.tag", "Bap.Std.Image.html#VALsection", "<div class=\"info\">\n<p>tags a section</p>\n\n</div>\n", ["SECTION", "TAGS"]);
add_ocaml_element("symbol", "Std.Image.symbol", "value", "string Std.tag", "Bap.Std.Image.html#VALsymbol", "<div class=\"info\">\n<p>tags a symbol</p>\n\n</div>\n", ["SYMBOL", "TAGS"]);
add_ocaml_element("segment", "Std.Image.segment", "value", "Std.Image.segment Std.tag", "Bap.Std.Image.html#VALsegment", "<div class=\"info\">\n<p>tags a segment</p>\n\n</div>\n", ["SEGMENT", "TAGS"]);
add_ocaml_element("symbols", "Std.Image.symbols", "value", "Std.Image.t -> Std.Image.symbol Std.table", "Bap.Std.Image.html#VALsymbols", "<div class=\"info\">\n<p><code class=\"code\">symbols&nbsp;image</code> returns a mapping from addresses to symbols</p>\n\n</div>\n", ["ADDRESSES", "FROM", "IMAGE", "MAPPING", "RETURNS", "SYMBOLS"]);
add_ocaml_element("segments", "Std.Image.segments", "value", "Std.Image.t -> Std.Image.segment Std.table", "Bap.Std.Image.html#VALsegments", "<div class=\"info\">\n<p><code class=\"code\">segments&nbsp;image</code> returns a mapping from addresses to segments</p>\n\n</div>\n", ["ADDRESSES", "FROM", "IMAGE", "MAPPING", "RETURNS", "SEGMENTS"]);
add_ocaml_element("words", "Std.Image.words", "value", "Std.Image.t -> Std.size -> Std.word Std.table", "Bap.Std.Image.html#VALwords", "<div class=\"info\">\n<p><code class=\"code\">words&nbsp;image&nbsp;size</code> returns a mapping from addresses to words\n        of the specified <code class=\"code\">size</code>.</p>\n\n</div>\n", ["ADDRESSES", "ALL", "BYTES", "EXAMPLE", "FOR", "FROM", "IMAGE", "IMG", "MAPPING", "RETURNS", "SIZE", "SPECIFIED", "THE", "WORDS"]);
add_ocaml_element("endian", "Std.Image.endian", "value", "Std.Image.t -> Std.endian", "Bap.Std.Image.html#VALendian", "<div class=\"info\">\n<p><code class=\"code\">endian&nbsp;image</code> same as <code class=\"code\"><span class=\"constructor\">Arch</span>.endian&nbsp;(<span class=\"constructor\">Image</span>.arch&nbsp;image)</code></p>\n\n</div>\n", ["ARCH", "ENDIAN", "IMAGE", "SAME"]);
add_ocaml_element("addr_size", "Std.Image.addr_size", "value", "Std.Image.t -> Std.addr_size", "Bap.Std.Image.html#VALaddr_size", "<div class=\"info\">\n<p><code class=\"code\">addr_size&nbsp;image</code> same as <code class=\"code\"><span class=\"constructor\">Arch</span>.addr_size&nbsp;(<span class=\"constructor\">Image</span>.arch&nbsp;image)</code></p>\n\n</div>\n", ["ADDR_SIZE", "ARCH", "IMAGE", "SAME"]);
add_ocaml_element("arch", "Std.Image.arch", "value", "Std.Image.t -> Std.arch", "Bap.Std.Image.html#VALarch", "<div class=\"info\">\n<p><code class=\"code\">arch&nbsp;image</code> code architecture</p>\n\n</div>\n", ["ARCH", "ARCHITECTURE", "CODE", "IMAGE"]);
add_ocaml_element("filename", "Std.Image.filename", "value", "Std.Image.t -> string option", "Bap.Std.Image.html#VALfilename", "", []);
add_ocaml_element("entry_point", "Std.Image.entry_point", "value", "Std.Image.t -> Std.addr", "Bap.Std.Image.html#VALentry_point", "<div class=\"info\">\n<p><code class=\"code\">entry_point&nbsp;addr</code> is an address from which a kernel should start</p>\n\n</div>\n", ["ADDR", "ADDRESS", "ANY", "ENTRY_POINT", "FILE", "FILENAME", "FROM", "IMAGE", "KERNEL", "LOADED", "NAME", "SHOULD", "START", "WAS", "WHICH"]);
add_ocaml_element("of_bigstring", "Std.Image.of_bigstring", "value", "?backend:string -> Bigstring.t -> Std.Image.result", "Bap.Std.Image.html#VALof_bigstring", "<div class=\"info\">\n<p><code class=\"code\">of_bigstring&nbsp;?backend&nbsp;~data</code> creates an image from the specified\n        <code class=\"code\">data</code>.</p>\n\n</div>\n", ["BACKEND", "BAP", "CREATE", "CREATES", "DATA", "FOR", "FROM", "IMAGE", "OF_BIGSTRING", "PARAMETER", "SEE", "SPECIFIED", "STD", "THE"]);
add_ocaml_element("of_string", "Std.Image.of_string", "value", "?backend:string -> string -> Std.Image.result", "Bap.Std.Image.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;?backend&nbsp;~data</code> creates an image from the specified\n        <code class=\"code\">data</code>.</p>\n\n</div>\n", ["BACKEND", "BAP", "CREATE", "CREATES", "DATA", "FOR", "FROM", "IMAGE", "OF_STRING", "PARAMETER", "SEE", "SPECIFIED", "STD", "THE"]);
add_ocaml_element("create", "Std.Image.create", "value", "?backend:string -> Std.Image.path -> Std.Image.result", "Bap.Std.Image.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?backend&nbsp;filename</code> creates an image of the file specified\n        specified by the <code class=\"code\">filename</code>.</p>\n\n</div>\n", ["ALL", "AMBIGUITY", "ARE", "AUTO", "BACKEND", "BACKENDS", "CAN", "CREATE", "CREATES", "EQUAL", "FILE", "FILENAME", "IMAGE", "LLVM", "NOT", "ONE", "ONLY", "ORDER", "READ", "RETURNED", "SPECIFED", "SPECIFIED", "THE", "THEN", "THERE", "THIS", "TRIED", "USED"]);
add_ocaml_element("pp", "Std.Table.pp", "value", "'a Std.printer -> 'a Std.Table.t Std.printer", "Bap.Std.Table.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;printer</code> - creates a printer for table from value printer</p>\n\n</div>\n", ["CREATES", "FOR", "FROM", "PRINTER", "TABLE", "VALUE"]);
add_ocaml_element("elements", "Std.Table.elements", "value", "('a Std.Table.t -> 'a Std.seq) Std.Table.ranged", "Bap.Std.Table.html#VALelements", "<div class=\"info\">\n<p><code class=\"code\">elements&nbsp;table</code> returns in an ascending order of addresses all\n        elements mapped in a <code class=\"code\">table</code></p>\n\n</div>\n", ["ADDRESSES", "ALL", "ASCENDING", "ELEMENTS", "MAPPED", "ORDER", "RETURNS", "TABLE"]);
add_ocaml_element("regions", "Std.Table.regions", "value", "('a Std.Table.t -> Std.mem Std.seq) Std.Table.ranged", "Bap.Std.Table.html#VALregions", "<div class=\"info\">\n<p><code class=\"code\">regions&nbsp;table</code> returns in an ascending order of addresses all\n        memory regions mapped in a <code class=\"code\">table</code></p>\n\n</div>\n", ["ADDRESSES", "ALL", "ASCENDING", "MAPPED", "MEMORY", "ORDER", "REGIONS", "RETURNS", "TABLE"]);
add_ocaml_element("to_sequence", "Std.Table.to_sequence", "value", "('a Std.Table.t -> (Std.mem * 'a) Std.seq) Std.Table.ranged", "Bap.Std.Table.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;~start&nbsp;~until&nbsp;table</code> converts the <code class=\"code\">table</code> to a\n        sequence of key-value pairs.</p>\n\n</div>\n", ["CONVERTS", "KEY", "PAIRS", "SEQUENCE", "START", "TABLE", "THE", "TO_SEQUENCE", "UNTIL", "VALUE"]);
add_ocaml_element("filter_mapi", "Std.Table.filter_mapi", "value", "('a Std.Table.t ->\n   f:(Std.mem -> 'a -> 'b option) -> 'b Std.Table.t)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfilter_mapi", "<div class=\"info\">\n<p><code class=\"code\">filter_mapi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALfilter_map\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.filter_map</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "FILTER_MAP", "FILTER_MAPI", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("filteri", "Std.Table.filteri", "value", "('a Std.Table.t -> f:(Std.mem -> 'a -> bool) -> 'a Std.Table.t)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfilteri", "<div class=\"info\">\n<p><code class=\"code\">filteri&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALfilter\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.filter</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "FILTER", "FILTERI", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("filter_map", "Std.Table.filter_map", "value", "('a Std.Table.t -> f:('a -> 'b option) -> 'b Std.Table.t)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter_map&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> return a subtable of\n        <code class=\"code\">table</code> containing only elements for which <code class=\"code\">f</code> returns\n        <code class=\"code\"><span class=\"constructor\">Some</span></code></p>\n\n</div>\n", ["CONTAINING", "ELEMENTS", "FILTER_MAP", "FOR", "ONLY", "RETURN", "RETURNS", "SOME", "START", "SUBTABLE", "TABLE", "UNTIL", "WHICH"]);
add_ocaml_element("filter", "Std.Table.filter", "value", "('a Std.Table.t -> f:('a -> bool) -> 'a Std.Table.t)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> removes all mappings from\n        <code class=\"code\">table</code> that doesn't satisfies the predicate <code class=\"code\">f</code></p>\n\n</div>\n", ["ALL", "DOESN", "FILTER", "FROM", "MAPPINGS", "PREDICATE", "REMOVES", "SATISFIES", "START", "TABLE", "THAT", "THE", "UNTIL"]);
add_ocaml_element("mapi", "Std.Table.mapi", "value", "('a Std.Table.t -> f:(Std.mem -> 'a -> 'b) -> 'b Std.Table.t)\n  Std.Table.ranged", "Bap.Std.Table.html#VALmapi", "<div class=\"info\">\n<p><code class=\"code\">mapi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALmap\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.map</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "LIKE", "MAP", "MAPI", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("map", "Std.Table.map", "value", "('a Std.Table.t -> f:('a -> 'b) -> 'b Std.Table.t)\n  Std.Table.ranged", "Bap.Std.Table.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> applies <code class=\"code\">f</code> to elements of\n        <code class=\"code\">table</code> and builds new table with results returned by <code class=\"code\">f</code></p>\n\n</div>\n", ["AND", "APPLIES", "BUILDS", "ELEMENTS", "MAP", "NEW", "RESULTS", "RETURNED", "START", "TABLE", "UNTIL", "WITH"]);
add_ocaml_element("iteri", "Std.Table.iteri", "value", "('a Std.Table.t -> f:(Std.mem -> 'a -> unit) -> unit)\n  Std.Table.ranged", "Bap.Std.Table.html#VALiteri", "<div class=\"info\">\n<p><code class=\"code\">ieri&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALiter\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.iter</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "IERI", "ITER", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("foldi", "Std.Table.foldi", "value", "('a Std.Table.t -> init:'b -> f:(Std.mem -> 'a -> 'b -> 'b) -> 'b)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfoldi", "<div class=\"info\">\n<p><code class=\"code\">foldi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALfold\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.fold</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "FOLD", "FOLDI", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("find_mapi", "Std.Table.find_mapi", "value", "('a Std.Table.t -> f:(Std.mem -> 'a -> 'b option) -> 'b option)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfind_mapi", "<div class=\"info\">\n<p><code class=\"code\">find_mapi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALfind_map\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.find_map</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "FIND_MAP", "FIND_MAPI", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("iter", "Std.Table.iter", "value", "('a Std.Table.t -> f:('a -> unit) -> unit) Std.Table.ranged", "Bap.Std.Table.html#VALiter", "<div class=\"info\">\n<p><code class=\"code\">iter&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> applies function <code class=\"code\">f</code> in turn to\n        elements of <code class=\"code\">table</code></p>\n\n</div>\n", ["APPLIES", "ELEMENTS", "FUNCTION", "ITER", "START", "TABLE", "TURN", "UNTIL"]);
add_ocaml_element("fold", "Std.Table.fold", "value", "('a Std.Table.t -> init:'b -> f:('a -> 'b -> 'b) -> 'b)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfold", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;~start&nbsp;~until&nbsp;~init&nbsp;~f&nbsp;table</code> returns a fold over\n        <code class=\"code\">table</code> in form <code class=\"code\">f&nbsp;elt_n&nbsp;(&nbsp;...&nbsp;(f&nbsp;elt_2&nbsp;(f&nbsp;(elt_1&nbsp;acc)))&nbsp;...&nbsp;)</code></p>\n\n</div>\n", ["ACC", "ELT_1", "ELT_2", "ELT_N", "FOLD", "FORM", "INIT", "OVER", "RETURNS", "START", "TABLE", "UNTIL"]);
add_ocaml_element("find_map", "Std.Table.find_map", "value", "('a Std.Table.t -> f:('a -> 'b option) -> 'b option) Std.Table.ranged", "Bap.Std.Table.html#VALfind_map", "<div class=\"info\">\n<p><code class=\"code\">find_map&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> returns the first evaluation\n        of <code class=\"code\">f</code> that returns <code class=\"code\"><span class=\"constructor\">Some</span></code> or None if <code class=\"code\">f</code> always returns <code class=\"code\"><span class=\"constructor\">None</span></code></p>\n\n</div>\n", ["ALWAYS", "EVALUATION", "FIND_MAP", "FIRST", "NONE", "RETURNS", "SOME", "START", "TABLE", "THAT", "THE", "UNTIL"]);
add_ocaml_element("find_if", "Std.Table.find_if", "value", "('a Std.Table.t -> f:('a -> bool) -> 'a option) Std.Table.ranged", "Bap.Std.Table.html#VALfind_if", "<div class=\"info\">\n<p><code class=\"code\">find_if&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> returns the first element of\n        <code class=\"code\">table</code> that satisfies the predicate <code class=\"code\">p</code> or None if no elements\n        satisfied</p>\n\n</div>\n", ["ELEMENT", "ELEMENTS", "FIND_IF", "FIRST", "NONE", "PREDICATE", "RETURNS", "SATISFIED", "SATISFIES", "START", "TABLE", "THAT", "THE", "UNTIL"]);
add_ocaml_element("count", "Std.Table.count", "value", "('a Std.Table.t -> f:('a -> bool) -> int) Std.Table.ranged", "Bap.Std.Table.html#VALcount", "<div class=\"info\">\n<p><code class=\"code\">count&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> returns the number of elements\n        <code class=\"code\">table</code> that satisfy the predicate <code class=\"code\">p</code></p>\n\n</div>\n", ["COUNT", "ELEMENTS", "NUMBER", "PREDICATE", "RETURNS", "SATISFY", "START", "TABLE", "THAT", "THE", "UNTIL"]);
add_ocaml_element("for_alli", "Std.Table.for_alli", "value", "('a Std.Table.t -> f:(Std.mem -> 'a -> bool) -> bool)\n  Std.Table.ranged", "Bap.Std.Table.html#VALfor_alli", "<div class=\"info\">\n<p><code class=\"code\">for_alli&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALfor_all\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.for_all</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "FOR_ALL", "FOR_ALLI", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("existsi", "Std.Table.existsi", "value", "('a Std.Table.t -> f:(Std.mem -> 'a -> bool) -> bool)\n  Std.Table.ranged", "Bap.Std.Table.html#VALexistsi", "<div class=\"info\">\n<p><code class=\"code\">existsi&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> is like <a href=\"Bap.Std.Table.html#VALexists\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Table</span>.exists</code></a>, but\n        also passes the memory as an argument.</p>\n\n</div>\n", ["ALSO", "ARGUMENT", "BAP", "BUT", "EXISTS", "EXISTSI", "LIKE", "MEMORY", "PASSES", "START", "STD", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("for_all", "Std.Table.for_all", "value", "('a Std.Table.t -> f:('a -> bool) -> bool) Std.Table.ranged", "Bap.Std.Table.html#VALfor_all", "<div class=\"info\">\n<p><code class=\"code\">for_all&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> checks if all elements\n        of <code class=\"code\">table</code> satisfies the predicate <code class=\"code\">f</code>.</p>\n\n</div>\n", ["ALL", "CHECKS", "ELEMENTS", "FOR_ALL", "PREDICATE", "SATISFIES", "START", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("exists", "Std.Table.exists", "value", "('a Std.Table.t -> f:('a -> bool) -> bool) Std.Table.ranged", "Bap.Std.Table.html#VALexists", "<div class=\"info\">\n<p><code class=\"code\">exists&nbsp;~start&nbsp;~until&nbsp;~f&nbsp;table</code> checks if at least one\n        element of <code class=\"code\">table</code> satisfies the predicate <code class=\"code\">f</code>.</p>\n\n</div>\n", ["CHECKS", "ELEMENT", "EXISTS", "LEAST", "ONE", "PREDICATE", "SATISFIES", "START", "TABLE", "THE", "UNTIL"]);
add_ocaml_element("rev_map", "Std.Table.rev_map", "value", "one_to:(Std.mem, 'r) Std.Table.r ->\n  'a Std.Table.hashable ->\n  'a Std.Table.t -> ('a -> 'r) Or_error.t", "Bap.Std.Table.html#VALrev_map", "<div class=\"info\">\n<p><code class=\"code\">rev_map&nbsp;arity&nbsp;t&nbsp;tab</code> creates a reverse mapping from values of\n        typeclass <code class=\"code\">t</code> stored in table <code class=\"code\">tab</code> to memory regions.</p>\n\n</div>\n", ["ARITY", "BUT", "CAN", "CASE", "CODE", "CONTIGUOUS", "CREATE", "CREATES", "ERROR", "EVERY", "EXAMPLE", "FOR", "FROM", "FUNCTION", "FUNCTIONS", "HASHABLE", "MANY", "MAPPING", "MAPPINGS", "MEMORY", "NON", "NOT", "NOTE", "OBTAIN", "OCCUPY", "ONE", "ONE_TO", "PARTICULAR", "REGIONS", "RESULT", "REVERSABLE", "REVERSE", "REVERSED", "REV_MAP", "SEQUENCE", "SEVERAL", "STORED", "SURJECTIVE", "SYM", "SYMBOL", "TAB", "TABLE", "TABLES", "TRYING", "TYPECLASS", "USING", "VALUES", "WHEN", "WILL", "WITH"]);
add_ocaml_element("link", "Std.Table.link", "value", "one_to:('b, 'r) Std.Table.r ->\n  'a Std.Table.hashable ->\n  'a Std.Table.t -> 'b Std.Table.t -> 'a -> 'r", "Bap.Std.Table.html#VALlink", "", []);
add_ocaml_element("maybe_one", "Std.Table.maybe_one", "value", "('a, 'a option) Std.Table.r", "Bap.Std.Table.html#VALmaybe_one", "<div class=\"info\">\n<p><code class=\"code\">0..1</code></p>\n\n</div>\n", []);
add_ocaml_element("one", "Std.Table.one", "value", "('a, 'a) Std.Table.r", "Bap.Std.Table.html#VALone", "<div class=\"info\">\n<p><code class=\"code\">1..1</code></p>\n\n</div>\n", []);
add_ocaml_element("at_least_one", "Std.Table.at_least_one", "value", "('a, 'a * 'a Std.seq) Std.Table.r", "Bap.Std.Table.html#VALat_least_one", "", []);
add_ocaml_element("many", "Std.Table.many", "value", "('a, 'a Std.seq) Std.Table.r", "Bap.Std.Table.html#VALmany", "<div class=\"info\">\n<p><code class=\"code\">0..*</code></p>\n\n</div>\n", []);
add_ocaml_element("max", "Std.Table.max", "value", "'a Std.Table.t -> (Std.mem * 'a) option", "Bap.Std.Table.html#VALmax", "<div class=\"info\">\n<p><code class=\"code\">max&nbsp;tab</code> return the highest binding</p>\n\n</div>\n", ["BINDING", "HIGHEST", "MAX", "RETURN", "TAB", "THE"]);
add_ocaml_element("min", "Std.Table.min", "value", "'a Std.Table.t -> (Std.mem * 'a) option", "Bap.Std.Table.html#VALmin", "<div class=\"info\">\n<p><code class=\"code\">min&nbsp;tab</code> return the lowest binding</p>\n\n</div>\n", ["BINDING", "LOWEST", "MIN", "RETURN", "TAB", "THE"]);
add_ocaml_element("prev", "Std.Table.prev", "value", "'a Std.Table.t -> Std.mem -> (Std.mem * 'a) option", "Bap.Std.Table.html#VALprev", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;table&nbsp;elt</code> returns element preceding to <code class=\"code\">elt</code>, if any</p>\n\n</div>\n", ["ANY", "ELEMENT", "ELT", "NEXT", "PRECEDING", "RETURNS", "TABLE"]);
add_ocaml_element("next", "Std.Table.next", "value", "'a Std.Table.t -> Std.mem -> (Std.mem * 'a) option", "Bap.Std.Table.html#VALnext", "<div class=\"info\">\n<p><code class=\"code\">next&nbsp;table&nbsp;elt</code> returns element next to <code class=\"code\">elt</code>, if any</p>\n\n</div>\n", ["ANY", "ELEMENT", "ELT", "NEXT", "RETURNS", "TABLE"]);
add_ocaml_element("mem", "Std.Table.mem", "value", "'a Std.Table.t -> Std.mem -> bool", "Bap.Std.Table.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;table&nbsp;mem</code> is true if table contains mem region <code class=\"code\">mem</code></p>\n\n</div>\n", ["CONTAINS", "MEM", "REGION", "TABLE", "TRUE"]);
add_ocaml_element("has_intersections", "Std.Table.has_intersections", "value", "'a Std.Table.t -> Std.mem -> bool", "Bap.Std.Table.html#VALhas_intersections", "<div class=\"info\">\n<p><code class=\"code\">has_intersections&nbsp;tab&nbsp;mem</code> is true iff some portion of <code class=\"code\">mem</code> is\n        is already mapped in <code class=\"code\">tab</code>.</p>\n\n</div>\n", ["ALREADY", "HAS_INTERSECTIONS", "IFF", "MAPPED", "MEM", "PORTION", "SOME", "TAB", "TRUE"]);
add_ocaml_element("fold_intersections", "Std.Table.fold_intersections", "value", "'a Std.Table.t ->\n  Std.mem -> init:'b -> f:(Std.mem -> 'a -> 'b -> 'b) -> 'b", "Bap.Std.Table.html#VALfold_intersections", "<div class=\"info\">\n<p><code class=\"code\">fold_intersections&nbsp;table&nbsp;mem</code> folds over all regions\n        intersecting with <code class=\"code\">mem</code></p>\n\n</div>\n", ["ALL", "FOLDS", "FOLD_INTERSECTIONS", "INTERSECTING", "MEM", "OVER", "REGIONS", "TABLE", "WITH"]);
add_ocaml_element("intersections", "Std.Table.intersections", "value", "'a Std.Table.t -> Std.mem -> (Std.mem * 'a) Std.seq", "Bap.Std.Table.html#VALintersections", "<div class=\"info\">\n<p><code class=\"code\">intersections&nbsp;table&nbsp;mem</code> returns all mappings in a <code class=\"code\">table</code> that\n        have intersections with <code class=\"code\">mem</code></p>\n\n</div>\n", ["ALL", "HAVE", "INTERSECTIONS", "MAPPINGS", "MEM", "RETURNS", "TABLE", "THAT", "WITH"]);
add_ocaml_element("find_addr", "Std.Table.find_addr", "value", "'a Std.Table.t -> Std.addr -> (Std.mem * 'a) option", "Bap.Std.Table.html#VALfind_addr", "<div class=\"info\">\n<p><code class=\"code\">find_addr&nbsp;tab&nbsp;addr</code> finds a memory region that contains a\n        specified <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "CONTAINS", "FINDS", "FIND_ADDR", "MEMORY", "REGION", "SPECIFIED", "TAB", "THAT"]);
add_ocaml_element("find", "Std.Table.find", "value", "'a Std.Table.t -> Std.mem -> 'a option", "Bap.Std.Table.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;table&nbsp;mem</code> finds an element mapped to the memory region <code class=\"code\">mem</code></p>\n\n</div>\n", ["ELEMENT", "FIND", "FINDS", "MAPPED", "MEM", "MEMORY", "REGION", "TABLE", "THE"]);
add_ocaml_element("length", "Std.Table.length", "value", "'a Std.Table.t -> int", "Bap.Std.Table.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;table</code> returns a number of entries in the table</p>\n\n</div>\n", ["ENTRIES", "LENGTH", "NUMBER", "RETURNS", "TABLE", "THE"]);
add_ocaml_element("change", "Std.Table.change", "value", "'a Std.Table.t ->\n  Std.mem ->\n  f:((Std.mem * 'a) Std.seq ->\n     [ `ignore\n     | `rebind of Std.mem * 'a\n     | `remove\n     | `update of Std.mem * 'a -> 'a ]) ->\n  'a Std.Table.t", "Bap.Std.Table.html#VALchange", "<div class=\"info\">\n<p><code class=\"code\">change&nbsp;tab&nbsp;mem&nbsp;~f</code> function <code class=\"code\">f</code> is applied to a set of all memory\n        regions that intersects with <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["ADDED", "ALL", "AND", "APPLIED", "ARE", "ASCENDING", "CHANGE", "EVALUATES", "FROM", "FUNCTION", "HAD", "HAVE", "INTERSECTIONS", "INTERSECTS", "MAP", "MAPPED", "MEM", "MEMORY", "NEW", "NEW_MEM", "NOTHING", "ORDER", "PASSED", "REGION", "REGIONS", "REMAP", "REMOVE", "REMOVED", "RETURNED", "SET", "SKIP", "SORTED", "TAB", "TABLE", "THAT", "THE", "THEN", "UNCHANGED", "WILL", "WITH"]);
add_ocaml_element("remove", "Std.Table.remove", "value", "'a Std.Table.t -> Std.mem -> 'a Std.Table.t", "Bap.Std.Table.html#VALremove", "<div class=\"info\">\n<p>returns a new table with all mappings from the mem region\n        <code class=\"code\">mem</code> removed</p>\n\n</div>\n", ["ALL", "FROM", "MAPPINGS", "MEM", "NEW", "REGION", "REMOVED", "RETURNS", "TABLE", "THE", "WITH"]);
add_ocaml_element("add", "Std.Table.add", "value", "'a Std.Table.t ->\n  Std.mem -> 'a -> 'a Std.Table.t Or_error.t", "Bap.Std.Table.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;table&nbsp;mem&nbsp;v</code> returns a new table with added mapping from a\n        mem region <code class=\"code\">mem</code> to a data value <code class=\"code\">v</code></p>\n\n</div>\n", ["ADD", "ADDED", "DATA", "FROM", "MAPPING", "MEM", "NEW", "REGION", "RETURNS", "TABLE", "VALUE", "WITH"]);
add_ocaml_element("singleton", "Std.Table.singleton", "value", "Std.mem -> 'a -> 'a Std.Table.t", "Bap.Std.Table.html#VALsingleton", "<div class=\"info\">\n<p>creates a table containing one bindins</p>\n\n</div>\n", ["BINDINS", "CONTAINING", "CREATES", "ONE", "TABLE"]);
add_ocaml_element("empty", "Std.Table.empty", "value", "'a Std.Table.t", "Bap.Std.Table.html#VALempty", "<div class=\"info\">\n<p>creates an empty table</p>\n\n</div>\n", ["CREATES", "EMPTY", "TABLE"]);
add_ocaml_element("find_map", "Std.Memory_iterators.find_map", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.addr -> Std.word -> 'a option Std.Memory_iterators.m) ->\n  'a option Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALfind_map", "<div class=\"info\">\n<p><code class=\"code\">find_map&nbsp;~word_size&nbsp;~f&nbsp;t</code> returns the first evaluation\n        of <code class=\"code\">f</code> that returns <code class=\"code\"><span class=\"constructor\">Some</span></code> or None if <code class=\"code\">f</code> always returns <code class=\"code\"><span class=\"constructor\">None</span></code></p>\n\n</div>\n", ["ALWAYS", "EVALUATION", "FIND_MAP", "FIRST", "NONE", "RETURNS", "SOME", "THAT", "THE", "WORD_SIZE"]);
add_ocaml_element("find_if", "Std.Memory_iterators.find_if", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.addr -> Std.word -> bool Std.Memory_iterators.m) ->\n  Std.word option Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALfind_if", "<div class=\"info\">\n<p><code class=\"code\">find_if&nbsp;~word_size&nbsp;~f&nbsp;t</code> returns the first element of\n        <code class=\"code\">t</code> that satisfies the predicate <code class=\"code\">p</code> or None if no elements\n        satisfied</p>\n\n</div>\n", ["ELEMENT", "ELEMENTS", "FIND_IF", "FIRST", "NONE", "PREDICATE", "RETURNS", "SATISFIED", "SATISFIES", "THAT", "THE", "WORD_SIZE"]);
add_ocaml_element("count", "Std.Memory_iterators.count", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.addr -> Std.word -> bool Std.Memory_iterators.m) ->\n  int Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALcount", "<div class=\"info\">\n<p><code class=\"code\">count&nbsp;~word_size&nbsp;~f&nbsp;t</code> is the number of elements in <code class=\"code\">t</code>\n        that satisfies the predicate <code class=\"code\">f</code>.</p>\n\n</div>\n", ["COUNT", "ELEMENTS", "NUMBER", "PREDICATE", "SATISFIES", "THAT", "THE", "WORD_SIZE"]);
add_ocaml_element("for_all", "Std.Memory_iterators.for_all", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.addr -> Std.word -> bool Std.Memory_iterators.m) ->\n  bool Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALfor_all", "<div class=\"info\">\n<p><code class=\"code\">for_all&nbsp;~word_size&nbsp;~f&nbsp;t</code> checks if all elements of <code class=\"code\">t</code>\n        satisfies the predicate <code class=\"code\">f</code></p>\n\n</div>\n", ["ALL", "CHECKS", "ELEMENTS", "FOR_ALL", "PREDICATE", "SATISFIES", "THE", "WORD_SIZE"]);
add_ocaml_element("exists", "Std.Memory_iterators.exists", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.addr -> Std.word -> bool Std.Memory_iterators.m) ->\n  bool Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALexists", "<div class=\"info\">\n<p><code class=\"code\">exists&nbsp;~word_size&nbsp;~f&nbsp;t</code> checks if at least one element of <code class=\"code\">t</code>\n        satisfies the predicate <code class=\"code\">f</code></p>\n\n</div>\n", ["CHECKS", "ELEMENT", "EXISTS", "LEAST", "ONE", "PREDICATE", "SATISFIES", "THE", "WORD_SIZE"]);
add_ocaml_element("iteri", "Std.Memory_iterators.iteri", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.addr -> Std.word -> unit Std.Memory_iterators.m) ->\n  unit Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALiteri", "<div class=\"info\">\n<p><code class=\"code\">iteri&nbsp;~word_size&nbsp;~f&nbsp;t</code> is like <a href=\"Bap.Std.Memory_iterators.html#VALiter\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Memory_iterators</span>.iter</code></a>, but also passes\n        an address to the <code class=\"code\">f</code></p>\n\n</div>\n", ["ADDRESS", "ALSO", "BAP", "BUT", "ITER", "ITERI", "LIKE", "MEMORY_ITERATORS", "PASSES", "STD", "THE", "WORD_SIZE"]);
add_ocaml_element("foldi", "Std.Memory_iterators.foldi", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  init:'b ->\n  f:(Std.addr -> Std.word -> 'b -> 'b Std.Memory_iterators.m) ->\n  'b Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALfoldi", "<div class=\"info\">\n<p><code class=\"code\">foldi&nbsp;~word_size&nbsp;~init&nbsp;~f&nbsp;t</code> is like <a href=\"Bap.Std.Memory_iterators.html#VALfold\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Memory_iterators</span>.fold</code></a>, but also passes\n        an address to the <code class=\"code\">f</code></p>\n\n</div>\n", ["ADDRESS", "ALSO", "BAP", "BUT", "FOLD", "FOLDI", "INIT", "LIKE", "MEMORY_ITERATORS", "PASSES", "STD", "THE", "WORD_SIZE"]);
add_ocaml_element("iter", "Std.Memory_iterators.iter", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  f:(Std.word -> unit Std.Memory_iterators.m) ->\n  unit Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALiter", "<div class=\"info\">\n<p><code class=\"code\">iter&nbsp;~word_size&nbsp;~f&nbsp;t</code> applies <code class=\"code\">f</code> to elements of <code class=\"code\">t</code></p>\n\n</div>\n", ["APPLIES", "ELEMENTS", "ITER", "WORD_SIZE"]);
add_ocaml_element("fold", "Std.Memory_iterators.fold", "value", "?word_size:Std.size ->\n  Std.Memory_iterators.t ->\n  init:'b ->\n  f:(Std.word -> 'b -> 'b Std.Memory_iterators.m) ->\n  'b Std.Memory_iterators.m", "Bap.Std.Memory_iterators.html#VALfold", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;~word_size&nbsp;~init&nbsp;~f&nbsp;t</code> folds over elements of <code class=\"code\">t</code>,\n        so a result is <code class=\"code\">f&nbsp;(...&nbsp;(f&nbsp;(f&nbsp;a&nbsp;elt_1)&nbsp;elt_2)&nbsp;...)&nbsp;elt_n</code></p>\n\n</div>\n", ["ELEMENTS", "ELT_1", "ELT_2", "ELT_N", "FOLD", "FOLDS", "INIT", "OVER", "RESULT", "WORD_SIZE"]);
add_ocaml_element("int64", "Std.Memory.Input.int64", "value", "Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALint64", "<div class=\"info\">\n<p><code class=\"code\">int64</code> a 64-bit word reader</p>\n\n</div>\n", ["BIT", "INT64", "READER", "WORD"]);
add_ocaml_element("int32", "Std.Memory.Input.int32", "value", "Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALint32", "<div class=\"info\">\n<p><code class=\"code\">int32</code> a 32-bit word reader</p>\n\n</div>\n", ["BIT", "INT32", "READER", "WORD"]);
add_ocaml_element("uint16", "Std.Memory.Input.uint16", "value", "Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALuint16", "<div class=\"info\">\n<p><code class=\"code\">uint16</code> an unsigned 16-bit word reader</p>\n\n</div>\n", ["BIT", "READER", "UINT16", "UNSIGNED", "WORD"]);
add_ocaml_element("int16", "Std.Memory.Input.int16", "value", "Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALint16", "<div class=\"info\">\n<p><code class=\"code\">int16</code> a signed 16-bit word reader</p>\n\n</div>\n", ["BIT", "INT16", "READER", "SIGNED", "WORD"]);
add_ocaml_element("uint8", "Std.Memory.Input.uint8", "value", "Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALuint8", "<div class=\"info\">\n<p><code class=\"code\">uint8</code> an unsigned byte reader</p>\n\n</div>\n", ["BYTE", "READER", "UINT8", "UNSIGNED"]);
add_ocaml_element("int8", "Std.Memory.Input.int8", "value", "Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALint8", "<div class=\"info\">\n<p><code class=\"code\">int8</code> a signed byte reader</p>\n\n</div>\n", ["BYTE", "INT8", "READER", "SIGNED"]);
add_ocaml_element("word", "Std.Memory.Input.word", "value", "word_size:Std.size -> Std.word Std.Memory.Input.reader", "Bap.Std.Memory.Input.html#VALword", "<div class=\"info\">\n<p><code class=\"code\">word&nbsp;~word_size</code> a reader that reads words of <code class=\"code\">word_size</code></p>\n\n</div>\n", ["READER", "READS", "THAT", "WORD", "WORDS", "WORD_SIZE"]);
add_ocaml_element("to_buffer", "Std.Memory.to_buffer", "value", "Std.Memory.t -> Bigsubstring.t", "Bap.Std.Memory.html#VALto_buffer", "<div class=\"info\">\n<p><code class=\"code\">to_buffers&nbsp;mem</code> creates a buffer representing the memory <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["BUFFER", "BUFFERS", "CONTIGUOUS", "CREATES", "EACH", "GUARANTEED", "HAS", "IMPLEMENTATION", "MEM", "MEMORY", "MODIFIED", "NOT", "OTHER", "PART", "REPRESENTING", "RETURNED", "SEQUENCE", "SHARING", "SHOULDN", "SINCE", "SOME", "SPECIFIED", "THAT", "THE", "TO_BUFFERS", "UNDERLYING", "WHETHER", "WITH", "WORDS"]);
add_ocaml_element("hexdump", "Std.Memory.hexdump", "value", "Std.Memory.t -> string", "Bap.Std.Memory.html#VALhexdump", "<div class=\"info\">\n<p><code class=\"code\">hexdump&nbsp;t&nbsp;out</code> outputs hexdump (as per <code class=\"code\">hexdump&nbsp;-<span class=\"constructor\">C</span></code>) of the\n        memory to formatter <code class=\"code\">out</code></p>\n\n</div>\n", ["FORMATTER", "HEXDUMP", "MEMORY", "OUT", "OUTPUTS", "PER", "THE"]);
add_ocaml_element("compare_with", "Std.Memory.compare_with", "value", "Std.Memory.t ->\n  Std.addr -> [ `addr_is_above | `addr_is_below | `addr_is_inside ]", "Bap.Std.Memory.html#VALcompare_with", "<div class=\"info\">\n<p><code class=\"code\">compare_with&nbsp;mem&nbsp;addr</code> compares memory with <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "COMPARES", "COMPARE_WITH", "MEM", "MEMORY", "WITH"]);
add_ocaml_element("contains", "Std.Memory.contains", "value", "Std.Memory.t -> Std.addr -> bool", "Bap.Std.Memory.html#VALcontains", "<div class=\"info\">\n<p><code class=\"code\">contains&nbsp;mem&nbsp;addr</code> returns true if <code class=\"code\">mem</code> contains address <code class=\"code\">addr</code></p>\n\n</div>\n", ["ADDR", "ADDRESS", "CONTAINS", "MEM", "RETURNS", "TRUE"]);
add_ocaml_element("length", "Std.Memory.length", "value", "Std.Memory.t -> int", "Bap.Std.Memory.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;m</code> returns a number of bytes in m</p>\n\n</div>\n", ["BYTES", "LENGTH", "NUMBER", "RETURNS"]);
add_ocaml_element("min_addr", "Std.Memory.min_addr", "value", "Std.Memory.t -> Std.addr", "Bap.Std.Memory.html#VALmin_addr", "<div class=\"info\">\n<p><code class=\"code\">min_addr&nbsp;m</code> is an address of the first byte of <code class=\"code\">m</code></p>\n\n</div>\n", ["ADDRESS", "BYTE", "FIRST", "MIN_ADDR", "THE"]);
add_ocaml_element("max_addr", "Std.Memory.max_addr", "value", "Std.Memory.t -> Std.addr", "Bap.Std.Memory.html#VALmax_addr", "<div class=\"info\">\n<p><code class=\"code\">max_addr&nbsp;m</code> is an address of the last byte of <code class=\"code\">m</code></p>\n\n</div>\n", ["ADDRESS", "BYTE", "LAST", "MAX_ADDR", "THE"]);
add_ocaml_element("(^!)", "Std.Memory.(^!)", "value", "Std.Memory.t -> Std.addr -> Std.word", "Bap.Std.Memory.html#VAL(^!)", "<div class=\"info\">\n<p><code class=\"code\">m^.n</code> dereferences a byte at address <code class=\"code\">n</code></p>\n\n</div>\n", ["ADDRESS", "BYTE", "DEREFERENCES"]);
add_ocaml_element("(^)", "Std.Memory.(^)", "value", "Std.Memory.t -> Std.addr -> Std.word Or_error.t", "Bap.Std.Memory.html#VAL(^)", "<div class=\"info\">\n<p><code class=\"code\">m^n</code> dereferences a byte at address <code class=\"code\">n</code></p>\n\n</div>\n", ["ADDRESS", "BYTE", "DEREFERENCES"]);
add_ocaml_element("get", "Std.Memory.get", "value", "?disp:int ->\n  ?index:int ->\n  ?scale:Std.size ->\n  ?addr:Std.addr -> Std.Memory.t -> Std.word Or_error.t", "Bap.Std.Memory.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;word_size&nbsp;mem&nbsp;addr</code> reads memory value from the specified\n        address.</p>\n\n</div>\n", ["ADDR", "ADDRESS", "DEFAULT", "FROM", "GET", "MEM", "MEMORY", "READS", "SPECIFIED", "THE", "VALUE", "WORD_SIZE"]);
add_ocaml_element("endian", "Std.Memory.endian", "value", "Std.Memory.t -> Std.endian", "Bap.Std.Memory.html#VALendian", "<div class=\"info\">\n<p>returns the order of bytes in a word</p>\n\n</div>\n", ["BYTES", "ORDER", "RETURNS", "THE", "WORD"]);
add_ocaml_element("last_byte", "Std.Memory.last_byte", "value", "Std.Memory.t -> Std.Memory.t", "Bap.Std.Memory.html#VALlast_byte", "<div class=\"info\">\n<p><code class=\"code\">last_byte&nbsp;m</code> returns last byte of <code class=\"code\">m</code> as a memory</p>\n\n</div>\n", ["BYTE", "LAST", "LAST_BYTE", "MEMORY", "RETURNS"]);
add_ocaml_element("first_byte", "Std.Memory.first_byte", "value", "Std.Memory.t -> Std.Memory.t", "Bap.Std.Memory.html#VALfirst_byte", "<div class=\"info\">\n<p><code class=\"code\">first_byte&nbsp;m</code> returns first byte of <code class=\"code\">m</code> as a memory</p>\n\n</div>\n", ["BYTE", "FIRST", "FIRST_BYTE", "MEMORY", "RETURNS"]);
add_ocaml_element("merge", "Std.Memory.merge", "value", "Std.Memory.t ->\n  Std.Memory.t -> Std.Memory.t Or_error.t", "Bap.Std.Memory.html#VALmerge", "<div class=\"info\">\n<p><code class=\"code\">merge&nbsp;m1&nbsp;m2</code> takes two memory regions, that either intersects or\n        share edges (i.e., difference between <code class=\"code\">min_addr</code> of one of the\n        blocks and <code class=\"code\">max_addr</code> of another is less then or equal to one, and\n        returns memory blocks that spans memory starting from the address</p>\n<pre class=\"codepre\"><code class=\"code\">min (min_addr m1) (min_addr m2)</code></pre><p>and ending with address</p>\n<pre class=\"codepre\"><code class=\"code\">max (max_addr m1) (max_addr m2)</code></pre><p>.</p>\n\n</div>\n", ["ABOVE", "ADDRESS", "AND", "ANOTHER", "BASES", "BETWEEN", "BLOCKS", "DIFFERENCE", "DIFFERENT", "DOESN", "EDGES", "EITHER", "ENDIANNESS", "ENDING", "EQUAL", "ERROR", "FROM", "HAVE", "HOLD", "INTERSECTS", "LESS", "MAX", "MAX_ADDR", "MEMORY", "MERGE", "MIN", "MIN_ADDR", "ONE", "PRECONDITION", "REGIONS", "RETURN", "RETURNS", "SAME", "SHARE", "SPANS", "STARTING", "STATE", "TAKES", "THAT", "THE", "THEN", "THEY", "THIS", "TWO", "UNDERLYING", "WILL", "WITH"]);
add_ocaml_element("range", "Std.Memory.range", "value", "Std.Memory.t ->\n  Std.addr -> Std.addr -> Std.Memory.t Or_error.t", "Bap.Std.Memory.html#VALrange", "<div class=\"info\">\n<p><code class=\"code\">range&nbsp;mem&nbsp;a0&nbsp;a1</code> returns a view on <code class=\"code\">mem</code> starting from\n        address <code class=\"code\">a0</code> and ending at <code class=\"code\">a1</code>, bounds inclusive</p>\n\n</div>\n", ["ADDRESS", "AND", "BOUNDS", "ENDING", "FROM", "INCLUSIVE", "MEM", "RANGE", "RETURNS", "STARTING", "VIEW"]);
add_ocaml_element("view", "Std.Memory.view", "value", "?word_size:Std.size ->\n  ?from:Std.addr ->\n  ?words:int -> Std.Memory.t -> Std.Memory.t Or_error.t", "Bap.Std.Memory.html#VALview", "<div class=\"info\">\n<p><code class=\"code\">view&nbsp;word_size&nbsp;~from&nbsp;~words&nbsp;mem</code> returns a new memory\n        that represents the specified region of memory <code class=\"code\">mem</code>.</p>\n\n</div>\n", ["COPY", "DEEP", "FROM", "FUNCTION", "MEM", "MEMORY", "NEW", "PERFORMS", "REGION", "REPRESENTS", "RETURNS", "SPECIFIED", "THAT", "THE", "VIEW", "WORDS", "WORD_SIZE"]);
add_ocaml_element("of_file", "Std.Memory.of_file", "value", "Std.endian ->\n  Std.addr -> string -> Std.Memory.t Or_error.t", "Bap.Std.Memory.html#VALof_file", "<div class=\"info\">\n<p><code class=\"code\">of_file&nbsp;endian&nbsp;start&nbsp;name</code> creates a memory region from file.</p>\n\n</div>\n", ["ADDRESS", "AND", "CREATES", "DATA", "ENDIAN", "FILE", "FOR", "FROM", "GIVEN", "MAPS", "MEMORY", "NAME", "OF_FILE", "READING", "REGION", "SPECIFIED", "START", "STARTING", "STORED", "STORING", "TAKES", "THE", "USING", "WITH", "WORDS"]);
add_ocaml_element("create", "Std.Memory.create", "value", "?pos:int ->\n  ?len:int ->\n  Std.endian ->\n  Std.addr ->\n  Bigstring.t -> Std.Memory.t Or_error.t", "Bap.Std.Memory.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?pos&nbsp;?len&nbsp;endian&nbsp;start&nbsp;data</code> creates a memory region.</p>\n\n</div>\n", ["ADDRESS", "AND", "BIGSTRING", "BYTE", "CAN", "COPIED", "CORRESPONDINGLY", "CREATE", "CREATES", "DATA", "DEFAULT", "DOWN", "ENDIAN", "FIRST", "LEN", "LENGTH", "MAPPING", "MAY", "MEMORY", "NARROW", "NOT", "OBJECT", "ORDER", "PARAMETERS", "POS", "PROVIDED", "REFERENCE", "REGION", "RETURNED", "SAME", "SPECIFIED", "START", "STRING", "THE", "USED", "USING", "VIEW"]);
add_ocaml_element("pp", "Std.Vector.pp", "value", "'a Std.printer -> 'a Std.Vector.t Std.printer", "Bap.Std.Vector.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_elem</code> creates a vector printer that uses <code class=\"code\">pp_elem</code> to\n        print elements.</p>\n\n</div>\n", ["CREATES", "ELEMENTS", "PP_ELEM", "PRINT", "PRINTER", "THAT", "USES", "VECTOR"]);
add_ocaml_element("index_with", "Std.Vector.index_with", "value", "?equal:('a -> 'a -> bool) -> default:int -> 'a Std.Vector.t -> 'a -> int", "Bap.Std.Vector.html#VALindex_with", "<div class=\"info\">\n<p><code class=\"code\">index_with&nbsp;?equal&nbsp;~default&nbsp;xs&nbsp;x</code> same as <code class=\"code\">index</code> but returns\n        the <code class=\"code\">default</code> value instead of <code class=\"code\"><span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["BUT", "DEFAULT", "EQUAL", "INDEX", "INDEX_WITH", "INSTEAD", "NONE", "RETURNS", "SAME", "THE", "VALUE"]);
add_ocaml_element("index_exn", "Std.Vector.index_exn", "value", "?equal:('a -> 'a -> bool) -> 'a Std.Vector.t -> 'a -> int", "Bap.Std.Vector.html#VALindex_exn", "<div class=\"info\">\n<p><code class=\"code\">index_exn&nbsp;?equal&nbsp;xs&nbsp;x</code> is the same as <code class=\"code\">index&nbsp;?equal&nbsp;xs&nbsp;x</code> but\n        an exception is thrown instead of <code class=\"code\"><span class=\"constructor\">None</span></code></p>\n\n</div>\n", ["BUT", "EQUAL", "EXCEPTION", "INDEX", "INDEX_EXN", "INSTEAD", "NONE", "SAME", "THE", "THROWN"]);
add_ocaml_element("index", "Std.Vector.index", "value", "?equal:('a -> 'a -> bool) -> 'a Std.Vector.t -> 'a -> int option", "Bap.Std.Vector.html#VALindex", "<div class=\"info\">\n<p><code class=\"code\">index&nbsp;?equal&nbsp;xs&nbsp;x</code> returns an index of the first element <code class=\"code\">p</code> of\n        <code class=\"code\">xs</code> for which <code class=\"code\">equal&nbsp;p&nbsp;x</code> is <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["BUILTIN", "DEFAULTS", "ELEMENT", "EQUAL", "EQUALITY", "FIRST", "FOR", "INDEX", "OCAML", "PARAMETER", "POLYMORPHIC", "RETURNS", "THE", "TRUE", "WHICH"]);
add_ocaml_element("foldi", "Std.Vector.foldi", "value", "'a Std.Vector.t -> init:'b -> f:(int -> 'b -> 'a -> 'b) -> 'b", "Bap.Std.Vector.html#VALfoldi", "<div class=\"info\">\n<p><code class=\"code\">foldi&nbsp;xs&nbsp;~init:s_0&nbsp;~f</code> computes <code class=\"code\">f&nbsp;n&nbsp;s_n&nbsp;x_n</code>, where <code class=\"code\">s_n&nbsp;=&nbsp;f<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(n-1)&nbsp;s_[n-1]&nbsp;x_[n-1]</code> and <code class=\"code\">n</code> is the number of elements in\n        <code class=\"code\">xs</code></p>\n\n</div>\n", ["AND", "COMPUTES", "ELEMENTS", "FOLDI", "INIT", "NUMBER", "S_0", "S_N", "THE", "WHERE", "X_N"]);
add_ocaml_element("iteri", "Std.Vector.iteri", "value", "'a Std.Vector.t -> f:(int -> 'a -> unit) -> unit", "Bap.Std.Vector.html#VALiteri", "<div class=\"info\">\n<p><code class=\"code\">iter&nbsp;xs&nbsp;~f</code> applies <code class=\"code\">f&nbsp;i&nbsp;x</code> for each <code class=\"code\">x_i</code> in <code class=\"code\">xs</code></p>\n\n</div>\n", ["APPLIES", "EACH", "FOR", "ITER", "X_I"]);
add_ocaml_element("findi", "Std.Vector.findi", "value", "'a Std.Vector.t -> f:(int -> 'a -> bool) -> (int * 'a) option", "Bap.Std.Vector.html#VALfindi", "<div class=\"info\">\n<p><code class=\"code\">findi&nbsp;xs&nbsp;~f</code> retuns an index <code class=\"code\">i</code> and a value <code class=\"code\">x</code> of the first\n        element of <code class=\"code\">xs</code>, for which <code class=\"code\">f&nbsp;i&nbsp;x</code> is <code class=\"code\"><span class=\"keyword\">true</span></code>.</p>\n\n</div>\n", ["AND", "ELEMENT", "FINDI", "FIRST", "FOR", "INDEX", "RETUNS", "THE", "TRUE", "VALUE", "WHICH"]);
add_ocaml_element("map_to_array", "Std.Vector.map_to_array", "value", "'a Std.Vector.t -> f:('a -> 'b) -> 'b array", "Bap.Std.Vector.html#VALmap_to_array", "<div class=\"info\">\n<p><code class=\"code\">map_to_array&nbsp;xs&nbsp;~f</code> copies data from <code class=\"code\">xs</code> to an array applying\n        <code class=\"code\">f</code> to each element.</p>\n\n</div>\n", ["ALSO", "APPLYING", "ARRAY", "CONTAINER", "COPIES", "DATA", "EACH", "ELEMENT", "FROM", "FUNCTION", "INTERFACE", "MAP_TO_ARRAY", "SEE", "TO_ARRAY"]);
add_ocaml_element("set", "Std.Vector.set", "value", "'a Std.Vector.t -> int -> 'a -> unit", "Bap.Std.Vector.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;vec&nbsp;n&nbsp;x</code> sets <code class=\"code\">n</code>'th element of a vector <code class=\"code\">vec</code> to <code class=\"code\">x</code> if\n        <code class=\"code\">n&nbsp;&lt;&nbsp;length&nbsp;vec</code> then raises exception</p>\n\n</div>\n", ["ELEMENT", "EXCEPTION", "LENGTH", "RAISES", "SET", "SETS", "THEN", "VEC", "VECTOR"]);
add_ocaml_element("get", "Std.Vector.get", "value", "'a Std.Vector.t -> int -> 'a", "Bap.Std.Vector.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;vec&nbsp;n</code> like <code class=\"code\">nth</code> but raises exception if index is out of\n        bounds</p>\n\n</div>\n", ["BOUNDS", "BUT", "EXCEPTION", "GET", "INDEX", "LIKE", "NTH", "OUT", "RAISES", "VEC"]);
add_ocaml_element("nth", "Std.Vector.nth", "value", "'a Std.Vector.t -> int -> 'a option", "Bap.Std.Vector.html#VALnth", "<div class=\"info\">\n<p><code class=\"code\">nth&nbsp;vec&nbsp;n</code> returns <code class=\"code\">n</code>'th element of vector <code class=\"code\">vec</code></p>\n\n</div>\n", ["ELEMENT", "NTH", "RETURNS", "VEC", "VECTOR"]);
add_ocaml_element("append", "Std.Vector.append", "value", "'a Std.Vector.t -> 'a -> unit", "Bap.Std.Vector.html#VALappend", "<div class=\"info\">\n<p><code class=\"code\">append&nbsp;xs&nbsp;x</code> appends <code class=\"code\">x</code> to the end of <code class=\"code\">xs</code></p>\n\n</div>\n", ["APPEND", "APPENDS", "END", "THE"]);
add_ocaml_element("create", "Std.Vector.create", "value", "?capacity:int -> 'a -> 'a Std.Vector.t", "Bap.Std.Vector.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?capacity&nbsp;default</code> creates an empty vector with a a given\n        <code class=\"code\">capacity</code>.</p>\n\n</div>\n", ["APPEND", "CAPACITY", "CREATE", "CREATES", "DEFAULT", "EMPTY", "EXPLICITELY", "GIVEN", "GUARANTEED", "INTO", "NEVER", "PUT", "SEEN", "SET", "THAT", "THE", "UNLESS", "USER", "VALUE", "VECTOR", "WILL", "WITH"]);
add_ocaml_element("filter", "Std.Dict.filter", "value", "Std.Dict.t -> f:(Std.value -> bool) -> Std.Dict.t", "Bap.Std.Dict.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;dict&nbsp;~f</code> returns a new dict, filtered with <code class=\"code\">f</code></p>\n\n</div>\n", ["DICT", "FILTER", "FILTERED", "NEW", "RETURNS", "WITH"]);
add_ocaml_element("data", "Std.Dict.data", "value", "Std.Dict.t -> Std.value Std.seq", "Bap.Std.Dict.html#VALdata", "<div class=\"info\">\n<p><code class=\"code\">data&nbsp;dict</code> is a sequence of all dict elements</p>\n\n</div>\n", ["ALL", "DATA", "DICT", "ELEMENTS", "SEQUENCE"]);
add_ocaml_element("to_sequence", "Std.Dict.to_sequence", "value", "Std.Dict.t -> (Std.Value.typeid * Std.value) Std.seq", "Bap.Std.Dict.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;dict</code> is a sequence of all tid value\n        entries</p>\n\n</div>\n", ["ALL", "DICT", "ENTRIES", "SEQUENCE", "TID", "TO_SEQUENCE", "VALUE"]);
add_ocaml_element("remove", "Std.Dict.remove", "value", "Std.Dict.t -> 'a Std.tag -> Std.Dict.t", "Bap.Std.Dict.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;map&nbsp;tag</code> returns a map without a value associated\n        with <code class=\"code\">tag</code></p>\n\n</div>\n", ["ASSOCIATED", "MAP", "REMOVE", "RETURNS", "TAG", "VALUE", "WITH", "WITHOUT"]);
add_ocaml_element("change", "Std.Dict.change", "value", "Std.Dict.t ->\n  'a Std.tag -> ('a option -> 'a option) -> Std.Dict.t", "Bap.Std.Dict.html#VALchange", "<div class=\"info\">\n<p><code class=\"code\">change&nbsp;map&nbsp;tag&nbsp;f</code> changes value.</p>\n\n</div>\n", ["CHANGE", "CHANGES", "MAP", "TAG", "VALUE"]);
add_ocaml_element("add", "Std.Dict.add", "value", "Std.Dict.t ->\n  'a Std.tag -> 'a -> [ `Duplicate | `Ok of Std.Dict.t ]", "Bap.Std.Dict.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;map&nbsp;tag&nbsp;x</code> adds new value</p>\n\n</div>\n", ["ADD", "ADDS", "MAP", "NEW", "TAG", "VALUE"]);
add_ocaml_element("find", "Std.Dict.find", "value", "Std.Dict.t -> 'a Std.tag -> 'a option", "Bap.Std.Dict.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;map&nbsp;tag</code> lookups value</p>\n\n</div>\n", ["FIND", "LOOKUPS", "MAP", "TAG", "VALUE"]);
add_ocaml_element("mem", "Std.Dict.mem", "value", "Std.Dict.t -> 'a Std.tag -> bool", "Bap.Std.Dict.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;map&nbsp;tag</code> checks membership</p>\n\n</div>\n", ["CHECKS", "MAP", "MEM", "MEMBERSHIP", "TAG"]);
add_ocaml_element("set", "Std.Dict.set", "value", "Std.Dict.t -> 'a Std.tag -> 'a -> Std.Dict.t", "Bap.Std.Dict.html#VALset", "<div class=\"info\">\n<p><code class=\"code\">set&nbsp;map&nbsp;tag&nbsp;x</code> inserts or update</p>\n\n</div>\n", ["INSERTS", "MAP", "SET", "TAG", "UPDATE"]);
add_ocaml_element("is_empty", "Std.Dict.is_empty", "value", "Std.Dict.t -> bool", "Bap.Std.Dict.html#VALis_empty", "<div class=\"info\">\n<p><code class=\"code\">is_empty&nbsp;map</code> true if is empty.</p>\n\n</div>\n", ["EMPTY", "IS_EMPTY", "MAP", "TRUE"]);
add_ocaml_element("empty", "Std.Dict.empty", "value", "Std.Dict.t", "Bap.Std.Dict.html#VALempty", "<div class=\"info\">\n<p>an empty instance</p>\n\n</div>\n", ["EMPTY", "INSTANCE"]);
add_ocaml_element("pp", "Std.Value.S.pp", "value", "Stdlib.Format.formatter -> Std.Value.S.t -> unit", "Bap.Std.Value.S.html#VALpp", "", []);
add_ocaml_element("default", "Std.Value.Match.default", "value", "(unit -> 's) -> 's Std.Value.Match.t", "Bap.Std.Value.Match.html#VALdefault", "<div class=\"info\">\n<p><code class=\"code\">default&nbsp;def</code> creates an empty matcher with default handler <code class=\"code\">def</code>.</p>\n\n</div>\n", ["CREATES", "DEF", "DEFAULT", "EMPTY", "HANDLER", "MATCHER", "WITH"]);
add_ocaml_element("case", "Std.Value.Match.case", "value", "'a Std.Value.tag ->\n  ('a -> 's) -> 's Std.Value.Match.t -> 's Std.Value.Match.t", "Bap.Std.Value.Match.html#VALcase", "<div class=\"info\">\n<p><code class=\"code\">case&nbsp;tag&nbsp;action&nbsp;matcher</code> adds an <code class=\"code\">action</code> to <code class=\"code\">matcher</code> that\n          will be invoked for values with a a given <code class=\"code\">tag</code></p>\n\n</div>\n", ["ACTION", "ADDS", "CASE", "FOR", "GIVEN", "INVOKED", "MATCHER", "TAG", "THAT", "VALUES", "WILL", "WITH"]);
add_ocaml_element("select", "Std.Value.Match.select", "value", "'s Std.Value.Match.t -> Std.value -> 's", "Bap.Std.Value.Match.html#VALselect", "<div class=\"info\">\n<p><code class=\"code\">select&nbsp;matcher&nbsp;x</code> applies <code class=\"code\">matcher</code> to value <code class=\"code\">x</code>.</p>\n\n</div>\n", ["APPLIES", "FLIP", "MATCHER", "SAME", "SELECT", "SWITCH", "THE", "VALUE"]);
add_ocaml_element("switch", "Std.Value.Match.switch", "value", "Std.value -> 's Std.Value.Match.t -> 's", "Bap.Std.Value.Match.html#VALswitch", "<div class=\"info\">\n<p><code class=\"code\">switch&nbsp;x&nbsp;matcher</code> applies <code class=\"code\">matcher</code> to value <code class=\"code\">x</code></p>\n\n</div>\n", ["APPLIES", "MATCHER", "SWITCH", "VALUE"]);
add_ocaml_element("typeid", "Std.Value.Tag.typeid", "value", "'a Std.Value.Tag.t -> Std.Value.typeid", "Bap.Std.Value.Tag.html#VALtypeid", "<div class=\"info\">\n<p><code class=\"code\">typeid&nbsp;t</code> returns a type identifier of a type tag <code class=\"code\">t</code>.</p>\n\n</div>\n", ["IDENTIFIER", "RETURNS", "TAG", "TYPE", "TYPEID"]);
add_ocaml_element("same_witness_exn", "Std.Value.Tag.same_witness_exn", "value", "'a Std.Value.Tag.t ->\n  'b Std.Value.Tag.t -> ('a, 'b) Type_equal.t", "Bap.Std.Value.Tag.html#VALsame_witness_exn", "<div class=\"info\">\n<p><code class=\"code\">same_witness_exn&nbsp;x&nbsp;y</code> is the same as <code class=\"code\">same_witness</code> but\n          raises exception if <code class=\"code\">not&nbsp;(same&nbsp;x&nbsp;y)</code>.</p>\n\n</div>\n", ["BUT", "EXCEPTION", "NOT", "RAISES", "SAME", "SAME_WITNESS", "SAME_WITNESS_EXN", "THE"]);
add_ocaml_element("same_witness", "Std.Value.Tag.same_witness", "value", "'a Std.Value.Tag.t ->\n  'b Std.Value.Tag.t -> ('a, 'b) Type_equal.t option", "Bap.Std.Value.Tag.html#VALsame_witness", "<div class=\"info\">\n<p><code class=\"code\">same_witness&nbsp;x&nbsp;y</code> returns a value witnessing that value tags\n          <code class=\"code\">x</code> and <code class=\"code\">y</code> has the same type.</p>\n\n</div>\n", ["AND", "HAS", "RETURNS", "SAME", "SAME_WITNESS", "TAGS", "THAT", "THE", "TYPE", "VALUE", "WITNESSING"]);
add_ocaml_element("same", "Std.Value.Tag.same", "value", "'a Std.Value.Tag.t -> 'b Std.Value.Tag.t -> bool", "Bap.Std.Value.Tag.html#VALsame", "<div class=\"info\">\n<p><code class=\"code\">same&nbsp;x&nbsp;y</code> is true if tags <code class=\"code\">x</code> and <code class=\"code\">y</code> have the same type.</p>\n\n</div>\n", ["AND", "HAVE", "SAME", "TAGS", "THE", "TRUE", "TYPE"]);
add_ocaml_element("name", "Std.Value.Tag.name", "value", "'a Std.Value.Tag.t -> string", "Bap.Std.Value.Tag.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;cons</code> returns a name of a constructor.</p>\n\n</div>\n", ["CONS", "CONSTRUCTOR", "NAME", "RETURNS"]);
add_ocaml_element("register", "Std.Value.Tag.register", "value", "name:Std.Value.literal ->\n  uuid:Std.Value.literal ->\n  (module Std.Value.S with type t = 'a) -> 'a Std.Value.tag", "Bap.Std.Value.Tag.html#VALregister", "", []);
add_ocaml_element("typeid", "Std.Value.typeid", "value", "Std.Value.t -> Std.Value.typeid", "Bap.Std.Value.html#VALtypeid", "<div class=\"info\">\n<p><code class=\"code\">typeid&nbsp;value</code> returns a type identifier of the <code class=\"code\">value</code></p>\n\n</div>\n", ["IDENTIFIER", "RETURNS", "THE", "TYPE", "TYPEID", "VALUE"]);
add_ocaml_element("tagname", "Std.Value.tagname", "value", "Std.Value.t -> string", "Bap.Std.Value.html#VALtagname", "<div class=\"info\">\n<p><code class=\"code\">tagname&nbsp;value</code> returns a constructor name of the <code class=\"code\">value</code></p>\n\n</div>\n", ["CONSTRUCTOR", "NAME", "RETURNS", "TAGNAME", "THE", "VALUE"]);
add_ocaml_element("get_exn", "Std.Value.get_exn", "value", "'a Std.Value.tag -> Std.Value.t -> 'a", "Bap.Std.Value.html#VALget_exn", "<div class=\"info\">\n<p><code class=\"code\">get_exn&nbsp;t&nbsp;v</code> extracts value created with <code class=\"code\">t</code> from the\n        variant.</p>\n\n</div>\n", ["CREATED", "EXCEPTION", "EXTRACTS", "FROM", "GET_EXN", "RAISES", "THE", "UNSPECIFIED", "VALUE", "VARIANT", "WASN", "WITH"]);
add_ocaml_element("get", "Std.Value.get", "value", "'a Std.Value.tag -> Std.Value.t -> 'a option", "Bap.Std.Value.html#VALget", "<div class=\"info\">\n<p><code class=\"code\">get&nbsp;cons</code> extracts a value associated with a constructor <code class=\"code\">cons</code>\n        (Essentially, performs a pattern match on the specified variant\n        branch)</p>\n\n</div>\n", ["ASSOCIATED", "BRANCH", "CONS", "CONSTRUCTOR", "ESSENTIALLY", "EXTRACTS", "GET", "MATCH", "PATTERN", "PERFORMS", "SPECIFIED", "THE", "VALUE", "VARIANT", "WITH"]);
add_ocaml_element("is", "Std.Value.is", "value", "'a Std.Value.tag -> Std.Value.t -> bool", "Bap.Std.Value.html#VALis", "<div class=\"info\">\n<p><code class=\"code\">is&nbsp;cons&nbsp;v</code> true if value <code class=\"code\">v</code> was constructed with constructor\n        <code class=\"code\">cons</code>, i.e., it is true only when <code class=\"code\">is_cons&nbsp;t&nbsp;(create&nbsp;t&nbsp;x)</code></p>\n\n</div>\n", ["CONS", "CONSTRUCTED", "CONSTRUCTOR", "CREATE", "IS_CONS", "ONLY", "TRUE", "VALUE", "WAS", "WHEN", "WITH"]);
add_ocaml_element("create", "Std.Value.create", "value", "'a Std.Value.tag -> 'a -> Std.Value.t", "Bap.Std.Value.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;cons&nbsp;x</code> creates a value using constructor <code class=\"code\">cons</code> and\n        argument <code class=\"code\">x</code></p>\n\n</div>\n", ["AND", "ARGUMENT", "CONS", "CONSTRUCTOR", "CREATE", "CREATES", "USING", "VALUE"]);
add_ocaml_element("endian", "Std.Arch.endian", "value", "Std.Arch.t -> Std.endian", "Bap.Std.Arch.html#VALendian", "<div class=\"info\">\n<p><code class=\"code\">endian&nbsp;arch</code> returns a word endianness of the <code class=\"code\">arch</code></p>\n\n</div>\n", ["ARCH", "ENDIAN", "ENDIANNESS", "RETURNS", "THE", "WORD"]);
add_ocaml_element("addr_size", "Std.Arch.addr_size", "value", "Std.Arch.t -> Std.addr_size", "Bap.Std.Arch.html#VALaddr_size", "<div class=\"info\">\n<p><code class=\"code\">addr_size&nbsp;arch</code> returns an address size for a a given <code class=\"code\">arch</code></p>\n\n</div>\n", ["ADDRESS", "ADDR_SIZE", "ARCH", "FOR", "GIVEN", "RETURNS", "SIZE"]);
add_ocaml_element("of_string", "Std.Arch.of_string", "value", "string -> Std.Arch.t option", "Bap.Std.Arch.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;s</code> will try to be clever and to capture all\n        commonly known synonyms, e.g., <code class=\"code\">of_string&nbsp;<span class=\"string\">\"i686\"</span></code> will\n        work</p>\n\n</div>\n", ["ALL", "AND", "CAPTURE", "CLEVER", "COMMONLY", "I686", "KNOWN", "OF_STRING", "SYNONYMS", "TRY", "WILL", "WORK"]);
add_ocaml_element("pp_adt", "Std.Stmt.pp_adt", "value", "Std.Stmt.t Std.printer", "Bap.Std.Stmt.html#VALpp_adt", "", []);
add_ocaml_element("eval", "Std.Stmt.eval", "value", "Std.Stmt.t list -> (#Std.Bili.context as 'a) -> 'a", "Bap.Std.Stmt.html#VALeval", "<div class=\"info\">\n<p><code class=\"code\">eval&nbsp;prog</code> eval BIL program under given context.</p>\n\n</div>\n", ["ALL", "BIL", "COMPUTATIONS", "CONTAINS", "CONTEXT", "EFFECTS", "EVAL", "GIVEN", "PROG", "PROGRAM", "RETURNS", "THE", "UNDER", "WHICH"]);
add_ocaml_element("free_vars", "Std.Stmt.free_vars", "value", "Std.Stmt.t -> Std.Var.Set.t", "Bap.Std.Stmt.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;stmt</code> returns a set of all unbound variables, that\n        occurs in <code class=\"code\">stmt</code>.</p>\n\n</div>\n", ["ALL", "FREE_VARS", "OCCURS", "RETURNS", "SET", "STMT", "THAT", "UNBOUND", "VARIABLES"]);
add_ocaml_element("fixpoint", "Std.Stmt.fixpoint", "value", "(Std.Stmt.t -> Std.Stmt.t) -> Std.Stmt.t -> Std.Stmt.t", "Bap.Std.Stmt.html#VALfixpoint", "<div class=\"info\">\n<p><code class=\"code\">fixpoint&nbsp;f&nbsp;x</code> applies transformation <code class=\"code\">f</code> until it reaches\n        fixpoint.</p>\n\n</div>\n", ["AND", "APPLIES", "BAP", "BIL", "FIXPOINT", "REACHES", "SEE", "STD", "TRANSFORMATION", "UNTIL"]);
add_ocaml_element("simpl", "Std.Stmt.simpl", "value", "?ignore:Std.Eff.t list -> Std.Stmt.t list -> Std.Stmt.t list", "Bap.Std.Stmt.html#VALsimpl", "<div class=\"info\">\n<p><code class=\"code\">simpl&nbsp;?ignore&nbsp;xs</code> recursively applies <code class=\"code\"><span class=\"constructor\">Exp</span>.simpl</code> and also\n        simplifies <code class=\"code\"><span class=\"keyword\">if</span></code> and <code class=\"code\"><span class=\"keyword\">while</span></code> expressions with statically known\n        conditionals, e.g., <code class=\"code\"><span class=\"keyword\">if</span>&nbsp;(<span class=\"keyword\">true</span>)&nbsp;xs&nbsp;ys</code> is simplified to <code class=\"code\">xs</code>,\n        <code class=\"code\"><span class=\"keyword\">while</span>&nbsp;(<span class=\"keyword\">false</span>)&nbsp;xs</code> is simplified to <code class=\"code\">xs</code>.</p>\n\n</div>\n", ["ALSO", "AND", "APPLIES", "CONDITIONALS", "EXP", "EXPRESSIONS", "FALSE", "IGNORE", "KNOWN", "RECURSIVELY", "SIMPL", "SIMPLIFIED", "SIMPLIFIES", "SINCE", "STATICALLY", "TRUE", "WHILE", "WITH"]);
add_ocaml_element("normalize", "Std.Stmt.normalize", "value", "?normalize_exp:bool -> Std.stmt list -> Std.stmt list", "Bap.Std.Stmt.html#VALnormalize", "<div class=\"info\">\n<p><code class=\"code\">normalize&nbsp;?normalize_exp&nbsp;xs</code> produces a normalized BIL\n        program with the same<code class=\"code\">^1</code> semantics but in the BIL normalized\n        form (BNF).</p>\n\n</div>\n", ["ABOVE", "ACCESSES", "ADDRESS", "ALL", "ALSO", "ANALYSIS", "AND", "APPLIED", "ARE", "ASSIGMENTS", "ASSIGNEMNT", "ASSIGNMENT", "BAP", "BELOW", "BIL", "BNF", "BNF1", "BNF2", "BOTH", "BUT", "BYTE", "CAN", "CHANGES", "CODE", "COMMITED", "COMPREHEND", "CONCRETE", "CONDITIONAL", "CONSIDER", "CONSIDERED", "CONSTRUCTOR", "CREATED", "CREATION", "DEFAULT", "DESCRIBED", "DESTINATIONS", "DEVICE", "DIFFERENT", "DISALLOWS", "DUPLICATE", "DURING", "EFFECT", "EFFECTIVELY", "EFFECTS", "ENDIAN", "ENDIANNES", "EQUAL", "ETC", "EVERY", "EXAMPLE", "EXP", "EXPR", "EXPRESSION", "EXPRESSIONS", "FAULTS", "FIRST", "FOLLOWING", "FOR", "FORM", "FORMAL", "FORMS", "FREE", "GENERATIVE", "GIVEN", "GUARANTEE", "HAND", "HARD", "HAS", "HAVE", "HOWEVER", "HUMAN", "IGNORED", "INSTRUCTION", "INTEGER", "JMP", "LANGUAGE", "LEAVING", "LET", "LOAD", "MAKE", "MAPPED", "MAY", "MEMORY", "MEM_T", "MIGHT", "MORE", "MOVE", "NEW", "NON", "NORMALIZATION", "NORMALIZE", "NORMALIZED", "NORMALIZE_EXP", "NOT", "OCCUR", "ONE", "ONLY", "OPERATION", "OPERATIONS", "PAGE", "PASS", "PERFORMED", "POSITIONS", "PRECONDITION", "PRESERVING", "PROCEDURE", "PRODUCES", "PROGRAM", "PROGRAMS", "PROPERTIES", "PROVIDES", "PUTS", "READ", "READABLE", "REGIONS", "REGISTER", "REQUEST", "REQUIRES", "RESTRICTIONS", "REWRITES", "REWRITTEN", "RHS", "RIGHT", "SAME", "SECOND", "SEMANTICS", "SENSE", "SIDE", "SINCE", "SIZE", "SIZES", "SOMETIMES", "STATMENT", "STORAGE", "STORE", "STRICT", "SUBEXPRESSIONS", "SUBSET", "SUCH", "TEMPORARY", "THAT", "THE", "THEM", "THERE", "THIS", "THUS", "TIMES", "TRANSFORMATION", "TREAT", "TRUE", "TWO", "TYPE", "TYPED", "VALID", "VALUE", "VAR", "VARIABLES", "VIA", "WELL", "WHERE", "WILL", "WITH", "YIELDS"]);
add_ocaml_element("is_referenced", "Std.Stmt.is_referenced", "value", "Std.var -> Std.Stmt.t -> bool", "Bap.Std.Stmt.html#VALis_referenced", "<div class=\"info\">\n<p><code class=\"code\">is_referenced&nbsp;x&nbsp;stmt</code> is true is <code class=\"code\">x</code> is used in the <code class=\"code\">stmt</code>\n        in any place other then right hand side of the assignment.</p>\n\n</div>\n", ["ANY", "ASSIGNMENT", "BAP", "BIL", "BUT", "DETAILS", "FALSE", "FOR", "HAND", "IS_REFERENCED", "MORE", "OTHER", "PLACE", "RIGHT", "SEE", "SIDE", "STD", "STMT", "THE", "THEN", "TRUE", "USED", "VAR"]);
add_ocaml_element("exists", "Std.Stmt.exists", "value", "unit #Std.Stmt.finder -> Std.Stmt.t -> bool", "Bap.Std.Stmt.html#VALexists", "<div class=\"info\">\n<p><code class=\"code\">exists&nbsp;finder&nbsp;stmt</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> iff <code class=\"code\">find&nbsp;finder&nbsp;stmt&nbsp;&lt;&gt;&nbsp;<span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["AND", "BAP", "BIL", "DETAILS", "EXISTS", "EXP", "FIND", "FINDER", "FOR", "IFF", "MORE", "NONE", "SEE", "STD", "STMT", "TRUE"]);
add_ocaml_element("find", "Std.Stmt.find", "value", "'a #Std.Stmt.finder -> Std.Stmt.t -> 'a option", "Bap.Std.Stmt.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;finder&nbsp;stmt</code> performs a lookup into the Bil statement.</p>\n\n</div>\n", ["AND", "BAP", "BIL", "DETAILS", "EXP", "FIND", "FINDER", "FOR", "INTO", "LOOKUP", "MORE", "PERFORMS", "SEE", "STATEMENT", "STD", "STMT", "THE"]);
add_ocaml_element("map", "Std.Stmt.map", "value", "#Std.Stmt.mapper -> Std.Stmt.t list -> Std.Stmt.t list", "Bap.Std.Stmt.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;mapper&nbsp;bil</code> applies <code class=\"code\">mapper</code> to the program <code class=\"code\">bil</code></p>\n\n</div>\n", ["APPLIES", "BIL", "MAP", "MAPPER", "PROGRAM", "THE"]);
add_ocaml_element("iter", "Std.Stmt.iter", "value", "unit #Std.Stmt.visitor -> Std.Stmt.t -> unit", "Bap.Std.Stmt.html#VALiter", "<div class=\"info\">\n<p><code class=\"code\">iter&nbsp;visitor&nbsp;stmt</code> iters over a <code class=\"code\">stmt</code> with a visitor.</p>\n\n</div>\n", ["AND", "BAP", "BIL", "DETAILS", "EXP", "FOR", "ITER", "ITERS", "MORE", "OVER", "SEE", "STD", "STMT", "VISITOR", "WITH"]);
add_ocaml_element("fold", "Std.Stmt.fold", "value", "'a #Std.Stmt.visitor -> init:'a -> Std.Stmt.t -> 'a", "Bap.Std.Stmt.html#VALfold", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;~init&nbsp;visitor&nbsp;stmt</code> folds a <code class=\"code\">stmt</code> with a visitor.</p>\n\n</div>\n", ["AND", "BAP", "BIL", "DETAILS", "EXP", "FOLD", "FOLDS", "FOR", "INIT", "MORE", "SEE", "STD", "STMT", "VISITOR", "WITH"]);
add_ocaml_element("pp_adt", "Std.Exp.pp_adt", "value", "Std.Exp.t Std.printer", "Bap.Std.Exp.html#VALpp_adt", "", []);
add_ocaml_element("eval", "Std.Exp.eval", "value", "Std.Exp.t -> Std.Bil.value", "Bap.Std.Exp.html#VALeval", "<div class=\"info\">\n<p><code class=\"code\">eval&nbsp;x</code> evaluate expression <code class=\"code\">x</code> to a value.</p>\n\n</div>\n", ["EVAL", "EVALUATE", "EXPRESSION", "VALUE"]);
add_ocaml_element("free_vars", "Std.Exp.free_vars", "value", "Std.Exp.t -> Std.Var.Set.t", "Bap.Std.Exp.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;exp</code> returns a set of all unbound variables, that\n        occurs in the expression <code class=\"code\">exp</code>.</p>\n\n</div>\n", ["ALL", "EXP", "EXPRESSION", "FREE_VARS", "OCCURS", "RETURNS", "SET", "THAT", "THE", "UNBOUND", "VARIABLES"]);
add_ocaml_element("fixpoint", "Std.Exp.fixpoint", "value", "(Std.Exp.t -> Std.Exp.t) -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.html#VALfixpoint", "<div class=\"info\">\n<p><code class=\"code\">fixpoint&nbsp;f</code> applies transformation <code class=\"code\">f</code> to <code class=\"code\">t</code> until it\n        reaches a fixpoint, i.e., such point <code class=\"code\">x</code> that\n        <code class=\"code\">f&nbsp;x</code> = <code class=\"code\">f&nbsp;(f&nbsp;x)</code>.</p>\n\n</div>\n", ["ALSO", "AND", "APPLIES", "BAP", "BIL", "FIXPOINT", "POINT", "REACHES", "SEE", "STD", "STMT", "SUCH", "THAT", "TRANSFORMATION", "UNTIL"]);
add_ocaml_element("fold_consts", "Std.Exp.fold_consts", "value", "Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.html#VALfold_consts", "<div class=\"info\">\n<p><code class=\"code\">fold_consts&nbsp;x</code> performs constant folding of the expression <code class=\"code\">x</code>.</p>\n\n</div>\n", ["ALL", "ALSO", "BAP", "BIL", "COMPUTABLE", "CONSTANT", "EXPRESSION", "EXPRESSIONS", "FOLDING", "FOLD_CONSTS", "INTEGERS", "PERFORMS", "REDUCES", "SEE", "STD", "THE"]);
add_ocaml_element("normalize_negatives", "Std.Exp.normalize_negatives", "value", "Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.html#VALnormalize_negatives", "<div class=\"info\">\n<p><code class=\"code\">normalize_negatives&nbsp;exp</code> returns an exp where all negative\n        additions are substituted by subtractions.</p>\n\n</div>\n", ["ADDITIONS", "ALL", "ARE", "BAP", "BIL", "DETAILS", "EXP", "FOR", "MORE", "NEGATIVE", "NORMALIZE_NEGATIVES", "RETURNS", "SEE", "STD", "SUBSTITUTED", "SUBTRACTIONS", "WHERE"]);
add_ocaml_element("is_referenced", "Std.Exp.is_referenced", "value", "Std.var -> Std.Exp.t -> bool", "Bap.Std.Exp.html#VALis_referenced", "<div class=\"info\">\n<p><code class=\"code\">is_referenced&nbsp;x&nbsp;exp</code> true if <code class=\"code\">exp</code> contains <code class=\"code\"><span class=\"constructor\">Var</span>&nbsp;x</code> on one of\n        its leafs.</p>\n\n</div>\n", ["ALSO", "AND", "BAP", "BIL", "CONTAINS", "EXP", "IS_REFERENCED", "ITS", "LEAFS", "ONE", "SEE", "STD", "STMT", "TRUE", "VAR"]);
add_ocaml_element("simpl", "Std.Exp.simpl", "value", "?ignore:Std.Eff.t list -> Std.exp -> Std.exp", "Bap.Std.Exp.html#VALsimpl", "<div class=\"info\">\n<p><code class=\"code\">simpl&nbsp;~ignore:effects&nbsp;x</code> iff expression <code class=\"code\">x</code> is well-typed,\n        then returns an expression with the same semantics as <code class=\"code\">x</code>,\n        that might smaller according to some metrics.</p>\n\n</div>\n", ["ABOVE", "ACCORDING", "AMOUNT", "AND", "ANY", "APPLIED", "ARE", "BEING", "BINARY", "BOOLEAN", "BOTH", "BRANCHES", "CAN", "CODE", "COMPARISON", "COMPLEMENT", "COMPUTATION", "COMPUTED", "CONSIDER", "CONSIDERED", "CONSTANT", "DEFAULT", "DEFAULTS", "DISJUNCTION", "DOESN", "DOUBLE", "EAX", "EFF", "EFFECT", "EFFECTS", "ELEMENT", "ELIMINATION", "EMPTY", "EQUAL", "EQUALITY", "EXCLUSIVE", "EXPRESIONS", "EXPRESSION", "EXPRESSIONS", "FALSE", "FOLDING", "FOLLOWING", "FROM", "HENCE", "IFF", "IGNORE", "KNOWN", "LIST", "MANIFEST", "METRICS", "MIGHT", "NEGATION", "NEUTRAL", "NOT", "NOTE", "ODD", "ONE", "OPERAND", "OPERANDS", "OPERATIONS", "OTHER", "PARAMETER", "PASSING", "PROPAGATION", "READ", "READS", "REDUCE", "REDUCED", "REDUCES", "REDUCTION", "REGISTER", "REMOVED", "RESULT", "RETURNS", "SAME", "SEMANTICS", "SIMPL", "SIMPLIFICATION", "SINCE", "SMALLER", "SOME", "SORT", "SPECIFIED", "STATICALLY", "SUBEXRESSION", "SUBSTITUTED", "SUBTITUTED", "SUBTRACTION", "SUCH", "SYMBOLIC", "SYNTACTICALLY", "THAN", "THAT", "THE", "THEN", "THOSE", "THUS", "TRANSFORMATIONS", "TRUE", "TWO", "TYPED", "UNARY", "WANT", "WELL", "WITH", "WOULDN", "XOR", "YOU", "ZERO"]);
add_ocaml_element("normalize", "Std.Exp.normalize", "value", "Std.exp -> Std.exp", "Bap.Std.Exp.html#VALnormalize", "<div class=\"info\">\n<p><code class=\"code\">normalize&nbsp;x</code> ensures no-lets and normalized-memory (BNF2).</p>\n\n</div>\n", ["ALL", "AND", "ARE", "BAP", "BNF1", "BNF2", "BREAKING", "BYTE", "CHAINS", "CONCATENATION", "DEFINITION", "DUPLICATE", "ENSURES", "EVEN", "EXPANDS", "EXPRESSION", "EXPRESSIONS", "FOR", "FUNCTION", "GENERATIVE", "INLINES", "INTO", "LET", "LETS", "LOADS", "MAY", "MEMORY", "MULTIBYTE", "NORMALIZE", "NORMALIZED", "NOT", "ONE", "PRECONDITION", "SEE", "SEMANTICS", "SINCE", "STD", "STMT", "STORES", "THAT", "THE", "THOSE", "THUS", "TYPED", "WELL"]);
add_ocaml_element("substitute", "Std.Exp.substitute", "value", "Std.exp -> Std.exp -> Std.exp -> Std.exp", "Bap.Std.Exp.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;pat&nbsp;rep&nbsp;x</code> subsitutes each occurence of an\n        expression <code class=\"code\">pat</code> in <code class=\"code\">x</code> with an expression <code class=\"code\">rep</code></p>\n\n</div>\n", ["EACH", "EXPRESSION", "OCCURENCE", "PAT", "REP", "SUBSITUTES", "SUBSTITUTE", "WITH"]);
add_ocaml_element("exists", "Std.Exp.exists", "value", "unit #Std.Exp.finder -> Std.Exp.t -> bool", "Bap.Std.Exp.html#VALexists", "<div class=\"info\">\n<p><code class=\"code\">exists&nbsp;finder&nbsp;exp</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">finder</code> finds\n        something.</p>\n\n</div>\n", ["ALSO", "AND", "BIL", "EXISTS", "EXP", "FINDER", "FINDS", "SEE", "SOMETHING", "TRUE"]);
add_ocaml_element("map", "Std.Exp.map", "value", "#Std.Exp.mapper -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;mapper&nbsp;exp</code> maps <code class=\"code\">exp</code> tree using provided <code class=\"code\">mapper</code>.</p>\n\n</div>\n", ["ALSO", "BIL", "EXP", "MAP", "MAPPER", "MAPS", "PROVIDED", "SEE", "TREE", "USING"]);
add_ocaml_element("find", "Std.Exp.find", "value", "'a #Std.Exp.finder -> Std.Exp.t -> 'a option", "Bap.Std.Exp.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;finder&nbsp;exp</code> returns <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;thing</code> if finder finds some\n        <code class=\"code\">thing</code>.</p>\n\n</div>\n", ["ALSO", "AND", "BAP", "BIL", "EXP", "FIND", "FINDER", "FINDS", "RETURNS", "SEE", "SOME", "STD", "STMT", "THING"]);
add_ocaml_element("iter", "Std.Exp.iter", "value", "unit #Std.Exp.visitor -> Std.Exp.t -> unit", "Bap.Std.Exp.html#VALiter", "<div class=\"info\">\n<p><code class=\"code\">iter&nbsp;visitor&nbsp;exp</code> iterates over all terms of the <code class=\"code\">exp</code> using\n        provided visitor.</p>\n\n</div>\n", ["ALL", "ALSO", "AND", "BAP", "BIL", "EXP", "ITER", "ITERATES", "OVER", "PROVIDED", "SEE", "STD", "STMT", "TERMS", "THE", "USING", "VISITOR"]);
add_ocaml_element("fold", "Std.Exp.fold", "value", "'a #Std.Exp.visitor -> init:'a -> Std.Exp.t -> 'a", "Bap.Std.Exp.html#VALfold", "<div class=\"info\">\n<p><code class=\"code\">fold&nbsp;visitor&nbsp;~init&nbsp;exp</code> traverse the <code class=\"code\">exp</code> tree with\n        provided <code class=\"code\">visitor</code>.</p>\n\n</div>\n", ["ACCESSED", "ADDR", "ADDRESS", "ADDRS", "ALL", "ALSO", "AND", "ARE", "BAP", "BIL", "COLLECT", "COLLECT_LOAD_ADDRESSES", "END", "ENTER_LOAD", "EXAMPLE", "EXP", "FOLD", "FOLLOWING", "FOR", "INHERIT", "INIT", "INT", "LET", "LIST", "LOAD", "MATCH", "MEM", "METHOD", "OBJECT", "OPERATION", "PROVIDED", "SEE", "STD", "STMT", "THAT", "THE", "TRAVERSE", "TREE", "VISITOR", "WILL", "WITH", "WORD"]);
add_ocaml_element("compute", "Std.Eff.compute", "value", "Std.exp -> Std.Eff.t", "Bap.Std.Eff.html#VALcompute", "", []);
add_ocaml_element("has_coeffects", "Std.Eff.has_coeffects", "value", "Std.Eff.t -> bool", "Bap.Std.Eff.html#VALhas_coeffects", "<div class=\"info\">\n<p><code class=\"code\">has_coeffects&nbsp;eff</code> if <code class=\"code\">loads&nbsp;eff</code> || <code class=\"code\">reads&nbsp;eff</code></p>\n\n</div>\n", ["EFF", "HAS_COEFFECTS", "LOADS", "READS"]);
add_ocaml_element("has_effects", "Std.Eff.has_effects", "value", "Std.Eff.t -> bool", "Bap.Std.Eff.html#VALhas_effects", "<div class=\"info\">\n<p><code class=\"code\">has_effects&nbsp;eff</code> if <code class=\"code\">stores&nbsp;eff</code> || <code class=\"code\">raises&nbsp;eff</code></p>\n\n</div>\n", ["EFF", "HAS_EFFECTS", "RAISES", "STORES"]);
add_ocaml_element("raises", "Std.Eff.raises", "value", "Std.Eff.t -> bool", "Bap.Std.Eff.html#VALraises", "<div class=\"info\">\n<p><code class=\"code\">raises&nbsp;eff</code> if <code class=\"code\">raise</code> in <code class=\"code\">eff</code></p>\n\n</div>\n", ["EFF", "RAISE", "RAISES"]);
add_ocaml_element("stores", "Std.Eff.stores", "value", "Std.Eff.t -> bool", "Bap.Std.Eff.html#VALstores", "<div class=\"info\">\n<p><code class=\"code\">stores&nbsp;eff</code> if <code class=\"code\">load</code> in <code class=\"code\">eff</code></p>\n\n</div>\n", ["EFF", "LOAD", "STORES"]);
add_ocaml_element("loads", "Std.Eff.loads", "value", "Std.Eff.t -> bool", "Bap.Std.Eff.html#VALloads", "<div class=\"info\">\n<p><code class=\"code\">loads&nbsp;eff</code> if <code class=\"code\">load</code> in <code class=\"code\">eff</code></p>\n\n</div>\n", ["EFF", "LOAD", "LOADS"]);
add_ocaml_element("reads", "Std.Eff.reads", "value", "Std.Eff.t -> bool", "Bap.Std.Eff.html#VALreads", "<div class=\"info\">\n<p><code class=\"code\">reads&nbsp;eff</code> if <code class=\"code\">read</code> in <code class=\"code\">eff</code></p>\n\n</div>\n", ["EFF", "READ", "READS"]);
add_ocaml_element("raise", "Std.Eff.raise", "value", "Std.Eff.t", "Bap.Std.Eff.html#VALraise", "<div class=\"info\">\n<p>an expression raises a CPU exception</p>\n\n</div>\n", ["CPU", "EXCEPTION", "EXPRESSION", "RAISES"]);
add_ocaml_element("store", "Std.Eff.store", "value", "Std.Eff.t", "Bap.Std.Eff.html#VALstore", "<div class=\"info\">\n<p>an expression stores a value in a memory</p>\n\n</div>\n", ["EXPRESSION", "MEMORY", "STORES", "VALUE"]);
add_ocaml_element("load", "Std.Eff.load", "value", "Std.Eff.t", "Bap.Std.Eff.html#VALload", "<div class=\"info\">\n<p>an expression loads a value from a memory</p>\n\n</div>\n", ["EXPRESSION", "FROM", "LOADS", "MEMORY", "VALUE"]);
add_ocaml_element("read", "Std.Eff.read", "value", "Std.Eff.t", "Bap.Std.Eff.html#VALread", "<div class=\"info\">\n<p>an expression reads a register (nonvirtual) variable.</p>\n\n</div>\n", ["EXPRESSION", "NONVIRTUAL", "READS", "REGISTER", "VARIABLE"]);
add_ocaml_element("none", "Std.Eff.none", "value", "Std.Eff.t", "Bap.Std.Eff.html#VALnone", "<div class=\"info\">\n<p>an expression doesn't have any effects</p>\n\n</div>\n", ["ANY", "DOESN", "EFFECTS", "EXPRESSION", "HAVE"]);
add_ocaml_element("same", "Std.Var.same", "value", "Std.Var.t -> Std.Var.t -> bool", "Bap.Std.Var.html#VALsame", "<div class=\"info\">\n<p><code class=\"code\">same&nbsp;x&nbsp;y</code> compares variables ignoring indices, i.e., for\n        variables <code class=\"code\">x</code> and <code class=\"code\">y</code> the <code class=\"code\">same&nbsp;x&nbsp;y</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> iff <code class=\"code\">equal<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(base&nbsp;x)&nbsp;(base&nbsp;y)</code></p>\n\n</div>\n", ["AND", "BASE", "COMPARES", "EQUAL", "FOR", "IFF", "IGNORING", "INDICES", "SAME", "THE", "TRUE", "VARIABLES"]);
add_ocaml_element("base", "Std.Var.base", "value", "Std.Var.t -> Std.Var.t", "Bap.Std.Var.html#VALbase", "<div class=\"info\">\n<p><code class=\"code\">base&nbsp;v</code> returns an original variable.</p>\n\n</div>\n", ["BASE", "ESSENTIALLY", "IDENTICAL", "ORIGINAL", "RETURNS", "VARIABLE", "WITH_INDEX"]);
add_ocaml_element("index", "Std.Var.index", "value", "Std.Var.t -> int", "Bap.Std.Var.html#VALindex", "<div class=\"info\">\n<p><code class=\"code\">index&nbsp;v</code> is an index of <code class=\"code\">v</code></p>\n\n</div>\n", ["INDEX"]);
add_ocaml_element("with_index", "Std.Var.with_index", "value", "Std.Var.t -> int -> Std.Var.t", "Bap.Std.Var.html#VALwith_index", "<div class=\"info\">\n<p><code class=\"code\">with_index&nbsp;v&nbsp;i</code> returns a variable, that is identical to\n        <code class=\"code\">v</code>, but with the index <code class=\"code\">i</code></p>\n\n</div>\n", ["BUT", "IDENTICAL", "INDEX", "RETURNS", "THAT", "THE", "VARIABLE", "WITH", "WITH_INDEX"]);
add_ocaml_element("is_virtual", "Std.Var.is_virtual", "value", "Std.Var.t -> bool", "Bap.Std.Var.html#VALis_virtual", "<div class=\"info\">\n<p><code class=\"code\">is_virtual&nbsp;v</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">v</code> is not physical</p>\n\n</div>\n", ["IS_VIRTUAL", "NOT", "PHYSICAL", "TRUE"]);
add_ocaml_element("is_physical", "Std.Var.is_physical", "value", "Std.Var.t -> bool", "Bap.Std.Var.html#VALis_physical", "<div class=\"info\">\n<p><code class=\"code\">is_physical&nbsp;v</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">v</code> represents a contents of a\n        physical register.</p>\n\n</div>\n", ["CONTENTS", "IS_PHYSICAL", "PHYSICAL", "REGISTER", "REPRESENTS", "TRUE"]);
add_ocaml_element("typ", "Std.Var.typ", "value", "Std.Var.t -> Std.typ", "Bap.Std.Var.html#VALtyp", "<div class=\"info\">\n<p><code class=\"code\">typ&nbsp;var</code> returns a type assosiated with variable</p>\n\n</div>\n", ["ASSOSIATED", "RETURNS", "TYP", "TYPE", "VAR", "VARIABLE", "WITH"]);
add_ocaml_element("name", "Std.Var.name", "value", "Std.Var.t -> string", "Bap.Std.Var.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;var</code> returns a name assosiated with variable</p>\n\n</div>\n", ["ASSOSIATED", "NAME", "RETURNS", "VAR", "VARIABLE", "WITH"]);
add_ocaml_element("create", "Std.Var.create", "value", "?is_virtual:bool -> ?fresh:bool -> string -> Std.typ -> Std.Var.t", "Bap.Std.Var.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;?register&nbsp;?fresh&nbsp;name&nbsp;typ</code> creates a variable with\n        a given <code class=\"code\">name</code> and <code class=\"code\">typ</code>e.</p>\n\n</div>\n", ["ADDED", "AND", "ARTIFICIALLY", "CORRESPOND", "CREATE", "CREATED", "CREATES", "DEFAULTS", "DOESN", "EQUAL", "FALSE", "FRESH", "GIVEN", "HAS", "IS_VIRTUAL", "LOCATION", "MAKING", "MEMORY", "MIXED", "NAME", "NEWLY", "PHYSICAL", "PROGRAM", "REGISTER", "SALT", "SOME", "THE", "THEN", "TRUE", "TYP", "TYPE", "UNIQUE", "VARIABLE", "VERSION", "VIRTUAL", "WAS", "WITH"]);
add_ocaml_element("expect", "Std.Type.Error.expect", "value", "Std.typ -> got:Std.typ -> 'a", "Bap.Std.Type.Error.html#VALexpect", "<div class=\"info\">\n<p><code class=\"code\">expect&nbsp;t&nbsp;~got:u</code> raises <code class=\"code\"><span class=\"constructor\">T</span>&nbsp;(bap_type&nbsp;~exp:t&nbsp;~got:t)</code></p>\n\n</div>\n", ["BAP_TYPE", "EXP", "EXPECT", "GOT", "RAISES"]);
add_ocaml_element("wrong_cast", "Std.Type.Error.wrong_cast", "value", "unit -> 'a", "Bap.Std.Type.Error.html#VALwrong_cast", "<div class=\"info\">\n<p><code class=\"code\">wrong_cast&nbsp;()</code> raises <code class=\"code\"><span class=\"constructor\">T</span>&nbsp;bad_cast</code></p>\n\n</div>\n", ["BAD_CAST", "RAISES", "WRONG_CAST"]);
add_ocaml_element("expect_imm", "Std.Type.Error.expect_imm", "value", "unit -> 'a", "Bap.Std.Type.Error.html#VALexpect_imm", "<div class=\"info\">\n<p><code class=\"code\">expect_imm&nbsp;()</code> raises <code class=\"code\"><span class=\"constructor\">T</span>&nbsp;bad_imm</code></p>\n\n</div>\n", ["BAD_IMM", "EXPECT_IMM", "RAISES"]);
add_ocaml_element("expect_mem", "Std.Type.Error.expect_mem", "value", "unit -> 'a", "Bap.Std.Type.Error.html#VALexpect_mem", "<div class=\"info\">\n<p><code class=\"code\">expect_mem&nbsp;()</code> raises <code class=\"code\"><span class=\"constructor\">T</span>&nbsp;bad_mem</code></p>\n\n</div>\n", ["BAD_MEM", "EXPECT_MEM", "RAISES"]);
add_ocaml_element("bad_type", "Std.Type.Error.bad_type", "value", "exp:Std.typ -> got:Std.typ -> Std.Type.Error.t", "Bap.Std.Type.Error.html#VALbad_type", "<div class=\"info\">\n<p><code class=\"code\">bad_type&nbsp;~exp&nbsp;~got</code> error happens when we expect a value of\n          type <code class=\"code\">exp</code> but got a value of type <code class=\"code\">got</code>.</p>\n\n</div>\n", ["BAD_TYPE", "BUT", "ERROR", "EXP", "EXPECT", "GOT", "HAPPENS", "TYPE", "VALUE", "WHEN"]);
add_ocaml_element("bad_cast", "Std.Type.Error.bad_cast", "value", "Std.Type.Error.t", "Bap.Std.Type.Error.html#VALbad_cast", "<div class=\"info\">\n<p><code class=\"code\">bad_cast</code> error occurs when parameters to the cast operation\n          are not valid, or if a store operand is not of a word size</p>\n\n</div>\n", ["ARE", "BAD_CAST", "CAST", "ERROR", "NOT", "OCCURS", "OPERAND", "OPERATION", "PARAMETERS", "SIZE", "STORE", "THE", "VALID", "WHEN", "WORD"]);
add_ocaml_element("bad_imm", "Std.Type.Error.bad_imm", "value", "Std.Type.Error.t", "Bap.Std.Type.Error.html#VALbad_imm", "<div class=\"info\">\n<p><code class=\"code\">bad_imm</code> error occurs when a value of type <code class=\"code\">imm</code> was expected</p>\n\n</div>\n", ["BAD_IMM", "ERROR", "EXPECTED", "IMM", "OCCURS", "TYPE", "VALUE", "WAS", "WHEN"]);
add_ocaml_element("bad_mem", "Std.Type.Error.bad_mem", "value", "Std.Type.Error.t", "Bap.Std.Type.Error.html#VALbad_mem", "<div class=\"info\">\n<p><code class=\"code\">bad_mem</code> error occurs when a value of type <code class=\"code\">mem</code> was expected</p>\n\n</div>\n", ["BAD_MEM", "ERROR", "EXPECTED", "MEM", "OCCURS", "TYPE", "VALUE", "WAS", "WHEN"]);
add_ocaml_element("check", "Std.Type.check", "value", "Std.bil -> (unit, Std.Type.error) Result.t", "Bap.Std.Type.html#VALcheck", "<div class=\"info\">\n<p><code class=\"code\">check&nbsp;bil</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;()</code> if <code class=\"code\">bil</code> is well-typed, otherwise the\n        first type error <code class=\"code\">e</code> is returned as <code class=\"code\"><span class=\"constructor\">Error</span>&nbsp;e</code>.</p>\n\n</div>\n", ["BIL", "CHECK", "ERROR", "FIRST", "OTHERWISE", "RETURNED", "SINCE", "THE", "TYPE", "TYPED", "WELL"]);
add_ocaml_element("infer_exn", "Std.Type.infer_exn", "value", "Std.exp -> Std.Type.t", "Bap.Std.Type.html#VALinfer_exn", "<div class=\"info\">\n<p><code class=\"code\">infer_exn&nbsp;t</code> is the same as <code class=\"code\">ok_exn&nbsp;@@&nbsp;infer_exn&nbsp;t</code>.</p>\n\n</div>\n", ["INFER_EXN", "OK_EXN", "SAME", "SINCE", "THE"]);
add_ocaml_element("infer", "Std.Type.infer", "value", "Std.exp -> (Std.Type.t, Std.Type.error) Result.t", "Bap.Std.Type.html#VALinfer", "<div class=\"info\">\n<p><code class=\"code\">infer&nbsp;exp</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;t</code> if <code class=\"code\">exp</code> is well-typed and has type <code class=\"code\">t</code>\n        otherwise <code class=\"code\"><span class=\"constructor\">Error</span>&nbsp;e</code>.</p>\n\n</div>\n", ["AND", "ERROR", "EXP", "HAS", "INFER", "OTHERWISE", "SINCE", "TYPE", "TYPED", "WELL"]);
add_ocaml_element("mem", "Std.Type.mem", "value", "Std.addr_size -> Std.size -> Std.Type.t", "Bap.Std.Type.html#VALmem", "<div class=\"info\">\n<p><code class=\"code\">mem&nbsp;n&nbsp;m</code> denotes a type of memory storages with\n        the element type <code class=\"code\">imm&nbsp;m</code> and the index type <code class=\"code\">imm&nbsp;n</code></p>\n\n</div>\n", ["AND", "DENOTES", "ELEMENT", "IMM", "INDEX", "MEM", "MEMORY", "STORAGES", "THE", "TYPE", "WITH"]);
add_ocaml_element("imm", "Std.Type.imm", "value", "int -> Std.Type.t", "Bap.Std.Type.html#VALimm", "<div class=\"info\">\n<p><code class=\"code\">imm&nbsp;n</code> denotes a type of bitvectors of the given bitwidth</p>\n\n</div>\n", ["BITVECTORS", "BITWIDTH", "DENOTES", "GIVEN", "IMM", "THE", "TYPE"]);
add_ocaml_element("name", "Std.Bil.Pass.name", "value", "Std.Bil.pass -> string", "Bap.Std.Bil.Pass.html#VALname", "<div class=\"info\">\n<p><code class=\"code\">name&nbsp;p</code> returns the name of the given pass.</p>\n\n</div>\n", ["GIVEN", "NAME", "PASS", "RETURNS", "THE"]);
add_ocaml_element("normalize", "Std.Bil.Trie.normalize", "value", "?subst:(exp * exp) list -> stmt list -> Std.Bil.Trie.normalized_bil", "Bap.Std.Bil.Trie.html#VALnormalize", "<div class=\"info\">\n<p><code class=\"code\">normalize&nbsp;?subst&nbsp;bil</code> normalize BIL.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "BEFORE", "BIL", "BUT", "COMPARED", "COMPARISON", "DIFFERENCES", "DIFFERENTLY", "EACH", "EFFECT", "EQUAL", "EXPRESSION", "FOLLOWING", "FST", "IMMEDIATE", "NOMINALLY", "NORMALIZATION", "NORMALIZE", "OCCURENCE", "PROVIDED", "REDUCE", "SIMPLIFIED", "SND", "STILL", "SUBST", "SUBSTITUTE", "SYNTACTIC", "THE", "THEN", "VALUES", "VARIABLES", "WILL"]);
add_ocaml_element("succ", "Std.Bil.Result.Id.succ", "value", "Std.Bil.Result.t -> Std.Bil.Result.t", "Bap.Std.Bil.Result.Id.html#VALsucc", "<div class=\"info\">\n<p><code class=\"code\">succ&nbsp;x</code> successor</p>\n\n</div>\n", ["SUCC", "SUCCESSOR"]);
add_ocaml_element("zero", "Std.Bil.Result.Id.zero", "value", "Std.Bil.Result.t", "Bap.Std.Bil.Result.Id.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero</code> identifier</p>\n\n</div>\n", ["IDENTIFIER", "ZERO"]);
add_ocaml_element("value", "Std.Bil.Result.value", "value", "Std.Bil.Result.t -> Std.Bil.value", "Bap.Std.Bil.Result.html#VALvalue", "<div class=\"info\">\n<p>returns result's value</p>\n\n</div>\n", ["RESULT", "RETURNS", "VALUE"]);
add_ocaml_element("id", "Std.Bil.Result.id", "value", "Std.Bil.Result.t -> Std.Bil.Result.id", "Bap.Std.Bil.Result.html#VALid", "<div class=\"info\">\n<p>returns result's identifier</p>\n\n</div>\n", ["IDENTIFIER", "RESULT", "RETURNS"]);
add_ocaml_element("word", "Std.Bil.Result.word", "value", "Std.word -> Std.Bil.Result.id -> Std.Bil.Result.t", "Bap.Std.Bil.Result.html#VALword", "<div class=\"info\">\n<p><code class=\"code\">word&nbsp;w&nbsp;id</code> creates a result with the given <code class=\"code\">id</code> and\n          word <code class=\"code\">w</code> as a value</p>\n\n</div>\n", ["AND", "CREATES", "GIVEN", "RESULT", "THE", "VALUE", "WITH", "WORD"]);
add_ocaml_element("storage", "Std.Bil.Result.storage", "value", "Std.Bil.storage -> Std.Bil.Result.id -> Std.Bil.Result.t", "Bap.Std.Bil.Result.html#VALstorage", "<div class=\"info\">\n<p><code class=\"code\">storage&nbsp;s&nbsp;id</code> creates a result with the given <code class=\"code\">id</code> and\n          storage <code class=\"code\">s</code> as a value</p>\n\n</div>\n", ["AND", "CREATES", "GIVEN", "RESULT", "STORAGE", "THE", "VALUE", "WITH"]);
add_ocaml_element("undefined", "Std.Bil.Result.undefined", "value", "Std.Bil.Result.id -> Std.Bil.Result.t", "Bap.Std.Bil.Result.html#VALundefined", "<div class=\"info\">\n<p><code class=\"code\">undefined&nbsp;id</code> creates a result with the given <code class=\"code\">id</code> and\n          undefined value</p>\n\n</div>\n", ["AND", "CREATES", "GIVEN", "RESULT", "THE", "UNDEFINED", "VALUE", "WITH"]);
add_ocaml_element("cast", "Std.Bil.Apply.cast", "value", "cast -> int -> Std.word -> Std.word", "Bap.Std.Bil.Apply.html#VALcast", "<div class=\"info\">\n<p><code class=\"code\">cast&nbsp;t&nbsp;s&nbsp;x</code> casts <code class=\"code\">x</code> using the cast type <code class=\"code\">t</code> to the given\n          size <code class=\"code\">s</code>.</p>\n\n</div>\n", ["CAST", "CASTS", "EXPRESSION", "GIVEN", "INT", "PRECONDITION", "SHALL", "SIZE", "THE", "TYPE", "TYPED", "USING", "WELL"]);
add_ocaml_element("unop", "Std.Bil.Apply.unop", "value", "unop -> Std.word -> Std.word", "Bap.Std.Bil.Apply.html#VALunop", "<div class=\"info\">\n<p><code class=\"code\">unop&nbsp;op&nbsp;x</code> applies the unary operation <code class=\"code\">op</code> to <code class=\"code\">x</code>.</p>\n\n</div>\n", ["APPLIES", "EXPRESSION", "INT", "OPERATION", "PRECONDITION", "SHALL", "THE", "TYPED", "UNARY", "UNOP", "WELL"]);
add_ocaml_element("binop", "Std.Bil.Apply.binop", "value", "binop -> Std.word -> Std.word -> Std.word", "Bap.Std.Bil.Apply.html#VALbinop", "<div class=\"info\">\n<p><code class=\"code\">binop&nbsp;op&nbsp;x&nbsp;y</code> applies the binary operation <code class=\"code\">op</code> to <code class=\"code\">x</code> and\n          <code class=\"code\">y</code>.</p>\n\n</div>\n", ["AND", "APPLIES", "BINARY", "BINOP", "EXPRESSION", "INT", "OPERATION", "PRECONDITION", "SHALL", "THE", "TYPED", "WELL"]);
add_ocaml_element("(^)", "Std.Bil.Infix.(^)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(^)", "<div class=\"info\">\n<p><code class=\"code\">a&nbsp;^&nbsp;b&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Concat</span>&nbsp;(a,b)</code></p>\n\n</div>\n", ["CONCAT"]);
add_ocaml_element("(>=$)", "Std.Bil.Infix.(>=$)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(>=$)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&gt;=$&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">SLE</span>,y,x)</code></p>\n\n</div>\n", ["BINOP", "SLE"]);
add_ocaml_element("(<=$)", "Std.Bil.Infix.(<=$)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(<=$)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;=$&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">SLE</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "SLE"]);
add_ocaml_element("(>$)", "Std.Bil.Infix.(>$)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(>$)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&gt;$&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">SLT</span>,y,x)</code></p>\n\n</div>\n", ["BINOP", "SLT"]);
add_ocaml_element("(<$)", "Std.Bil.Infix.(<$)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(<$)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;$&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">SLT</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "SLT"]);
add_ocaml_element("(>=)", "Std.Bil.Infix.(>=)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(>=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;=&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">LE</span>,y,x)</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("(<=)", "Std.Bil.Infix.(<=)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(<=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;=&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">LE</span>,x,y)</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("(>)", "Std.Bil.Infix.(>)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(>)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&gt;&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Binop</span>(<span class=\"constructor\">LT</span>,y,x)&nbsp;</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("(<)", "Std.Bil.Infix.(<)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(<)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;&lt;&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">LT</span>,x,y)</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("(<>)", "Std.Bil.Infix.(<>)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(<>)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;=&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">NEQ</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "NEQ"]);
add_ocaml_element("(=)", "Std.Bil.Infix.(=)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;=&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">EQ</span>,x,y)</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("lnot", "Std.Bil.Infix.lnot", "value", "exp -> exp", "Bap.Std.Bil.Infix.html#VALlnot", "<div class=\"info\">\n<p><code class=\"code\">lnot&nbsp;x&nbsp;=&nbsp;<span class=\"constructor\">UnOp</span>&nbsp;(<span class=\"constructor\">NOT</span>,x,y)</code></p>\n\n</div>\n", ["LNOT", "NOT", "UNOP"]);
add_ocaml_element("(lxor)", "Std.Bil.Infix.(lxor)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(lxor)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lxor</span>&nbsp;y&nbsp;=&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">XOR</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "LXOR", "XOR"]);
add_ocaml_element("(lor)", "Std.Bil.Infix.(lor)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(lor)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lor</span>&nbsp;y&nbsp;=&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">OR</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "LOR"]);
add_ocaml_element("(land)", "Std.Bil.Infix.(land)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(land)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">land</span>&nbsp;y&nbsp;=&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">AND</span>,x,y)</code></p>\n\n</div>\n", ["AND", "BINOP", "LAND"]);
add_ocaml_element("(asr)", "Std.Bil.Infix.(asr)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(asr)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">asr</span>&nbsp;y&nbsp;=&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">ARSHIFT</span>,x,y)</code></p>\n\n</div>\n", ["ARSHIFT", "ASR", "BINOP"]);
add_ocaml_element("(lsr)", "Std.Bil.Infix.(lsr)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(lsr)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lsr</span>&nbsp;y&nbsp;=&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">RSHIFT</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "LSR", "RSHIFT"]);
add_ocaml_element("(lsl)", "Std.Bil.Infix.(lsl)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(lsl)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lsl</span>&nbsp;y&nbsp;=&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">LSHIFT</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "LSHIFT", "LSL"]);
add_ocaml_element("(%$)", "Std.Bil.Infix.(%$)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(%$)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;%$&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">SMOD</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "SMOD"]);
add_ocaml_element("(mod)", "Std.Bil.Infix.(mod)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(mod)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">mod</span>&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">MOD</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "MOD"]);
add_ocaml_element("(/$)", "Std.Bil.Infix.(/$)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(/$)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;/$&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">SDIVIDE</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "SDIVIDE"]);
add_ocaml_element("(/)", "Std.Bil.Infix.(/)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(/)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;/&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">DIVIDE</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "DIVIDE"]);
add_ocaml_element("( * )", "Std.Bil.Infix.( * )", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL( * )", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;*&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">TIMES</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "TIMES"]);
add_ocaml_element("(-)", "Std.Bil.Infix.(-)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(-)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;-&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(<span class=\"constructor\">MINUS</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "MINUS"]);
add_ocaml_element("(+)", "Std.Bil.Infix.(+)", "value", "exp -> exp -> exp", "Bap.Std.Bil.Infix.html#VAL(+)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;+&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>&nbsp;(<span class=\"constructor\">PLUS</span>,x,y)</code></p>\n\n</div>\n", ["BINOP", "PLUS"]);
add_ocaml_element("(:=)", "Std.Bil.Infix.(:=)", "value", "var -> exp -> stmt", "Bap.Std.Bil.Infix.html#VAL(:=)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;:=&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Move</span>&nbsp;(x,y)</code></p>\n\n</div>\n", ["MOVE"]);
add_ocaml_element("passes", "Std.Bil.passes", "value", "unit -> Std.Bil.pass list", "Bap.Std.Bil.html#VALpasses", "<div class=\"info\">\n<p><code class=\"code\">passes&nbsp;()</code> returns all currently registered passes.</p>\n\n</div>\n", ["ALL", "CURRENTLY", "PASSES", "REGISTERED", "RETURNS", "SINCE"]);
add_ocaml_element("select_passes", "Std.Bil.select_passes", "value", "Std.Bil.pass list -> unit", "Bap.Std.Bil.html#VALselect_passes", "<div class=\"info\">\n<p><code class=\"code\">select_passes&nbsp;passes</code> select the <code class=\"code\">passes</code> for the BIL transformation pipeline.</p>\n\n</div>\n", ["ABOUT", "BAP", "BIL", "FOR", "INFORMATION", "MORE", "PASSES", "PIPELINE", "REGISTER_PASS", "SEE", "SELECT", "SELECT_PASSES", "SINCE", "STD", "THE", "TRANSFORMATION"]);
add_ocaml_element("register_pass", "Std.Bil.register_pass", "value", "?desc:string ->\n  string -> (Std.Bil.t -> Std.Bil.t) -> Std.Bil.pass", "Bap.Std.Bil.html#VALregister_pass", "<div class=\"info\">\n<p><code class=\"code\">register_pass&nbsp;~desc&nbsp;name&nbsp;pass</code> provides a pass to the BIL transformation pipeline.</p>\n\n</div>\n", ["AFTER", "ALL", "APPLIED", "ARCH", "ARCHITECTURE", "ARE", "BASED", "BIL", "CAN", "DEFAULT", "DESC", "DETECTED", "EACH", "EMBEDDED", "FIXED", "FOR", "FUNCTION", "INFO", "INTERFACE", "INTO", "LIFT", "LIFTING", "LOOP", "MODULES", "NAME", "ORDER", "PASS", "PASSES", "PIPELINE", "PLUGIN", "POINT", "PROCEDURE", "PROJECT", "PROVIDED", "PROVIDES", "REACHED", "REGISTER", "REGISTER_PASS", "SELECTED", "SELECTION", "SELECTIVELY", "SELECT_PASSES", "SINCE", "SOME", "SUBSCRIBING", "TARGET", "THAT", "THE", "TRANSFORMATION", "UNTIL", "USEFUL", "USER", "VARIABLE", "WELL", "WERE", "YOU"]);
add_ocaml_element("prune_dead_virtuals", "Std.Bil.prune_dead_virtuals", "value", "stmt list -> stmt list", "Bap.Std.Bil.html#VALprune_dead_virtuals", "<div class=\"info\">\n<p><code class=\"code\">prune_dead_virtuals&nbsp;bil</code> removes definitions of virtual variables that are\n        not live in the provided <code class=\"code\">bil</code> program.</p>\n\n</div>\n", ["ANALYSIS", "AND", "ANY", "APPROXIMATES", "ARE", "ASSUME", "BIL", "BODY", "DEFINITION", "DEFINITIONS", "DEPENDS", "DOESN", "LIVE", "LOCATIONS", "LOOP", "LOOPS", "MEMORY", "NOT", "OCCURS", "OVER", "PROGRAM", "PROVIDED", "PRUNE_DEAD_VIRTUALS", "REMOVAL", "REMOVE", "REMOVES", "REPRESENT", "SAFE", "SINCE", "TEMPORARIES", "THAT", "THE", "THEIR", "THUS", "TRACK", "USED", "VARIABLES", "VIRTUAL", "WHICH", "WHILE", "WON"]);
add_ocaml_element("propagate_consts", "Std.Bil.propagate_consts", "value", "stmt list -> stmt list", "Bap.Std.Bil.html#VALpropagate_consts", "<div class=\"info\">\n<p><code class=\"code\">propagate_consts&nbsp;bil</code> propagates consts from their reaching definitions.</p>\n\n</div>\n", ["ANALYSIS", "AND", "BIL", "COMPUTE", "COMPUTES", "CONSTS", "CYCLES", "DEFINITION", "DEFINITIONS", "DOESN", "FROM", "IGNORES", "IMPLEMENTATION", "INFERENCE", "LOCATIONS", "MEET", "MEMORY", "OVER", "OVERAPPROXIMATES", "PATHS", "PROPAGATES", "PROPAGATE_CONSTS", "REACHING", "SINCE", "SOLUTION", "STYLE", "THE", "THEIR", "USING", "WHILE"]);
add_ocaml_element("fixpoint", "Std.Bil.fixpoint", "value", "(stmt list -> stmt list) -> stmt list -> stmt list", "Bap.Std.Bil.html#VALfixpoint", "<div class=\"info\">\n<p><code class=\"code\">fixpoint&nbsp;f</code> applies transformation <code class=\"code\">f</code> until fixpoint is\n        reached.</p>\n\n</div>\n", ["APPLIES", "ARBITRARY", "CONTAINS", "CYCLE", "CYCLES", "FIXPOINT", "NON", "ORBIT", "POINT", "REACHED", "STOP", "THE", "THEN", "TRANSFORMATION", "TRIVIAL", "UNTIL", "WILL"]);
add_ocaml_element("fold_consts", "Std.Bil.fold_consts", "value", "stmt list -> stmt list", "Bap.Std.Bil.html#VALfold_consts", "<div class=\"info\">\n<p><code class=\"code\">fold_consts</code> evaluates constant expressions and statements.</p>\n\n</div>\n", ["AND", "CONSTANT", "EVALUATES", "EXPRESSIONS", "FOLD_CONSTS", "STATEMENTS"]);
add_ocaml_element("free_vars", "Std.Bil.free_vars", "value", "stmt list -> Std.Bil.vars", "Bap.Std.Bil.html#VALfree_vars", "<div class=\"info\">\n<p><code class=\"code\">free_vars&nbsp;bil</code> returns a set of free variables in program\n        <code class=\"code\">bil</code>.</p>\n\n</div>\n", ["BIL", "BOUND", "CONSIDERED", "EXPRESSION", "FREE", "FREE_VARS", "LET", "NOT", "PRECEDING", "PROGRAM", "RETURNS", "SET", "STATEMENT", "VARIABLE", "VARIABLES", "WITH"]);
add_ocaml_element("substitute_var", "Std.Bil.substitute_var", "value", "var -> exp -> stmt list -> stmt list", "Bap.Std.Bil.html#VALsubstitute_var", "<div class=\"info\">\n<p><code class=\"code\">substitute_var&nbsp;x&nbsp;y&nbsp;p</code> substitutes all free occurences of\n        variable <code class=\"code\">x</code> in program <code class=\"code\">p</code> by expression <code class=\"code\">y</code>.</p>\n\n</div>\n", ["ALL", "BOUND", "BOUNDED", "EXPRESSION", "FREE", "LET", "NOT", "OCCURENCES", "PRECEDING", "PROGRAM", "STATEMENT", "SUBSTITUTES", "SUBSTITUTE_VAR", "VARIABLE", "WITH"]);
add_ocaml_element("substitute", "Std.Bil.substitute", "value", "exp -> exp -> stmt list -> stmt list", "Bap.Std.Bil.html#VALsubstitute", "<div class=\"info\">\n<p><code class=\"code\">substitute&nbsp;x&nbsp;y&nbsp;p</code> substitutes each occurrence of expression <code class=\"code\">x</code> by\n        expression <code class=\"code\">y</code> in program <code class=\"code\">p</code>.</p>\n\n</div>\n", ["EACH", "EXPRESSION", "MNEMONIC", "OCCURRENCE", "ORDER", "OUT", "PROGRAM", "RECALL", "REMEMBER", "SED", "SUBSTITUTE", "SUBSTITUTES", "SYNTAX", "THE"]);
add_ocaml_element("normalize_negatives", "Std.Bil.normalize_negatives", "value", "stmt list -> stmt list", "Bap.Std.Bil.html#VALnormalize_negatives", "<div class=\"info\">\n<p><code class=\"code\">normalize_negatives&nbsp;p</code> transform <code class=\"code\">x&nbsp;+&nbsp;y</code> to <code class=\"code\">x&nbsp;-&nbsp;abs(y)</code> if <code class=\"code\">y&nbsp;&lt;&nbsp;0</code></p>\n\n</div>\n", ["ABS", "NORMALIZE_NEGATIVES", "TRANSFORM"]);
add_ocaml_element("prune_unreferenced", "Std.Bil.prune_unreferenced", "value", "?such_that:(var -> bool) ->\n  ?physicals:bool -> ?virtuals:bool -> stmt list -> stmt list", "Bap.Std.Bil.html#VALprune_unreferenced", "<div class=\"info\">\n<p><code class=\"code\">prune_unreferenced&nbsp;?physicals&nbsp;?virtuals&nbsp;?such_that&nbsp;p</code> remove\n        all assignments to variables that are not used in the program\n        <code class=\"code\">p</code>.</p>\n\n</div>\n", ["ABSOLUTELY", "ADDED", "AFTER", "ALL", "AND", "ARE", "ARTIFICIALLY", "ASSIGNMENT", "ASSIGNMENTS", "BAP", "BELOW", "DEFAULT", "DESCRIBED", "FOR", "GENERAL", "INFORMATION", "IS_PHYSICAL", "IS_VIRTUAL", "ITS", "KIND", "LEXICAL", "LIVE", "LOCAL", "LOCATIONS", "MATCHES", "MEMORY", "MORE", "NOT", "NOTE", "NOTHING", "ONE", "ONLY", "OPTIMIZATION", "OPTION", "OUT", "PASSING", "PHYSICAL", "PHYSICALLY", "PHYSICALS", "PROGRAM", "PRUNED", "PRUNE_UNREFERENCED", "REFERENCED", "REGISTERS", "REMOVE", "REPRESENTED", "SCOPE", "SEE", "SPECIFIED", "STD", "SUCH", "SUCH_THAT", "SURE", "THAT", "THE", "THIS", "TRUE", "UNLESS", "UNREFERENCED", "UNSOUND", "USED", "USER", "VALUES", "VAR", "VARIABLE", "VARIABLES", "VIRTUAL", "VIRTUALS", "WERE", "WHICH", "WILL", "YOU"]);
add_ocaml_element("is_assigned", "Std.Bil.is_assigned", "value", "?strict:bool -> var -> stmt list -> bool", "Bap.Std.Bil.html#VALis_assigned", "<div class=\"info\">\n<p><code class=\"code\">is_assigned&nbsp;x&nbsp;p</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if there exists such <code class=\"code\"><span class=\"constructor\">Move</span></code>\n        statement, that <code class=\"code\">x</code> occures on the left side of it.</p>\n\n</div>\n", ["ACCOUNTED", "ARE", "ASSIGNMENTS", "DEFAULT", "EXISTS", "FALSE", "IS_ASSIGNED", "LEFT", "MOVE", "OCCURES", "ONLY", "SIDE", "STATEMENT", "STRICT", "SUCH", "THAT", "THE", "THEN", "THERE", "TRUE", "UNCONDITIONAL"]);
add_ocaml_element("is_referenced", "Std.Bil.is_referenced", "value", "var -> stmt list -> bool", "Bap.Std.Bil.html#VALis_referenced", "<div class=\"info\">\n<p><code class=\"code\">is_referenced&nbsp;x&nbsp;p</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">x</code> is referenced in some\n        expression or statement in program <code class=\"code\">p</code>, before it is\n        assigned.</p>\n\n</div>\n", ["ASSIGNED", "BEFORE", "EXPRESSION", "IS_REFERENCED", "PROGRAM", "REFERENCED", "SOME", "STATEMENT", "TRUE"]);
add_ocaml_element("concat", "Std.Bil.concat", "value", "exp -> exp -> exp", "Bap.Std.Bil.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat&nbsp;x&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Concat</span>&nbsp;(x,y)</code></p>\n\n</div>\n", ["CONCAT"]);
add_ocaml_element("extract", "Std.Bil.extract", "value", "hi:int -> lo:int -> exp -> exp", "Bap.Std.Bil.html#VALextract", "<div class=\"info\">\n<p><code class=\"code\">extract&nbsp;~hi&nbsp;~lo&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Extract</span>&nbsp;(hi,lo,x)</code></p>\n\n</div>\n", ["EXTRACT"]);
add_ocaml_element("ite", "Std.Bil.ite", "value", "if_:exp -> then_:exp -> else_:exp -> exp", "Bap.Std.Bil.html#VALite", "<div class=\"info\">\n<p><code class=\"code\">ite&nbsp;~if_:cond&nbsp;~then_:e1&nbsp;~else_:e2&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Ite</span>&nbsp;(cond,e1,e2)</code></p>\n\n</div>\n", ["COND", "ELSE_", "IF_", "ITE", "THEN_"]);
add_ocaml_element("unknown", "Std.Bil.unknown", "value", "string -> typ -> exp", "Bap.Std.Bil.html#VALunknown", "<div class=\"info\">\n<p><code class=\"code\">unknown&nbsp;msg&nbsp;typ&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Unknown</span>(msg,typ)</code></p>\n\n</div>\n", ["MSG", "TYP", "UNKNOWN"]);
add_ocaml_element("let_", "Std.Bil.let_", "value", "var -> exp -> exp -> exp", "Bap.Std.Bil.html#VALlet_", "<div class=\"info\">\n<p><code class=\"code\">let_&nbsp;var&nbsp;value&nbsp;expr&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Let</span>(var,value,expr)</code></p>\n\n</div>\n", ["EXPR", "LET", "LET_", "VALUE", "VAR"]);
add_ocaml_element("cast", "Std.Bil.cast", "value", "cast -> int -> exp -> exp", "Bap.Std.Bil.html#VALcast", "<div class=\"info\">\n<p><code class=\"code\">cast&nbsp;t&nbsp;w&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Cast</span>&nbsp;(t,w,x)</code></p>\n\n</div>\n", ["CAST"]);
add_ocaml_element("int", "Std.Bil.int", "value", "Std.word -> exp", "Bap.Std.Bil.html#VALint", "<div class=\"info\">\n<p><code class=\"code\">int&nbsp;w&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Int</span>&nbsp;w</code></p>\n\n</div>\n", ["INT"]);
add_ocaml_element("var", "Std.Bil.var", "value", "var -> exp", "Bap.Std.Bil.html#VALvar", "<div class=\"info\">\n<p><code class=\"code\">var&nbsp;v&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Var</span>&nbsp;v</code></p>\n\n</div>\n", ["VAR"]);
add_ocaml_element("unop", "Std.Bil.unop", "value", "unop -> exp -> exp", "Bap.Std.Bil.html#VALunop", "<div class=\"info\">\n<p><code class=\"code\">unop&nbsp;op&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">UnOp</span>(op,x)</code></p>\n\n</div>\n", ["UNOP"]);
add_ocaml_element("binop", "Std.Bil.binop", "value", "binop -> exp -> exp -> exp", "Bap.Std.Bil.html#VALbinop", "<div class=\"info\">\n<p><code class=\"code\">binop&nbsp;op&nbsp;x&nbsp;y&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">BinOp</span>(op,x,y)</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("store", "Std.Bil.store", "value", "mem:exp -> addr:exp -> exp -> Std.endian -> Std.size -> exp", "Bap.Std.Bil.html#VALstore", "<div class=\"info\">\n<p><code class=\"code\">store&nbsp;~mem&nbsp;~addr&nbsp;exp&nbsp;endian&nbsp;size&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Store</span>(mem,addr,endian,size)</code></p>\n\n</div>\n", ["ADDR", "ENDIAN", "EXP", "MEM", "SIZE", "STORE"]);
add_ocaml_element("load", "Std.Bil.load", "value", "mem:exp -> addr:exp -> Std.endian -> Std.size -> exp", "Bap.Std.Bil.html#VALload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;~mem&nbsp;~addr&nbsp;endian&nbsp;size&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Load</span>&nbsp;(mem,addr,endian,size)</code></p>\n\n</div>\n", ["ADDR", "ENDIAN", "LOAD", "MEM", "SIZE"]);
add_ocaml_element("not", "Std.Bil.not", "value", "unop", "Bap.Std.Bil.html#VALnot", "<div class=\"info\">\n<p><code class=\"code\">not&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">NOT</span></code></p>\n\n</div>\n", ["NOT"]);
add_ocaml_element("neg", "Std.Bil.neg", "value", "unop", "Bap.Std.Bil.html#VALneg", "<div class=\"info\">\n<p><code class=\"code\">neg&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">NEG</span></code></p>\n\n</div>\n", ["NEG"]);
add_ocaml_element("sle", "Std.Bil.sle", "value", "binop", "Bap.Std.Bil.html#VALsle", "<div class=\"info\">\n<p><code class=\"code\">sle&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">SLE</span></code></p>\n\n</div>\n", ["SLE"]);
add_ocaml_element("slt", "Std.Bil.slt", "value", "binop", "Bap.Std.Bil.html#VALslt", "<div class=\"info\">\n<p><code class=\"code\">slt&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">SLT</span></code></p>\n\n</div>\n", ["SLT"]);
add_ocaml_element("le", "Std.Bil.le", "value", "binop", "Bap.Std.Bil.html#VALle", "<div class=\"info\">\n<p><code class=\"code\">le&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">LE</span></code></p>\n\n</div>\n", []);
add_ocaml_element("lt", "Std.Bil.lt", "value", "binop", "Bap.Std.Bil.html#VALlt", "<div class=\"info\">\n<p><code class=\"code\">lt&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">LT</span></code></p>\n\n</div>\n", []);
add_ocaml_element("neq", "Std.Bil.neq", "value", "binop", "Bap.Std.Bil.html#VALneq", "<div class=\"info\">\n<p><code class=\"code\">neq&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">NEQ</span></code></p>\n\n</div>\n", ["NEQ"]);
add_ocaml_element("eq", "Std.Bil.eq", "value", "binop", "Bap.Std.Bil.html#VALeq", "<div class=\"info\">\n<p><code class=\"code\">eq&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">EQ</span></code></p>\n\n</div>\n", []);
add_ocaml_element("bit_xor", "Std.Bil.bit_xor", "value", "binop", "Bap.Std.Bil.html#VALbit_xor", "<div class=\"info\">\n<p><code class=\"code\">bit_xor&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">XOR</span></code></p>\n\n</div>\n", ["BIT_XOR", "XOR"]);
add_ocaml_element("bit_or", "Std.Bil.bit_or", "value", "binop", "Bap.Std.Bil.html#VALbit_or", "<div class=\"info\">\n<p><code class=\"code\">bit_or&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">OR</span></code></p>\n\n</div>\n", ["BIT_OR"]);
add_ocaml_element("bit_and", "Std.Bil.bit_and", "value", "binop", "Bap.Std.Bil.html#VALbit_and", "<div class=\"info\">\n<p><code class=\"code\">bit_and&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">AND</span></code></p>\n\n</div>\n", ["AND", "BIT_AND"]);
add_ocaml_element("arshift", "Std.Bil.arshift", "value", "binop", "Bap.Std.Bil.html#VALarshift", "<div class=\"info\">\n<p><code class=\"code\">arshift&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">ARSHIFT</span></code></p>\n\n</div>\n", ["ARSHIFT"]);
add_ocaml_element("rshift", "Std.Bil.rshift", "value", "binop", "Bap.Std.Bil.html#VALrshift", "<div class=\"info\">\n<p><code class=\"code\">rshift&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">RSHIFT</span></code></p>\n\n</div>\n", ["RSHIFT"]);
add_ocaml_element("lshift", "Std.Bil.lshift", "value", "binop", "Bap.Std.Bil.html#VALlshift", "<div class=\"info\">\n<p><code class=\"code\">lshift&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">LSHIFT</span></code></p>\n\n</div>\n", ["LSHIFT"]);
add_ocaml_element("smodulo", "Std.Bil.smodulo", "value", "binop", "Bap.Std.Bil.html#VALsmodulo", "<div class=\"info\">\n<p><code class=\"code\">smodulo&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">SMOD</span></code></p>\n\n</div>\n", ["SMOD", "SMODULO"]);
add_ocaml_element("modulo", "Std.Bil.modulo", "value", "binop", "Bap.Std.Bil.html#VALmodulo", "<div class=\"info\">\n<p><code class=\"code\">modulo&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">MOD</span></code></p>\n\n</div>\n", ["MOD", "MODULO"]);
add_ocaml_element("sdivide", "Std.Bil.sdivide", "value", "binop", "Bap.Std.Bil.html#VALsdivide", "<div class=\"info\">\n<p><code class=\"code\">sdivide&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">SDIVIDE</span></code></p>\n\n</div>\n", ["SDIVIDE"]);
add_ocaml_element("divide", "Std.Bil.divide", "value", "binop", "Bap.Std.Bil.html#VALdivide", "<div class=\"info\">\n<p><code class=\"code\">divide&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">DIVIDE</span></code></p>\n\n</div>\n", ["DIVIDE"]);
add_ocaml_element("times", "Std.Bil.times", "value", "binop", "Bap.Std.Bil.html#VALtimes", "<div class=\"info\">\n<p><code class=\"code\">times&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">TIMES</span></code></p>\n\n</div>\n", ["TIMES"]);
add_ocaml_element("minus", "Std.Bil.minus", "value", "binop", "Bap.Std.Bil.html#VALminus", "<div class=\"info\">\n<p><code class=\"code\">minus&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">MINUS</span></code></p>\n\n</div>\n", ["MINUS"]);
add_ocaml_element("plus", "Std.Bil.plus", "value", "binop", "Bap.Std.Bil.html#VALplus", "<div class=\"info\">\n<p><code class=\"code\">plus&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">PLUS</span></code></p>\n\n</div>\n", ["PLUS"]);
add_ocaml_element("low", "Std.Bil.low", "value", "cast", "Bap.Std.Bil.html#VALlow", "<div class=\"info\">\n<p><code class=\"code\">low&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">LOW</span></code></p>\n\n</div>\n", ["LOW"]);
add_ocaml_element("high", "Std.Bil.high", "value", "cast", "Bap.Std.Bil.html#VALhigh", "<div class=\"info\">\n<p><code class=\"code\">high&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">HIGH</span></code></p>\n\n</div>\n", ["HIGH"]);
add_ocaml_element("signed", "Std.Bil.signed", "value", "cast", "Bap.Std.Bil.html#VALsigned", "<div class=\"info\">\n<p><code class=\"code\">signed&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">SIGNED</span></code></p>\n\n</div>\n", ["SIGNED"]);
add_ocaml_element("unsigned", "Std.Bil.unsigned", "value", "cast", "Bap.Std.Bil.html#VALunsigned", "<div class=\"info\">\n<p><code class=\"code\">unsigned&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">UNSIGNED</span></code></p>\n\n</div>\n", ["UNSIGNED"]);
add_ocaml_element("cpuexn", "Std.Bil.cpuexn", "value", "int -> stmt", "Bap.Std.Bil.html#VALcpuexn", "<div class=\"info\">\n<p><code class=\"code\">cpuexn&nbsp;number&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">CpuExn</span>&nbsp;number</code></p>\n\n</div>\n", ["CPUEXN", "NUMBER"]);
add_ocaml_element("if_", "Std.Bil.if_", "value", "exp -> stmt list -> stmt list -> stmt", "Bap.Std.Bil.html#VALif_", "<div class=\"info\">\n<p><code class=\"code\">if_&nbsp;cond&nbsp;s1&nbsp;s2&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">If</span>(cond,s1,s2)</code></p>\n\n</div>\n", ["COND", "IF_"]);
add_ocaml_element("while_", "Std.Bil.while_", "value", "exp -> stmt list -> stmt", "Bap.Std.Bil.html#VALwhile_", "<div class=\"info\">\n<p><code class=\"code\">while_&nbsp;cond&nbsp;stmts&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">While</span>&nbsp;(cond,stmts)</code></p>\n\n</div>\n", ["COND", "STMTS", "WHILE", "WHILE_"]);
add_ocaml_element("special", "Std.Bil.special", "value", "string -> stmt", "Bap.Std.Bil.html#VALspecial", "<div class=\"info\">\n<p><code class=\"code\">special&nbsp;msg&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Special</span>&nbsp;msg</code></p>\n\n</div>\n", ["MSG", "SPECIAL"]);
add_ocaml_element("jmp", "Std.Bil.jmp", "value", "exp -> stmt", "Bap.Std.Bil.html#VALjmp", "<div class=\"info\">\n<p><code class=\"code\">jmp&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Jmp</span>&nbsp;x</code></p>\n\n</div>\n", ["JMP"]);
add_ocaml_element("move", "Std.Bil.move", "value", "var -> exp -> stmt", "Bap.Std.Bil.html#VALmove", "<div class=\"info\">\n<p><code class=\"code\">move&nbsp;v&nbsp;x&nbsp;<span class=\"keywordsign\">-&gt;</span>&nbsp;<span class=\"constructor\">Move</span>&nbsp;(v,x)</code></p>\n\n</div>\n", ["MOVE"]);
add_ocaml_element("string_of_cast", "Std.Bil.string_of_cast", "value", "cast -> string", "Bap.Std.Bil.html#VALstring_of_cast", "<div class=\"info\">\n<p><code class=\"code\">string_of_cast&nbsp;t</code> is a textual representation of a cast type</p>\n\n</div>\n", ["CAST", "REPRESENTATION", "SINCE", "STRING_OF_CAST", "TEXTUAL", "TYPE"]);
add_ocaml_element("string_of_unop", "Std.Bil.string_of_unop", "value", "unop -> string", "Bap.Std.Bil.html#VALstring_of_unop", "<div class=\"info\">\n<p><code class=\"code\">string_of_unop&nbsp;op</code> is a textual representation of <code class=\"code\">op</code>.</p>\n\n</div>\n", ["REPRESENTATION", "SINCE", "STRING_OF_UNOP", "TEXTUAL"]);
add_ocaml_element("string_of_binop", "Std.Bil.string_of_binop", "value", "binop -> string", "Bap.Std.Bil.html#VALstring_of_binop", "<div class=\"info\">\n<p><code class=\"code\">string_of_binop&nbsp;op</code> is a textual representation of <code class=\"code\">op</code>.</p>\n\n</div>\n", ["REPRESENTATION", "SINCE", "STRING_OF_BINOP", "TEXTUAL"]);
add_ocaml_element("pp_cast", "Std.Bil.pp_cast", "value", "cast Std.printer", "Bap.Std.Bil.html#VALpp_cast", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_cast&nbsp;t</code> prints a cast type <code class=\"code\">t</code></p>\n\n</div>\n", ["CAST", "PP_CAST", "PRINTF", "PRINTS", "SINCE", "TYPE"]);
add_ocaml_element("pp_unop", "Std.Bil.pp_unop", "value", "unop Std.printer", "Bap.Std.Bil.html#VALpp_unop", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_unop&nbsp;op</code> prints an unary operation <code class=\"code\">op</code></p>\n\n</div>\n", ["OPERATION", "PP_UNOP", "PRINTF", "PRINTS", "UNARY"]);
add_ocaml_element("pp_binop", "Std.Bil.pp_binop", "value", "binop Std.printer", "Bap.Std.Bil.html#VALpp_binop", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_binop&nbsp;op</code> prints a binary operation <code class=\"code\">op</code>.</p>\n\n</div>\n", ["BINARY", "OPERATION", "PP_BINOP", "PRINTF", "PRINTS"]);
add_ocaml_element("memref", "Std.Addr.memref", "value", "?disp:int ->\n  ?index:int -> ?scale:Std.size -> Std.addr -> Std.addr", "Bap.Std.Addr.html#VALmemref", "<div class=\"info\">\n<p><code class=\"code\">memref&nbsp;?disp&nbsp;?index&nbsp;?scale&nbsp;base</code> mimics a memory reference syntax\n        in gas assembler,   <code class=\"code\">dis(base,index,scale)</code>\n        assembler operation.</p>\n\n</div>\n", ["ADDRESS", "ASSEMBLER", "BASE", "DIS", "DISP", "GAS", "INDEX", "MEMORY", "MEMREF", "MIMICS", "OPERATION", "REFERENCE", "RETURNS", "SCALE", "SYNTAX"]);
add_ocaml_element("of_word_size", "Std.Bitvector.Int_err.of_word_size", "value", "Word_size.t ->\n  Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALof_word_size", "<div class=\"info\">\n<p><code class=\"code\">of_word_size&nbsp;w</code> creates a lifter for a specified word size\n          <code class=\"code\">w</code>, i.e.</p>\n\n</div>\n", ["CREATES", "EITHER", "FOR", "I32", "I64", "LIFTER", "OF_WORD_SIZE", "SIZE", "SPECIFIED", "WORD"]);
add_ocaml_element("int", "Std.Bitvector.Int_err.int", "value", "int -> Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALint", "<div class=\"info\">\n<p><code class=\"code\">int&nbsp;w&nbsp;v</code> will be <code class=\"code\"><span class=\"constructor\">Ok</span></code> if <code class=\"code\">v</code> has width <code class=\"code\">w</code></p>\n\n</div>\n", ["HAS", "INT", "WIDTH", "WILL"]);
add_ocaml_element("i64", "Std.Bitvector.Int_err.i64", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALi64", "<div class=\"info\">\n<p><code class=\"code\">i64&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;x</code> iff <code class=\"code\">bitwidth&nbsp;x&nbsp;=&nbsp;64</code></p>\n\n</div>\n", ["BITWIDTH", "I64", "IFF"]);
add_ocaml_element("i32", "Std.Bitvector.Int_err.i32", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALi32", "<div class=\"info\">\n<p><code class=\"code\">i32&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;x</code> iff <code class=\"code\">bitwidth&nbsp;x&nbsp;=&nbsp;32</code></p>\n\n</div>\n", ["BITWIDTH", "I32", "IFF"]);
add_ocaml_element("i16", "Std.Bitvector.Int_err.i16", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALi16", "<div class=\"info\">\n<p><code class=\"code\">i16&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;x</code> iff <code class=\"code\">bitwidth&nbsp;x&nbsp;=&nbsp;16</code></p>\n\n</div>\n", ["BITWIDTH", "I16", "IFF"]);
add_ocaml_element("i8", "Std.Bitvector.Int_err.i8", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALi8", "<div class=\"info\">\n<p><code class=\"code\">i8&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;x</code> iff <code class=\"code\">bitwidth&nbsp;x&nbsp;=&nbsp;8</code></p>\n\n</div>\n", ["BITWIDTH", "IFF"]);
add_ocaml_element("i4", "Std.Bitvector.Int_err.i4", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALi4", "<div class=\"info\">\n<p><code class=\"code\">i4&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;x</code> iff <code class=\"code\">bitwidth&nbsp;x&nbsp;=&nbsp;4</code></p>\n\n</div>\n", ["BITWIDTH", "IFF"]);
add_ocaml_element("i1", "Std.Bitvector.Int_err.i1", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VALi1", "<div class=\"info\">\n<p><code class=\"code\">i1&nbsp;x</code> is <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;x</code> iff <code class=\"code\">bitwidth&nbsp;x&nbsp;=&nbsp;1</code></p>\n\n</div>\n", ["BITWIDTH", "IFF"]);
add_ocaml_element("(!$)", "Std.Bitvector.Int_err.(!$)", "value", "Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.Int_err.html#VAL(!$)", "<div class=\"info\">\n<p><code class=\"code\">!$v</code> lifts <code class=\"code\">v</code> to an Or_error monad.</p>\n\n</div>\n", ["ESSENTIALLY", "LIFTS", "MONAD", "OR_ERROR", "SAME", "THE"]);
add_ocaml_element("is_non_positive", "Std.Bitvector.is_non_positive", "value", "Std.Bitvector.t -> bool", "Bap.Std.Bitvector.html#VALis_non_positive", "<div class=\"info\">\n<p><code class=\"code\">is_non_positive&nbsp;x</code> is true if <code class=\"code\">x</code> is less than zero.</p>\n\n</div>\n", ["CONTRADICTION", "IS_NON_POSITIVE", "LESS", "NOT", "SIGNED", "THAN", "TRUE", "ZERO"]);
add_ocaml_element("is_negative", "Std.Bitvector.is_negative", "value", "Std.Bitvector.t -> bool", "Bap.Std.Bitvector.html#VALis_negative", "<div class=\"info\">\n<p><code class=\"code\">is_negative&nbsp;x</code> is true if <code class=\"code\">x</code> is strictly less than zero.</p>\n\n</div>\n", ["CONTRADICTION", "IS_NEGATIVE", "LESS", "NOT", "SIGNED", "STRICTLY", "THAN", "TRUE", "ZERO"]);
add_ocaml_element("is_non_negative", "Std.Bitvector.is_non_negative", "value", "Std.Bitvector.t -> bool", "Bap.Std.Bitvector.html#VALis_non_negative", "<div class=\"info\">\n<p><code class=\"code\">is_non_negative&nbsp;x</code> is true if <code class=\"code\">x</code> is greater than or equal to\n        zero.</p>\n\n</div>\n", ["EQUAL", "GREATER", "IS_NON_NEGATIVE", "TAUTOLOGY", "THAN", "TRUE", "UNSIGNED", "ZERO"]);
add_ocaml_element("is_positive", "Std.Bitvector.is_positive", "value", "Std.Bitvector.t -> bool", "Bap.Std.Bitvector.html#VALis_positive", "<div class=\"info\">\n<p><code class=\"code\">is_positive&nbsp;x</code> is true if <code class=\"code\">x</code> is greater than zero.</p>\n\n</div>\n", ["ALWAYS", "GREATER", "IS_POSITIVE", "THAN", "TRUE", "UNSIGNED", "ZERO"]);
add_ocaml_element("validate_non_positive", "Std.Bitvector.validate_non_positive", "value", "Std.Bitvector.t Validate.check", "Bap.Std.Bitvector.html#VALvalidate_non_positive", "<div class=\"info\">\n<p><code class=\"code\">validate_non_positive</code> validates that a value is not positive.</p>\n\n</div>\n", ["NOT", "POSITIVE", "THAT", "VALIDATES", "VALIDATE_NON_POSITIVE", "VALUE"]);
add_ocaml_element("validate_negative", "Std.Bitvector.validate_negative", "value", "Std.Bitvector.t Validate.check", "Bap.Std.Bitvector.html#VALvalidate_negative", "<div class=\"info\">\n<p><code class=\"code\">validate_negative</code> validates that a value is negative.</p>\n\n</div>\n", ["NEGATIVE", "THAT", "VALIDATES", "VALIDATE_NEGATIVE", "VALUE"]);
add_ocaml_element("validate_non_negative", "Std.Bitvector.validate_non_negative", "value", "Std.Bitvector.t Validate.check", "Bap.Std.Bitvector.html#VALvalidate_non_negative", "<div class=\"info\">\n<p><code class=\"code\">validate_non_negative</code> validates that a value is non negative.</p>\n\n</div>\n", ["NEGATIVE", "NON", "THAT", "VALIDATES", "VALIDATE_NON_NEGATIVE", "VALUE"]);
add_ocaml_element("validate_positive", "Std.Bitvector.validate_positive", "value", "Std.Bitvector.t Validate.check", "Bap.Std.Bitvector.html#VALvalidate_positive", "<div class=\"info\">\n<p><code class=\"code\">validate_positive</code> validates that a value is positive.</p>\n\n</div>\n", ["POSITIVE", "THAT", "VALIDATES", "VALIDATE_POSITIVE", "VALUE"]);
add_ocaml_element("enum_bits", "Std.Bitvector.enum_bits", "value", "Std.Bitvector.t -> Std.Bitvector.endian -> bool Std.seq", "Bap.Std.Bitvector.html#VALenum_bits", "<div class=\"info\">\n<p><code class=\"code\">enum_bits&nbsp;x&nbsp;order</code> returns bits of <code class=\"code\">x</code> in a specified <code class=\"code\">order</code>.</p>\n\n</div>\n", ["ALWAYS", "BITS", "BITVECTOR", "DEFINES", "ENUM_BITS", "FIRST", "LENGTH", "MSB", "ONLY", "ORDER", "ORDERING", "POWER", "RETURNS", "SEQUENCE", "SPECIFIED", "THE", "WILL", "WORDS"]);
add_ocaml_element("enum_chars", "Std.Bitvector.enum_chars", "value", "Std.Bitvector.t -> Std.Bitvector.endian -> char Std.seq", "Bap.Std.Bitvector.html#VALenum_chars", "<div class=\"info\">\n<p><code class=\"code\">enum_bytes&nbsp;x&nbsp;order</code> returns bytes of <code class=\"code\">x</code> in a specified <code class=\"code\">order</code>,\n        with bytes represented by <code class=\"code\">char</code> type</p>\n\n</div>\n", ["BYTES", "CHAR", "ENUM_BYTES", "ORDER", "REPRESENTED", "RETURNS", "SPECIFIED", "TYPE", "WITH"]);
add_ocaml_element("enum_bytes", "Std.Bitvector.enum_bytes", "value", "Std.Bitvector.t ->\n  Std.Bitvector.endian -> Std.Bitvector.t Std.seq", "Bap.Std.Bitvector.html#VALenum_bytes", "<div class=\"info\">\n<p><code class=\"code\">enum_bytes&nbsp;x&nbsp;order</code> returns a sequence of bytes of <code class=\"code\">x</code> in a\n        specified <code class=\"code\">order</code>.</p>\n\n</div>\n", ["BITVECTOR", "BYTE", "BYTES", "EACH", "ENUM_BYTES", "ITSELF", "ORDER", "REPRESENTED", "RETURNS", "SEQUENCE", "SPECIFIED"]);
add_ocaml_element("gcdext_exn", "Std.Bitvector.gcdext_exn", "value", "Std.Bitvector.t ->\n  Std.Bitvector.t ->\n  Std.Bitvector.t * Std.Bitvector.t * Std.Bitvector.t", "Bap.Std.Bitvector.html#VALgcdext_exn", "<div class=\"info\">\n<p><code class=\"code\">gcdext_exn&nbsp;x&nbsp;y</code> is the same as <code class=\"code\">gcdext</code>, but will raise\n        an exception on error.</p>\n\n</div>\n", ["BUT", "ERROR", "EXCEPTION", "GCDEXT", "GCDEXT_EXN", "RAISE", "SAME", "THE", "WILL"]);
add_ocaml_element("lcm_exn", "Std.Bitvector.lcm_exn", "value", "Std.Bitvector.t -> Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALlcm_exn", "<div class=\"info\">\n<p><code class=\"code\">lcm_exn&nbsp;x&nbsp;y</code> is the same as <code class=\"code\">lcm</code>, but will raise\n        an exception on error.</p>\n\n</div>\n", ["BUT", "ERROR", "EXCEPTION", "LCM", "LCM_EXN", "RAISE", "SAME", "THE", "WILL"]);
add_ocaml_element("gcd_exn", "Std.Bitvector.gcd_exn", "value", "Std.Bitvector.t -> Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALgcd_exn", "<div class=\"info\">\n<p><code class=\"code\">gcd_exn&nbsp;x&nbsp;y</code> is the same as <code class=\"code\">gcd</code>, but will raise\n        an exception on error.</p>\n\n</div>\n", ["BUT", "ERROR", "EXCEPTION", "GCD", "GCD_EXN", "RAISE", "SAME", "THE", "WILL"]);
add_ocaml_element("gcdext", "Std.Bitvector.gcdext", "value", "Std.Bitvector.t ->\n  Std.Bitvector.t ->\n  (Std.Bitvector.t * Std.Bitvector.t * Std.Bitvector.t)\n  Or_error.t", "Bap.Std.Bitvector.html#VALgcdext", "<div class=\"info\">\n<p><code class=\"code\">gcdext&nbsp;x&nbsp;y</code> returns <code class=\"code\">(g,&nbsp;s,&nbsp;t)</code> where <code class=\"code\">g&nbsp;=&nbsp;gcd&nbsp;x&nbsp;y</code> and\n        <code class=\"code\">g&nbsp;=&nbsp;s*x&nbsp;+&nbsp;t*y</code>.</p>\n\n</div>\n", ["AND", "DOCUMENTATION", "FOR", "FUNCTION", "GCD", "GCDEXT", "RETURNS", "SEE", "THE", "THIS", "TRICKY", "USE", "WHERE", "WHY"]);
add_ocaml_element("lcm", "Std.Bitvector.lcm", "value", "Std.Bitvector.t ->\n  Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.html#VALlcm", "<div class=\"info\">\n<p><code class=\"code\">lcm&nbsp;x&nbsp;y</code> is the least common multiple of <code class=\"code\">x</code> and <code class=\"code\">y</code>\n        in the integers.</p>\n\n</div>\n", ["ALWAYS", "AND", "BITVECTORS", "COMMON", "DOCUMENTATION", "EVEN", "EXAMPLE", "FIXED", "FOR", "FUNCTION", "GCD", "INPUTS", "INTEGERS", "LCM", "LEAST", "LENGTH", "LIKE", "MULTIPLE", "NOT", "NOTE", "RESULT", "SEE", "SOME", "THAT", "THE", "THIS", "WIDTH", "WILL"]);
add_ocaml_element("gcd", "Std.Bitvector.gcd", "value", "Std.Bitvector.t ->\n  Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.html#VALgcd", "<div class=\"info\">\n<p><code class=\"code\">gcd&nbsp;x&nbsp;y</code> is the greatest common divisor of <code class=\"code\">x</code> and <code class=\"code\">y</code>\n        in the integers.</p>\n\n</div>\n", ["ABS", "ALWAYS", "AND", "ARE", "BIT", "BITVECTORS", "BOTH", "COMMON", "DIVISOR", "EVEN", "EXAMPLE", "FIXED", "FOR", "GCD", "GREATEST", "HOLD", "INTEGERS", "LENGTH", "MIN", "MULTIPLES", "NOT", "NOTE", "PROPERTIES", "STILL", "THAT", "THE", "THIS", "THOUGH", "THUS", "TWO", "UNSIGNED"]);
add_ocaml_element("(--)", "Std.Bitvector.(--)", "value", "Std.Bitvector.t -> int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VAL(--)", "<div class=\"info\">\n<p><code class=\"code\">a&nbsp;--&nbsp;n</code> is <code class=\"code\">npred&nbsp;a&nbsp;n</code></p>\n\n</div>\n", ["NPRED"]);
add_ocaml_element("(++)", "Std.Bitvector.(++)", "value", "Std.Bitvector.t -> int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VAL(++)", "<div class=\"info\">\n<p><code class=\"code\">a&nbsp;++&nbsp;n</code> is <code class=\"code\">nsucc&nbsp;a&nbsp;n</code></p>\n\n</div>\n", ["NSUCC"]);
add_ocaml_element("npred", "Std.Bitvector.npred", "value", "Std.Bitvector.t -> int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALnpred", "<div class=\"info\">\n<p><code class=\"code\">npred&nbsp;m&nbsp;n</code> is <code class=\"code\"><span class=\"constructor\">Fn</span>.apply_n_times&nbsp;~n&nbsp;pred&nbsp;addr</code>, but more\n        efficient.</p>\n\n</div>\n", ["ADDR", "APPLY_N_TIMES", "BUT", "EFFICIENT", "MORE", "NPRED", "PRED"]);
add_ocaml_element("nsucc", "Std.Bitvector.nsucc", "value", "Std.Bitvector.t -> int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALnsucc", "<div class=\"info\">\n<p><code class=\"code\">nsucc&nbsp;m&nbsp;n</code> is <code class=\"code\"><span class=\"constructor\">Fn</span>.apply_n_times&nbsp;~n&nbsp;succ&nbsp;m</code>, but more\n        efficient.</p>\n\n</div>\n", ["APPLY_N_TIMES", "BUT", "EFFICIENT", "MORE", "NSUCC", "SUCC"]);
add_ocaml_element("pred", "Std.Bitvector.pred", "value", "Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALpred", "<div class=\"info\">\n<p><code class=\"code\">pred&nbsp;n</code> returns a value preceding <code class=\"code\">n</code>.</p>\n\n</div>\n", ["PRECEDING", "PRED", "RETURNS", "VALUE"]);
add_ocaml_element("succ", "Std.Bitvector.succ", "value", "Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALsucc", "<div class=\"info\">\n<p><code class=\"code\">succ&nbsp;n</code> returns next value after <code class=\"code\">n</code>.</p>\n\n</div>\n", ["AFTER", "GUARANTEED", "NEXT", "NOT", "RETURNS", "SIGNED", "SUCC", "THAT", "VALUE"]);
add_ocaml_element("(@.)", "Std.Bitvector.(@.)", "value", "Std.Bitvector.t -> Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VAL(@.)", "<div class=\"info\">\n<p><code class=\"code\">b1&nbsp;@.&nbsp;b2</code> is <code class=\"code\">concat&nbsp;b1&nbsp;b2</code></p>\n\n</div>\n", ["CONCAT"]);
add_ocaml_element("concat", "Std.Bitvector.concat", "value", "Std.Bitvector.t -> Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALconcat", "<div class=\"info\">\n<p><code class=\"code\">concat&nbsp;b1&nbsp;b2</code> concatenates two bitvectors</p>\n\n</div>\n", ["BITVECTORS", "CONCAT", "CONCATENATES", "TWO"]);
add_ocaml_element("extract_exn", "Std.Bitvector.extract_exn", "value", "?hi:int -> ?lo:int -> Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALextract_exn", "<div class=\"info\">\n<p><code class=\"code\">extract_exn&nbsp;bv&nbsp;~hi&nbsp;~lo</code> is the same as <code class=\"code\">extract</code>, but will raise\n        an exception on error.</p>\n\n</div>\n", ["BUT", "ERROR", "EXCEPTION", "EXTRACT", "EXTRACT_EXN", "RAISE", "SAME", "THE", "WILL"]);
add_ocaml_element("extract", "Std.Bitvector.extract", "value", "?hi:int ->\n  ?lo:int -> Std.Bitvector.t -> Std.Bitvector.t Or_error.t", "Bap.Std.Bitvector.html#VALextract", "<div class=\"info\">\n<p><code class=\"code\">extract&nbsp;bv&nbsp;~hi&nbsp;~lo</code> extracts a subvector from <code class=\"code\">bv</code>, starting\n        from bit <code class=\"code\">hi</code> and ending with <code class=\"code\">lo</code>.</p>\n\n</div>\n", ["AND", "ARE", "BIT", "BITS", "CONSISTING", "DEFAULTS", "ENDING", "ENUMERATED", "EQUAL", "EXAMPLE", "EXTRACT", "EXTRACTS", "FORTH", "FROM", "GREATER", "LEAST", "LEFT", "LESS", "MAYBE", "MOST", "MUST", "NEGATIVE", "NON", "NUMBER", "NUMBERS", "OF_INT", "RESULT", "RIGHT", "SHOULD", "SIGNIFICANT", "SIZE", "STARTING", "SUBVECTOR", "THAN", "THE", "THEN", "THIRD", "TWO", "VECTOR", "WIDTH", "WILL", "WITH", "ZERO"]);
add_ocaml_element("bitwidth", "Std.Bitvector.bitwidth", "value", "Std.Bitvector.t -> int", "Bap.Std.Bitvector.html#VALbitwidth", "<div class=\"info\">\n<p><code class=\"code\">bitwidth&nbsp;bv</code> return a bit-width, i.e., the amount of bits</p>\n\n</div>\n", ["AMOUNT", "BIT", "BITS", "BITWIDTH", "RETURN", "THE", "WIDTH"]);
add_ocaml_element("is_one", "Std.Bitvector.is_one", "value", "Std.Bitvector.t -> bool", "Bap.Std.Bitvector.html#VALis_one", "<div class=\"info\">\n<p><code class=\"code\">is_ones&nbsp;bv</code> is true if the least significant bit is equal to one</p>\n\n</div>\n", ["BIT", "EQUAL", "IS_ONES", "LEAST", "ONE", "SIGNIFICANT", "THE", "TRUE"]);
add_ocaml_element("is_zero", "Std.Bitvector.is_zero", "value", "Std.Bitvector.t -> bool", "Bap.Std.Bitvector.html#VALis_zero", "<div class=\"info\">\n<p><code class=\"code\">is_zero&nbsp;bv</code> is true iff all bits are set to zero.</p>\n\n</div>\n", ["ALL", "ARE", "BITS", "IFF", "IS_ZERO", "SET", "TRUE", "ZERO"]);
add_ocaml_element("unsigned", "Std.Bitvector.unsigned", "value", "Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALunsigned", "<div class=\"info\">\n<p><code class=\"code\">unsigned&nbsp;t</code> casts <code class=\"code\">t</code> to an unsigned type, so that any\n        operations applied to it will interpret <code class=\"code\">t</code> as an unsigned\n        word.</p>\n\n</div>\n", ["ANY", "APPLIED", "CASTS", "INTERPRET", "OPERATIONS", "SINCE", "THAT", "TYPE", "UNSIGNED", "WILL", "WORD"]);
add_ocaml_element("signed", "Std.Bitvector.signed", "value", "Std.Bitvector.t -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALsigned", "<div class=\"info\">\n<p><code class=\"code\">signed&nbsp;t</code> casts t to a signed type, so that any operations\n        applied on <code class=\"code\">t</code> will be signed.</p>\n\n</div>\n", ["ANY", "APPLIED", "CASTS", "OPERATIONS", "SIGNED", "THAT", "TYPE", "WILL"]);
add_ocaml_element("string_of_value", "Std.Bitvector.string_of_value", "value", "?hex:bool -> Std.Bitvector.t -> string", "Bap.Std.Bitvector.html#VALstring_of_value", "<div class=\"info\">\n<p><code class=\"code\">string_of_value&nbsp;?hex&nbsp;x</code> returns a textual representation of\n        the <code class=\"code\">x</code> value, i.e., ignores size and signedness.</p>\n\n</div>\n", ["AND", "ARE", "DECIMAL", "DEFAULT", "FORMAT", "HEX", "HEXADECIMAL", "IGNORES", "LEADING", "LETTER", "LITERALS", "LOWERCASE", "NEGATIVE", "NOT", "OTHERWISE", "PREFIXED", "PRINTED", "REPRESENTATION", "RETURNED", "RETURNS", "SIGN", "SIGNED", "SIGNEDNESS", "SIZE", "STRING_OF_VALUE", "TEXTUAL", "THE", "THEN", "TRUE", "USED", "VALUE", "ZEROS"]);
add_ocaml_element("pp_generic", "Std.Bitvector.pp_generic", "value", "?case:[ `lower | `upper ] ->\n  ?prefix:[ `auto | `base | `none | `this of string ] ->\n  ?suffix:[ `full | `none | `size ] ->\n  ?format:[ `bin | `dec | `hex | `oct ] ->\n  Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_generic", "<div class=\"info\">\n<p><code class=\"code\">pp_generic&nbsp;?case&nbsp;?prefix&nbsp;?suffix&nbsp;?format&nbsp;ppf&nbsp;x</code> - a printer\n        to suit all tastes.</p>\n\n</div>\n", ["ALL", "CASE", "FACTORY", "FORMAT", "GENERIC", "NINE", "NONE", "NOTE", "PPF", "PP_GENERIC", "PREFIX", "PREINSTANTIATED", "PRINTER", "SHOULD", "SUFFIX", "SUIT", "SUITS", "TASTES", "THAT", "THE", "THIS", "USED", "YOU"]);
add_ocaml_element("pp_bin_full", "Std.Bitvector.pp_bin_full", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_bin_full", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_bin_full&nbsp;x</code> prints <code class=\"code\">x</code> in the binary (0 and 1)\n        format omitting suffixes, and the prefix if it is necessary.</p>\n\n</div>\n", ["0B11011110101011011011111011101111", "0X1", "0XDEADBEEFL", "32U", "AND", "BINARY", "EXAMPLE", "FORMAT", "NECESSARY", "OF_INT32", "OMITTING", "PP_BIN_FULL", "PREFIX", "PRINTF", "PRINTS", "SUFFIXES", "THE", "WORD"]);
add_ocaml_element("pp_oct_full", "Std.Bitvector.pp_oct_full", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_oct_full", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_oct_full&nbsp;x</code> prints <code class=\"code\">x</code> in the octal format with\n        suffixes, and the prefix if it is necessary.</p>\n\n</div>\n", ["0O33653337357", "0X1", "0XDEADBEEFL", "32U", "AND", "EXAMPLE", "FORMAT", "NECESSARY", "OCTAL", "OF_INT32", "PP_OCT_FULL", "PREFIX", "PRINTF", "PRINTS", "SUFFIXES", "THE", "WITH", "WORD"]);
add_ocaml_element("pp_dec_full", "Std.Bitvector.pp_dec_full", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_dec_full", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_dec_full&nbsp;x</code> prints <code class=\"code\">x</code> in the decimal format with\n        suffixes and prefixes.</p>\n\n</div>\n", ["0X1", "0XDEADBEEFL", "32U", "3735928559", "AND", "DECIMAL", "EXAMPLE", "FORMAT", "OF_INT32", "PP_DEC_FULL", "PREFIXES", "PRINTF", "PRINTS", "SINCE", "SUFFIXES", "THE", "WITH", "WORD"]);
add_ocaml_element("pp_hex_full", "Std.Bitvector.pp_hex_full", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_hex_full", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_hex_full&nbsp;x</code> prints <code class=\"code\">x</code> in the hexadecimal format with\n        suffixes, and the prefix if it is necessary.</p>\n\n</div>\n", ["0X1", "0XDEADBEEF", "0XDEADBEEFL", "32U", "AND", "EXAMPLE", "FORMAT", "HEXADECIMAL", "NECESSARY", "OF_INT32", "PP_HEX_FULL", "PREFIX", "PRINTF", "PRINTS", "SUFFIXES", "THE", "WITH", "WORD"]);
add_ocaml_element("pp_bin", "Std.Bitvector.pp_bin", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_bin", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_bin&nbsp;x</code> prints <code class=\"code\">x</code> in the binary (0 and 1) format omitting\n        suffixes, and the prefix if it is not necessary.</p>\n\n</div>\n", ["0B11011110101011011011111011101111", "0X1", "0XDEADBEEFL", "AND", "BINARY", "EXAMPLE", "FORMAT", "NECESSARY", "NOT", "OF_INT32", "OMITTING", "PP_BIN", "PREFIX", "PRINTF", "PRINTS", "SINCE", "SUFFIXES", "THE", "WORD"]);
add_ocaml_element("pp_oct", "Std.Bitvector.pp_oct", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_oct", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_oct&nbsp;x</code> prints <code class=\"code\">x</code> in the octal format omitting\n        suffixes, and the prefix if it is not necessary.</p>\n\n</div>\n", ["0O33653337357", "0X1", "0XDEADBEEFL", "AND", "EXAMPLE", "FORMAT", "NECESSARY", "NOT", "OCTAL", "OF_INT32", "OMITTING", "PP_OCT", "PREFIX", "PRINTF", "PRINTS", "SUFFIXES", "THE", "WORD"]);
add_ocaml_element("pp_dec", "Std.Bitvector.pp_dec", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_dec", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_dec&nbsp;x</code> prints <code class=\"code\">x</code> in the decimal format omitting\n        suffixes and prefixes.</p>\n\n</div>\n", ["0X1", "0XDEADBEEFL", "3735928559", "AND", "DECIMAL", "EXAMPLE", "FORMAT", "OF_INT32", "OMITTING", "PP_DEC", "PREFIXES", "PRINTF", "PRINTS", "SINCE", "SUFFIXES", "THE", "WORD"]);
add_ocaml_element("pp_hex", "Std.Bitvector.pp_hex", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp_hex", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp_hex&nbsp;x</code> prints <code class=\"code\">x</code> in the hexadecimal format omitting\n        suffixes, and the prefix if it is not necessary.</p>\n\n</div>\n", ["0X1", "0XDEADBEEF", "0XDEADBEEFL", "AND", "EXAMPLE", "FORMAT", "HEXADECIMAL", "NECESSARY", "NOT", "OF_INT32", "OMITTING", "PP_HEX", "PREFIX", "PRINTF", "PRINTS", "SINCE", "SUFFIXES", "THE", "WORD"]);
add_ocaml_element("pp", "Std.Bitvector.pp", "value", "Std.Bitvector.t Std.printer", "Bap.Std.Bitvector.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">printf&nbsp;<span class=\"string\">\"%a\"</span>&nbsp;pp&nbsp;x</code> prints <code class=\"code\">x</code> into a formatter.</p>\n\n</div>\n", ["ACTUAL", "AND", "ARE", "ASSUMED", "AVAILABLE", "AVAILABLE_WRITERS", "BOX", "CONTROLLED", "DEFAULT", "DEFAULTS", "DESCRIPTION", "EXAMPLES", "FOR", "FORMAT", "FORMATS", "FORMATTER", "FROM", "FUNCTION", "INTO", "LIST", "MODULE", "MULTIPLE", "NOTE", "OPEN", "OUT", "PP_HEX_FULL", "PRINTER", "PRINTF", "PRINTS", "REFERS", "SCOPE", "SEE", "SET_DEFAULT_PRINTER", "THAT", "THE", "THIS", "THUS"]);
add_ocaml_element("to_int64_exn", "Std.Bitvector.to_int64_exn", "value", "Std.Bitvector.t -> int64", "Bap.Std.Bitvector.html#VALto_int64_exn", "<div class=\"info\">\n<p><code class=\"code\">to_int64_exn&nbsp;x</code> projects <code class=\"code\">x</code> in to <code class=\"code\">int64</code></p>\n\n</div>\n", ["INT64", "PROJECTS", "SINCE", "TO_INT64_EXN"]);
add_ocaml_element("to_int32_exn", "Std.Bitvector.to_int32_exn", "value", "Std.Bitvector.t -> int32", "Bap.Std.Bitvector.html#VALto_int32_exn", "<div class=\"info\">\n<p><code class=\"code\">to_int32_exn&nbsp;x</code> projects <code class=\"code\">x</code> in to <code class=\"code\">int32</code></p>\n\n</div>\n", ["INT32", "PROJECTS", "SINCE", "TO_INT32_EXN"]);
add_ocaml_element("to_int_exn", "Std.Bitvector.to_int_exn", "value", "Std.Bitvector.t -> int", "Bap.Std.Bitvector.html#VALto_int_exn", "<div class=\"info\">\n<p><code class=\"code\">to_int_exn&nbsp;x</code> projects <code class=\"code\">x</code> in to OCaml <code class=\"code\">int</code>.</p>\n\n</div>\n", ["INT", "OCAML", "PROJECTS", "SINCE", "TO_INT_EXN"]);
add_ocaml_element("to_int64", "Std.Bitvector.to_int64", "value", "Std.Bitvector.t -> int64 Or_error.t", "Bap.Std.Bitvector.html#VALto_int64", "<div class=\"info\">\n<p><code class=\"code\">to_int64&nbsp;x</code> projects <code class=\"code\">x</code> in to <code class=\"code\">int64</code></p>\n\n</div>\n", ["INT64", "PROJECTS", "TO_INT64"]);
add_ocaml_element("to_int32", "Std.Bitvector.to_int32", "value", "Std.Bitvector.t -> int32 Or_error.t", "Bap.Std.Bitvector.html#VALto_int32", "<div class=\"info\">\n<p><code class=\"code\">to_int32&nbsp;x</code> projects <code class=\"code\">x</code> in to <code class=\"code\">int32</code></p>\n\n</div>\n", ["INT32", "PROJECTS", "TO_INT32"]);
add_ocaml_element("to_int", "Std.Bitvector.to_int", "value", "Std.Bitvector.t -> int Or_error.t", "Bap.Std.Bitvector.html#VALto_int", "<div class=\"info\">\n<p><code class=\"code\">to_int&nbsp;x</code> projects <code class=\"code\">x</code> in to OCaml <code class=\"code\">int</code>.</p>\n\n</div>\n", ["INT", "OCAML", "PROJECTS", "TO_INT"]);
add_ocaml_element("of_binary", "Std.Bitvector.of_binary", "value", "?width:int -> Std.Bitvector.endian -> string -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALof_binary", "<div class=\"info\">\n<p><code class=\"code\">of_binary&nbsp;?width&nbsp;endian&nbsp;num</code> creates a bitvector from a string\n        interpreted as a sequence of bytes in a specified order.</p>\n\n</div>\n", ["ALWAYS", "AND", "ARGUMENT", "BITS", "BITVECTOR", "BYTES", "CREATES", "DEFAULTS", "ENDIAN", "FROM", "INTERPRETED", "LENGTH", "NOT", "NUM", "OF_BINARY", "ORDER", "POSITIVE", "RESULT", "SEQUENCE", "SHARED", "SPECIFIED", "STRING", "THE", "UNSIGNED", "WIDTH"]);
add_ocaml_element("ones", "Std.Bitvector.ones", "value", "int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALones", "<div class=\"info\">\n<p><code class=\"code\">ones&nbsp;width</code> is a number with a specified <code class=\"code\">width</code>, and all bits\n        set to 1.</p>\n\n</div>\n", ["ALL", "AND", "BITS", "FOR", "LNOT", "NUMBER", "ONES", "SET", "SHORTCUT", "SPECIFIED", "WIDTH", "WITH", "ZERO"]);
add_ocaml_element("zero", "Std.Bitvector.zero", "value", "int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALzero", "<div class=\"info\">\n<p><code class=\"code\">zero&nbsp;width</code> zero with a specified <code class=\"code\">width</code>, is a shortcut for\n        <code class=\"code\">of_int&nbsp;0&nbsp;~width</code></p>\n\n</div>\n", ["FOR", "OF_INT", "SHORTCUT", "SPECIFIED", "WIDTH", "WITH", "ZERO"]);
add_ocaml_element("one", "Std.Bitvector.one", "value", "int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALone", "<div class=\"info\">\n<p><code class=\"code\">one&nbsp;width</code> number one with a specified <code class=\"code\">width</code>, is a shortcut for\n        <code class=\"code\">of_int&nbsp;1&nbsp;~width</code></p>\n\n</div>\n", ["FOR", "NUMBER", "OF_INT", "ONE", "SHORTCUT", "SPECIFIED", "WIDTH", "WITH"]);
add_ocaml_element("b1", "Std.Bitvector.b1", "value", "Std.Bitvector.t", "Bap.Std.Bitvector.html#VALb1", "<div class=\"info\">\n<p><code class=\"code\">b1&nbsp;=&nbsp;of_bool&nbsp;<span class=\"keyword\">true</span></code></p>\n\n</div>\n", ["OF_BOOL", "TRUE"]);
add_ocaml_element("b0", "Std.Bitvector.b0", "value", "Std.Bitvector.t", "Bap.Std.Bitvector.html#VALb0", "<div class=\"info\">\n<p><code class=\"code\">b0&nbsp;=&nbsp;of_bool&nbsp;<span class=\"keyword\">false</span></code></p>\n\n</div>\n", ["FALSE", "OF_BOOL"]);
add_ocaml_element("of_int64", "Std.Bitvector.of_int64", "value", "?width:int -> int64 -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALof_int64", "<div class=\"info\">\n<p><code class=\"code\">of_int32&nbsp;?width&nbsp;n</code> creates a bitvector of the specified\n        bit-<code class=\"code\">width</code> with the value equal to <code class=\"code\">n</code>.</p>\n\n</div>\n", ["ARE", "BIT", "BITS", "BITVECTOR", "CREATES", "DEFAULTS", "DOESN", "EQUAL", "FIT", "IGNORED", "INTO", "OF_INT32", "PARAMETER", "SPECIFIED", "THAT", "THE", "VALUE", "WIDTH", "WITH"]);
add_ocaml_element("of_int32", "Std.Bitvector.of_int32", "value", "?width:int -> int32 -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALof_int32", "<div class=\"info\">\n<p><code class=\"code\">of_int32&nbsp;?width&nbsp;n</code> creates a bitvector of the specified\n        bit-<code class=\"code\">width</code> with the value equal to <code class=\"code\">n</code>.</p>\n\n</div>\n", ["ARE", "BIT", "BITS", "BITVECTOR", "CREATES", "DEFAULTS", "DOESN", "EQUAL", "FIT", "IGNORED", "INTO", "OF_INT32", "PARAMETER", "SPECIFIED", "THAT", "THE", "VALUE", "WIDTH", "WITH"]);
add_ocaml_element("of_int", "Std.Bitvector.of_int", "value", "width:int -> int -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALof_int", "<div class=\"info\">\n<p><code class=\"code\">of_int&nbsp;~width&nbsp;n</code> creates a bitvector of the specified\n        bit-<code class=\"code\">width</code> with the value equal to <code class=\"code\">n</code>.</p>\n\n</div>\n", ["ARE", "BIT", "BITS", "BITVECTOR", "CREATES", "DOESN", "EQUAL", "FIT", "IGNORED", "INTO", "OF_INT", "SPECIFIED", "THAT", "THE", "VALUE", "WIDTH", "WITH"]);
add_ocaml_element("of_bool", "Std.Bitvector.of_bool", "value", "bool -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALof_bool", "<div class=\"info\">\n<p><code class=\"code\">of_bool&nbsp;x</code> is a bitvector with length <code class=\"code\">1</code> and value <code class=\"code\">b0</code> if\n        <code class=\"code\">x</code> is false and <code class=\"code\">b1</code> otherwise.</p>\n\n</div>\n", ["AND", "BITVECTOR", "FALSE", "LENGTH", "OF_BOOL", "OTHERWISE", "VALUE", "WITH"]);
add_ocaml_element("of_string", "Std.Bitvector.of_string", "value", "string -> Std.Bitvector.t", "Bap.Std.Bitvector.html#VALof_string", "<div class=\"info\">\n<p><code class=\"code\">of_string&nbsp;s</code> parses a bitvector from a string representation\n        defined in section <code class=\"code\">bv_string</code>.</p>\n\n</div>\n", ["BITVECTOR", "BV_STRING", "DEFINED", "FROM", "OF_STRING", "PARSES", "REPRESENTATION", "SECTION", "STRING"]);
add_ocaml_element("in_bytes", "Std.Size.in_bytes", "value", "[< Std.Size.all ] Std.Size.p -> int", "Bap.Std.Size.html#VALin_bytes", "<div class=\"info\">\n<p><code class=\"code\">in_bytes&nbsp;sz</code> returns size in bytes</p>\n\n</div>\n", ["BYTES", "IN_BYTES", "RETURNS", "SIZE"]);
add_ocaml_element("in_bits", "Std.Size.in_bits", "value", "[< Std.Size.all ] Std.Size.p -> int", "Bap.Std.Size.html#VALin_bits", "<div class=\"info\">\n<p><code class=\"code\">in_bits&nbsp;size</code> returns size in bits.</p>\n\n</div>\n", ["BITS", "IN_BITS", "RETURNS", "SIZE"]);
add_ocaml_element("to_addr_size", "Std.Size.to_addr_size", "value", "Std.Size.t -> [ `r32 | `r64 ] Or_error.t", "Bap.Std.Size.html#VALto_addr_size", "", []);
add_ocaml_element("word_of_addr_size", "Std.Size.word_of_addr_size", "value", "[ `r32 | `r64 ] -> Word_size.t", "Bap.Std.Size.html#VALword_of_addr_size", "", []);
add_ocaml_element("addr_of_word_size", "Std.Size.addr_of_word_size", "value", "Word_size.t -> [ `r32 | `r64 ]", "Bap.Std.Size.html#VALaddr_of_word_size", "", []);
add_ocaml_element("addr_of_int_opt", "Std.Size.addr_of_int_opt", "value", "int -> [ `r32 | `r64 ] option", "Bap.Std.Size.html#VALaddr_of_int_opt", "<div class=\"info\">\n<p><code class=\"code\">addr_of_int_opt&nbsp;n</code> the same as <code class=\"code\">addr_of_int</code> but uses <code class=\"code\">option</code> type\n        instead of <code class=\"code\"><span class=\"constructor\">Or_error</span>.t</code></p>\n\n</div>\n", ["ADDR_OF_INT", "ADDR_OF_INT_OPT", "BUT", "INSTEAD", "OPTION", "OR_ERROR", "SAME", "THE", "TYPE", "USES"]);
add_ocaml_element("addr_of_int_exn", "Std.Size.addr_of_int_exn", "value", "int -> [ `r32 | `r64 ]", "Bap.Std.Size.html#VALaddr_of_int_exn", "<div class=\"info\">\n<p><code class=\"code\">addr_of_int_exn&nbsp;n</code> the same as <code class=\"code\">addr_of_int</code>, but raises exception\n        instead of returning <code class=\"code\"><span class=\"constructor\">Error</span></code></p>\n\n</div>\n", ["ADDR_OF_INT", "ADDR_OF_INT_EXN", "BUT", "ERROR", "EXCEPTION", "INSTEAD", "RAISES", "RETURNING", "SAME", "THE"]);
add_ocaml_element("addr_of_int", "Std.Size.addr_of_int", "value", "int -> [ `r32 | `r64 ] Or_error.t", "Bap.Std.Size.html#VALaddr_of_int", "<div class=\"info\">\n<p><code class=\"code\">addr_of_int&nbsp;n</code> return <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;<span class=\"keywordsign\">`</span>rn</code> if <code class=\"code\"><span class=\"keywordsign\">`</span>rn</code> exists, <code class=\"code\"><span class=\"constructor\">Error</span></code>\n        otherwise.</p>\n\n</div>\n", ["ADDR_OF_INT", "ERROR", "EXISTS", "OTHERWISE", "RETURN"]);
add_ocaml_element("of_int_opt", "Std.Size.of_int_opt", "value", "int -> Std.Size.t option", "Bap.Std.Size.html#VALof_int_opt", "<div class=\"info\">\n<p><code class=\"code\">of_int_opt&nbsp;n</code> the same as <code class=\"code\">of_int</code> but uses <code class=\"code\">option</code> type\n        instead of <code class=\"code\"><span class=\"constructor\">Or_error</span>.t</code></p>\n\n</div>\n", ["BUT", "INSTEAD", "OF_INT", "OF_INT_OPT", "OPTION", "OR_ERROR", "SAME", "THE", "TYPE", "USES"]);
add_ocaml_element("of_int_exn", "Std.Size.of_int_exn", "value", "int -> Std.Size.t", "Bap.Std.Size.html#VALof_int_exn", "<div class=\"info\">\n<p><code class=\"code\">of_int_exn&nbsp;n</code> the same as <code class=\"code\">of_int</code>, but raises exception\n        instead of returning <code class=\"code\"><span class=\"constructor\">Error</span></code></p>\n\n</div>\n", ["BUT", "ERROR", "EXCEPTION", "INSTEAD", "OF_INT", "OF_INT_EXN", "RAISES", "RETURNING", "SAME", "THE"]);
add_ocaml_element("of_int", "Std.Size.of_int", "value", "int -> Std.Size.t Or_error.t", "Bap.Std.Size.html#VALof_int", "<div class=\"info\">\n<p><code class=\"code\">of_int&nbsp;n</code> return <code class=\"code\"><span class=\"constructor\">Ok</span>&nbsp;<span class=\"keywordsign\">`</span>rn</code> if <code class=\"code\"><span class=\"keywordsign\">`</span>rn</code> exists, <code class=\"code\"><span class=\"constructor\">Error</span></code>\n        otherwise.</p>\n\n</div>\n", ["ERROR", "EXISTS", "OF_INT", "OTHERWISE", "RETURN"]);
add_ocaml_element("upper", "Std.Interval_tree.Interval.upper", "value", "Std.Interval_tree.Interval.t -> Std.Interval_tree.Interval.point", "Bap.Std.Interval_tree.Interval.html#VALupper", "<div class=\"info\">\n<p>the upper bound of an interval</p>\n\n</div>\n", ["BOUND", "INTERVAL", "THE", "UPPER"]);
add_ocaml_element("lower", "Std.Interval_tree.Interval.lower", "value", "Std.Interval_tree.Interval.t -> Std.Interval_tree.Interval.point", "Bap.Std.Interval_tree.Interval.html#VALlower", "<div class=\"info\">\n<p>the lower bound of an interval</p>\n\n</div>\n", ["BOUND", "INTERVAL", "LOWER", "THE"]);
add_ocaml_element("to_sequence", "Std.Interval_tree.S.to_sequence", "value", "'a Std.Interval_tree.S.t ->\n  (Std.Interval_tree.S.key * 'a) Sequence.t", "Bap.Std.Interval_tree.S.html#VALto_sequence", "<div class=\"info\">\n<p><code class=\"code\">to_sequence&nbsp;t</code> returns all bindings in <code class=\"code\">t</code></p>\n\n</div>\n", ["ALL", "BINDINGS", "RETURNS", "TO_SEQUENCE"]);
add_ocaml_element("remove_dominators", "Std.Interval_tree.S.remove_dominators", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.key -> 'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALremove_dominators", "<div class=\"info\">\n<p><code class=\"code\">remove_dominators&nbsp;t&nbsp;k</code> removes all bindings that are\n          included (dominated by) in the interval <code class=\"code\">k</code></p>\n\n</div>\n", ["ALL", "ARE", "BINDINGS", "DOMINATED", "INCLUDED", "INTERVAL", "REMOVES", "REMOVE_DOMINATORS", "THAT", "THE"]);
add_ocaml_element("remove_intersections", "Std.Interval_tree.S.remove_intersections", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.key -> 'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALremove_intersections", "<div class=\"info\">\n<p><code class=\"code\">remove_intersections&nbsp;t&nbsp;k</code> removes all bindings that\n          intersect with the key <code class=\"code\">k</code>.</p>\n\n</div>\n", ["ALL", "BINDINGS", "INTERSECT", "KEY", "REMOVES", "REMOVE_INTERSECTIONS", "THAT", "THE", "WITH"]);
add_ocaml_element("remove", "Std.Interval_tree.S.remove", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.key -> 'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;t&nbsp;k</code> removes all bindings to the key <code class=\"code\">k</code></p>\n\n</div>\n", ["ALL", "BINDINGS", "KEY", "REMOVE", "REMOVES", "THE"]);
add_ocaml_element("filter_mapi", "Std.Interval_tree.S.filter_mapi", "value", "'a Std.Interval_tree.S.t ->\n  f:(Std.Interval_tree.S.key -> 'a -> 'b option) ->\n  'b Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALfilter_mapi", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;t&nbsp;~f</code> returns a tree where all elements for which\n          <code class=\"code\">f</code> returned <code class=\"code\"><span class=\"constructor\">None</span></code> are removed and all others are mapped.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "ELEMENTS", "FILTER", "FOR", "MAPPED", "NONE", "OTHERS", "REMOVED", "RETURNED", "RETURNS", "TREE", "WHERE", "WHICH"]);
add_ocaml_element("filter_map", "Std.Interval_tree.S.filter_map", "value", "'a Std.Interval_tree.S.t ->\n  f:('a -> 'b option) -> 'b Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALfilter_map", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;t&nbsp;~f</code> returns a tree where all elements for which\n          <code class=\"code\">f</code> returned <code class=\"code\"><span class=\"constructor\">None</span></code> are removed and all others are mapped.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "ELEMENTS", "FILTER", "FOR", "MAPPED", "NONE", "OTHERS", "REMOVED", "RETURNED", "RETURNS", "TREE", "WHERE", "WHICH"]);
add_ocaml_element("filter", "Std.Interval_tree.S.filter", "value", "'a Std.Interval_tree.S.t ->\n  f:('a -> bool) -> 'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALfilter", "<div class=\"info\">\n<p><code class=\"code\">filter&nbsp;t&nbsp;~f</code> returns a tree where all elements for which\n          <code class=\"code\">f</code> returned <code class=\"code\"><span class=\"keyword\">false</span></code> are removed.</p>\n\n</div>\n", ["ALL", "ARE", "ELEMENTS", "FALSE", "FILTER", "FOR", "REMOVED", "RETURNED", "RETURNS", "TREE", "WHERE", "WHICH"]);
add_ocaml_element("mapi", "Std.Interval_tree.S.mapi", "value", "'a Std.Interval_tree.S.t ->\n  f:(Std.Interval_tree.S.key -> 'a -> 'b) -> 'b Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALmapi", "<div class=\"info\">\n<p><code class=\"code\">mapi&nbsp;k&nbsp;~f</code> maps all bindings with the function <code class=\"code\">f</code></p>\n\n</div>\n", ["ALL", "BINDINGS", "FUNCTION", "MAPI", "MAPS", "THE", "WITH"]);
add_ocaml_element("map", "Std.Interval_tree.S.map", "value", "'a Std.Interval_tree.S.t -> f:('a -> 'b) -> 'b Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALmap", "<div class=\"info\">\n<p><code class=\"code\">map&nbsp;k&nbsp;~f</code> maps all data values with the function <code class=\"code\">f</code></p>\n\n</div>\n", ["ALL", "DATA", "FUNCTION", "MAP", "MAPS", "THE", "VALUES", "WITH"]);
add_ocaml_element("lookup", "Std.Interval_tree.S.lookup", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.point ->\n  (Std.Interval_tree.S.key * 'a) Sequence.t", "Bap.Std.Interval_tree.S.html#VALlookup", "<div class=\"info\">\n<p><code class=\"code\">lookup&nbsp;t&nbsp;p</code> returns bindings of all intervals that\n          contain the given point</p>\n\n</div>\n", ["ALL", "BINDINGS", "CONTAIN", "GIVEN", "INTERVALS", "LOOKUP", "POINT", "RETURNS", "THAT", "THE"]);
add_ocaml_element("contains", "Std.Interval_tree.S.contains", "value", "'a Std.Interval_tree.S.t -> Std.Interval_tree.S.point -> bool", "Bap.Std.Interval_tree.S.html#VALcontains", "<div class=\"info\">\n<p><code class=\"code\">contains&nbsp;t&nbsp;p</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> if <code class=\"code\">p</code> belongs to at least one\n          interval in <code class=\"code\">t</code></p>\n\n</div>\n", ["BELONGS", "CONTAINS", "INTERVAL", "LEAST", "ONE", "TRUE"]);
add_ocaml_element("dominates", "Std.Interval_tree.S.dominates", "value", "'a Std.Interval_tree.S.t -> Std.Interval_tree.S.key -> bool", "Bap.Std.Interval_tree.S.html#VALdominates", "<div class=\"info\">\n<p><code class=\"code\">dominates&nbsp;t&nbsp;k</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> iff all intervals in <code class=\"code\">t</code> are\n          included in <code class=\"code\">k</code>.</p>\n\n</div>\n", ["ALL", "ARE", "DOMINATES", "IFF", "INCLUDED", "INTERVALS", "TRUE"]);
add_ocaml_element("intersects", "Std.Interval_tree.S.intersects", "value", "'a Std.Interval_tree.S.t -> Std.Interval_tree.S.key -> bool", "Bap.Std.Interval_tree.S.html#VALintersects", "<div class=\"info\">\n<p><code class=\"code\">intersects&nbsp;t&nbsp;k</code> is <code class=\"code\"><span class=\"keyword\">true</span></code> iff <code class=\"code\">t</code> contains an interval\n          that intersects with <code class=\"code\">k</code></p>\n\n</div>\n", ["CONTAINS", "IFF", "INTERSECTS", "INTERVAL", "THAT", "TRUE", "WITH"]);
add_ocaml_element("intersections", "Std.Interval_tree.S.intersections", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.key ->\n  (Std.Interval_tree.S.key * 'a) Sequence.t", "Bap.Std.Interval_tree.S.html#VALintersections", "<div class=\"info\">\n<p><code class=\"code\">intersections&nbsp;t&nbsp;k</code> returns all intervals and their associated\n          values that intersects with <code class=\"code\">k</code></p>\n\n</div>\n", ["ALL", "AND", "ASSOCIATED", "INTERSECTIONS", "INTERSECTS", "INTERVALS", "RETURNS", "THAT", "THEIR", "VALUES", "WITH"]);
add_ocaml_element("dominators", "Std.Interval_tree.S.dominators", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.key ->\n  (Std.Interval_tree.S.key * 'a) Sequence.t", "Bap.Std.Interval_tree.S.html#VALdominators", "<div class=\"info\">\n<p><code class=\"code\">dominators&nbsp;t&nbsp;k</code> returns all intervals and their associated\n          values that include <code class=\"code\">k</code>.</p>\n\n</div>\n", ["ALL", "AND", "ASSOCIATED", "DOMINATORS", "INCLUDE", "INTERVALS", "RETURNS", "THAT", "THEIR", "VALUES"]);
add_ocaml_element("add", "Std.Interval_tree.S.add", "value", "'a Std.Interval_tree.S.t ->\n  Std.Interval_tree.S.key -> 'a -> 'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;t&nbsp;k&nbsp;x</code> adds a new binding (k,x) to the mapping.</p>\n\n</div>\n", ["ADD", "ADDS", "BINDING", "MAPPING", "NEW", "THE"]);
add_ocaml_element("max_binding", "Std.Interval_tree.S.max_binding", "value", "'a Std.Interval_tree.S.t -> (Std.Interval_tree.S.key * 'a) option", "Bap.Std.Interval_tree.S.html#VALmax_binding", "<div class=\"info\">\n<p><code class=\"code\">max_binding&nbsp;t</code> returns the greatest binding in the tree</p>\n\n</div>\n", ["BINDING", "GREATEST", "MAX_BINDING", "RETURNS", "THE", "TREE"]);
add_ocaml_element("min_binding", "Std.Interval_tree.S.min_binding", "value", "'a Std.Interval_tree.S.t -> (Std.Interval_tree.S.key * 'a) option", "Bap.Std.Interval_tree.S.html#VALmin_binding", "<div class=\"info\">\n<p><code class=\"code\">min_bining&nbsp;t</code> returns the least binding in the tree</p>\n\n</div>\n", ["BINDING", "LEAST", "MIN_BINING", "RETURNS", "THE", "TREE"]);
add_ocaml_element("greatest", "Std.Interval_tree.S.greatest", "value", "'a Std.Interval_tree.S.t -> Std.Interval_tree.S.point option", "Bap.Std.Interval_tree.S.html#VALgreatest", "<div class=\"info\">\n<p><code class=\"code\">greatest&nbsp;t</code> returns the greatest bound of the tree <code class=\"code\">t</code>.</p>\n\n</div>\n", ["BOUND", "EMPTY", "GREATEST", "NONE", "RETURNS", "THE", "TREE"]);
add_ocaml_element("least", "Std.Interval_tree.S.least", "value", "'a Std.Interval_tree.S.t -> Std.Interval_tree.S.point option", "Bap.Std.Interval_tree.S.html#VALleast", "<div class=\"info\">\n<p><code class=\"code\">least&nbsp;t</code> returns the least bound of the tree <code class=\"code\">t</code>.</p>\n\n</div>\n", ["BOUND", "EMPTY", "LEAST", "NONE", "RETURNS", "THE", "TREE"]);
add_ocaml_element("singleton", "Std.Interval_tree.S.singleton", "value", "Std.Interval_tree.S.key -> 'a -> 'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALsingleton", "<div class=\"info\">\n<p><code class=\"code\">singleton&nbsp;k&nbsp;x</code> creates an interval tree that has only one\n          mapping - from the key <code class=\"code\">k</code> to data <code class=\"code\">x</code></p>\n\n</div>\n", ["CREATES", "DATA", "FROM", "HAS", "INTERVAL", "KEY", "MAPPING", "ONE", "ONLY", "SINGLETON", "THAT", "THE", "TREE"]);
add_ocaml_element("empty", "Std.Interval_tree.S.empty", "value", "'a Std.Interval_tree.S.t", "Bap.Std.Interval_tree.S.html#VALempty", "<div class=\"info\">\n<p><code class=\"code\">empty&nbsp;x</code> an empty interval tree</p>\n\n</div>\n", ["EMPTY", "INTERVAL", "TREE"]);
add_ocaml_element("hash", "Std.Trie.Token.hash", "value", "Std.Trie.Token.t -> int", "Bap.Std.Trie.Token.html#VALhash", "", []);
add_ocaml_element("token_hash", "Std.Trie.Key.token_hash", "value", "Std.Trie.Key.token -> int", "Bap.Std.Trie.Key.html#VALtoken_hash", "<div class=\"info\">\n<p><code class=\"code\">hash_token&nbsp;tok</code> efficient hash function for the <code class=\"code\">token</code> type.</p>\n\n</div>\n", ["CAME", "EFFICIENT", "FOR", "FUNCTION", "HASH", "HASHTBL", "HASH_TOKEN", "JUST", "MIND", "NOTHING", "THE", "TOK", "TOKEN", "TYPE", "USE"]);
add_ocaml_element("nth_token", "Std.Trie.Key.nth_token", "value", "Std.Trie.Key.t -> int -> Std.Trie.Key.token", "Bap.Std.Trie.Key.html#VALnth_token", "<div class=\"info\">\n<p><code class=\"code\">nth_token&nbsp;key&nbsp;n</code> the <code class=\"code\">n</code>'th token of key.</p>\n\n</div>\n", ["KEY", "NTH_TOKEN", "SHOULD", "THE", "TOKEN"]);
add_ocaml_element("length", "Std.Trie.Key.length", "value", "Std.Trie.Key.t -> int", "Bap.Std.Trie.Key.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;key</code> return the amount of tokens in a <code class=\"code\">key</code></p>\n\n</div>\n", ["AMOUNT", "KEY", "LENGTH", "RETURN", "THE", "TOKENS"]);
add_ocaml_element("pp", "Std.Trie.S.pp", "value", "'a Std.printer -> 'a Std.Trie.S.t Std.printer", "Bap.Std.Trie.S.html#VALpp", "<div class=\"info\">\n<p><code class=\"code\">pp&nbsp;pp_val</code> creates a printer for a given value printer\n          <code class=\"code\">pp_val</code>.</p>\n\n</div>\n", ["CREATE", "CREATES", "EXAMPLE", "FOR", "GIVEN", "INTEGERS", "INT_TRIE", "LET", "POPULATED", "PP_INT", "PP_VAL", "PRINTER", "STRING", "THAT", "TRIE", "VALUE", "WILL"]);
add_ocaml_element("length", "Std.Trie.S.length", "value", "'a Std.Trie.S.t -> int", "Bap.Std.Trie.S.html#VALlength", "<div class=\"info\">\n<p><code class=\"code\">length&nbsp;trie</code> returns the number of values in <code class=\"code\">trie</code></p>\n\n</div>\n", ["LENGTH", "NUMBER", "RETURNS", "THE", "TRIE", "VALUES"]);
add_ocaml_element("longest_match", "Std.Trie.S.longest_match", "value", "'a Std.Trie.S.t -> Std.Trie.S.key -> (int * 'a) option", "Bap.Std.Trie.S.html#VALlongest_match", "<div class=\"info\">\n<p><code class=\"code\">longest_match&nbsp;trie&nbsp;key</code> find a value associated with a\n          longest substring of <code class=\"code\">key</code>.</p>\n\n</div>\n", ["AND", "ASSOCIATED", "FIND", "KEY", "LENGTH", "LONGEST", "LONGEST_MATCH", "MATCHED", "PAIR", "RETURNS", "SUBSTRING", "THAT", "THE", "TRIE", "VALUE", "WITH"]);
add_ocaml_element("remove", "Std.Trie.S.remove", "value", "'a Std.Trie.S.t -> Std.Trie.S.key -> unit", "Bap.Std.Trie.S.html#VALremove", "<div class=\"info\">\n<p><code class=\"code\">remove&nbsp;trie&nbsp;key</code> removes value bound with <code class=\"code\">key</code> if any.</p>\n\n</div>\n", ["ANY", "BOUND", "KEY", "REMOVE", "REMOVES", "TRIE", "VALUE", "WITH"]);
add_ocaml_element("walk", "Std.Trie.S.walk", "value", "'a Std.Trie.S.t ->\n  Std.Trie.S.key -> init:'b -> f:('b -> 'a option -> 'b) -> 'b", "Bap.Std.Trie.S.html#VALwalk", "<div class=\"info\">\n<p><code class=\"code\">walk&nbsp;trie&nbsp;key&nbsp;~init&nbsp;~f</code> walks down the tree starting from the\n          root and ending with the last token of the key.</p>\n\n</div>\n", ["ALL", "AND", "ASSOCIATED", "DOWN", "ENDING", "FOLD", "FROM", "FUNCTION", "INIT", "KEY", "LAST", "OVER", "ROOT", "STARTING", "SUBSTRING", "SUBSTRINGS", "THE", "TOKEN", "TREE", "TRIE", "VALUES", "WALK", "WALKS", "WITH", "ZERO"]);
add_ocaml_element("find", "Std.Trie.S.find", "value", "'a Std.Trie.S.t -> Std.Trie.S.key -> 'a option", "Bap.Std.Trie.S.html#VALfind", "<div class=\"info\">\n<p><code class=\"code\">find&nbsp;trie&nbsp;key</code> finds data associated with <code class=\"code\">key</code></p>\n\n</div>\n", ["ASSOCIATED", "DATA", "FIND", "FINDS", "KEY", "TRIE", "WITH"]);
add_ocaml_element("change", "Std.Trie.S.change", "value", "'a Std.Trie.S.t -> Std.Trie.S.key -> ('a option -> 'a option) -> unit", "Bap.Std.Trie.S.html#VALchange", "<div class=\"info\">\n<p><code class=\"code\">change&nbsp;trie&nbsp;key&nbsp;f</code> if trie has <code class=\"code\">data</code> associated with <code class=\"code\">key</code> then\n          <code class=\"code\">f</code> will be called with <code class=\"code\"><span class=\"constructor\">Some</span>&nbsp;data</code>, otherwise it will be called\n          with <code class=\"code\"><span class=\"constructor\">None</span></code>.</p>\n\n</div>\n", ["ASSOCIATED", "CALLED", "CHANGE", "DATA", "HAS", "KEY", "NONE", "OTHERWISE", "RETURNS", "SOME", "THEN", "THERE", "THING", "TRIE", "WILL", "WITH"]);
add_ocaml_element("add", "Std.Trie.S.add", "value", "'a Std.Trie.S.t -> key:Std.Trie.S.key -> data:'a -> unit", "Bap.Std.Trie.S.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;trie&nbsp;~key&nbsp;~data</code> associates <code class=\"code\">data</code> with <code class=\"code\">key</code>.</p>\n\n</div>\n", ["ADD", "ALREADY", "ASSOCIATED", "ASSOCIATES", "DATA", "HAS", "KEY", "OVERWRITTEN", "REBOUND", "SOME", "THE", "THEN", "TRIE", "VALUE", "WILL", "WITH"]);
add_ocaml_element("create", "Std.Trie.S.create", "value", "unit -> 'a Std.Trie.S.t", "Bap.Std.Trie.S.html#VALcreate", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;()</code> creates new empty trie</p>\n\n</div>\n", ["CREATE", "CREATES", "EMPTY", "NEW", "TRIE"]);
add_ocaml_element("arshift", "Std.Integer.Base.arshift", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALarshift", "<div class=\"info\">\n<p><code class=\"code\">arshift&nbsp;x&nbsp;y</code> shift <code class=\"code\">x</code> by <code class=\"code\">y</code> bits to the right and fill with\n          the sign bit.</p>\n\n</div>\n", ["AND", "ARSHIFT", "BIT", "BITS", "FILL", "RIGHT", "SHIFT", "SIGN", "THE", "WITH"]);
add_ocaml_element("rshift", "Std.Integer.Base.rshift", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALrshift", "<div class=\"info\">\n<p><code class=\"code\">rshift&nbsp;x&nbsp;y</code> shift <code class=\"code\">x</code> by <code class=\"code\">y</code> bits to the right</p>\n\n</div>\n", ["BITS", "RIGHT", "RSHIFT", "SHIFT", "THE"]);
add_ocaml_element("lshift", "Std.Integer.Base.lshift", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALlshift", "<div class=\"info\">\n<p><code class=\"code\">lshift&nbsp;x&nbsp;y</code> shift <code class=\"code\">x</code> by <code class=\"code\">y</code> bits left</p>\n\n</div>\n", ["BITS", "LEFT", "LSHIFT", "SHIFT"]);
add_ocaml_element("logxor", "Std.Integer.Base.logxor", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALlogxor", "<div class=\"info\">\n<p><code class=\"code\">logxor&nbsp;x&nbsp;y</code> is exclusive or between <code class=\"code\">x</code> and <code class=\"code\">y</code></p>\n\n</div>\n", ["AND", "BETWEEN", "EXCLUSIVE", "LOGXOR"]);
add_ocaml_element("logor", "Std.Integer.Base.logor", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALlogor", "<div class=\"info\">\n<p><code class=\"code\">logor&nbsp;x&nbsp;y</code> is a disjunction of <code class=\"code\">x</code> and <code class=\"code\">y</code></p>\n\n</div>\n", ["AND", "DISJUNCTION", "LOGOR"]);
add_ocaml_element("logand", "Std.Integer.Base.logand", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALlogand", "", []);
add_ocaml_element("lnot", "Std.Integer.Base.lnot", "value", "Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALlnot", "<div class=\"info\">\n<p><code class=\"code\">lnot&nbsp;x</code> is a logical negation of <code class=\"code\">x</code> (1-complement)</p>\n\n</div>\n", ["AND", "COMPLEMENT", "CONJUNCTION", "LNOT", "LOGAND", "LOGICAL", "NEGATION"]);
add_ocaml_element("modulo", "Std.Integer.Base.modulo", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALmodulo", "<div class=\"info\">\n<p><code class=\"code\">modulo&nbsp;&nbsp;x&nbsp;y</code> is <code class=\"code\">x&nbsp;<span class=\"keyword\">mod</span>&nbsp;y</code></p>\n\n</div>\n", ["MOD", "MODULO"]);
add_ocaml_element("div", "Std.Integer.Base.div", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALdiv", "<div class=\"info\">\n<p><code class=\"code\">div&nbsp;x&nbsp;y</code> is <code class=\"code\">x&nbsp;/&nbsp;y</code></p>\n\n</div>\n", ["DIV"]);
add_ocaml_element("mul", "Std.Integer.Base.mul", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALmul", "<div class=\"info\">\n<p><code class=\"code\">mul&nbsp;x&nbsp;y</code> is <code class=\"code\">x&nbsp;*&nbsp;y</code></p>\n\n</div>\n", ["MUL"]);
add_ocaml_element("sub", "Std.Integer.Base.sub", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALsub", "<div class=\"info\">\n<p><code class=\"code\">sub&nbsp;x&nbsp;y</code> is <code class=\"code\">x&nbsp;-&nbsp;y</code></p>\n\n</div>\n", ["SUB"]);
add_ocaml_element("add", "Std.Integer.Base.add", "value", "Std.Integer.Base.t -> Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALadd", "<div class=\"info\">\n<p><code class=\"code\">add&nbsp;x&nbsp;y</code> is <code class=\"code\">x&nbsp;+&nbsp;y</code></p>\n\n</div>\n", ["ADD"]);
add_ocaml_element("neg", "Std.Integer.Base.neg", "value", "Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALneg", "<div class=\"info\">\n<p><code class=\"code\">neg&nbsp;x</code> = <code class=\"code\">-x</code></p>\n\n</div>\n", ["NEG"]);
add_ocaml_element("abs", "Std.Integer.Base.abs", "value", "Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALabs", "<div class=\"info\">\n<p><code class=\"code\">abs&nbsp;x</code> absolute value of <code class=\"code\">x</code></p>\n\n</div>\n", ["ABS", "ABSOLUTE", "VALUE"]);
add_ocaml_element("pred", "Std.Integer.Base.pred", "value", "Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALpred", "<div class=\"info\">\n<p><code class=\"code\">pred&nbsp;n</code> is a predecessor of <code class=\"code\">n</code></p>\n\n</div>\n", ["PRED", "PREDECESSOR"]);
add_ocaml_element("succ", "Std.Integer.Base.succ", "value", "Std.Integer.Base.t -> Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALsucc", "<div class=\"info\">\n<p><code class=\"code\">succ&nbsp;n</code> successor of <code class=\"code\">n</code></p>\n\n</div>\n", ["SUCC", "SUCCESSOR"]);
add_ocaml_element("one", "Std.Integer.Base.one", "value", "Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALone", "<div class=\"info\">\n<p>element neutral to the multiplication</p>\n\n</div>\n", ["ELEMENT", "MULTIPLICATION", "NEUTRAL", "THE"]);
add_ocaml_element("zero", "Std.Integer.Base.zero", "value", "Std.Integer.Base.t", "Bap.Std.Integer.Base.html#VALzero", "<div class=\"info\">\n<p>element neutral to the addition</p>\n\n</div>\n", ["ADDITION", "ELEMENT", "NEUTRAL", "THE"]);
add_ocaml_element("(asr)", "Std.Integer.S.(asr)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(asr)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">asr</span>&nbsp;y&nbsp;=&nbsp;arshift&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["ARSHIFT", "ASR"]);
add_ocaml_element("(lsr)", "Std.Integer.S.(lsr)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(lsr)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lsr</span>&nbsp;y</code> = rshift x y</p>\n\n</div>\n", ["LSR", "RSHIFT"]);
add_ocaml_element("(lsl)", "Std.Integer.S.(lsl)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(lsl)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lsl</span>&nbsp;y&nbsp;=&nbsp;lshift&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["LSHIFT", "LSL"]);
add_ocaml_element("(lxor)", "Std.Integer.S.(lxor)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(lxor)", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keyword\">lxor</span>&nbsp;x&nbsp;y&nbsp;=&nbsp;logxor&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["LOGXOR", "LXOR"]);
add_ocaml_element("(lor)", "Std.Integer.S.(lor)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(lor)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">lor</span>&nbsp;y&nbsp;=&nbsp;logor&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["LOGOR", "LOR"]);
add_ocaml_element("(land)", "Std.Integer.S.(land)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(land)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">land</span>&nbsp;y&nbsp;=&nbsp;logand&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["LAND", "LOGAND"]);
add_ocaml_element("(mod)", "Std.Integer.S.(mod)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(mod)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;<span class=\"keyword\">mod</span>&nbsp;y&nbsp;=&nbsp;modulo&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["MOD", "MODULO"]);
add_ocaml_element("(/)", "Std.Integer.S.(/)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(/)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;/&nbsp;y&nbsp;=&nbsp;div&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["DIV"]);
add_ocaml_element("( * )", "Std.Integer.S.( * )", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL( * )", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;*&nbsp;y&nbsp;=&nbsp;mul&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["MUL"]);
add_ocaml_element("(-)", "Std.Integer.S.(-)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(-)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;-&nbsp;y&nbsp;=&nbsp;sub&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["SUB"]);
add_ocaml_element("(+)", "Std.Integer.S.(+)", "value", "Std.Integer.S.t -> Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(+)", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;+&nbsp;y&nbsp;=&nbsp;add&nbsp;x&nbsp;y</code></p>\n\n</div>\n", ["ADD"]);
add_ocaml_element("(~-)", "Std.Integer.S.(~-)", "value", "Std.Integer.S.t -> Std.Integer.S.t", "Bap.Std.Integer.S.html#VAL(~-)", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keywordsign\">~-</span>x&nbsp;=&nbsp;neg&nbsp;x</code></p>\n\n</div>\n", ["NEG"]);
add_ocaml_element("register_target", "Std.register_target", "value", "Std.arch -> (module Std.Target) -> unit", "Bap.Std.html#VALregister_target", "<div class=\"info\">\n<p>Register new target architecture.</p>\n\n</div>\n", ["ALREADY", "ARCH", "ARCHITECTURE", "EXISTS", "FOR", "GIVEN", "NEW", "REGISTER", "SUPERSEEDED", "TARGET", "THE", "THEN", "WILL"]);
add_ocaml_element("target_of_arch", "Std.target_of_arch", "value", "Std.arch -> (module Std.Target)", "Bap.Std.html#VALtarget_of_arch", "<div class=\"info\">\n<p><code class=\"code\">target_of_arch&nbsp;arch</code> returns a module packed into value, that\n      abstracts target architecture.</p>\n\n</div>\n", ["ABSTRACTS", "AND", "ARCH", "ARCHITECTURE", "BAP", "CAN", "HAS", "INTO", "LET", "LOCALLY", "MODULE", "PACKED", "RETURNED", "RETURNS", "STD", "TARGET", "TARGET_OF_ARCH", "THAT", "THE", "TYPE", "UNPACKED", "VAL", "VALUE", "WITH"]);
add_ocaml_element("filename", "Std.filename", "value", "string Std.tag", "Bap.Std.html#VALfilename", "<div class=\"info\">\n<p>A name of a file</p>\n\n</div>\n", ["FILE", "NAME"]);
add_ocaml_element("address", "Std.address", "value", "Std.addr Std.tag", "Bap.Std.html#VALaddress", "<div class=\"info\">\n<p>A virtual address of an entity</p>\n\n</div>\n", ["ADDRESS", "ENTITY", "VIRTUAL"]);
add_ocaml_element("weight", "Std.weight", "value", "float Std.tag", "Bap.Std.html#VALweight", "<div class=\"info\">\n<p>Give a weight</p>\n\n</div>\n", ["GIVE", "WEIGHT"]);
add_ocaml_element("mark", "Std.mark", "value", "unit Std.tag", "Bap.Std.html#VALmark", "<div class=\"info\">\n<p>Mark something as marked</p>\n\n</div>\n", ["MARK", "MARKED", "SOMETHING"]);
add_ocaml_element("shell", "Std.shell", "value", "string Std.tag", "Bap.Std.html#VALshell", "<div class=\"info\">\n<p>A command in shell language</p>\n\n</div>\n", ["COMMAND", "LANGUAGE", "SHELL"]);
add_ocaml_element("python", "Std.python", "value", "string Std.tag", "Bap.Std.html#VALpython", "<div class=\"info\">\n<p>A command in python language</p>\n\n</div>\n", ["COMMAND", "LANGUAGE", "PYTHON"]);
add_ocaml_element("comment", "Std.comment", "value", "string Std.tag", "Bap.Std.html#VALcomment", "<div class=\"info\">\n<p>A human readable comment</p>\n\n</div>\n", ["COMMENT", "HUMAN", "READABLE"]);
add_ocaml_element("background", "Std.background", "value", "Std.color Std.tag", "Bap.Std.html#VALbackground", "<div class=\"info\">\n<p>print marked entity with specified color.</p>\n\n</div>\n", ["COLOR", "ENTITY", "FOREGROUND", "MARKED", "PRINT", "SEE", "SPECIFIED", "WITH"]);
add_ocaml_element("foreground", "Std.foreground", "value", "Std.color Std.tag", "Bap.Std.html#VALforeground", "<div class=\"info\">\n<p>print marked entity with the specified color.</p>\n\n</div>\n", ["ASCII", "BUT", "COLOR", "CORRESPONDING", "ENTITY", "ESCAPE", "FUNCTION", "MARKED", "OUTPUT", "PRETTY", "PRINT", "PRINTING", "SAME", "SEQUENCE", "SPECIFIED", "THE", "WILL", "WITH"]);
add_ocaml_element("color", "Std.color", "value", "Std.color Std.tag", "Bap.Std.html#VALcolor", "<div class=\"info\">\n<p>Color something with a color</p>\n\n</div>\n", ["COLOR", "SOMETHING", "WITH"]);
add_ocaml_element("jmp_t", "Std.jmp_t", "value", "(Std.blk, Std.jmp) Std.cls", "Bap.Std.html#VALjmp_t", "<div class=\"info\">\n<p>jmp</p>\n\n</div>\n", ["JMP"]);
add_ocaml_element("def_t", "Std.def_t", "value", "(Std.blk, Std.def) Std.cls", "Bap.Std.html#VALdef_t", "<div class=\"info\">\n<p>def</p>\n\n</div>\n", ["DEF"]);
add_ocaml_element("phi_t", "Std.phi_t", "value", "(Std.blk, Std.phi) Std.cls", "Bap.Std.html#VALphi_t", "<div class=\"info\">\n<p>phi</p>\n\n</div>\n", ["PHI"]);
add_ocaml_element("blk_t", "Std.blk_t", "value", "(Std.sub, Std.blk) Std.cls", "Bap.Std.html#VALblk_t", "<div class=\"info\">\n<p>blk</p>\n\n</div>\n", ["BLK"]);
add_ocaml_element("arg_t", "Std.arg_t", "value", "(Std.sub, Std.arg) Std.cls", "Bap.Std.html#VALarg_t", "<div class=\"info\">\n<p>arg</p>\n\n</div>\n", ["ARG"]);
add_ocaml_element("sub_t", "Std.sub_t", "value", "(Std.program, Std.sub) Std.cls", "Bap.Std.html#VALsub_t", "<div class=\"info\">\n<p>sub</p>\n\n</div>\n", ["SUB"]);
add_ocaml_element("program_t", "Std.program_t", "value", "(Std.nil, Std.program) Std.cls", "Bap.Std.html#VALprogram_t", "<div class=\"info\">\n<p>program</p>\n\n</div>\n", ["PROGRAM"]);
add_ocaml_element("mem64_t", "Std.mem64_t", "value", "Std.size -> Std.typ", "Bap.Std.html#VALmem64_t", "<div class=\"info\">\n<p><code class=\"code\">mem64_t&nbsp;size</code> creates a type for memory with <code class=\"code\">64</code>-bit addresses\n      and elements of the given <code class=\"code\">size</code>.</p>\n\n</div>\n", ["ADDRESSES", "AND", "BIT", "CREATES", "ELEMENTS", "FOR", "GIVEN", "MEM64_T", "MEMORY", "SIZE", "THE", "TYPE", "WITH"]);
add_ocaml_element("mem32_t", "Std.mem32_t", "value", "Std.size -> Std.typ", "Bap.Std.html#VALmem32_t", "<div class=\"info\">\n<p><code class=\"code\">mem32_t&nbsp;size</code> creates a type for memory with <code class=\"code\">32</code>-bit addresses\n      and elements of the given <code class=\"code\">size</code>.</p>\n\n</div>\n", ["ADDRESSES", "AND", "BIT", "CREATES", "ELEMENTS", "FOR", "GIVEN", "MEM32_T", "MEMORY", "SIZE", "THE", "TYPE", "WITH"]);
add_ocaml_element("reg256_t", "Std.reg256_t", "value", "Std.typ", "Bap.Std.html#VALreg256_t", "<div class=\"info\">\n<p>256-bit width value</p>\n\n</div>\n", ["256", "BIT", "VALUE", "WIDTH"]);
add_ocaml_element("reg128_t", "Std.reg128_t", "value", "Std.typ", "Bap.Std.html#VALreg128_t", "<div class=\"info\">\n<p>128-bit width value</p>\n\n</div>\n", ["128", "BIT", "VALUE", "WIDTH"]);
add_ocaml_element("reg64_t", "Std.reg64_t", "value", "Std.typ", "Bap.Std.html#VALreg64_t", "<div class=\"info\">\n<p>64-bit width value</p>\n\n</div>\n", ["BIT", "VALUE", "WIDTH"]);
add_ocaml_element("reg32_t", "Std.reg32_t", "value", "Std.typ", "Bap.Std.html#VALreg32_t", "<div class=\"info\">\n<p>32-bit width value</p>\n\n</div>\n", ["BIT", "VALUE", "WIDTH"]);
add_ocaml_element("reg16_t", "Std.reg16_t", "value", "Std.typ", "Bap.Std.html#VALreg16_t", "<div class=\"info\">\n<p>16-bit width value</p>\n\n</div>\n", ["BIT", "VALUE", "WIDTH"]);
add_ocaml_element("reg8_t", "Std.reg8_t", "value", "Std.typ", "Bap.Std.html#VALreg8_t", "<div class=\"info\">\n<p>8-bit width value</p>\n\n</div>\n", ["BIT", "VALUE", "WIDTH"]);
add_ocaml_element("bool_t", "Std.bool_t", "value", "Std.typ", "Bap.Std.html#VALbool_t", "<div class=\"info\">\n<p>one bit</p>\n\n</div>\n", ["BIT", "ONE"]);
add_ocaml_element("Unknown_mode", "Text_tags.Unknown_mode", "exception", "string", "Text_tags.html#EXCEPTIONUnknown_mode", "", []);
add_ocaml_element("Not_in_path", "Bap_ida.Std.Ida.Not_in_path", "exception", "", "Bap_ida.Std.Ida.html#EXCEPTIONNot_in_path", "", []);
add_ocaml_element("Failed", "Bap_ida.Std.Ida.Failed", "exception", "string", "Bap_ida.Std.Ida.html#EXCEPTIONFailed", "<div class=\"info\">\n<p>exception External_command_failed occurs when the external IDA\n        command was not executed successfully</p>\n\n</div>\n", ["COMMAND", "EXCEPTION", "EXECUTED", "EXTERNAL", "EXTERNAL_COMMAND_FAILED", "IDA", "NOT", "OCCURS", "SUCCESSFULLY", "THE", "WAS", "WHEN"]);
add_ocaml_element("Parse_error", "Bap_bml.Parse_error", "exception", "string", "Bap_bml.html#EXCEPTIONParse_error", "<div class=\"info\">\n<p>A parser error</p>\n\n</div>\n", ["ERROR", "PARSER"]);
add_ocaml_element("Lifting_failed", "Arm_types.Lifting_failed", "exception", "string", "Arm_types.html#EXCEPTIONLifting_failed", "", []);
add_ocaml_element("Not_a_bundle", "Bap_bundle.Std.Not_a_bundle", "exception", "", "Bap_bundle.Std.html#EXCEPTIONNot_a_bundle", "", []);
add_ocaml_element("Failed", "Std.Project.Pass.Failed", "exception", "Std.Project.Pass.error", "Bap.Std.Project.Pass.html#EXCEPTIONFailed", "<div class=\"info\">\n<p>raised when a pass failed to load or to run.</p>\n\n</div>\n", ["AND", "DOCUMENTATION", "EXCEPTION", "FAILED", "FROM", "FUNCTIONS", "HAS", "LOAD", "MODULE", "NAME", "NOTE", "ONLY", "PASS", "RAISED", "RUN", "STATE", "SUFFIX", "THAT", "THEIR", "THIS", "TWO", "WHEN"]);
add_ocaml_element("T", "Std.Type.Error.T", "exception", "Std.Type.Error.t", "Bap.Std.Type.Error.html#EXCEPTIONT", "", []);
add_ocaml_element("mode", "Text_tags.mode", "type", "<i>(... type ...)</i>", "Text_tags.html#TYPEmode", "<div class=\"info\">\n<p>A name of mode, by default the following modes ares supported\n    <code class=\"code\">html</code>, <code class=\"code\">blocks</code>, <code class=\"code\">attr</code> and <code class=\"code\">none</code></p>\n\n</div>\n", ["AND", "ARES", "ATTR", "BLOCKS", "DEFAULT", "FOLLOWING", "HTML", "MODE", "MODES", "NAME", "NONE", "SUPPORTED", "THE"]);
add_ocaml_element("t", "Bap_strings_unscrambler.Make.t", "type", "<i>(... type ...)</i>", "Bap_strings_unscrambler.Make.html#TYPEt", "", []);
add_ocaml_element("decision", "Bap_strings_detector.decision", "type", "<i>(... type ...)</i>", "Bap_strings_detector.html#TYPEdecision", "", []);
add_ocaml_element("t", "Bap_strings_detector.t", "type", "<i>(... type ...)</i>", "Bap_strings_detector.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">detector</code></p>\n\n</div>\n", ["DETECTOR"]);
add_ocaml_element("t", "Bap_strings_index.Key.t", "type", "<i>(... type ...)</i>", "Bap_strings_index.Key.html#TYPEt", "", []);
add_ocaml_element("key", "Bap_strings_index.Persistent.S.key", "type", "<i>(... type ...)</i>", "Bap_strings_index.Persistent.S.html#TYPEkey", "", []);
add_ocaml_element("t", "Bap_strings_index.Persistent.S.t", "type", "<i>(... type ...)</i>", "Bap_strings_index.Persistent.S.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Trace_stats.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace_stats.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.File_stats.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.File_stats.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Binary.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Binary.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Tracer.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Tracer.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Modload.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Modload.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Return.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Return.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Call.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Call.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Location.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Location.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Exn.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Exn.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Syscall.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Syscall.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Chunk.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Chunk.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Move.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Move.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Trace.Monitor.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.Monitor.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_traces.Std.Trace.Reader.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.Reader.html#TYPEt", "", []);
add_ocaml_element("step", "Bap_traces.Std.Trace.step", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEstep", "", []);
add_ocaml_element("reader", "Bap_traces.Std.Trace.reader", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEreader", "", []);
add_ocaml_element("error", "Bap_traces.Std.Trace.error", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEerror", "", []);
add_ocaml_element("io_error", "Bap_traces.Std.Trace.io_error", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEio_error", "", []);
add_ocaml_element("t", "Bap_traces.Std.Trace.t", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEt", "", []);
add_ocaml_element("id", "Bap_traces.Std.Trace.id", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEid", "", []);
add_ocaml_element("tool", "Bap_traces.Std.Trace.tool", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEtool", "", []);
add_ocaml_element("proto", "Bap_traces.Std.Trace.proto", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEproto", "", []);
add_ocaml_element("monitor", "Bap_traces.Std.Trace.monitor", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEmonitor", "", []);
add_ocaml_element("event", "Bap_traces.Std.Trace.event", "type", "<i>(... type ...)</i>", "Bap_traces.Std.Trace.html#TYPEevent", "", []);
add_ocaml_element("trace_stats", "Bap_traces.Std.trace_stats", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEtrace_stats", "", []);
add_ocaml_element("file_stats", "Bap_traces.Std.file_stats", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEfile_stats", "", []);
add_ocaml_element("binary", "Bap_traces.Std.binary", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEbinary", "", []);
add_ocaml_element("tracer", "Bap_traces.Std.tracer", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEtracer", "", []);
add_ocaml_element("modload", "Bap_traces.Std.modload", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEmodload", "", []);
add_ocaml_element("return", "Bap_traces.Std.return", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEreturn", "", []);
add_ocaml_element("call", "Bap_traces.Std.call", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEcall", "", []);
add_ocaml_element("exn", "Bap_traces.Std.exn", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEexn", "", []);
add_ocaml_element("syscall", "Bap_traces.Std.syscall", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEsyscall", "", []);
add_ocaml_element("chunk", "Bap_traces.Std.chunk", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEchunk", "", []);
add_ocaml_element("move", "Bap_traces.Std.move", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEmove", "", []);
add_ocaml_element("location", "Bap_traces.Std.location", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPElocation", "", []);
add_ocaml_element("trace", "Bap_traces.Std.trace", "type", "<i>(... type ...)</i>", "Bap_traces.Std.html#TYPEtrace", "<div class=\"info\">\n<p>the trace</p>\n\n</div>\n", ["THE", "TRACE"]);
add_ocaml_element("x86_syntax", "Bap_llvm.Std.x86_syntax", "type", "<i>(... type ...)</i>", "Bap_llvm.Std.html#TYPEx86_syntax", "", []);
add_ocaml_element("t", "Bap_ida.Std.Service.t", "type", "<i>(... type ...)</i>", "Bap_ida.Std.Service.html#TYPEt", "", []);
add_ocaml_element("language", "Bap_ida.Std.Command.language", "type", "<i>(... type ...)</i>", "Bap_ida.Std.Command.html#TYPElanguage", "", []);
add_ocaml_element("t", "Bap_ida.Std.Command.t", "type", "<i>(... type ...)</i>", "Bap_ida.Std.Command.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_ida.Std.Ida.t", "type", "<i>(... type ...)</i>", "Bap_ida.Std.Ida.html#TYPEt", "<div class=\"info\">\n<p>IDA instance</p>\n\n</div>\n", ["IDA", "INSTANCE"]);
add_ocaml_element("command", "Bap_ida.Std.command", "type", "<i>(... type ...)</i>", "Bap_ida.Std.html#TYPEcommand", "", []);
add_ocaml_element("ida", "Bap_ida.Std.ida", "type", "<i>(... type ...)</i>", "Bap_ida.Std.html#TYPEida", "", []);
add_ocaml_element("decoder", "Bap_dwarf.Std.Leb128.decoder", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Leb128.html#TYPEdecoder", "", []);
add_ocaml_element("encoder", "Bap_dwarf.Std.Leb128.encoder", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Leb128.html#TYPEencoder", "<div class=\"info\">\n<p><code class=\"code\">encode&nbsp;~signed&nbsp;v</code> encodes value <code class=\"code\">v</code> in a LEB128 format.</p>\n\n</div>\n", ["DECODE", "DECODES", "ENCODE", "ENCODES", "ENCODING", "FORMAT", "FROM", "LEB", "LEB128", "NUMBER", "REPRESENTATION", "SIGNED", "THEN", "TRUE", "USES", "VALUE"]);
add_ocaml_element("t", "Bap_dwarf.Std.Leb128.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Leb128.html#TYPEt", "<div class=\"info\">\n<p>an encoded value</p>\n\n</div>\n", ["ENCODED", "VALUE"]);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Fbi.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Fbi.html#TYPEt", "", []);
add_ocaml_element("buffer", "Bap_dwarf.Std.Dwarf.Data.buffer", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Data.html#TYPEbuffer", "", []);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Data.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Data.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Buffer.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Buffer.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">create&nbsp;~pos:0&nbsp;</code> creates a buffer from a data</p>\n\n</div>\n", ["BUFFER", "CREATE", "CREATES", "DATA", "FROM", "POS"]);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Fn.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Fn.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Form.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Attr.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Attr.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Tag.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_dwarf.Std.Dwarf.Section.t", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.Section.html#TYPEt", "", []);
add_ocaml_element("fn", "Bap_dwarf.Std.Dwarf.fn", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.html#TYPEfn", "", []);
add_ocaml_element("section", "Bap_dwarf.Std.Dwarf.section", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.html#TYPEsection", "", []);
add_ocaml_element("form", "Bap_dwarf.Std.Dwarf.form", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.html#TYPEform", "", []);
add_ocaml_element("attr", "Bap_dwarf.Std.Dwarf.attr", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.html#TYPEattr", "", []);
add_ocaml_element("tag", "Bap_dwarf.Std.Dwarf.tag", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.html#TYPEtag", "", []);
add_ocaml_element("lenspec", "Bap_dwarf.Std.Dwarf.lenspec", "type", "<i>(... type ...)</i>", "Bap_dwarf.Std.Dwarf.html#TYPElenspec", "", []);
add_ocaml_element("t", "Bap_demangle.Std.Demangler.t", "type", "<i>(... type ...)</i>", "Bap_demangle.Std.Demangler.html#TYPEt", "", []);
add_ocaml_element("demangler", "Bap_demangle.Std.demangler", "type", "<i>(... type ...)</i>", "Bap_demangle.Std.html#TYPEdemangler", "", []);
add_ocaml_element("key", "Bap_byteweight.Corpus.key", "type", "<i>(... type ...)</i>", "Bap_byteweight.Corpus.html#TYPEkey", "", []);
add_ocaml_element("t", "Bap_byteweight.Corpus.t", "type", "<i>(... type ...)</i>", "Bap_byteweight.Corpus.html#TYPEt", "", []);
add_ocaml_element("corpus", "Bap_byteweight.S.corpus", "type", "<i>(... type ...)</i>", "Bap_byteweight.S.html#TYPEcorpus", "", []);
add_ocaml_element("key", "Bap_byteweight.S.key", "type", "<i>(... type ...)</i>", "Bap_byteweight.S.html#TYPEkey", "", []);
add_ocaml_element("t", "Bap_byteweight.S.t", "type", "<i>(... type ...)</i>", "Bap_byteweight.S.html#TYPEt", "", []);
add_ocaml_element("error", "Bap_byteweight_signatures.error", "type", "<i>(... type ...)</i>", "Bap_byteweight_signatures.html#TYPEerror", "<div class=\"info\">\n<p>Error conditions</p>\n\n</div>\n", ["CONDITIONS", "ERROR"]);
add_ocaml_element("t", "Bap_bml.Registry.t", "type", "<i>(... type ...)</i>", "Bap_bml.Registry.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_bml.Ops.t", "type", "<i>(... type ...)</i>", "Bap_bml.Ops.html#TYPEt", "", []);
add_ocaml_element("parser", "Bap_c_parser.parser", "type", "<i>(... type ...)</i>", "Bap_c_parser.html#TYPEparser", "", []);
add_ocaml_element("decls", "Bap_c_parser.decls", "type", "<i>(... type ...)</i>", "Bap_c_parser.html#TYPEdecls", "", []);
add_ocaml_element("bits", "Bap_c_size.bits", "type", "<i>(... type ...)</i>", "Bap_c_size.html#TYPEbits", "", []);
add_ocaml_element("t", "Bap_c_abi.t", "type", "<i>(... type ...)</i>", "Bap_c_abi.html#TYPEt", "<div class=\"info\">\n<p>an abi processor.</p>\n\n</div>\n", ["ABI", "ARCHITECTURE", "BETWEEN", "DISPATCHING", "EACH", "FOR", "ITS", "OWN", "PROCESSED", "PROCESSOR", "PROCESSORS", "REGISTERS", "RESPONSIBLE", "SPECIFIC", "SUBROUTINE", "THAT", "THE"]);
add_ocaml_element("args", "Bap_c_abi.args", "type", "<i>(... type ...)</i>", "Bap_c_abi.html#TYPEargs", "<div class=\"info\">\n<p>subroutine argument list is split into three parts:\n    <code class=\"code\">return</code> is the return arguments, that is optional;\n    <code class=\"code\">params</code> are regular positional parameters, the length\n    of the <code class=\"code\">params</code> list must equal to the amount of the\n    formals in the function prototype;\n    <code class=\"code\">hidden</code> are hidden parameters, that are inserted by abi\n    to pass special arguments, like <code class=\"code\">this</code> pointer or a pointer\n    to a structural value, for example.</p>\n\n</div>\n", ["ABI", "ALL", "AMOUNT", "AND", "ANY", "API", "ARE", "ARG", "ARGUMENT", "ARGUMENTS", "BETWEEN", "CORRESPONDS", "COUNTING", "CREATED", "EQUAL", "EXAMPLE", "FOLLOWING", "FOR", "FORMALS", "FROM", "FUNCTION", "HIDDEN", "INSERT", "INSERTED", "INTO", "LAST", "LENGTH", "LIKE", "LIST", "MODULE", "MUST", "NTH", "OPTIONAL", "PARAMETERS", "PARAMS", "PARTS", "PASS", "POINTER", "POSITIONAL", "PROCESSOR", "PROTOTYPE", "PUT", "REGULAR", "RETURN", "SPECIAL", "SPLIT", "STRUCTURAL", "SUB", "SUBROUTINE", "TERM", "TERMS", "THAT", "THE", "THIS", "THREE", "VALUE", "WAY", "WILL"]);
add_ocaml_element("param", "Bap_c_abi.param", "type", "<i>(... type ...)</i>", "Bap_c_abi.html#TYPEparam", "<div class=\"info\">\n<p>Function formal parameter is represented as a pair of\n    an abstraction of data, that is passed via the parameter,\n    and a BIL expression, that denotes the parameter.</p>\n\n</div>\n", ["ABSTRACTION", "AND", "BIL", "DATA", "DENOTES", "EXPRESSION", "FORMAL", "FUNCTION", "PAIR", "PARAMETER", "PASSED", "REPRESENTED", "THAT", "THE", "VIA"]);
add_ocaml_element("m", "Bap_c_type_mapper_intf.S.m", "type", "<i>(... type ...)</i>", "Bap_c_type_mapper_intf.S.html#TYPEm", "", []);
add_ocaml_element("pass", "Bap_c_attr.pass", "type", "<i>(... type ...)</i>", "Bap_c_attr.html#TYPEpass", "<div class=\"info\">\n<p>a type of action</p>\n\n</div>\n", ["ACTION", "TYPE"]);
add_ocaml_element("t", "Bap_c_data.t", "type", "<i>(... type ...)</i>", "Bap_c_data.html#TYPEt", "<div class=\"info\">\n<p>abstraction of a \208\161 datum.</p>\n\n</div>\n", ["ABSTRACT", "ABSTRACTION", "AND", "BITS", "DATA", "DATUM", "EITHER", "GIVEN", "IMMEDIATE", "LATTICE", "PARTICULAR", "POINTER", "REPRESENT", "SEQUENCE", "SIZE", "THAT", "THE", "VALUE"]);
add_ocaml_element("value", "Bap_c_data.value", "type", "<i>(... type ...)</i>", "Bap_c_data.html#TYPEvalue", "<div class=\"info\">\n<p>Abstract value lattice.</p>\n\n</div>\n", ["ABSTRACT", "AND", "BOT", "COMPLETE", "LATTICE", "SET", "SUPREMUM", "THE", "VALUE"]);
add_ocaml_element("model", "Bap_c_data.model", "type", "<i>(... type ...)</i>", "Bap_c_data.html#TYPEmodel", "<div class=\"info\">\n<p>The following table summarize all models of integer\n    representation.</p>\n\n</div>\n", ["ADDR", "ALL", "CHAR", "FOLLOWING", "ILP32", "ILP64", "INT", "INTEGER", "LLP64", "LONG", "LP32", "LP64", "MODELS", "REPRESENTATION", "SHORT", "SUMMARIZE", "TABLE", "THE"]);
add_ocaml_element("model64", "Bap_c_data.model64", "type", "<i>(... type ...)</i>", "Bap_c_data.html#TYPEmodel64", "<div class=\"info\">\n<p>models for 64 bit systems</p>\n\n</div>\n", ["BIT", "FOR", "MODELS", "SYSTEMS"]);
add_ocaml_element("model32", "Bap_c_data.model32", "type", "<i>(... type ...)</i>", "Bap_c_data.html#TYPEmodel32", "<div class=\"info\">\n<p>models for 32 bit systems</p>\n\n</div>\n", ["BIT", "FOR", "MODELS", "SYSTEMS"]);
add_ocaml_element("t", "Bap_c_type.Array.t", "type", "<i>(... type ...)</i>", "Bap_c_type.Array.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_c_type.Compound.t", "type", "<i>(... type ...)</i>", "Bap_c_type.Compound.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_c_type.Proto.t", "type", "<i>(... type ...)</i>", "Bap_c_type.Proto.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_c_type.Spec.t", "type", "<i>(... type ...)</i>", "Bap_c_type.Spec.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_c_type.Attr.t", "type", "<i>(... type ...)</i>", "Bap_c_type.Attr.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_c_type.Qualifier.t", "type", "<i>(... type ...)</i>", "Bap_c_type.Qualifier.html#TYPEt", "", []);
add_ocaml_element("aggregate", "Bap_c_type.aggregate", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEaggregate", "", []);
add_ocaml_element("scalar", "Bap_c_type.scalar", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEscalar", "", []);
add_ocaml_element("array", "Bap_c_type.array", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEarray", "", []);
add_ocaml_element("compound", "Bap_c_type.compound", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEcompound", "", []);
add_ocaml_element("proto", "Bap_c_type.proto", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEproto", "", []);
add_ocaml_element("t", "Bap_c_type.t", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEt", "", []);
add_ocaml_element("no_qualifier", "Bap_c_type.no_qualifier", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEno_qualifier", "", []);
add_ocaml_element("spec", "Bap_c_type.spec", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEspec", "", []);
add_ocaml_element("attr", "Bap_c_type.attr", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEattr", "", []);
add_ocaml_element("qualifier", "Bap_c_type.qualifier", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEqualifier", "", []);
add_ocaml_element("cvr", "Bap_c_type.cvr", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEcvr", "", []);
add_ocaml_element("cv", "Bap_c_type.cv", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEcv", "", []);
add_ocaml_element("basic", "Bap_c_type.basic", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEbasic", "", []);
add_ocaml_element("floating", "Bap_c_type.floating", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEfloating", "", []);
add_ocaml_element("complex", "Bap_c_type.complex", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEcomplex", "", []);
add_ocaml_element("real", "Bap_c_type.real", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEreal", "", []);
add_ocaml_element("integer", "Bap_c_type.integer", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEinteger", "", []);
add_ocaml_element("enum", "Bap_c_type.enum", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEenum", "", []);
add_ocaml_element("unsigned", "Bap_c_type.unsigned", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEunsigned", "", []);
add_ocaml_element("signed", "Bap_c_type.signed", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEsigned", "", []);
add_ocaml_element("long_long", "Bap_c_type.long_long", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPElong_long", "", []);
add_ocaml_element("long", "Bap_c_type.long", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPElong", "", []);
add_ocaml_element("cint", "Bap_c_type.cint", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEcint", "", []);
add_ocaml_element("short", "Bap_c_type.short", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEshort", "", []);
add_ocaml_element("char", "Bap_c_type.char", "type", "<i>(... type ...)</i>", "Bap_c_type.html#TYPEchar", "", []);
add_ocaml_element("t", "Bap_api.S.t", "type", "<i>(... type ...)</i>", "Bap_api.S.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_api.t", "type", "<i>(... type ...)</i>", "Bap_api.html#TYPEt", "<div class=\"info\">\n<p>language processor type</p>\n\n</div>\n", ["LANGUAGE", "PROCESSOR", "TYPE"]);
add_ocaml_element("api", "Bap_api.api", "type", "<i>(... type ...)</i>", "Bap_api.html#TYPEapi", "", []);
add_ocaml_element("filename", "Bap_api.filename", "type", "<i>(... type ...)</i>", "Bap_api.html#TYPEfilename", "", []);
add_ocaml_element("t", "X86_asm_reg_types.t", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEt", "", []);
add_ocaml_element("gpr", "X86_asm_reg_types.gpr", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEgpr", "", []);
add_ocaml_element("segment_base", "X86_asm_reg_types.segment_base", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEsegment_base", "", []);
add_ocaml_element("segment", "X86_asm_reg_types.segment", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEsegment", "", []);
add_ocaml_element("ip", "X86_asm_reg_types.ip", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEip", "", []);
add_ocaml_element("r256", "X86_asm_reg_types.r256", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr256", "", []);
add_ocaml_element("r128", "X86_asm_reg_types.r128", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr128", "<div class=\"info\">\n<p>SSE register types</p>\n\n</div>\n", ["REGISTER", "SSE", "TYPES"]);
add_ocaml_element("r64", "X86_asm_reg_types.r64", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr64", "<div class=\"info\">\n<p>64-bit GPR registers</p>\n\n</div>\n", ["BIT", "GPR", "REGISTERS"]);
add_ocaml_element("r32", "X86_asm_reg_types.r32", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr32", "<div class=\"info\">\n<p>32-bit GPR registers</p>\n\n</div>\n", ["BIT", "GPR", "REGISTERS"]);
add_ocaml_element("r16", "X86_asm_reg_types.r16", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr16", "<div class=\"info\">\n<p>16-bit GPR registers</p>\n\n</div>\n", ["BIT", "GPR", "REGISTERS"]);
add_ocaml_element("r8", "X86_asm_reg_types.r8", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr8", "<div class=\"info\">\n<p>all 8 bit GPR registers</p>\n\n</div>\n", ["ALL", "BIT", "GPR", "REGISTERS"]);
add_ocaml_element("r8h", "X86_asm_reg_types.r8h", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr8h", "<div class=\"info\">\n<p>8-bit high-byte GPR registers</p>\n\n</div>\n", ["BIT", "BYTE", "GPR", "HIGH", "REGISTERS"]);
add_ocaml_element("r8l", "X86_asm_reg_types.r8l", "type", "<i>(... type ...)</i>", "X86_asm_reg_types.html#TYPEr8l", "<div class=\"info\">\n<p>8-bit low byte GPR registers</p>\n\n</div>\n", ["BIT", "BYTE", "GPR", "LOW", "REGISTERS"]);
add_ocaml_element("reg", "X86_asm.reg", "type", "<i>(... type ...)</i>", "X86_asm.html#TYPEreg", "", []);
add_ocaml_element("pcmpinfo", "X86_types.Pcmpstr.pcmpinfo", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEpcmpinfo", "<div class=\"info\">\n<p>Information about the type of pcmp instruction.</p>\n\n</div>\n", ["ABOUT", "INFORMATION", "INSTRUCTION", "PCMP", "THE", "TYPE"]);
add_ocaml_element("len", "X86_types.Pcmpstr.len", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPElen", "", []);
add_ocaml_element("out", "X86_types.Pcmpstr.out", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEout", "", []);
add_ocaml_element("imm8cb", "X86_types.Pcmpstr.imm8cb", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEimm8cb", "<div class=\"info\">\n<p>See Section 4.1 of Intel manual for more\n     information on the immediate control byte.</p>\n\n</div>\n", ["ALL", "ANY", "ARE", "BIT", "BITS", "BYTE", "BYTES", "COMPLEMENT", "CONTROL", "EACH", "ELEMENTS", "EQUAL", "FOR", "IMMEDIATE", "INFORMATION", "INTEL", "INTRES1", "INTRES2", "LEAST", "MANUAL", "MASKED", "MEM", "MORE", "MOST", "NEGATED", "NEGATION", "ORDERED", "PACKED", "RANGES", "REG", "SECTION", "SEE", "SET", "SIGNED", "SIGNIFICANT", "THE", "UNDEFINED", "UNMODIFIED", "UNSIGNED", "USE", "VALIDITY", "WORDS"]);
add_ocaml_element("outselectmask", "X86_types.Pcmpstr.outselectmask", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEoutselectmask", "", []);
add_ocaml_element("outselectsig", "X86_types.Pcmpstr.outselectsig", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEoutselectsig", "", []);
add_ocaml_element("agg", "X86_types.Pcmpstr.agg", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEagg", "", []);
add_ocaml_element("ssign", "X86_types.Pcmpstr.ssign", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEssign", "", []);
add_ocaml_element("ssize", "X86_types.Pcmpstr.ssize", "type", "<i>(... type ...)</i>", "X86_types.Pcmpstr.html#TYPEssize", "", []);
add_ocaml_element("prefix", "X86_types.prefix", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("vex", "X86_types.vex", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEvex", "", []);
add_ocaml_element("rex", "X86_types.rex", "type", "<i>(... type ...)</i>", "X86_types.html#TYPErex", "<div class=\"info\">\n<p>See Table 2-4: REX Prefix Fields.</p>\n\n</div>\n", ["FIELDS", "PREFIX", "REX", "SEE", "TABLE"]);
add_ocaml_element("opcode", "X86_types.opcode", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("cast_type", "X86_types.cast_type", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEcast_type", "", []);
add_ocaml_element("offsetinfo", "X86_types.offsetinfo", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEoffsetinfo", "", []);
add_ocaml_element("jumptarget", "X86_types.jumptarget", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEjumptarget", "", []);
add_ocaml_element("operand", "X86_types.operand", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEoperand", "", []);
add_ocaml_element("direction", "X86_types.direction", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEdirection", "", []);
add_ocaml_element("order", "X86_types.order", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEorder", "", []);
add_ocaml_element("mode", "X86_types.mode", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEmode", "", []);
add_ocaml_element("binopf", "X86_types.binopf", "type", "<i>(... type ...)</i>", "X86_types.html#TYPEbinopf", "", []);
add_ocaml_element("smul_size", "Arm_types.smul_size", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("shift", "Arm_types.shift", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEshift", "<div class=\"info\">\n<p>shift types</p>\n\n</div>\n", ["SHIFT", "TYPES"]);
add_ocaml_element("repair", "Arm_types.repair", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPErepair", "", []);
add_ocaml_element("data_oper", "Arm_types.data_oper", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEdata_oper", "", []);
add_ocaml_element("move", "Arm_types.move", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmove", "", []);
add_ocaml_element("arth", "Arm_types.arth", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEarth", "<div class=\"info\">\n<p>Types for data movement operations</p>\n\n</div>\n", ["DATA", "FOR", "MOVEMENT", "OPERATIONS", "TYPES"]);
add_ocaml_element("update_m", "Arm_types.update_m", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEupdate_m", "", []);
add_ocaml_element("mode_m", "Arm_types.mode_m", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmode_m", "<div class=\"info\">\n<p>Types for multiple-register memory access</p>\n\n</div>\n", ["ACCESS", "FOR", "MEMORY", "MULTIPLE", "REGISTER", "TYPES"]);
add_ocaml_element("size", "Arm_types.size", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEsize", "", []);
add_ocaml_element("operation", "Arm_types.operation", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEoperation", "", []);
add_ocaml_element("sign", "Arm_types.sign", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEsign", "", []);
add_ocaml_element("mode_r", "Arm_types.mode_r", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmode_r", "<div class=\"info\">\n<p>Types for single-register memory access</p>\n\n</div>\n", ["ACCESS", "FOR", "MEMORY", "REGISTER", "SINGLE", "TYPES"]);
add_ocaml_element("insn", "Arm_types.insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEinsn", "", []);
add_ocaml_element("special_insn", "Arm_types.special_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEspecial_insn", "", []);
add_ocaml_element("branch_insn", "Arm_types.branch_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEbranch_insn", "", []);
add_ocaml_element("mem_insn", "Arm_types.mem_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmem_insn", "", []);
add_ocaml_element("mem_multi_insn", "Arm_types.mem_multi_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmem_multi_insn", "", []);
add_ocaml_element("mult_insn", "Arm_types.mult_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmult_insn", "", []);
add_ocaml_element("bits_insn", "Arm_types.bits_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEbits_insn", "", []);
add_ocaml_element("move_insn", "Arm_types.move_insn", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEmove_insn", "", []);
add_ocaml_element("op", "Arm_types.op", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEop", "", []);
add_ocaml_element("reg", "Arm_types.reg", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEreg", "", []);
add_ocaml_element("non_nil_reg", "Arm_types.non_nil_reg", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEnon_nil_reg", "", []);
add_ocaml_element("ccr_or_nil", "Arm_types.ccr_or_nil", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEccr_or_nil", "", []);
add_ocaml_element("ccr_reg", "Arm_types.ccr_reg", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEccr_reg", "<div class=\"info\">\n<p>conditition code registers</p>\n\n</div>\n", ["CODE", "CONDITITION", "REGISTERS"]);
add_ocaml_element("gpr_or_nil", "Arm_types.gpr_or_nil", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEgpr_or_nil", "", []);
add_ocaml_element("gpr_reg", "Arm_types.gpr_reg", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEgpr_reg", "<div class=\"info\">\n<p>General purpose registers</p>\n\n</div>\n", ["GENERAL", "PURPOSE", "REGISTERS"]);
add_ocaml_element("nil_reg", "Arm_types.nil_reg", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEnil_reg", "", []);
add_ocaml_element("cond", "Arm_types.cond", "type", "<i>(... type ...)</i>", "Arm_types.html#TYPEcond", "", []);
add_ocaml_element("t", "Arm_reg.t", "type", "<i>(... type ...)</i>", "Arm_reg.html#TYPEt", "", []);
add_ocaml_element("t", "Arm_cond.t", "type", "<i>(... type ...)</i>", "Arm_cond.html#TYPEt", "", []);
add_ocaml_element("t", "Arm_op.t", "type", "<i>(... type ...)</i>", "Arm_op.html#TYPEt", "", []);
add_ocaml_element("t", "Arm_insn.t", "type", "<i>(... type ...)</i>", "Arm_insn.html#TYPEt", "<div class=\"info\">\n<p>insn opcode.</p>\n\n</div>\n", ["ARM", "BAP", "BETTER", "CONTRADICITION", "INSN", "JUST", "MUCH", "NAME", "ONE", "OPCODE", "OPERANDS", "POSSIBLY", "THE", "WITH", "WITHOUT", "WOULD"]);
add_ocaml_element("error", "Bare.Rule.error", "type", "<i>(... type ...)</i>", "Bare.Rule.html#TYPEerror", "<div class=\"info\">\n<p>an abstract representation of an error</p>\n\n</div>\n", ["ABSTRACT", "ERROR", "REPRESENTATION"]);
add_ocaml_element("t", "Bare.Rule.t", "type", "<i>(... type ...)</i>", "Bare.Rule.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">rule&nbsp;abstract&nbsp;<span class=\"keyword\">type</span></code></p>\n\n</div>\n", ["ABSTRACT", "RULE", "TYPE"]);
add_ocaml_element("fact", "Bare.fact", "type", "<i>(... type ...)</i>", "Bare.html#TYPEfact", "<div class=\"info\">\n<p>representation of a fact</p>\n\n</div>\n", ["FACT", "REPRESENTATION"]);
add_ocaml_element("tuple", "Bare.tuple", "type", "<i>(... type ...)</i>", "Bare.html#TYPEtuple", "<div class=\"info\">\n<p>representation of a tuple</p>\n\n</div>\n", ["REPRESENTATION", "TUPLE"]);
add_ocaml_element("t", "Std.Primus.Exn.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Exn.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Primus.Lisp.Primitive.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Primitive.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Primus.Lisp.Message.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Message.html#TYPEt", "", []);
add_ocaml_element("parameters", "Std.Primus.Lisp.Type.parameters", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Type.html#TYPEparameters", "<div class=\"info\">\n<p>a type specifier for function parameters</p>\n\n</div>\n", ["DIRECTLY", "DON", "EDSL", "FOR", "FUNCTION", "MODULE", "PARAMETERS", "SPEC", "SPECIFIER", "THE", "THIS", "TYPE", "USE", "USES"]);
add_ocaml_element("error", "Std.Primus.Lisp.Type.error", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Type.html#TYPEerror", "<div class=\"info\">\n<p>An abstract type error</p>\n\n</div>\n", ["ABSTRACT", "ERROR", "TYPE"]);
add_ocaml_element("signature", "Std.Primus.Lisp.Type.signature", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Type.html#TYPEsignature", "<div class=\"info\">\n<p>Definition signature</p>\n\n</div>\n", ["DEFINITION", "SIGNATURE"]);
add_ocaml_element("t", "Std.Primus.Lisp.Type.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Type.html#TYPEt", "<div class=\"info\">\n<p>A type of an expression</p>\n\n</div>\n", ["EXPRESSION", "TYPE"]);
add_ocaml_element("t", "Std.Primus.Lisp.Doc.Element.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.Element.html#TYPEt", "", []);
add_ocaml_element("index", "Std.Primus.Lisp.Doc.index", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.html#TYPEindex", "<div class=\"info\">\n<p>Documentation index.</p>\n\n</div>\n", ["ALL", "ALPHABETIC", "ARE", "CATEGORY", "CATEGORY2", "DESCRIPTION", "DOCUMENTATION", "ELEMENT1", "ELEMENT2", "ENTRIES", "FOLLOWING", "HAS", "INDEX", "NAME", "OGRANIZATION", "ORDER", "SORTED", "THE"]);
add_ocaml_element("error", "Std.Primus.Lisp.Load.error", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.Load.html#TYPEerror", "<div class=\"info\">\n<p>abstract error type</p>\n\n</div>\n", ["ABSTRACT", "ERROR", "TYPE"]);
add_ocaml_element("primitives", "Std.Primus.Lisp.primitives", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.html#TYPEprimitives", "<div class=\"info\">\n<p>a list of primitives.</p>\n\n</div>\n", ["LIST", "PRIMITIVES"]);
add_ocaml_element("closure", "Std.Primus.Lisp.closure", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.html#TYPEclosure", "<div class=\"info\">\n<p>a closure packed as an OCaml value</p>\n\n</div>\n", ["CLOSURE", "OCAML", "PACKED", "VALUE"]);
add_ocaml_element("message", "Std.Primus.Lisp.message", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.html#TYPEmessage", "<div class=\"info\">\n<p>an abstract type that represents messages send with the\n          <code class=\"code\">msg</code> form.</p>\n\n</div>\n", ["ABSTRACT", "FORM", "MESSAGES", "MSG", "REPRESENTS", "SEND", "THAT", "THE", "TYPE", "WITH"]);
add_ocaml_element("program", "Std.Primus.Lisp.program", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Lisp.html#TYPEprogram", "<div class=\"info\">\n<p>an abstract type representing a lisp program</p>\n\n</div>\n", ["ABSTRACT", "LISP", "PROGRAM", "REPRESENTING", "TYPE"]);
add_ocaml_element("t", "Std.Primus.Generator.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Generator.html#TYPEt", "", []);
add_ocaml_element("dom", "Std.Primus.Iterator.Base.dom", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Iterator.Base.html#TYPEdom", "<div class=\"info\">\n<p>iterator domain</p>\n\n</div>\n", ["DOMAIN", "ITERATOR"]);
add_ocaml_element("t", "Std.Primus.Iterator.Base.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Iterator.Base.html#TYPEt", "<div class=\"info\">\n<p>iterator type</p>\n\n</div>\n", ["ITERATOR", "TYPE"]);
add_ocaml_element("m", "Std.Primus.Linker.Make.m", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Linker.Make.html#TYPEm", "", []);
add_ocaml_element("code", "Std.Primus.Linker.code", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Linker.html#TYPEcode", "<div class=\"info\">\n<p>code representation</p>\n\n</div>\n", ["CODE", "REPRESENTATION"]);
add_ocaml_element("name", "Std.Primus.Linker.name", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Linker.html#TYPEname", "<div class=\"info\">\n<p>A code identifier.</p>\n\n</div>\n", ["ADDRESS", "CAN", "CODE", "IDENTIFIED", "IDENTIFIER", "NAME", "PROGRAM", "TERM"]);
add_ocaml_element("m", "Std.Primus.Interpreter.Make.m", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Interpreter.Make.html#TYPEm", "", []);
add_ocaml_element("m", "Std.Primus.Value.Make.m", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Value.Make.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Primus.Value.Make.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Value.Make.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Primus.Value.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Value.html#TYPEt", "", []);
add_ocaml_element("id", "Std.Primus.Value.id", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Value.html#TYPEid", "", []);
add_ocaml_element("m", "Std.Primus.Machine.State.m", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.State.html#TYPEm", "", []);
add_ocaml_element("m", "Std.Primus.Machine.S.m", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.S.html#TYPEm", "<div class=\"info\">\n<p>an external monad in which the machine computation is wrapped</p>\n\n</div>\n", ["COMPUTATION", "EXTERNAL", "MACHINE", "MONAD", "THE", "WHICH", "WRAPPED"]);
add_ocaml_element("t", "Std.Primus.Machine.S.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.S.html#TYPEt", "<div class=\"info\">\n<p>the machine computation</p>\n\n</div>\n", ["COMPUTATION", "MACHINE", "THE"]);
add_ocaml_element("uuid", "Std.Primus.Machine.State.uuid", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.State.html#TYPEuuid", "<div class=\"info\">\n<p><code class=\"code\">uuid</code> is a string literal representing an UUID.</p>\n\n</div>\n", ["4915", "53DCF68A", "9F5B6F574201", "AE38", "C7C8", "DIGIT", "FORM", "HAVE", "HEX", "LITERAL", "REPRESENTING", "SHOULD", "STRING", "THE", "UUID", "WHERE", "XXXX", "XXXXXXXX", "XXXXXXXXXXXX"]);
add_ocaml_element("void", "Std.Primus.Machine.State.void", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.State.html#TYPEvoid", "<div class=\"info\">\n<p>a type that has no values</p>\n\n</div>\n", ["HAS", "THAT", "TYPE", "VALUES"]);
add_ocaml_element("state", "Std.Primus.Machine.State.state", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.State.html#TYPEstate", "", []);
add_ocaml_element("t", "Std.Primus.Machine.State.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.State.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keywordsign\">'</span>a&nbsp;t</code> is a type of state that holds a value of type\n            <code class=\"code\"><span class=\"keywordsign\">'</span>a</code>, and can be constructed from the base context of type\n            <code class=\"code\"><span class=\"keywordsign\">'</span>c</code>.</p>\n\n</div>\n", ["AND", "BASE", "CAN", "CONSTRUCTED", "CONTEXT", "FROM", "HOLDS", "STATE", "THAT", "THE", "TYPE", "VALUE"]);
add_ocaml_element("component", "Std.Primus.Machine.component", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.html#TYPEcomponent", "<div class=\"info\">\n<p>The Machine component.</p>\n\n</div>\n", ["COMPONENT", "MACHINE", "THE"]);
add_ocaml_element("state", "Std.Primus.Machine.state", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.html#TYPEstate", "", []);
add_ocaml_element("id", "Std.Primus.Machine.id", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Machine.html#TYPEid", "<div class=\"info\">\n<p>Machine identifier type.</p>\n\n</div>\n", ["IDENTIFIER", "MACHINE", "TYPE"]);
add_ocaml_element("t", "Std.Primus.Pos.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a program location</p>\n\n</div>\n", ["LOCATION", "PROGRAM"]);
add_ocaml_element("level0", "Std.Primus.Pos.level0", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPElevel0", "<div class=\"info\">\n<p>a level of the basic terms, e.g., defs, jmps and phi-nodes.</p>\n\n</div>\n", ["AND", "BASIC", "DEFS", "JMPS", "LEVEL", "NODES", "PHI", "TERMS", "THE"]);
add_ocaml_element("level1", "Std.Primus.Pos.level1", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPElevel1", "<div class=\"info\">\n<p>a level of arguments and basic blocks</p>\n\n</div>\n", ["AND", "ARGUMENTS", "BASIC", "BLOCKS", "LEVEL"]);
add_ocaml_element("level2", "Std.Primus.Pos.level2", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPElevel2", "<div class=\"info\">\n<p>a cursor pointing to a function</p>\n\n</div>\n", ["CURSOR", "FUNCTION", "POINTING"]);
add_ocaml_element("level3", "Std.Primus.Pos.level3", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPElevel3", "<div class=\"info\">\n<p>the highest level of the hierarchy - a cursor the points\n          to the whole program.</p>\n\n</div>\n", ["CURSOR", "HIERARCHY", "HIGHEST", "LEVEL", "POINTS", "POSITION", "PROGRAM", "STARTING", "THE", "THIS", "WHOLE"]);
add_ocaml_element("level", "Std.Primus.Pos.level", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPElevel", "<div class=\"info\">\n<p><code class=\"code\">(t,p)&nbsp;level</code> a cursor pointing to a <code class=\"code\">t&nbsp;term</code>, that is\n          nested in the parent cursor <code class=\"code\">p</code>.</p>\n\n</div>\n", ["CURSOR", "LEVEL", "NESTED", "PARENT", "POINTING", "TERM", "THAT", "THE"]);
add_ocaml_element("top", "Std.Primus.Pos.top", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPEtop", "<div class=\"info\">\n<p>the top-most program term.</p>\n\n</div>\n", ["MOST", "PROGRAM", "TERM", "THE", "TOP"]);
add_ocaml_element("nil", "Std.Primus.Pos.nil", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Pos.html#TYPEnil", "<div class=\"info\">\n<p>uninhabited type</p>\n\n</div>\n", ["TYPE", "UNINHABITED"]);
add_ocaml_element("t", "Std.Primus.Observation.Provider.t", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Observation.Provider.html#TYPEt", "", []);
add_ocaml_element("provider", "Std.Primus.Observation.provider", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.Observation.html#TYPEprovider", "<div class=\"info\">\n<p>An observation provider.</p>\n\n</div>\n", ["AFFECTING", "ANALYSIS", "AND", "BEHAVIOR", "CAN", "DEBUGGING", "DUMPING", "EFFECTS", "EXECUTION", "FACILITATES", "FOR", "INTROSPECTION", "ITS", "LOGGING", "MACHINE", "MAIN", "NOT", "OBSERVATION", "PRIMUS", "PROVIDER", "PURPOSE", "SAKE", "SHOUD", "THE", "TRACING", "USED"]);
add_ocaml_element("component", "Std.Primus.component", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEcomponent", "<div class=\"info\">\n<p>The Machine component.</p>\n\n</div>\n", ["COMPONENT", "MACHINE", "THE"]);
add_ocaml_element("state", "Std.Primus.state", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEstate", "<div class=\"info\">\n<p>type abbreviation for the Machine.state</p>\n\n</div>\n", ["ABBREVIATION", "FOR", "MACHINE", "STATE", "THE", "TYPE"]);
add_ocaml_element("pos", "Std.Primus.pos", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEpos", "", []);
add_ocaml_element("generator", "Std.Primus.generator", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEgenerator", "<div class=\"info\">\n<p>value generator</p>\n\n</div>\n", ["GENERATOR", "VALUE"]);
add_ocaml_element("effect", "Std.Primus.effect", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEeffect", "<div class=\"info\">\n<p>An abstract type that represents an effect produced by a\n        Machine run.</p>\n\n</div>\n", ["ABSTRACT", "AND", "DIRECTLY", "DISALLOW", "EFFECT", "HAS", "INSTANTIATION", "ITS", "LEFT", "MACHINE", "MAIN", "MODULE", "OPERATIONS", "PRODUCED", "PURPOSE", "REPRESENTS", "RUN", "RUNNING", "THAT", "THE", "TYPE", "WITHOUT"]);
add_ocaml_element("exit_status", "Std.Primus.exit_status", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEexit_status", "<div class=\"info\">\n<p>Machine exit status.</p>\n\n</div>\n", ["ABNORMALLY", "EXCEPTION", "EXIT", "MACHINE", "MAY", "NORMALLY", "SPECIFIED", "STATUS", "TERMINATE", "THE", "WITH"]);
add_ocaml_element("value", "Std.Primus.value", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEvalue", "<div class=\"info\">\n<p>a result of computation</p>\n\n</div>\n", ["COMPUTATION", "RESULT"]);
add_ocaml_element("statement", "Std.Primus.statement", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEstatement", "<div class=\"info\">\n<p><code class=\"code\">a&nbsp;statement</code> is used to make an observation of type <code class=\"code\">a</code>.</p>\n\n</div>\n", ["MAKE", "OBSERVATION", "STATEMENT", "TYPE", "USED"]);
add_ocaml_element("observation", "Std.Primus.observation", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEobservation", "<div class=\"info\">\n<p><code class=\"code\">an&nbsp;observation</code> of a value of type <code class=\"code\">an</code>.</p>\n\n</div>\n", ["OBSERVATION", "TYPE", "VALUE"]);
add_ocaml_element("exn", "Std.Primus.exn", "type", "<i>(... type ...)</i>", "Bap_primus.Std.Primus.html#TYPEexn", "<div class=\"info\">\n<p>Machine Exception.</p>\n\n</div>\n", ["AND", "COMPONENTS", "CONSTRUCTORS", "ERROR", "EXCEPTION", "EXN", "EXTENSIBLE", "MACHINE", "OWN", "REGISTER", "THE", "THEIR", "TYPE", "USUALLY", "VARIANT"]);
add_ocaml_element("m", "Bap_taint.Std.Value.m", "type", "<i>(... type ...)</i>", "Bap_taint.Std.Value.html#TYPEm", "<div class=\"info\">\n<p><code class=\"code\">to_value&nbsp;x</code> injects <code class=\"code\">x</code> into the <code class=\"code\">value</code> domain</p>\n\n</div>\n", ["DOMAIN", "INJECTS", "INTO", "THE", "TO_VALUE", "VALUE"]);
add_ocaml_element("t", "Bap_taint.Std.Value.t", "type", "<i>(... type ...)</i>", "Bap_taint.Std.Value.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_taint.Std.Taint.Propagation.Policy.t", "type", "<i>(... type ...)</i>", "Bap_taint.Std.Taint.Propagation.Policy.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_taint.Std.Taint.Object.t", "type", "<i>(... type ...)</i>", "Bap_taint.Std.Taint.Object.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_taint.Std.Taint.Rel.t", "type", "<i>(... type ...)</i>", "Bap_taint.Std.Taint.Rel.html#TYPEt", "<div class=\"info\">\n<p>Denotes the direct relation between a value and the object\n          that we track, e.g., a value contains the runtime\n          representation of the object or a part of it.</p>\n\n</div>\n", ["AND", "BETWEEN", "CONTAINS", "DENOTES", "DIRECT", "OBJECT", "PART", "RELATION", "REPRESENTATION", "RUNTIME", "THAT", "THE", "TRACK", "VALUE"]);
add_ocaml_element("t", "Bap_taint.Std.Taint.Kind.t", "type", "<i>(... type ...)</i>", "Bap_taint.Std.Taint.Kind.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Isomorphism.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Isomorphism.html#TYPEt", "", []);
add_ocaml_element("s", "Std.Isomorphism.s", "type", "<i>(... type ...)</i>", "Graphlib.Std.Isomorphism.html#TYPEs", "", []);
add_ocaml_element("node", "Std.Predicate.node", "type", "<i>(... type ...)</i>", "Graphlib.Std.Predicate.html#TYPEnode", "", []);
add_ocaml_element("edge", "Std.Predicate.edge", "type", "<i>(... type ...)</i>", "Graphlib.Std.Predicate.html#TYPEedge", "", []);
add_ocaml_element("label", "Std.Edge.label", "type", "<i>(... type ...)</i>", "Graphlib.Std.Edge.html#TYPElabel", "", []);
add_ocaml_element("graph", "Std.Edge.graph", "type", "<i>(... type ...)</i>", "Graphlib.Std.Edge.html#TYPEgraph", "", []);
add_ocaml_element("node", "Std.Edge.node", "type", "<i>(... type ...)</i>", "Graphlib.Std.Edge.html#TYPEnode", "", []);
add_ocaml_element("t", "Std.Edge.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Edge.html#TYPEt", "", []);
add_ocaml_element("edge", "Std.Node.edge", "type", "<i>(... type ...)</i>", "Graphlib.Std.Node.html#TYPEedge", "", []);
add_ocaml_element("label", "Std.Node.label", "type", "<i>(... type ...)</i>", "Graphlib.Std.Node.html#TYPElabel", "", []);
add_ocaml_element("graph", "Std.Node.graph", "type", "<i>(... type ...)</i>", "Graphlib.Std.Node.html#TYPEgraph", "", []);
add_ocaml_element("t", "Std.Node.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Node.html#TYPEt", "<div class=\"info\">\n<p>node type is opaque</p>\n\n</div>\n", ["NODE", "OPAQUE", "TYPE"]);
add_ocaml_element("edge", "Std.Graph.edge", "type", "<i>(... type ...)</i>", "Graphlib.Std.Graph.html#TYPEedge", "<div class=\"info\">\n<p>type of edges</p>\n\n</div>\n", ["EDGES", "TYPE"]);
add_ocaml_element("node", "Std.Graph.node", "type", "<i>(... type ...)</i>", "Graphlib.Std.Graph.html#TYPEnode", "<div class=\"info\">\n<p>type of nodes</p>\n\n</div>\n", ["NODES", "TYPE"]);
add_ocaml_element("t", "Std.Graph.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Graph.html#TYPEt", "<div class=\"info\">\n<p>type of graph</p>\n\n</div>\n", ["GRAPH", "TYPE"]);
add_ocaml_element("symbolizer", "Std.symbolizer", "type", "<i>(... type ...)</i>", "Graphlib.Std.Graphlib.html#TYPEsymbolizer", "<div class=\"info\">\n<p>a function that gives a name for a value of type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code></p>\n\n</div>\n", ["FOR", "FUNCTION", "GIVES", "NAME", "THAT", "TYPE", "VALUE"]);
add_ocaml_element("scheme", "Std.scheme", "type", "<i>(... type ...)</i>", "Graphlib.Std.Graphlib.html#TYPEscheme", "<div class=\"info\">\n<p>name generation scheme</p>\n\n</div>\n", ["GENERATION", "NAME", "SCHEME"]);
add_ocaml_element("t", "Std.Solution.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Solution.html#TYPEt", "<div class=\"info\">\n<p>an abstract representation of a solution</p>\n\n</div>\n", ["ABSTRACT", "REPRESENTATION", "SOLUTION"]);
add_ocaml_element("t", "Std.Equiv.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Equiv.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Group.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Group.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Partition.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Partition.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Path.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Path.html#TYPEt", "<div class=\"info\">\n<p>representation type</p>\n\n</div>\n", ["REPRESENTATION", "TYPE"]);
add_ocaml_element("t", "Std.Frontier.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Frontier.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Tree.t", "type", "<i>(... type ...)</i>", "Graphlib.Std.Tree.html#TYPEt", "", []);
add_ocaml_element("labeled", "Std.labeled", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPElabeled", "", []);
add_ocaml_element("graph_attr", "Std.graph_attr", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEgraph_attr", "", []);
add_ocaml_element("edge_attr", "Std.edge_attr", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEedge_attr", "", []);
add_ocaml_element("node_attr", "Std.node_attr", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEnode_attr", "", []);
add_ocaml_element("equiv", "Std.equiv", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEequiv", "<div class=\"info\">\n<p>runtime witness of the <a href=\"Graphlib.Std.Equiv.html\">equivalence class</a></p>\n\n</div>\n", ["CLASS", "EQUIVALENCE", "RUNTIME", "THE", "WITNESS"]);
add_ocaml_element("path", "Std.path", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEpath", "<div class=\"info\">\n<p>walk without a repetition of edges and inner nodes</p>\n\n</div>\n", ["AND", "EDGES", "INNER", "NODES", "REPETITION", "WALK", "WITHOUT"]);
add_ocaml_element("group", "Std.group", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEgroup", "<div class=\"info\">\n<p>a partition <a href=\"Graphlib.Std.Group.html\">Cell</a></p>\n\n</div>\n", ["CELL", "PARTITION"]);
add_ocaml_element("partition", "Std.partition", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEpartition", "<div class=\"info\">\n<p>a <a href=\"Graphlib.Std.Partition.html\">result</a> of partitioning algorithms</p>\n\n</div>\n", ["ALGORITHMS", "PARTITIONING", "RESULT"]);
add_ocaml_element("frontier", "Std.frontier", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEfrontier", "<div class=\"info\">\n<p>a type representing <a href=\"Graphlib.Std.Frontier.html\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Frontier</span></code></a>s</p>\n\n</div>\n", ["FRONTIERS", "GRAPHLIB", "REPRESENTING", "STD", "TYPE"]);
add_ocaml_element("tree", "Std.tree", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEtree", "<div class=\"info\">\n<p>a <a href=\"Graphlib.Std.Tree.html\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Tree</span></code></a> representation.</p>\n\n</div>\n", ["GRAPHLIB", "REPRESENTATION", "STD", "TREE"]);
add_ocaml_element("edge_kind", "Std.edge_kind", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEedge_kind", "<div class=\"info\">\n<p>Graph edges classification.</p>\n\n</div>\n", ["CLASSIFICATION", "DFS", "EDGES", "EXPLANATIONS", "FOR", "GRAPH", "SEE"]);
add_ocaml_element("graph", "Std.graph", "type", "<i>(... type ...)</i>", "Graphlib.Std.html#TYPEgraph", "<div class=\"info\">\n<p>a type abbreviation for a packed module, implementing graph\n      interface.</p>\n\n</div>\n", ["ABBREVIATION", "ENOUGH", "FOR", "GRAPH", "IMPLEMENTING", "INTERFACE", "MODULE", "NOT", "NOTE", "ONLY", "OUT", "PACKED", "PRENEXES", "SOMETIMES", "THIS", "TYPE", "VARIABLES"]);
add_ocaml_element("t", "Bap_future.Std.Signal.t", "type", "<i>(... type ...)</i>", "Bap_future.Std.Signal.html#TYPEt", "", []);
add_ocaml_element("id", "Bap_future.Std.Stream.id", "type", "<i>(... type ...)</i>", "Bap_future.Std.Stream.html#TYPEid", "", []);
add_ocaml_element("t", "Bap_future.Std.Stream.t", "type", "<i>(... type ...)</i>", "Bap_future.Std.Stream.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_future.Std.Promise.t", "type", "<i>(... type ...)</i>", "Bap_future.Std.Promise.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_future.Std.t", "type", "<i>(... type ...)</i>", "Bap_future.Std.Future.html#TYPEt", "", []);
add_ocaml_element("arg", "Bap_future.Std.Variadic.S.arg", "type", "<i>(... type ...)</i>", "Bap_future.Std.Variadic.S.html#TYPEarg", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keywordsign\">'</span>a&nbsp;arg</code> is an Applicable value</p>\n\n</div>\n", ["APPLICABLE", "ARG", "VALUE"]);
add_ocaml_element("t", "Bap_future.Std.Variadic.S.t", "type", "<i>(... type ...)</i>", "Bap_future.Std.Variadic.S.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">(<span class=\"keywordsign\">'</span>f,<span class=\"keywordsign\">'</span>r)&nbsp;t</code> is a list of arguments, where <code class=\"code\"><span class=\"keywordsign\">'</span>f</code> defines the\n          arrow type of the arguments, and <code class=\"code\"><span class=\"keywordsign\">'</span>r</code> is the return type.</p>\n\n</div>\n", ["AND", "ARGUMENTS", "ARROW", "CONSTUCTOR", "DEFINES", "FIRST", "FORMAT", "LAST", "LIST", "PARAMETER", "RETURN", "THE", "TYPE", "WHERE", "WITH"]);
add_ocaml_element("t", "Bap_future.Std.Applicable.S.t", "type", "<i>(... type ...)</i>", "Bap_future.Std.Applicable.S.html#TYPEt", "", []);
add_ocaml_element("signal", "Bap_future.Std.signal", "type", "<i>(... type ...)</i>", "Bap_future.Std.html#TYPEsignal", "", []);
add_ocaml_element("stream", "Bap_future.Std.stream", "type", "<i>(... type ...)</i>", "Bap_future.Std.html#TYPEstream", "", []);
add_ocaml_element("promise", "Bap_future.Std.promise", "type", "<i>(... type ...)</i>", "Bap_future.Std.html#TYPEpromise", "", []);
add_ocaml_element("future", "Bap_future.Std.future", "type", "<i>(... type ...)</i>", "Bap_future.Std.html#TYPEfuture", "", []);
add_ocaml_element("t", "Ogre.Doc.t", "type", "<i>(... type ...)</i>", "Ogre.Doc.html#TYPEt", "", []);
add_ocaml_element("tables", "Ogre.Query.tables", "type", "<i>(... type ...)</i>", "Ogre.Query.html#TYPEtables", "<div class=\"info\">\n<p>a selection of attributes.</p>\n\n</div>\n", ["AND", "ARE", "ATTR", "ATTR1", "ATTR2", "ATTRIBUTES", "CAN", "CLASSES", "CLAUSE", "CONSTRUCTED", "CONSTRUCTORS", "FOLLOWING", "FROM", "GRAMMAR", "INFIX", "OTHER", "PREFIX", "SELECTION", "STUDENTS", "TABLES", "TEACHERS", "THE", "THERE", "TWO", "USING", "WORDS"]);
add_ocaml_element("join", "Ogre.Query.join", "type", "<i>(... type ...)</i>", "Ogre.Query.html#TYPEjoin", "<div class=\"info\">\n<p>join statement.</p>\n\n</div>\n", ["ALL", "AND", "ANOTHER", "ARE", "ATTRIBUTE", "ATTRIBUTES", "CLASS", "CLASSES", "CLASSID", "CLAUSE", "CONCRETE", "CONSTRAINT", "CONSTRUCT", "CONSTRUCTED", "CORRESPONDING", "DEFINED", "DEFINES", "EACH", "ELEMENTS", "EMPOSES", "EQUAL", "EQUALITY", "EQUIVALENT", "EXAMPLE", "EXPRESSION", "FIELD", "FIELDS", "FOR", "FROM", "FULLY", "FUNCTION", "GIVEN", "IGNORING", "IMPOSE", "INNER", "INSTEAD", "JOIN", "KINDS", "LIST", "MAKES", "MATCHES", "MORE", "NAME", "NOTE", "ONLY", "PENALTY", "PERFORMANCE", "QUALIFIED", "QUERY", "READABLE", "REQUIRING", "ROUGHLY", "SAME", "SELECT", "SELECTED", "SELECTION", "SQL", "STATEMENT", "STUDENT", "TEACHER", "THE", "THERE", "TWO", "UNQUALIFIED", "USE", "VALUES", "VARIABLE", "VARIABLES", "WAY", "WHERE", "WILL", "WITH"]);
add_ocaml_element("exp", "Ogre.Query.exp", "type", "<i>(... type ...)</i>", "Ogre.Query.html#TYPEexp", "<div class=\"info\">\n<p>logical expression language, defined as</p>\n<pre class=\"verbatim\">      exp ::= str `string`\n            | int `int64`\n            | float `float`\n            | bool `bool`\n            | `'a attribute`.(`'b field`)\n            | `'b field`.[`int`]\n            | exp &lt;bop&gt; exp\n            | &lt;uop&gt; exp\n\n      bop ::=  &lt;aop&gt; | &lt;lop&gt; | &lt;cop&gt;\n      uop ::=  not\n      aop ::= + | -\n      lop ::= || | &amp;&amp; | ==&gt;\n      cop ::= &lt; | &gt; | = | &lt;&gt; | &lt;= | &gt;=\n     </pre>\n</div>\n", ["ABOVE", "ALL", "ALSO", "AND", "AOP", "ARE", "ASSUMING", "ATTRIBUTE", "BACKTICKS", "BOOL", "BOP", "COP", "DEFINED", "DELIMITED", "EXAMPLE", "EXP", "EXPRESSION", "EXPRESSIONS", "FIELD", "FLOAT", "FOR", "FORMED", "GPA", "GRAMMAR", "HAS", "HELLO", "INFORMALLY", "INT", "INT64", "LANGUAGE", "LOCATIONS", "LOGICAL", "LOP", "MUST", "NAMES", "NOT", "OBEY", "OCAML", "PASSED", "REPRESENT", "RULES", "SAME", "SHOULD", "SIMPLE", "SORT", "STR", "STRING", "STUDENT", "SYNTACTIC", "THAT", "THE", "THESE", "THEY", "TYPE", "TYPES", "TYPING", "UNQUOTING", "UOP", "VALUE", "VALUES", "WELL", "WFF", "WITH"]);
add_ocaml_element("t", "Ogre.Query.t", "type", "<i>(... type ...)</i>", "Ogre.Query.html#TYPEt", "", []);
add_ocaml_element("t", "Ogre.Type.t", "type", "<i>(... type ...)</i>", "Ogre.Type.html#TYPEt", "<div class=\"info\">\n<p>type descriptor.</p>\n\n</div>\n", ["DESCRIPTOR", "TYPE"]);
add_ocaml_element("scheme", "Ogre.scheme", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEscheme", "<div class=\"info\">\n<p>type that describes an attribute.</p>\n\n</div>\n", ["ACCESSOR", "ADDED", "ALONG", "AND", "ATTRIBUTE", "CAN", "COME", "CONSTRUCTED", "CONSTRUCTOR", "DATABASE", "DESCRIBE", "DESCRIBES", "DESTRUCTOR", "DIFFER", "EVERY", "EXTENDED", "FIELD", "FOR", "FORM", "GENERAL", "HOW", "INSTANCE", "INTERFACE", "NEW", "ONLY", "PACKED", "RETURN", "SCHEME", "THAT", "THE", "THESE", "TIME", "TWO", "TYPE", "TYPES", "VARIABLE", "VARIABLES", "WHERE"]);
add_ocaml_element("seq", "Ogre.seq", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEseq", "<div class=\"info\">\n<p>a result of a selection.</p>\n\n</div>\n", ["RESULT", "SELECTION"]);
add_ocaml_element("query", "Ogre.query", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEquery", "<div class=\"info\">\n<p><code class=\"code\">attrs&nbsp;query</code> constructs a query type.</p>\n\n</div>\n", ["AND", "ARBITRARY", "ATTRIBUTES", "ATTRS", "CAN", "CONSTRUCTS", "CONTINUATION", "CORRESPONDINGLY", "CREATED", "DENOTING", "ENCODES", "EXAMPLE", "EXECUTED", "FACT", "FOR", "LATER", "MODULE", "QUERY", "REPRESENTED", "REPRESENTS", "REQUESTED", "RESULT", "STUDENT", "TEACHER", "THAT", "THE", "TWO", "TYPE", "TYPES", "USING", "VARIABLE"]);
add_ocaml_element("field", "Ogre.field", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEfield", "<div class=\"info\">\n<p><code class=\"code\">t&nbsp;field</code> a descriptor of an attribute field.</p>\n\n</div>\n", ["AND", "ATTRIBUTE", "ATTRIBUTES", "BOOL", "CONSTRUCT", "DESCRIPTOR", "FIELD", "FIELDS", "FLOAT", "INT64", "PARTICULAR", "RANGE", "REFERENCE", "STRING", "THAT", "THE", "TYPE", "USED", "VARIABLE", "VARIABLES"]);
add_ocaml_element("attribute", "Ogre.attribute", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEattribute", "<div class=\"info\">\n<p>a decriptor of an attribute.</p>\n\n</div>\n", ["AND", "ATTRIBUTE", "CONSTRUCT", "CREATED", "DECLARE", "DECRIPTOR", "DEFINED", "DOCUMENTS", "DUE", "FUNCTION", "INFORMATION", "NOTE", "QUERY", "RESTRICTION", "RETURNING", "SHOULD", "THAT", "TYPE", "USED", "VALUE", "VALUES", "WITH"]);
add_ocaml_element("typeinfo", "Ogre.typeinfo", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEtypeinfo", "<div class=\"info\">\n<p>type information associated with an attribute</p>\n\n</div>\n", ["ASSOCIATED", "ATTRIBUTE", "INFORMATION", "TYPE", "WITH"]);
add_ocaml_element("doc", "Ogre.doc", "type", "<i>(... type ...)</i>", "Ogre.html#TYPEdoc", "<div class=\"info\">\n<p>the document</p>\n\n</div>\n", ["DOCUMENT", "THE"]);
add_ocaml_element("t", "Std.Monad.Minimal2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Minimal2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Minimal.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Minimal.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Basic2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Basic2.html#TYPEt", "<div class=\"info\">\n<p>(a,e) t is a type of monad, where <code class=\"code\">a</code> is a type of\n          computation values, and <code class=\"code\">e</code> is a type of some extra\n          information attached to the computation, usually a type of\n          environment.</p>\n\n</div>\n", ["AND", "ATTACHED", "COMPUTATION", "ENVIRONMENT", "EXTRA", "INFORMATION", "MONAD", "SOME", "THE", "TYPE", "USUALLY", "VALUES", "WHERE"]);
add_ocaml_element("t", "Std.Monad.Basic.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Basic.html#TYPEt", "", []);
add_ocaml_element("r", "Std.Monad.Cont.S.r", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.S.html#TYPEr", "<div class=\"info\">\n<p>type of the final result of computation</p>\n\n</div>\n", ["COMPUTATION", "FINAL", "RESULT", "THE", "TYPE"]);
add_ocaml_element("e", "Std.Monad.Cont.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Cont.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Cont.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Cont.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Cont.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Cont.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T1.html#TYPEm", "", []);
add_ocaml_element("r", "Std.Monad.Cont.T1.r", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.T1.html#TYPEr", "", []);
add_ocaml_element("cont", "Std.Monad.Cont.cont", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Cont.html#TYPEcont", "<div class=\"info\">\n<p>type of continuation monads</p>\n\n</div>\n", ["CONTINUATION", "MONADS", "TYPE"]);
add_ocaml_element("e", "Std.Monad.Lazy.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Lazy.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Lazy.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Lazy.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Lazy.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Lazy.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Lazy.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Lazy.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Lazy.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Lazy.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Lazy.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Lazy.T1.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Fun.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Fun.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Fun.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Fun.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Fun.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Fun.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.T1.html#TYPEm", "", []);
add_ocaml_element("thunk", "Std.Monad.Fun.thunk", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fun.html#TYPEthunk", "<div class=\"info\">\n<p>A function monad computation is a thunk that returns a value\n          of type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code>.</p>\n\n</div>\n", ["COMPUTATION", "FUNCTION", "MONAD", "RETURNS", "THAT", "THUNK", "TYPE", "VALUE"]);
add_ocaml_element("env", "Std.Monad.State.S.env", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.S.html#TYPEenv", "<div class=\"info\">\n<p>the environment type.</p>\n\n</div>\n", ["ENVIRONMENT", "THE", "TYPE"]);
add_ocaml_element("e", "Std.Monad.State.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.State.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.State.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.State.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.State.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.State.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T1.html#TYPEm", "", []);
add_ocaml_element("env", "Std.Monad.State.T1.env", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.T1.html#TYPEenv", "", []);
add_ocaml_element("id", "Std.Monad.State.Multi.S2.id", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.S2.html#TYPEid", "", []);
add_ocaml_element("id", "Std.Monad.State.Multi.S.id", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.S.html#TYPEid", "", []);
add_ocaml_element("e", "Std.Monad.State.Multi.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.State.Multi.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.State.Multi.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.State.Multi.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.State.Multi.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.State.Multi.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T1.html#TYPEm", "", []);
add_ocaml_element("env", "Std.Monad.State.Multi.T1.env", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.T1.html#TYPEenv", "", []);
add_ocaml_element("id", "Std.Monad.State.Multi.id", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.html#TYPEid", "", []);
add_ocaml_element("contexts", "Std.Monad.State.Multi.contexts", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.html#TYPEcontexts", "", []);
add_ocaml_element("status", "Std.Monad.State.Multi.status", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.Multi.html#TYPEstatus", "", []);
add_ocaml_element("state", "Std.Monad.State.state", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.html#TYPEstate", "<div class=\"info\">\n<p>an abstract type of stateful computations.</p>\n\n</div>\n", ["ABSTRACT", "AKA", "AND", "COMPUTATIONS", "DENOTES", "ENVIONMENT", "STATE", "STATEFUL", "THE", "TYPE", "TYPES", "VALUES", "VARIABLE", "WORLD"]);
add_ocaml_element("storage", "Std.Monad.State.storage", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.State.html#TYPEstorage", "<div class=\"info\">\n<p>an abstract storage</p>\n\n</div>\n", ["ABSTRACT", "STORAGE"]);
add_ocaml_element("env", "Std.Monad.Reader.S.env", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.S.html#TYPEenv", "", []);
add_ocaml_element("e", "Std.Monad.Reader.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Reader.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Reader.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Reader.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Reader.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Reader.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T1.html#TYPEm", "", []);
add_ocaml_element("env", "Std.Monad.Reader.T1.env", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.T1.html#TYPEenv", "", []);
add_ocaml_element("reader", "Std.Monad.Reader.reader", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Reader.html#TYPEreader", "<div class=\"info\">\n<p>an abstract type of reader computations</p>\n\n</div>\n", ["ABSTRACT", "COMPUTATIONS", "READER", "TYPE"]);
add_ocaml_element("state", "Std.Monad.Writer.S.state", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Writer.S.html#TYPEstate", "<div class=\"info\">\n<p>type representing the system state (enironment)</p>\n\n</div>\n", ["ENIRONMENT", "REPRESENTING", "STATE", "SYSTEM", "THE", "TYPE"]);
add_ocaml_element("e", "Std.Monad.Writer.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Writer.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Writer.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Writer.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Writer.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Writer.T1.html#TYPEm", "", []);
add_ocaml_element("state", "Std.Monad.Writer.T1.state", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Writer.T1.html#TYPEstate", "", []);
add_ocaml_element("writer", "Std.Monad.Writer.writer", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Writer.html#TYPEwriter", "", []);
add_ocaml_element("e", "Std.Monad.Seq.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Seq.T2.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Seq.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Seq.T2.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Seq.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Seq.T2.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.Seq.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Seq.T1.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Seq.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Seq.T1.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Seq.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Seq.T1.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.List.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.List.T2.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.List.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.List.T2.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.List.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.List.T2.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.List.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.List.T1.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.List.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.List.T1.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.List.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.List.T1.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.Result.Exception.T.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.Exception.T.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Result.Exception.T.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.Exception.T.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Result.Exception.T.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.Exception.T.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Result.Error.T.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.Error.T.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Result.Error.T.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.Error.T.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Result.Error.T.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.Error.T.html#TYPEm", "", []);
add_ocaml_element("err", "Std.Monad.Result.S.err", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.S.html#TYPEerr", "", []);
add_ocaml_element("e", "Std.Monad.Result.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T2.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Result.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T2.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Result.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T2.html#TYPEm", "", []);
add_ocaml_element("e", "Std.Monad.Result.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T1.html#TYPEe", "", []);
add_ocaml_element("t", "Std.Monad.Result.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T1.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Monad.Result.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T1.html#TYPEm", "", []);
add_ocaml_element("error", "Std.Monad.Result.T1.error", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.T1.html#TYPEerror", "", []);
add_ocaml_element("result", "Std.Monad.Result.result", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Result.html#TYPEresult", "", []);
add_ocaml_element("e", "Std.Monad.Option.T2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Option.T2.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Option.T2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Option.T2.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Option.T2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Option.T2.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.Option.T1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Option.T1.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Option.T1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Option.T1.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Option.T1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Option.T1.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.S2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.S.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Syntax.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Syntax.S2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Syntax.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Syntax.S.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Collection.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Collection.S.html#TYPEt", "<div class=\"info\">\n<p>type of the container</p>\n\n</div>\n", ["CONTAINER", "THE", "TYPE"]);
add_ocaml_element("m", "Std.Monad.Collection.S.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Collection.S.html#TYPEm", "<div class=\"info\">\n<p>the monad</p>\n\n</div>\n", ["MONAD", "THE"]);
add_ocaml_element("t", "Std.Monad.Collection.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Collection.S2.html#TYPEt", "<div class=\"info\">\n<p>type of the container</p>\n\n</div>\n", ["CONTAINER", "THE", "TYPE"]);
add_ocaml_element("m", "Std.Monad.Collection.S2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Collection.S2.html#TYPEm", "<div class=\"info\">\n<p>the monad</p>\n\n</div>\n", ["MONAD", "THE"]);
add_ocaml_element("t", "Std.Monad.Collection.Basic.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Collection.Basic.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">x&nbsp;t</code> a container that hold values of type <code class=\"code\">x</code></p>\n\n</div>\n", ["CONTAINER", "HOLD", "THAT", "TYPE", "VALUES"]);
add_ocaml_element("e", "Std.Monad.Trans.S2.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S2.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Trans.S2.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S2.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Trans.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S2.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.Trans.S1.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S1.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Trans.S1.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S1.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Trans.S1.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S1.html#TYPEt", "", []);
add_ocaml_element("e", "Std.Monad.Trans.S.e", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S.html#TYPEe", "", []);
add_ocaml_element("m", "Std.Monad.Trans.S.m", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Monad.Trans.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Trans.S.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Choice.Basic2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Choice.Basic2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Choice.Basic.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Choice.Basic.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Choice.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Choice.S2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Choice.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Choice.S.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Fail.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fail.S2.html#TYPEt", "<div class=\"info\">\n<p>a monad type, where <code class=\"code\"><span class=\"keywordsign\">'</span>a</code> is a value type, and <code class=\"code\"><span class=\"keywordsign\">'</span>e</code> is a type\n            parameter of the <code class=\"code\">error</code> type.</p>\n\n</div>\n", ["AND", "ERROR", "MONAD", "PARAMETER", "THE", "TYPE", "VALUE", "WHERE"]);
add_ocaml_element("error", "Std.Monad.Fail.S2.error", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fail.S2.html#TYPEerror", "<div class=\"info\">\n<p>a type of error</p>\n\n</div>\n", ["ERROR", "TYPE"]);
add_ocaml_element("t", "Std.Monad.Fail.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fail.S.html#TYPEt", "<div class=\"info\">\n<p>a monad type</p>\n\n</div>\n", ["MONAD", "TYPE"]);
add_ocaml_element("error", "Std.Monad.Fail.S.error", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Fail.S.html#TYPEerror", "<div class=\"info\">\n<p>a type of error</p>\n\n</div>\n", ["ERROR", "TYPE"]);
add_ocaml_element("t", "Std.Monad.Plus.S2.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Plus.S2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monad.Plus.S.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monad.Plus.S.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monoid.Base.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monoid.Base.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Monoid.TList.t", "type", "<i>(... type ...)</i>", "Monads.Std.Monoid.TList.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Bytes.t", "type", "<i>(... type ...)</i>", "Regular.Std.Bytes.html#TYPEt", "<div class=\"info\">\n<p>bytes</p>\n\n</div>\n", ["BYTES"]);
add_ocaml_element("t", "Std.Opaque.S.t", "type", "<i>(... type ...)</i>", "Regular.Std.Opaque.S.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Minimal.t", "type", "<i>(... type ...)</i>", "Regular.Std.Regular.Minimal.html#TYPEt", "<div class=\"info\">\n<p>type t should be binable, sexpable and provide compare function</p>\n\n</div>\n", ["AND", "BINABLE", "COMPARE", "FUNCTION", "PROVIDE", "SEXPABLE", "SHOULD", "TYPE"]);
add_ocaml_element("t", "Std.S.t", "type", "<i>(... type ...)</i>", "Regular.Std.Regular.S.html#TYPEt", "", []);
add_ocaml_element("service", "Std.Data.Cache.service", "type", "<i>(... type ...)</i>", "Regular.Std.Data.Cache.html#TYPEservice", "<div class=\"info\">\n<p>service signature</p>\n\n</div>\n", ["SERVICE", "SIGNATURE"]);
add_ocaml_element("t", "Std.Data.Cache.t", "type", "<i>(... type ...)</i>", "Regular.Std.Data.Cache.html#TYPEt", "<div class=\"info\">\n<p>cacher type class</p>\n\n</div>\n", ["CACHER", "CLASS", "TYPE"]);
add_ocaml_element("t", "Std.Data.Write.t", "type", "<i>(... type ...)</i>", "Regular.Std.Data.Write.html#TYPEt", "<div class=\"info\">\n<p>a writer type class</p>\n\n</div>\n", ["CLASS", "TYPE", "WRITER"]);
add_ocaml_element("t", "Std.Data.Read.t", "type", "<i>(... type ...)</i>", "Regular.Std.Data.Read.html#TYPEt", "<div class=\"info\">\n<p>readable</p>\n\n</div>\n", ["READABLE"]);
add_ocaml_element("info", "Std.Data.S.info", "type", "<i>(... type ...)</i>", "Regular.Std.Data.S.html#TYPEinfo", "<div class=\"info\">\n<p><code class=\"code\">name,<span class=\"constructor\">Ver</span>&nbsp;v,desc</code> information attached to a particular\n          reader or writer.</p>\n\n</div>\n", ["ATTACHED", "DESC", "INFORMATION", "NAME", "PARTICULAR", "READER", "VER", "WRITER"]);
add_ocaml_element("t", "Std.Data.S.t", "type", "<i>(... type ...)</i>", "Regular.Std.Data.S.html#TYPEt", "<div class=\"info\">\n<p>type constructor</p>\n\n</div>\n", ["CONSTRUCTOR", "TYPE"]);
add_ocaml_element("t", "Std.Data.Versioned.S.t", "type", "<i>(... type ...)</i>", "Regular.Std.Data.Versioned.S.html#TYPEt", "<div class=\"info\">\n<p>type of data</p>\n\n</div>\n", ["DATA", "TYPE"]);
add_ocaml_element("scanbuf", "Std.Data.scanbuf", "type", "<i>(... type ...)</i>", "Regular.Std.Data.html#TYPEscanbuf", "", []);
add_ocaml_element("lexbuf", "Std.Data.lexbuf", "type", "<i>(... type ...)</i>", "Regular.Std.Data.html#TYPElexbuf", "", []);
add_ocaml_element("dump", "Std.Data.dump", "type", "<i>(... type ...)</i>", "Regular.Std.Data.html#TYPEdump", "<div class=\"info\">\n<p><code class=\"code\">dump&nbsp;out&nbsp;obj</code> a type of functions that outputs a value <code class=\"code\">obj</code>\n        into output <code class=\"code\">out</code></p>\n\n</div>\n", ["DUMP", "FUNCTIONS", "INTO", "OBJ", "OUT", "OUTPUT", "OUTPUTS", "THAT", "TYPE", "VALUE"]);
add_ocaml_element("copy", "Std.Data.copy", "type", "<i>(... type ...)</i>", "Regular.Std.Data.html#TYPEcopy", "<div class=\"info\">\n<p><code class=\"code\">copy&nbsp;buf&nbsp;obj&nbsp;pos</code> is a method to copy object <code class=\"code\">obj</code> into a buffer\n        <code class=\"code\">buf</code>, starting from a position <code class=\"code\">pos</code> and will return the number\n        of bytes written.</p>\n\n</div>\n", ["AMOUNT", "AND", "BEFOREHAND", "BUF", "BUFFER", "BYTES", "COPY", "FROM", "INTO", "METHOD", "NEED", "NUMBER", "OBJ", "OBJECT", "POS", "POSITION", "RETURN", "STARTING", "THE", "WILL", "WRITTEN", "XXX"]);
add_ocaml_element("t", "Std.Seq.t", "type", "<i>(... type ...)</i>", "Regular.Std.Seq.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Printable.S.t", "type", "<i>(... type ...)</i>", "Regular.Std.Printable.S.html#TYPEt", "<div class=\"info\">\n<p>type of printable</p>\n\n</div>\n", ["PRINTABLE", "TYPE"]);
add_ocaml_element("seq", "Std.seq", "type", "<i>(... type ...)</i>", "Regular.Std.html#TYPEseq", "<div class=\"info\">\n<p>Abbreviation for <code class=\"code\"><span class=\"keywordsign\">'</span>a&nbsp;<span class=\"constructor\">Sequence</span>.t</code></p>\n\n</div>\n", ["ABBREVIATION", "FOR", "SEQUENCE"]);
add_ocaml_element("printer", "Std.printer", "type", "<i>(... type ...)</i>", "Regular.Std.html#TYPEprinter", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"keywordsign\">'</span>a&nbsp;printer</code> constructs a printer type for arbitrary type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code>.</p>\n\n</div>\n", ["ARBITRARY", "CONSTRUCTS", "EXPECTED", "FAMILY", "FOR", "FORMAT", "FUNCTION", "FUNCTIONS", "PRINTER", "PRINTF", "SPECIFIER", "THAT", "THE", "TYPE", "VALUE"]);
add_ocaml_element("digest", "Std.digest", "type", "<i>(... type ...)</i>", "Regular.Std.html#TYPEdigest", "<div class=\"info\">\n<p>a string that digests data</p>\n\n</div>\n", ["DATA", "DIGESTS", "STRING", "THAT"]);
add_ocaml_element("writer", "Std.writer", "type", "<i>(... type ...)</i>", "Regular.Std.html#TYPEwriter", "<div class=\"info\">\n<p>an interface for writing a value to the output.</p>\n\n</div>\n", ["FOR", "INTERFACE", "OUTPUT", "THE", "VALUE", "WRITING"]);
add_ocaml_element("reader", "Std.reader", "type", "<i>(... type ...)</i>", "Regular.Std.html#TYPEreader", "<div class=\"info\">\n<p>an interface for reading a value from the input.</p>\n\n</div>\n", ["FOR", "FROM", "INPUT", "INTERFACE", "READING", "THE", "VALUE"]);
add_ocaml_element("bytes", "Std.bytes", "type", "<i>(... type ...)</i>", "Regular.Std.html#TYPEbytes", "<div class=\"info\">\n<p>bytes is a mutable sequence of bytes that has a fixed length.</p>\n\n</div>\n", ["BYTES", "FIXED", "HAS", "LENGTH", "MUTABLE", "SEQUENCE", "THAT"]);
add_ocaml_element("event", "Bap_plugins.Std.Plugins.event", "type", "<i>(... type ...)</i>", "Bap_plugins.Std.Plugins.html#TYPEevent", "", []);
add_ocaml_element("t", "Bap_plugins.Std.Plugin.t", "type", "<i>(... type ...)</i>", "Bap_plugins.Std.Plugin.html#TYPEt", "", []);
add_ocaml_element("plugin", "Bap_plugins.Std.plugin", "type", "<i>(... type ...)</i>", "Bap_plugins.Std.html#TYPEplugin", "", []);
add_ocaml_element("t", "Bap_bundle.Std.Bundle.Builder.t", "type", "<i>(... type ...)</i>", "Bap_bundle.Std.Bundle.Builder.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_bundle.Std.Bundle.t", "type", "<i>(... type ...)</i>", "Bap_bundle.Std.Bundle.html#TYPEt", "", []);
add_ocaml_element("t", "Bap_bundle.Std.Manifest.t", "type", "<i>(... type ...)</i>", "Bap_bundle.Std.Manifest.html#TYPEt", "", []);
add_ocaml_element("manifest", "Bap_bundle.Std.manifest", "type", "<i>(... type ...)</i>", "Bap_bundle.Std.html#TYPEmanifest", "", []);
add_ocaml_element("bundle", "Bap_bundle.Std.bundle", "type", "<i>(... type ...)</i>", "Bap_bundle.Std.html#TYPEbundle", "", []);
add_ocaml_element("manpage_block", "Std.Self.Config.manpage_block", "type", "<i>(... type ...)</i>", "Bap.Std.Self.Config.html#TYPEmanpage_block", "<div class=\"info\">\n<p>The type for a block of man page text.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "BETWEEN", "BLANK", "BLOCK", "BLOCKS", "BOLD", "CAN", "COLLAPSED", "EXCEPT", "FOR", "INDENTED", "INTRODUCED", "INTRODUCES", "ITALIC", "LABEL", "LABELS", "LINE", "MAN", "NEW", "NEWLINES", "NOBLANK", "NOT", "PAGE", "PARAGRAPH", "PRE", "PREFORMATTED", "PRODUCE", "RESPECTIVELY", "SECTION", "SIGNIFICANT", "SINGLE", "SPACE", "STRINGS", "SUPPRESSES", "SYNTAX", "TEXT", "THE", "TWO", "TYPE", "USED", "WHITESPACE", "WITH"]);
add_ocaml_element("reader", "Std.Self.Config.reader", "type", "<i>(... type ...)</i>", "Bap.Std.Self.Config.html#TYPEreader", "<div class=\"info\">\n<p>A witness that can read configured params</p>\n\n</div>\n", ["CAN", "CONFIGURED", "PARAMS", "READ", "THAT", "WITNESS"]);
add_ocaml_element("converter", "Std.Self.Config.converter", "type", "<i>(... type ...)</i>", "Bap.Std.Self.Config.html#TYPEconverter", "<div class=\"info\">\n<p>Type for converting <code class=\"code\">string</code> &lt;-&gt; <code class=\"code\"><span class=\"keywordsign\">'</span>a</code>.</p>\n\n</div>\n", ["ALSO", "CONVERTING", "DEFAULT", "DEFINES", "FOR", "STRING", "THE", "TYPE", "VALUE"]);
add_ocaml_element("parser", "Std.Self.Config.parser", "type", "<i>(... type ...)</i>", "Bap.Std.Self.Config.html#TYPEparser", "<div class=\"info\">\n<p>Parse a string to an 'a</p>\n\n</div>\n", ["PARSE", "STRING"]);
add_ocaml_element("param", "Std.Self.Config.param", "type", "<i>(... type ...)</i>", "Bap.Std.Self.Config.html#TYPEparam", "<div class=\"info\">\n<p>An abstract parameter type that can be later read using a reader</p>\n\n</div>\n", ["ABSTRACT", "CAN", "LATER", "PARAMETER", "READ", "READER", "THAT", "TYPE", "USING"]);
add_ocaml_element("error", "Std.Project.Pass.error", "type", "<i>(... type ...)</i>", "Bap.Std.Project.Pass.html#TYPEerror", "<div class=\"info\">\n<p>An error that can occur when loading or running pass.</p>\n\n</div>\n", ["CAN", "DIDN", "EITHER", "ERROR", "EXN", "EXPECT", "FAILED", "FIND", "FOR", "GIVEN", "IMPLEMENTATION", "INDICATING", "LOAD", "LOADED", "LOADING", "LOGIC", "NAME", "NOT_LOADED", "OCCUR", "OUR", "PASS", "PATHS", "PLUGIN", "RAISED", "REASON", "RUN", "RUNNING", "RUNTIME_ERROR", "SEARCH", "SOME", "SOMETHING", "SYSTEM", "THAT", "THE", "THIS", "TRIED", "UNLIKELY", "VERY", "WAS", "WASN", "WEIRD", "WHEN", "WITH"]);
add_ocaml_element("t", "Std.Project.Pass.t", "type", "<i>(... type ...)</i>", "Bap.Std.Project.Pass.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Project.Input.t", "type", "<i>(... type ...)</i>", "Bap.Std.Project.Input.html#TYPEt", "", []);
add_ocaml_element("second", "Std.Project.second", "type", "<i>(... type ...)</i>", "Bap.Std.Project.html#TYPEsecond", "<div class=\"info\">\n<p>time duration in seconds</p>\n\n</div>\n", ["DURATION", "SECONDS", "TIME"]);
add_ocaml_element("pass", "Std.Project.pass", "type", "<i>(... type ...)</i>", "Bap.Std.Project.html#TYPEpass", "", []);
add_ocaml_element("input", "Std.Project.input", "type", "<i>(... type ...)</i>", "Bap.Std.Project.html#TYPEinput", "", []);
add_ocaml_element("t", "Std.Project.t", "type", "<i>(... type ...)</i>", "Bap.Std.Project.html#TYPEt", "", []);
add_ocaml_element("info", "Std.Event.Log.info", "type", "<i>(... type ...)</i>", "Bap.Std.Event.Log.html#TYPEinfo", "", []);
add_ocaml_element("level", "Std.Event.Log.level", "type", "<i>(... type ...)</i>", "Bap.Std.Event.Log.html#TYPElevel", "", []);
add_ocaml_element("event", "Std.Event.event", "type", "<i>(... type ...)</i>", "Bap.Std.Event.html#TYPEevent", "", []);
add_ocaml_element("t", "Std.Event.t", "type", "<i>(... type ...)</i>", "Bap.Std.Event.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Reconstructor.t", "type", "<i>(... type ...)</i>", "Bap.Std.Reconstructor.html#TYPEt", "", []);
add_ocaml_element("dests", "Std.Brancher.dests", "type", "<i>(... type ...)</i>", "Bap.Std.Brancher.html#TYPEdests", "", []);
add_ocaml_element("dest", "Std.Brancher.dest", "type", "<i>(... type ...)</i>", "Bap.Std.Brancher.html#TYPEdest", "<div class=\"info\">\n<p>destination target (if known) and edge classification (see <a href=\"Bap.Std.html#TYPEedge\"><code class=\"code\"><span class=\"constructor\">Std</span>.edge</code></a>)</p>\n\n</div>\n", ["AND", "BAP", "CLASSIFICATION", "DESTINATION", "EDGE", "KNOWN", "SEE", "STD", "TARGET"]);
add_ocaml_element("t", "Std.Brancher.t", "type", "<i>(... type ...)</i>", "Bap.Std.Brancher.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Rooter.t", "type", "<i>(... type ...)</i>", "Bap.Std.Rooter.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Symbolizer.t", "type", "<i>(... type ...)</i>", "Bap.Std.Symbolizer.html#TYPEt", "<div class=\"info\">\n<p>symbolizer data type</p>\n\n</div>\n", ["DATA", "SYMBOLIZER", "TYPE"]);
add_ocaml_element("state", "Std.Taint.S.state", "type", "<i>(... type ...)</i>", "Bap.Std.Taint.S.html#TYPEstate", "", []);
add_ocaml_element("map", "Std.Taint.map", "type", "<i>(... type ...)</i>", "Bap.Std.Taint.html#TYPEmap", "", []);
add_ocaml_element("set", "Std.Taint.set", "type", "<i>(... type ...)</i>", "Bap.Std.Taint.html#TYPEset", "", []);
add_ocaml_element("t", "Std.Taint.t", "type", "<i>(... type ...)</i>", "Bap.Std.Taint.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Source.Factory.S.t", "type", "<i>(... type ...)</i>", "Bap.Std.Source.Factory.S.html#TYPEt", "", []);
add_ocaml_element("source", "Std.Source.source", "type", "<i>(... type ...)</i>", "Bap.Std.Source.html#TYPEsource", "", []);
add_ocaml_element("t", "Std.Source.t", "type", "<i>(... type ...)</i>", "Bap.Std.Source.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Label.t", "type", "<i>(... type ...)</i>", "Bap.Std.Label.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Call.t", "type", "<i>(... type ...)</i>", "Bap.Std.Call.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Arg.t", "type", "<i>(... type ...)</i>", "Bap.Std.Arg.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Phi.t", "type", "<i>(... type ...)</i>", "Bap.Std.Phi.html#TYPEt", "<div class=\"info\">\n<p>Phi nodes are used to represent a set of values that can be\n        assigned to a given variable depending on a control flow path\n        taken.</p>\n\n</div>\n", ["ARE", "ASSIGNED", "BLOCK", "BLOCKS", "CAN", "CONTROL", "CORRESPONDS", "DEPENDING", "EACH", "EDGE", "ELEMENT", "FLOW", "FROM", "GIVEN", "HAS", "INCOMING", "MORE", "NODE", "NODES", "OCCUR", "ONE", "ONLY", "PARTICULAR", "PATH", "PHI", "REPRESENT", "SET", "SHOULD", "TAKEN", "THAN", "THAT", "THERE", "TRANSFER", "USED", "VALUES", "VARIABLE", "WHICH"]);
add_ocaml_element("t", "Std.Jmp.t", "type", "<i>(... type ...)</i>", "Bap.Std.Jmp.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Def.t", "type", "<i>(... type ...)</i>", "Bap.Std.Def.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Blk.Builder.t", "type", "<i>(... type ...)</i>", "Bap.Std.Blk.Builder.html#TYPEt", "<div class=\"info\">\n<p>This interface provides an efficient way to build new\n          blocks.</p>\n\n</div>\n", ["ALSO", "BLOCK", "BLOCKS", "BUILD", "EFFICIENT", "EXISTING", "IDENTIFIERS", "INSTANCE", "INTERFACE", "NEW", "PRESERVE", "PROGRAM", "PROVIDES", "REBUILDING", "RESPONSIBILITY", "THE", "THIS", "THROUGHOUT", "UNIQUENESS", "USEFUL", "USER", "WAY", "WHEN"]);
add_ocaml_element("elt", "Std.Blk.elt", "type", "<i>(... type ...)</i>", "Bap.Std.Blk.html#TYPEelt", "<div class=\"info\">\n<p>Union type for all element types</p>\n\n</div>\n", ["ALL", "ELEMENT", "FOR", "TYPE", "TYPES", "UNION"]);
add_ocaml_element("t", "Std.Blk.t", "type", "<i>(... type ...)</i>", "Bap.Std.Blk.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Sub.Builder.t", "type", "<i>(... type ...)</i>", "Bap.Std.Sub.Builder.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Sub.t", "type", "<i>(... type ...)</i>", "Bap.Std.Sub.html#TYPEt", "<div class=\"info\">\n<p>Subroutine is a set of blocks.</p>\n\n</div>\n", ["BLOCK", "BLOCKS", "CONSIDERED", "ENTRY", "FIRST", "FUNCTION", "SET", "SUBROUTINE", "THE"]);
add_ocaml_element("t", "Std.Program.Builder.t", "type", "<i>(... type ...)</i>", "Bap.Std.Program.Builder.html#TYPEt", "<div class=\"info\">\n<p>Initializes an empty builder.</p>\n\n</div>\n", ["BUILDER", "EMPTY", "INITIALIZES"]);
add_ocaml_element("t", "Std.Program.t", "type", "<i>(... type ...)</i>", "Bap.Std.Program.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Term.t", "type", "<i>(... type ...)</i>", "Bap.Std.Term.html#TYPEt", "<div class=\"info\">\n<p>term type</p>\n\n</div>\n", ["TERM", "TYPE"]);
add_ocaml_element("t", "Std.Tid.t", "type", "<i>(... type ...)</i>", "Bap.Std.Tid.html#TYPEt", "", []);
add_ocaml_element("fn", "Std.Symtab.fn", "type", "<i>(... type ...)</i>", "Bap.Std.Symtab.html#TYPEfn", "<div class=\"info\">\n<p><code class=\"code\">(name,entry,graph)</code> a simple representation of a function</p>\n\n</div>\n", ["ENTRY", "FUNCTION", "GRAPH", "NAME", "REPRESENTATION", "SIMPLE"]);
add_ocaml_element("t", "Std.Symtab.t", "type", "<i>(... type ...)</i>", "Bap.Std.Symtab.html#TYPEt", "<div class=\"info\">\n<p>symbol table</p>\n\n</div>\n", ["SYMBOL", "TABLE"]);
add_ocaml_element("t", "Std.Disasm.t", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm.html#TYPEt", "", []);
add_ocaml_element("node", "Std.Graphs.Ir.node", "type", "<i>(... type ...)</i>", "Bap.Std.Graphs.Ir.html#TYPEnode", "", []);
add_ocaml_element("edge", "Std.Graphs.Ir.edge", "type", "<i>(... type ...)</i>", "Bap.Std.Graphs.Ir.html#TYPEedge", "", []);
add_ocaml_element("t", "Std.Graphs.Ir.t", "type", "<i>(... type ...)</i>", "Bap.Std.Graphs.Ir.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Block.t", "type", "<i>(... type ...)</i>", "Bap.Std.Block.html#TYPEt", "", []);
add_ocaml_element("key", "Std.Insn.Trie.key", "type", "<i>(... type ...)</i>", "Bap.Std.Insn.Trie.html#TYPEkey", "<div class=\"info\">\n<p>Trie requires 0(1) get operation</p>\n\n</div>\n", ["GET", "OPERATION", "REQUIRES", "TRIE"]);
add_ocaml_element("property", "Std.Insn.property", "type", "<i>(... type ...)</i>", "Bap.Std.Insn.html#TYPEproperty", "", []);
add_ocaml_element("may", "Std.Insn.may", "type", "<i>(... type ...)</i>", "Bap.Std.Insn.html#TYPEmay", "", []);
add_ocaml_element("must", "Std.Insn.must", "type", "<i>(... type ...)</i>", "Bap.Std.Insn.html#TYPEmust", "", []);
add_ocaml_element("t", "Std.Insn.t", "type", "<i>(... type ...)</i>", "Bap.Std.Insn.html#TYPEt", "", []);
add_ocaml_element("error", "Std.Disasm_expert.Recursive.error", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Recursive.html#TYPEerror", "<div class=\"info\">\n<p><code class=\"code\">error</code> domain of errors.</p>\n\n</div>\n", ["DOMAIN", "ERROR", "ERRORS"]);
add_ocaml_element("t", "Std.Disasm_expert.Recursive.t", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Recursive.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Disasm_expert.Linear.t", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Linear.html#TYPEt", "<div class=\"info\">\n<p>output type of a disassembler.</p>\n\n</div>\n", ["DISASSEMBLER", "OUTPUT", "TYPE"]);
add_ocaml_element("key", "Std.Disasm_expert.Basic.Trie.key", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.Trie.html#TYPEkey", "", []);
add_ocaml_element("t", "Std.Disasm_expert.Basic.Insn.t", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.Insn.html#TYPEt", "", []);
add_ocaml_element("state", "Std.Disasm_expert.Basic.state", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEstate", "<div class=\"info\">\n<p>Disassembler state.</p>\n\n</div>\n", ["AND", "ANYWHERE", "ARBITRARY", "ARE", "BOUND", "BOUNDED", "CAN", "CASES", "CORRESPONDINGLY", "DIFFERENT", "DISASSEMBLER", "DISASSMBLER", "FIRST", "FOR", "FUNCTION", "FUNCTIONS", "HANDLERS", "INPUT", "INSIDE", "LAST", "MADE", "MONAD", "ONLY", "OUTPUT", "PAIR", "PRECAUTION", "RUN", "SAME", "SHOULDN", "SIMPLE", "STATE", "STORED", "THAT", "THE", "THEY", "THIS", "TWO", "TYPE", "TYPES", "USER", "VALID", "VARIABLES", "WORDS"]);
add_ocaml_element("t", "Std.Disasm_expert.Basic.t", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEt", "<div class=\"info\">\n<p>Disassembler.</p>\n\n</div>\n", ["ABOUT", "ACCESS", "ACCESSING", "ALTHOUGH", "AND", "ASM", "ASSEMBLER", "ASSEMBLY", "CAN", "DEFAULT", "DISABLED", "DISASSEMBLER", "DISASSEMBLY", "DON", "DROP_ASM", "EMPTY", "ENABLE", "ENABLED", "EVEN", "EXPLICITLY", "EXTRA", "FIRST", "FOR", "FROM", "FUNCTIONS", "GIVE", "HAVE", "INFORMATION", "INSTRUCTION", "KIND", "KINDS", "MIGHT", "MODES", "NOT", "NOTE", "OPERATION", "OTHERWISE", "POINTS", "PROCESS", "RETURNS", "SECOND", "SET", "SINCE", "SOME", "SPACE", "SPECIFIES", "SPECIFY", "STANDS", "STOPPING", "STORE", "STORE_ASM", "STORING", "STRINGS", "SWITCHED", "TAKES", "THAT", "THE", "THEN", "THIS", "THUS", "TIME", "TYPE", "USEFUL", "USING", "VARIABLE", "VARIABLES", "WHEN", "WHETHER", "WILL", "YOU"]);
add_ocaml_element("full_insn", "Std.Disasm_expert.Basic.full_insn", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEfull_insn", "<div class=\"info\">\n<p>abbreviate an instruction with full information.</p>\n\n</div>\n", ["ABBREVIATE", "FULL", "INFORMATION", "INSTRUCTION", "WITH"]);
add_ocaml_element("kinds", "Std.Disasm_expert.Basic.kinds", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEkinds", "<div class=\"info\">\n<p>witnesses a presence of the semantic kinds</p>\n\n</div>\n", ["KINDS", "PRESENCE", "SEMANTIC", "THE", "WITNESSES"]);
add_ocaml_element("asm", "Std.Disasm_expert.Basic.asm", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEasm", "<div class=\"info\">\n<p>witnesses a presence of the assembly string</p>\n\n</div>\n", ["ASSEMBLY", "PRESENCE", "STRING", "THE", "WITNESSES"]);
add_ocaml_element("empty", "Std.Disasm_expert.Basic.empty", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEempty", "<div class=\"info\">\n<p>witnesses the absence of the information</p>\n\n</div>\n", ["ABSENCE", "INFORMATION", "THE", "WITNESSES"]);
add_ocaml_element("insns", "Std.Disasm_expert.Basic.insns", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEinsns", "<div class=\"info\">\n<p><code class=\"code\">insns</code> is a list of pairs, where each pair consists of a\n          memory region occupied by an instruction, and the instruction\n          itself.</p>\n\n</div>\n", ["AND", "CONSISTS", "EACH", "INSNS", "INSTRUCTION", "ITSELF", "LIST", "MEMORY", "OCCUPIED", "PAIR", "PAIRS", "REGION", "THE", "WHERE"]);
add_ocaml_element("insn", "Std.Disasm_expert.Basic.insn", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEinsn", "<div class=\"info\">\n<p><code class=\"code\">insn</code> basic instruction.</p>\n\n</div>\n", ["BAP", "BASIC", "DESCRIPTION", "DETAILED", "DISASM_EXPERT", "FOR", "INSN", "INSTRUCTION", "MODULE", "MORE", "SEE", "STD"]);
add_ocaml_element("pred", "Std.Disasm_expert.Basic.pred", "type", "<i>(... type ...)</i>", "Bap.Std.Disasm_expert.Basic.html#TYPEpred", "<div class=\"info\">\n<p>predicate to drive the disassembler</p>\n\n</div>\n", ["DISASSEMBLER", "DRIVE", "PREDICATE", "THE"]);
add_ocaml_element("t", "Std.Op.t", "type", "<i>(... type ...)</i>", "Bap.Std.Op.html#TYPEt", "<div class=\"info\">\n<p>operand</p>\n\n</div>\n", ["OPERAND"]);
add_ocaml_element("t", "Std.Fmm.t", "type", "<i>(... type ...)</i>", "Bap.Std.Fmm.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Imm.t", "type", "<i>(... type ...)</i>", "Bap.Std.Imm.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Reg.t", "type", "<i>(... type ...)</i>", "Bap.Std.Reg.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Kind.t", "type", "<i>(... type ...)</i>", "Bap.Std.Kind.html#TYPEt", "", []);
add_ocaml_element("having_side_effect", "Std.Kind.having_side_effect", "type", "<i>(... type ...)</i>", "Bap.Std.Kind.html#TYPEhaving_side_effect", "", []);
add_ocaml_element("affecting_control", "Std.Kind.affecting_control", "type", "<i>(... type ...)</i>", "Bap.Std.Kind.html#TYPEaffecting_control", "", []);
add_ocaml_element("branch", "Std.Kind.branch", "type", "<i>(... type ...)</i>", "Bap.Std.Kind.html#TYPEbranch", "", []);
add_ocaml_element("t", "Std.Memmap.t", "type", "<i>(... type ...)</i>", "Bap.Std.Memmap.html#TYPEt", "<div class=\"info\">\n<p>memory map, aka interval trees</p>\n\n</div>\n", ["AKA", "INTERVAL", "MAP", "MEMORY", "TREES"]);
add_ocaml_element("region", "Std.Image.Scheme.region", "type", "<i>(... type ...)</i>", "Bap.Std.Image.Scheme.html#TYPEregion", "<div class=\"info\">\n<p>a contiguous piece of memory.</p>\n\n</div>\n", ["CONTIGUOUS", "MEMORY", "PIECE"]);
add_ocaml_element("off", "Std.Image.Scheme.off", "type", "<i>(... type ...)</i>", "Bap.Std.Image.Scheme.html#TYPEoff", "", []);
add_ocaml_element("size", "Std.Image.Scheme.size", "type", "<i>(... type ...)</i>", "Bap.Std.Image.Scheme.html#TYPEsize", "", []);
add_ocaml_element("addr", "Std.Image.Scheme.addr", "type", "<i>(... type ...)</i>", "Bap.Std.Image.Scheme.html#TYPEaddr", "", []);
add_ocaml_element("t", "Std.Image.Symbol.t", "type", "<i>(... type ...)</i>", "Bap.Std.Image.Symbol.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Image.Segment.t", "type", "<i>(... type ...)</i>", "Bap.Std.Image.Segment.html#TYPEt", "", []);
add_ocaml_element("result", "Std.Image.result", "type", "<i>(... type ...)</i>", "Bap.Std.Image.html#TYPEresult", "<div class=\"info\">\n<p>constructing an image can result in actual image and a set\n        (hopefully empty) of errors occured in a process of decoding an\n        image, that do not prevent us from actually creating an image.</p>\n\n</div>\n", ["ACTUAL", "ACTUALLY", "AND", "CAN", "CONSIDERED", "CONSTRUCTING", "CREATING", "DECODING", "EMPTY", "ERRORS", "FROM", "HOPEFULLY", "IMAGE", "INFORMATION", "MESSAGES", "NOT", "OCCURED", "PREVENT", "PROCESS", "RESULT", "SET", "THAT", "THIS", "WARNINGS"]);
add_ocaml_element("path", "Std.Image.path", "type", "<i>(... type ...)</i>", "Bap.Std.Image.html#TYPEpath", "", []);
add_ocaml_element("symbol", "Std.Image.symbol", "type", "<i>(... type ...)</i>", "Bap.Std.Image.html#TYPEsymbol", "<div class=\"info\">\n<p>symbol</p>\n\n</div>\n", ["SYMBOL"]);
add_ocaml_element("segment", "Std.Image.segment", "type", "<i>(... type ...)</i>", "Bap.Std.Image.html#TYPEsegment", "<div class=\"info\">\n<p>segment</p>\n\n</div>\n", ["SEGMENT"]);
add_ocaml_element("t", "Std.Image.t", "type", "<i>(... type ...)</i>", "Bap.Std.Image.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Backend.Img.t", "type", "<i>(... type ...)</i>", "Bap.Std.Backend.Img.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Backend.Section.t", "type", "<i>(... type ...)</i>", "Bap.Std.Backend.Section.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Backend.Symbol.t", "type", "<i>(... type ...)</i>", "Bap.Std.Backend.Symbol.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Backend.Segment.t", "type", "<i>(... type ...)</i>", "Bap.Std.Backend.Segment.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Backend.t", "type", "<i>(... type ...)</i>", "Bap.Std.Backend.html#TYPEt", "<div class=\"info\">\n<p>the actual interface to be implemented</p>\n\n</div>\n", ["ACTUAL", "IMPLEMENTED", "INTERFACE", "THE"]);
add_ocaml_element("perm", "Std.Backend.perm", "type", "<i>(... type ...)</i>", "Bap.Std.Backend.html#TYPEperm", "<div class=\"info\">\n<p>memory access permissions</p>\n\n</div>\n", ["ACCESS", "MEMORY", "PERMISSIONS"]);
add_ocaml_element("t", "Std.Location.t", "type", "<i>(... type ...)</i>", "Bap.Std.Location.html#TYPEt", "", []);
add_ocaml_element("ranged", "Std.Table.ranged", "type", "<i>(... type ...)</i>", "Bap.Std.Table.html#TYPEranged", "<div class=\"info\">\n<p>Iterators</p>\n\n</div>\n", ["ADDRESSES", "ALL", "AND", "ANOTHER", "APPLIES", "ARE", "ARROW", "ASCENDING", "BOOL", "BUT", "CAN", "CASE", "COMMON", "DATA", "DECREASING", "ELEMENTS", "ENTRIES", "FORGET", "FUNCTION", "FUNCTIONAL", "INTERFACE", "ITERATION", "ITERATOR", "ITERATORS", "JUST", "LIFTED", "MANNER", "MEANING", "MENTALLY", "NAME", "NARROWS", "NOT", "NOTE", "ORDER", "OTHER", "PARAMETERS", "PART", "PERFORMED", "PREPENDS", "PROVIDES", "RANGED", "SAME", "SECTION", "SEE", "SET", "SHARE", "SOME", "SPECIFIED", "START", "STRUCTURE", "SUBSET", "SUBSTITUTE", "TABLE", "TAKES", "THAT", "THE", "THEN", "THEY", "THIS", "TYPE", "UNSPECIFIED", "UNTIL", "USED", "WAS", "WHEN", "WILL", "WITH", "WORDS", "WOULD", "YOU"]);
add_ocaml_element("r", "Std.Table.r", "type", "<i>(... type ...)</i>", "Bap.Std.Table.html#TYPEr", "<div class=\"info\">\n<p>Relation multiplicity.</p>\n\n</div>\n", ["CREATES", "FOR", "GIVEN", "MULTIPLICITY", "RELATION", "TYPE"]);
add_ocaml_element("hashable", "Std.Table.hashable", "type", "<i>(... type ...)</i>", "Bap.Std.Table.html#TYPEhashable", "", []);
add_ocaml_element("t", "Std.Table.t", "type", "<i>(... type ...)</i>", "Bap.Std.Table.html#TYPEt", "", []);
add_ocaml_element("m", "Std.Memory_iterators.m", "type", "<i>(... type ...)</i>", "Bap.Std.Memory_iterators.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Memory_iterators.t", "type", "<i>(... type ...)</i>", "Bap.Std.Memory_iterators.html#TYPEt", "", []);
add_ocaml_element("reader", "Std.Memory.Input.reader", "type", "<i>(... type ...)</i>", "Bap.Std.Memory.Input.html#TYPEreader", "<div class=\"info\">\n<p><code class=\"code\">reader&nbsp;mem&nbsp;~pos_ref</code> defines a set of functions with a\n          common interface.</p>\n\n</div>\n", ["ACCEPTS", "ACTUALLY", "ADDRESS", "AMOUNT", "AND", "BYTES", "COMMON", "DEFINES", "EACH", "FOR", "FUNCTION", "FUNCTIONS", "INTERFACE", "INTO", "LIFTED", "MEM", "MEMORY", "MONAD", "POS_REF", "READ", "READER", "REFERENCE", "RETURNS", "SET", "SHOULD", "THAT", "THE", "THIS", "UPDATED", "WAS", "WILL", "WITH", "WORD"]);
add_ocaml_element("t", "Std.Memory.t", "type", "<i>(... type ...)</i>", "Bap.Std.Memory.html#TYPEt", "", []);
add_ocaml_element("r", "Std.Biri.S.r", "type", "<i>(... type ...)</i>", "Bap.Std.Biri.S.html#TYPEr", "", []);
add_ocaml_element("u", "Std.Biri.S.u", "type", "<i>(... type ...)</i>", "Bap.Std.Biri.S.html#TYPEu", "", []);
add_ocaml_element("state", "Std.Biri.S.state", "type", "<i>(... type ...)</i>", "Bap.Std.Biri.S.html#TYPEstate", "", []);
add_ocaml_element("t", "Std.Vector.t", "type", "<i>(... type ...)</i>", "Bap.Std.Vector.html#TYPEt", "<div class=\"info\">\n<p>a type of vector holding elements of type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code></p>\n\n</div>\n", ["ELEMENTS", "HOLDING", "TYPE", "VECTOR"]);
add_ocaml_element("t", "Std.Dict.t", "type", "<i>(... type ...)</i>", "Bap.Std.Dict.html#TYPEt", "<div class=\"info\">\n<p>type of map</p>\n\n</div>\n", ["MAP", "TYPE"]);
add_ocaml_element("t", "Std.Value.S.t", "type", "<i>(... type ...)</i>", "Bap.Std.Value.S.html#TYPEt", "<div class=\"info\">\n<p>In order to construct a value with the a given type you must\n          provide an implementation for marshaling functions,\n          comparison function and pretty-printing.</p>\n\n</div>\n", ["AND", "COMPARISON", "CONSTRUCT", "FOR", "FUNCTION", "FUNCTIONS", "GIVEN", "IMPLEMENTATION", "MARSHALING", "MUST", "ORDER", "PRETTY", "PRINTING", "PROVIDE", "THE", "TYPE", "VALUE", "WITH", "YOU"]);
add_ocaml_element("t", "Std.Value.Match.t", "type", "<i>(... type ...)</i>", "Bap.Std.Value.Match.html#TYPEt", "<div class=\"info\">\n<p>This module can be used to handle several cases in parallel\n          instead of using a sequence of nested matches or if/then/else\n          chains.</p>\n\n</div>\n", ["AND", "ARE", "BEGIN", "BUILD", "CAN", "CASE", "CASES", "CHAINS", "COMBINATOR", "COMBINATORS", "DEFAULT", "DESIGNED", "ELSE", "END", "EVALUATE", "EXAMPLE", "EXPRESSION", "FIRST", "FOLLOWS", "FOR", "FUN", "FUNCTION", "HANDLE", "INSTEAD", "LET", "LIFT", "LOAD", "MATCH", "MATCHES", "MATCHING", "MATTER", "MEMORY_LOAD", "MEMORY_STORE", "MODULE", "MORE", "NESTED", "NOTE", "OBJECT", "ONE", "PARALLEL", "PERFORMANCE", "READ", "RECOMMENDED", "REGISTER_READ", "RETURN", "SELECT", "SEQUENCE", "SEVERAL", "STORE", "SWITCH", "THAT", "THE", "THEN", "THERE", "THIS", "UNKNOWN", "USED", "USING", "VALUES", "WHEN", "WHOLE", "WILL"]);
add_ocaml_element("t", "Std.Value.Tag.t", "type", "<i>(... type ...)</i>", "Bap.Std.Value.Tag.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">register&nbsp;~name&nbsp;~uuid&nbsp;(<span class=\"keyword\">module</span>&nbsp;<span class=\"constructor\">T</span>)</code> creates a new variant\n          constructor, that accepts values of type <code class=\"code\"><span class=\"constructor\">T</span>.t</code>.</p>\n\n</div>\n", ["ABUSE", "ACCEPTS", "AND", "BINABLE", "CAN", "COMPARE", "COMPILE", "CONSTRUCTOR", "CREATE", "CREATES", "FUNCTIONS", "GET", "IMPLEMENT", "INTERFACES", "INTO", "KEY", "KNOWN", "LITERALS", "MODULE", "MUST", "NAME", "NEW", "PACK", "PARAMETERS", "PRETTY", "PREVENT", "PRINT", "PRINTING", "PROVIDE", "REGISTER", "RETURNED", "SERIALIZE", "SEXPABLE", "SHOULD", "SPECIAL", "STRING", "SYSTEM", "TAG", "THAT", "THE", "THEY", "THIS", "TIME", "TYPE", "UNPACK", "USED", "UUID", "VALUE", "VALUES", "VARIANT", "WILL", "WITH"]);
add_ocaml_element("typeid", "Std.Value.typeid", "type", "<i>(... type ...)</i>", "Bap.Std.Value.html#TYPEtypeid", "<div class=\"info\">\n<p>persistent type identifier</p>\n\n</div>\n", ["IDENTIFIER", "PERSISTENT", "TYPE"]);
add_ocaml_element("literal", "Std.Value.literal", "type", "<i>(... type ...)</i>", "Bap.Std.Value.html#TYPEliteral", "<div class=\"info\">\n<p>literal string.</p>\n\n</div>\n", ["AUTOMATICALLY", "COERCE", "COMPILER", "DON", "EQUATION", "HAND", "JUST", "LITERAL", "LITERALS", "LOOK", "NOT", "RIGHT", "SAY", "SHOULD", "SIDE", "STRING", "THAT", "THE", "THIS", "TYPE", "VALUE", "WAY", "WILL", "YOUR"]);
add_ocaml_element("void", "Std.Value.void", "type", "<i>(... type ...)</i>", "Bap.Std.Value.html#TYPEvoid", "<div class=\"info\">\n<p>uninhabited type</p>\n\n</div>\n", ["TYPE", "UNINHABITED"]);
add_ocaml_element("tag", "Std.Value.tag", "type", "<i>(... type ...)</i>", "Bap.Std.Value.html#TYPEtag", "<div class=\"info\">\n<p>Tag constructor of type <code class=\"code\"><span class=\"keywordsign\">'</span>a</code></p>\n\n</div>\n", ["CONSTRUCTOR", "TAG", "TYPE"]);
add_ocaml_element("t", "Std.Value.t", "type", "<i>(... type ...)</i>", "Bap.Std.Value.html#TYPEt", "<div class=\"info\">\n<p>a universal value</p>\n\n</div>\n", ["UNIVERSAL", "VALUE"]);
add_ocaml_element("t", "Std.Arch.t", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEt", "", []);
add_ocaml_element("xcore", "Std.Arch.xcore", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPExcore", "", []);
add_ocaml_element("systemz", "Std.Arch.systemz", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEsystemz", "", []);
add_ocaml_element("r600", "Std.Arch.r600", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEr600", "", []);
add_ocaml_element("hexagon", "Std.Arch.hexagon", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEhexagon", "", []);
add_ocaml_element("nvptx", "Std.Arch.nvptx", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEnvptx", "", []);
add_ocaml_element("sparc", "Std.Arch.sparc", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEsparc", "", []);
add_ocaml_element("mips", "Std.Arch.mips", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEmips", "", []);
add_ocaml_element("ppc", "Std.Arch.ppc", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEppc", "", []);
add_ocaml_element("aarch64", "Std.Arch.aarch64", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEaarch64", "", []);
add_ocaml_element("thumbeb", "Std.Arch.thumbeb", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEthumbeb", "", []);
add_ocaml_element("thumb", "Std.Arch.thumb", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEthumb", "", []);
add_ocaml_element("armeb", "Std.Arch.armeb", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEarmeb", "", []);
add_ocaml_element("arm", "Std.Arch.arm", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEarm", "", []);
add_ocaml_element("x86", "Std.Arch.x86", "type", "<i>(... type ...)</i>", "Bap.Std.Arch.html#TYPEx86", "", []);
add_ocaml_element("t", "Std.Stmt.t", "type", "<i>(... type ...)</i>", "Bap.Std.Stmt.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Exp.t", "type", "<i>(... type ...)</i>", "Bap.Std.Exp.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Eff.t", "type", "<i>(... type ...)</i>", "Bap.Std.Eff.html#TYPEt", "<div class=\"info\">\n<p>a set of expression effects</p>\n\n</div>\n", ["EFFECTS", "EXPRESSION", "SET"]);
add_ocaml_element("r", "Std.Bili.S.r", "type", "<i>(... type ...)</i>", "Bap.Std.Bili.S.html#TYPEr", "", []);
add_ocaml_element("u", "Std.Bili.S.u", "type", "<i>(... type ...)</i>", "Bap.Std.Bili.S.html#TYPEu", "", []);
add_ocaml_element("state", "Std.Bili.S.state", "type", "<i>(... type ...)</i>", "Bap.Std.Bili.S.html#TYPEstate", "", []);
add_ocaml_element("r", "Std.Expi.S.r", "type", "<i>(... type ...)</i>", "Bap.Std.Expi.S.html#TYPEr", "", []);
add_ocaml_element("u", "Std.Expi.S.u", "type", "<i>(... type ...)</i>", "Bap.Std.Expi.S.html#TYPEu", "", []);
add_ocaml_element("state", "Std.Expi.S.state", "type", "<i>(... type ...)</i>", "Bap.Std.Expi.S.html#TYPEstate", "", []);
add_ocaml_element("m", "Std.Eval.S.m", "type", "<i>(... type ...)</i>", "Bap.Std.Eval.S.html#TYPEm", "", []);
add_ocaml_element("m", "Std.Eval.S2.m", "type", "<i>(... type ...)</i>", "Bap.Std.Eval.S2.html#TYPEm", "", []);
add_ocaml_element("m", "Std.Eval.T2.m", "type", "<i>(... type ...)</i>", "Bap.Std.Eval.T2.html#TYPEm", "", []);
add_ocaml_element("m", "Std.Eval.T1.m", "type", "<i>(... type ...)</i>", "Bap.Std.Eval.T1.html#TYPEm", "", []);
add_ocaml_element("t", "Std.Var.t", "type", "<i>(... type ...)</i>", "Bap.Std.Var.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Type.Error.t", "type", "<i>(... type ...)</i>", "Bap.Std.Type.Error.html#TYPEt", "", []);
add_ocaml_element("error", "Std.Type.error", "type", "<i>(... type ...)</i>", "Bap.Std.Type.html#TYPEerror", "<div class=\"info\">\n<p>type error</p>\n\n</div>\n", ["ERROR", "TYPE"]);
add_ocaml_element("t", "Std.Type.t", "type", "<i>(... type ...)</i>", "Bap.Std.Type.html#TYPEt", "<div class=\"info\">\n<p>type is either an immediate value or a storage</p>\n\n</div>\n", ["EITHER", "IMMEDIATE", "STORAGE", "TYPE", "VALUE"]);
add_ocaml_element("normalized_bil", "Std.Bil.Trie.normalized_bil", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Trie.html#TYPEnormalized_bil", "", []);
add_ocaml_element("u", "Std.Bil.Result.u", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Result.html#TYPEu", "<div class=\"info\">\n<p>State monad that evaluates to unit</p>\n\n</div>\n", ["EVALUATES", "MONAD", "STATE", "THAT", "UNIT"]);
add_ocaml_element("r", "Std.Bil.Result.r", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Result.html#TYPEr", "<div class=\"info\">\n<p>State monad that evaluates to result</p>\n\n</div>\n", ["EVALUATES", "MONAD", "RESULT", "STATE", "THAT"]);
add_ocaml_element("t", "Std.Bil.Result.t", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Result.html#TYPEt", "", []);
add_ocaml_element("id", "Std.Bil.Result.id", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Result.html#TYPEid", "<div class=\"info\">\n<p>result identifier</p>\n\n</div>\n", ["IDENTIFIER", "RESULT"]);
add_ocaml_element("stmt", "Std.Bil.Types.stmt", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEstmt", "", []);
add_ocaml_element("typ", "Std.Bil.Types.typ", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEtyp", "", []);
add_ocaml_element("exp", "Std.Bil.Types.exp", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>BIL expression variants</p>\n\n</div>\n", ["BIL", "EXPRESSION", "VARIANTS"]);
add_ocaml_element("unop", "Std.Bil.Types.unop", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEunop", "<div class=\"info\">\n<p>Unary operations implemented in the IR</p>\n\n</div>\n", ["IMPLEMENTED", "OPERATIONS", "THE", "UNARY"]);
add_ocaml_element("binop", "Std.Bil.Types.binop", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Binary operations implemented in the BIL</p>\n\n</div>\n", ["BIL", "BINARY", "IMPLEMENTED", "OPERATIONS", "THE"]);
add_ocaml_element("cast", "Std.Bil.Types.cast", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEcast", "<div class=\"info\">\n<p>Different forms of casting</p>\n\n</div>\n", ["CASTING", "DIFFERENT", "FORMS"]);
add_ocaml_element("var", "Std.Bil.Types.var", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.Types.html#TYPEvar", "", []);
add_ocaml_element("pass", "Std.Bil.pass", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.html#TYPEpass", "", []);
add_ocaml_element("value", "Std.Bil.value", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.html#TYPEvalue", "<div class=\"info\">\n<span class=\"deprecated\"><p>Value of a result.</p>\n\n</span></div>\n", ["ABSENCE", "ADDR", "ALLOWING", "ALTHOUGH", "AND", "ANOTHER", "ARE", "ASSOC", "BAP", "BIL", "BOT", "DATA", "DEFAULT", "DEFINED", "DEPRECATED", "DIVERGE", "EFFECTIVE", "EFFICIENT", "EITHER", "EMPTY", "ENCOURAGED", "EQUIVALENT", "FOR", "FRAMEWORK", "FROM", "HEAVE", "IMPLEMENTATION", "IMPLEMENTATIONS", "IMPLEMENTED", "INDUCTIVE", "INDUCTIVELY", "INTERPRETERS", "ITS", "KNOWLEDGE", "LINEAR", "LIST", "LOG", "LOOKUP", "MAY", "MEM", "MEMORY", "METHODS", "MORE", "NAT", "OBJECT", "OPERATIONAL", "OWN", "PRIMUS", "PROVIDE", "PROVIDES", "RELY", "REPRESENTED", "REPRESENTING", "RESULT", "SEE", "SEMANTICS", "SLIGHTLY", "SPACE", "STD", "STORAGE", "STORE", "SYNTACTICALLY", "THAT", "THE", "THROUGHPUT", "TYPED", "UPDATE", "USE", "USER", "USERS", "USES", "VALUE", "VARIANT", "WELL", "WHERE", "WITH"]);
add_ocaml_element("result", "Std.Bil.result", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.html#TYPEresult", "<div class=\"info\">\n<span class=\"deprecated\"><p>Result of a computation.</p>\n\n</span></div>\n", ["COMPUTATION", "DEPRECATED", "FRAMEWORK", "PRIMUS", "RESULT", "THE", "USE"]);
add_ocaml_element("vars", "Std.Bil.vars", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.html#TYPEvars", "", []);
add_ocaml_element("var_compare", "Std.Bil.var_compare", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.html#TYPEvar_compare", "", []);
add_ocaml_element("t", "Std.Bil.t", "type", "<i>(... type ...)</i>", "Bap.Std.Bil.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Bitvector.Stable.V2.t", "type", "<i>(... type ...)</i>", "Bap.Std.Bitvector.Stable.V2.html#TYPEt", "", []);
add_ocaml_element("t", "Std.Bitvector.Stable.V1.t", "type", "<i>(... type ...)</i>", "Bap.Std.Bitvector.Stable.V1.html#TYPEt", "", []);
add_ocaml_element("endian", "Std.Bitvector.endian", "type", "<i>(... type ...)</i>", "Bap.Std.Bitvector.html#TYPEendian", "<div class=\"info\">\n<p>Specifies the order of bytes in a word.</p>\n\n</div>\n", ["BYTES", "ORDER", "SPECIFIES", "THE", "WORD"]);
add_ocaml_element("t", "Std.Bitvector.t", "type", "<i>(... type ...)</i>", "Bap.Std.Bitvector.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\">word</code> is an abbreviation to <code class=\"code\"><span class=\"constructor\">Bitvector</span>.t</code></p>\n\n</div>\n", ["ABBREVIATION", "BITVECTOR", "WORD"]);
add_ocaml_element("t", "Std.Size.t", "type", "<i>(... type ...)</i>", "Bap.Std.Size.html#TYPEt", "", []);
add_ocaml_element("p", "Std.Size.p", "type", "<i>(... type ...)</i>", "Bap.Std.Size.html#TYPEp", "", []);
add_ocaml_element("all", "Std.Size.all", "type", "<i>(... type ...)</i>", "Bap.Std.Size.html#TYPEall", "<div class=\"info\">\n<p>Defines possible sizes for operations operands</p>\n\n</div>\n", ["DEFINES", "FOR", "OPERANDS", "OPERATIONS", "POSSIBLE", "SIZES"]);
add_ocaml_element("point", "Std.Interval_tree.Interval_binable.point", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.Interval_binable.html#TYPEpoint", "", []);
add_ocaml_element("t", "Std.Interval_tree.Interval_binable.t", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.Interval_binable.html#TYPEt", "", []);
add_ocaml_element("point", "Std.Interval_tree.Interval.point", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.Interval.html#TYPEpoint", "<div class=\"info\">\n<p>point representation</p>\n\n</div>\n", ["POINT", "REPRESENTATION"]);
add_ocaml_element("t", "Std.Interval_tree.Interval.t", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.Interval.html#TYPEt", "<div class=\"info\">\n<p>interval representation</p>\n\n</div>\n", ["INTERVAL", "REPRESENTATION"]);
add_ocaml_element("t", "Std.Interval_tree.S_binable.t", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.S_binable.html#TYPEt", "", []);
add_ocaml_element("point", "Std.Interval_tree.S.point", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.S.html#TYPEpoint", "<div class=\"info\">\n<p>an element of the interval</p>\n\n</div>\n", ["ELEMENT", "INTERVAL", "THE"]);
add_ocaml_element("key", "Std.Interval_tree.S.key", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.S.html#TYPEkey", "<div class=\"info\">\n<p>the interval</p>\n\n</div>\n", ["INTERVAL", "THE"]);
add_ocaml_element("t", "Std.Interval_tree.S.t", "type", "<i>(... type ...)</i>", "Bap.Std.Interval_tree.S.html#TYPEt", "<div class=\"info\">\n<p>interval tree abstract representation</p>\n\n</div>\n", ["ABSTRACT", "INTERVAL", "REPRESENTATION", "TREE"]);
add_ocaml_element("t", "Std.Trie.Token.t", "type", "<i>(... type ...)</i>", "Bap.Std.Trie.Token.html#TYPEt", "", []);
add_ocaml_element("token", "Std.Trie.Key.token", "type", "<i>(... type ...)</i>", "Bap.Std.Trie.Key.html#TYPEtoken", "<div class=\"info\">\n<p>type of token must implement bin_prot, be comparable and\n          sexpable</p>\n\n</div>\n", ["AND", "BIN_PROT", "COMPARABLE", "IMPLEMENT", "MUST", "SEXPABLE", "TOKEN", "TYPE"]);
add_ocaml_element("t", "Std.Trie.Key.t", "type", "<i>(... type ...)</i>", "Bap.Std.Trie.Key.html#TYPEt", "<div class=\"info\">\n<p>the type of key</p>\n\n</div>\n", ["KEY", "THE", "TYPE"]);
add_ocaml_element("key", "Std.Trie.S.key", "type", "<i>(... type ...)</i>", "Bap.Std.Trie.S.html#TYPEkey", "<div class=\"info\">\n<p>a key type that is used to lookup data</p>\n\n</div>\n", ["DATA", "KEY", "LOOKUP", "THAT", "TYPE", "USED"]);
add_ocaml_element("t", "Std.Trie.S.t", "type", "<i>(... type ...)</i>", "Bap.Std.Trie.S.html#TYPEt", "<div class=\"info\">\n<p>trie can store arbitrary data</p>\n\n</div>\n", ["ARBITRARY", "CAN", "DATA", "STORE", "TRIE"]);
add_ocaml_element("t", "Std.Integer.Base.t", "type", "<i>(... type ...)</i>", "Bap.Std.Integer.Base.html#TYPEt", "<div class=\"info\">\n<p>type of integer</p>\n\n</div>\n", ["INTEGER", "TYPE"]);
add_ocaml_element("t", "Std.Integer.S.t", "type", "<i>(... type ...)</i>", "Bap.Std.Integer.S.html#TYPEt", "", []);
add_ocaml_element("project", "Std.project", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEproject", "", []);
add_ocaml_element("event", "Std.event", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEevent", "", []);
add_ocaml_element("source", "Std.source", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEsource", "", []);
add_ocaml_element("lifter", "Std.lifter", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPElifter", "", []);
add_ocaml_element("symtab", "Std.symtab", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEsymtab", "", []);
add_ocaml_element("op", "Std.op", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEop", "", []);
add_ocaml_element("kind", "Std.kind", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEkind", "<div class=\"info\">\n<p>kind of instruction</p>\n\n</div>\n", ["INSTRUCTION", "KIND"]);
add_ocaml_element("fmm", "Std.fmm", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEfmm", "<div class=\"info\">\n<p>floating point value</p>\n\n</div>\n", ["FLOATING", "POINT", "VALUE"]);
add_ocaml_element("imm", "Std.imm", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEimm", "<div class=\"info\">\n<p>opaque immediate value</p>\n\n</div>\n", ["IMMEDIATE", "OPAQUE", "VALUE"]);
add_ocaml_element("reg", "Std.reg", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEreg", "<div class=\"info\">\n<p>abstract and opaque register</p>\n\n</div>\n", ["ABSTRACT", "AND", "OPAQUE", "REGISTER"]);
add_ocaml_element("edge", "Std.edge", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEedge", "<div class=\"info\">\n<p>This type defines a relation between two basic blocks.</p>\n\n</div>\n", ["BASIC", "BETWEEN", "BLOCKS", "DEFINES", "RELATION", "THIS", "TWO", "TYPE"]);
add_ocaml_element("jump", "Std.jump", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEjump", "<div class=\"info\">\n<p>a jump kind.</p>\n\n</div>\n", ["ANOTHER", "BLOCK", "CAN", "CONDITIONAL", "JUMP", "KIND", "UNCONDITIONAL"]);
add_ocaml_element("cfg", "Std.cfg", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEcfg", "", []);
add_ocaml_element("block", "Std.block", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEblock", "<div class=\"info\">\n<p><code class=\"code\">block</code> is a region of memory that is believed to be a basic block\n      of control flow graph to the best of our knowledge.</p>\n\n</div>\n", ["BASIC", "BELIEVED", "BEST", "BLOCK", "CONTROL", "FLOW", "GRAPH", "KNOWLEDGE", "MEMORY", "OUR", "REGION", "THAT", "THE"]);
add_ocaml_element("insn", "Std.insn", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEinsn", "<div class=\"info\">\n<p>values of type <code class=\"code\">insn</code> represents machine instructions decoded\n      from the a given piece of memory</p>\n\n</div>\n", ["DECODED", "FROM", "GIVEN", "INSN", "INSTRUCTIONS", "MACHINE", "MEMORY", "PIECE", "REPRESENTS", "THE", "TYPE", "VALUES"]);
add_ocaml_element("disasm", "Std.disasm", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEdisasm", "<div class=\"info\">\n<p>value of type <code class=\"code\">disasm</code> is a result of the disassembling of a\n      memory region.</p>\n\n</div>\n", ["DISASM", "DISASSEMBLING", "MEMORY", "REGION", "RESULT", "THE", "TYPE", "VALUE"]);
add_ocaml_element("reconstructor", "Std.reconstructor", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEreconstructor", "<div class=\"info\">\n<p>Reconstructor  defines a method for reconstructing symbol tables</p>\n\n</div>\n", ["DEFINES", "FOR", "METHOD", "RECONSTRUCTING", "RECONSTRUCTOR", "SYMBOL", "TABLES"]);
add_ocaml_element("brancher", "Std.brancher", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEbrancher", "<div class=\"info\">\n<p>Brancher defines a method for resolving branch instruction</p>\n\n</div>\n", ["BRANCH", "BRANCHER", "DEFINES", "FOR", "INSTRUCTION", "METHOD", "RESOLVING"]);
add_ocaml_element("rooter", "Std.rooter", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPErooter", "<div class=\"info\">\n<p>Rooter defines a method for finding function starts in a program</p>\n\n</div>\n", ["DEFINES", "FINDING", "FOR", "FUNCTION", "METHOD", "PROGRAM", "ROOTER", "STARTS"]);
add_ocaml_element("symbolizer", "Std.symbolizer", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEsymbolizer", "<div class=\"info\">\n<p>Symbolizer defines a method for assigning symbolic names to addresses</p>\n\n</div>\n", ["ADDRESSES", "ASSIGNING", "DEFINES", "FOR", "METHOD", "NAMES", "SYMBOLIC", "SYMBOLIZER"]);
add_ocaml_element("location", "Std.location", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPElocation", "<div class=\"info\">\n<p>memory location</p>\n\n</div>\n", ["LOCATION", "MEMORY"]);
add_ocaml_element("memmap", "Std.memmap", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEmemmap", "<div class=\"info\">\n<p>interval trees from memory regions to <code class=\"code\"><span class=\"keywordsign\">'</span>a</code></p>\n\n</div>\n", ["FROM", "INTERVAL", "MEMORY", "REGIONS", "TREES"]);
add_ocaml_element("table", "Std.table", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEtable", "<div class=\"info\">\n<p>a table from memory to <code class=\"code\"><span class=\"keywordsign\">'</span>a</code></p>\n\n</div>\n", ["FROM", "MEMORY", "TABLE"]);
add_ocaml_element("mem", "Std.mem", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEmem", "<div class=\"info\">\n<p>opaque memory</p>\n\n</div>\n", ["MEMORY", "OPAQUE"]);
add_ocaml_element("image", "Std.image", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEimage", "<div class=\"info\">\n<p>an image loaded into memory</p>\n\n</div>\n", ["IMAGE", "INTO", "LOADED", "MEMORY"]);
add_ocaml_element("color", "Std.color", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEcolor", "", []);
add_ocaml_element("cls", "Std.cls", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEcls", "", []);
add_ocaml_element("intent", "Std.intent", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEintent", "<div class=\"info\">\n<p>argument intention</p>\n\n</div>\n", ["ARGUMENT", "INTENTION"]);
add_ocaml_element("jmp_kind", "Std.jmp_kind", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEjmp_kind", "<div class=\"info\">\n<p>control transfer variants</p>\n\n</div>\n", ["CONTROL", "TRANSFER", "VARIANTS"]);
add_ocaml_element("label", "Std.label", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPElabel", "<div class=\"info\">\n<p>target of control transfer</p>\n\n</div>\n", ["CONTROL", "TARGET", "TRANSFER"]);
add_ocaml_element("call", "Std.call", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEcall", "", []);
add_ocaml_element("tid", "Std.tid", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEtid", "", []);
add_ocaml_element("nil", "Std.nil", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEnil", "", []);
add_ocaml_element("jmp", "Std.jmp", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEjmp", "", []);
add_ocaml_element("def", "Std.def", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEdef", "", []);
add_ocaml_element("phi", "Std.phi", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEphi", "", []);
add_ocaml_element("blk", "Std.blk", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEblk", "", []);
add_ocaml_element("arg", "Std.arg", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEarg", "", []);
add_ocaml_element("sub", "Std.sub", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEsub", "", []);
add_ocaml_element("program", "Std.program", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEprogram", "", []);
add_ocaml_element("term", "Std.term", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEterm", "<div class=\"info\">\n<p>BAP IR.</p>\n\n</div>\n", ["BAP", "PROGRAM", "TERMS", "TREE"]);
add_ocaml_element("vector", "Std.vector", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEvector", "<div class=\"info\">\n<p><a href=\"Bap.Std.Vector.html\">Resizable array</a></p>\n\n</div>\n", ["ARRAY", "RESIZABLE"]);
add_ocaml_element("tag", "Std.tag", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEtag", "", []);
add_ocaml_element("arch", "Std.arch", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEarch", "<div class=\"info\">\n<p>architecture</p>\n\n</div>\n", ["ARCHITECTURE"]);
add_ocaml_element("type_error", "Std.type_error", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEtype_error", "<div class=\"info\">\n<p>A BIL type error</p>\n\n</div>\n", ["BIL", "ERROR", "TYPE"]);
add_ocaml_element("unop", "Std.unop", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEunop", "", []);
add_ocaml_element("stmt", "Std.stmt", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEstmt", "", []);
add_ocaml_element("exp", "Std.exp", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEexp", "", []);
add_ocaml_element("cast", "Std.cast", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEcast", "", []);
add_ocaml_element("binop", "Std.binop", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEbinop", "", []);
add_ocaml_element("bil", "Std.bil", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEbil", "", []);
add_ocaml_element("var", "Std.var", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEvar", "", []);
add_ocaml_element("typ", "Std.typ", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEtyp", "", []);
add_ocaml_element("endian", "Std.endian", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEendian", "<div class=\"info\">\n<p>Expose <code class=\"code\">endian</code> constructors to <code class=\"code\"><span class=\"constructor\">Bap</span>.<span class=\"constructor\">Std</span></code> namespace</p>\n\n</div>\n", ["BAP", "CONSTRUCTORS", "ENDIAN", "EXPOSE", "NAMESPACE", "STD"]);
add_ocaml_element("addr_size", "Std.addr_size", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEaddr_size", "<div class=\"info\">\n<p>size of address</p>\n\n</div>\n", ["ADDRESS", "SIZE"]);
add_ocaml_element("size", "Std.size", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEsize", "<div class=\"info\">\n<p>size of operand</p>\n\n</div>\n", ["OPERAND", "SIZE"]);
add_ocaml_element("addr", "Std.addr", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEaddr", "<div class=\"info\">\n<p>A synonym for <code class=\"code\">word</code>, that should be used for words\n      that are addresses</p>\n\n</div>\n", ["ADDRESSES", "ARE", "FOR", "SHOULD", "SYNONYM", "THAT", "USED", "WORD", "WORDS"]);
add_ocaml_element("word", "Std.word", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEword", "<div class=\"info\">\n<p>Type to represent machine word</p>\n\n</div>\n", ["MACHINE", "REPRESENT", "TYPE", "WORD"]);
add_ocaml_element("dict", "Std.dict", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEdict", "", []);
add_ocaml_element("value", "Std.value", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEvalue", "", []);
add_ocaml_element("seq", "Std.seq", "type", "<i>(... type ...)</i>", "Bap.Std.html#TYPEseq", "", []);
add_ocaml_element("user", "user", "field", "string", "Bap_traces.Std.Trace_stats.html#TYPEt", "<div class=\"info\">\n<p>Name of a trace creator</p>\n\n</div>\n", ["CREATOR", "NAME", "TRACE"]);
add_ocaml_element("host", "host", "field", "string", "Bap_traces.Std.Trace_stats.html#TYPEt", "<div class=\"info\">\n<p>A host where trace was created</p>\n\n</div>\n", ["CREATED", "HOST", "TRACE", "WAS", "WHERE"]);
add_ocaml_element("time", "time", "field", "float", "Bap_traces.Std.Trace_stats.html#TYPEt", "<div class=\"info\">\n<p>Time when tracing started</p>\n\n</div>\n", ["STARTED", "TIME", "TRACING", "WHEN"]);
add_ocaml_element("size", "size", "field", "int", "Bap_traces.Std.File_stats.html#TYPEt", "<div class=\"info\">\n<p>size of a file</p>\n\n</div>\n", ["FILE", "SIZE"]);
add_ocaml_element("atime", "atime", "field", "float", "Bap_traces.Std.File_stats.html#TYPEt", "<div class=\"info\">\n<p>last access time</p>\n\n</div>\n", ["ACCESS", "LAST", "TIME"]);
add_ocaml_element("mtime", "mtime", "field", "float", "Bap_traces.Std.File_stats.html#TYPEt", "<div class=\"info\">\n<p>last modification time</p>\n\n</div>\n", ["LAST", "MODIFICATION", "TIME"]);
add_ocaml_element("ctime", "ctime", "field", "float", "Bap_traces.Std.File_stats.html#TYPEt", "<div class=\"info\">\n<p>the creation time</p>\n\n</div>\n", ["CREATION", "THE", "TIME"]);
add_ocaml_element("path", "path", "field", "string", "Bap_traces.Std.Binary.html#TYPEt", "<div class=\"info\">\n<p>a path to the binary</p>\n\n</div>\n", ["BINARY", "PATH", "THE"]);
add_ocaml_element("args", "args", "field", "string array", "Bap_traces.Std.Binary.html#TYPEt", "<div class=\"info\">\n<p>arguments passed to the binary</p>\n\n</div>\n", ["ARGUMENTS", "BINARY", "PASSED", "THE"]);
add_ocaml_element("envp", "envp", "field", "string array", "Bap_traces.Std.Binary.html#TYPEt", "<div class=\"info\">\n<p>environment variables</p>\n\n</div>\n", ["ENVIRONMENT", "VARIABLES"]);
add_ocaml_element("md5sum", "md5sum", "field", "string", "Bap_traces.Std.Binary.html#TYPEt", "<div class=\"info\">\n<p>digest of the binary contents</p>\n\n</div>\n", ["BINARY", "CONTENTS", "DIGEST", "THE"]);
add_ocaml_element("name", "name", "field", "string", "Bap_traces.Std.Tracer.html#TYPEt", "<div class=\"info\">\n<p>name of a tool</p>\n\n</div>\n", ["NAME", "TOOL"]);
add_ocaml_element("args", "args", "field", "string array", "Bap_traces.Std.Tracer.html#TYPEt", "<div class=\"info\">\n<p>the tool arguments</p>\n\n</div>\n", ["ARGUMENTS", "THE", "TOOL"]);
add_ocaml_element("envp", "envp", "field", "string array", "Bap_traces.Std.Tracer.html#TYPEt", "<div class=\"info\">\n<p>environment variables</p>\n\n</div>\n", ["ENVIRONMENT", "VARIABLES"]);
add_ocaml_element("version", "version", "field", "string", "Bap_traces.Std.Tracer.html#TYPEt", "<div class=\"info\">\n<p>tool version</p>\n\n</div>\n", ["TOOL", "VERSION"]);
add_ocaml_element("name", "name", "field", "string", "Bap_traces.Std.Modload.html#TYPEt", "<div class=\"info\">\n<p>a name of linked module</p>\n\n</div>\n", ["LINKED", "MODULE", "NAME"]);
add_ocaml_element("low", "low", "field", "Std.addr", "Bap_traces.Std.Modload.html#TYPEt", "<div class=\"info\">\n<p>the lowest mapped address</p>\n\n</div>\n", ["ADDRESS", "LOWEST", "MAPPED", "THE"]);
add_ocaml_element("high", "high", "field", "Std.addr", "Bap_traces.Std.Modload.html#TYPEt", "<div class=\"info\">\n<p>the hightest mapped address</p>\n\n</div>\n", ["ADDRESS", "HIGHTEST", "MAPPED", "THE"]);
add_ocaml_element("caller", "caller", "field", "string", "Bap_traces.Std.Return.html#TYPEt", "<div class=\"info\">\n<p>caller name</p>\n\n</div>\n", ["CALLER", "NAME"]);
add_ocaml_element("callee", "callee", "field", "string", "Bap_traces.Std.Return.html#TYPEt", "<div class=\"info\">\n<p>calee name</p>\n\n</div>\n", ["CALEE", "NAME"]);
add_ocaml_element("caller", "caller", "field", "Bap_traces.Std.location", "Bap_traces.Std.Call.html#TYPEt", "<div class=\"info\">\n<p>location of a caller</p>\n\n</div>\n", ["CALLER", "LOCATION"]);
add_ocaml_element("callee", "callee", "field", "Bap_traces.Std.location", "Bap_traces.Std.Call.html#TYPEt", "<div class=\"info\">\n<p>location of a calee</p>\n\n</div>\n", ["CALEE", "LOCATION"]);
add_ocaml_element("args", "args", "field", "Std.word array", "Bap_traces.Std.Call.html#TYPEt", "<div class=\"info\">\n<p>call arguments</p>\n\n</div>\n", ["ARGUMENTS", "CALL"]);
add_ocaml_element("name", "name", "field", "string option", "Bap_traces.Std.Location.html#TYPEt", "<div class=\"info\">\n<p>a symbolic name</p>\n\n</div>\n", ["NAME", "SYMBOLIC"]);
add_ocaml_element("addr", "addr", "field", "Std.addr", "Bap_traces.Std.Location.html#TYPEt", "<div class=\"info\">\n<p>a virtual address</p>\n\n</div>\n", ["ADDRESS", "VIRTUAL"]);
add_ocaml_element("number", "number", "field", "int", "Bap_traces.Std.Exn.html#TYPEt", "<div class=\"info\">\n<p>an exception number</p>\n\n</div>\n", ["EXCEPTION", "NUMBER"]);
add_ocaml_element("src", "src", "field", "Std.addr option", "Bap_traces.Std.Exn.html#TYPEt", "<div class=\"info\">\n<p>a source address</p>\n\n</div>\n", ["ADDRESS", "SOURCE"]);
add_ocaml_element("dst", "dst", "field", "Std.addr option", "Bap_traces.Std.Exn.html#TYPEt", "<div class=\"info\">\n<p>a destination address</p>\n\n</div>\n", ["ADDRESS", "DESTINATION"]);
add_ocaml_element("number", "number", "field", "int", "Bap_traces.Std.Syscall.html#TYPEt", "<div class=\"info\">\n<p>system call number</p>\n\n</div>\n", ["CALL", "NUMBER", "SYSTEM"]);
add_ocaml_element("args", "args", "field", "Std.word array", "Bap_traces.Std.Syscall.html#TYPEt", "<div class=\"info\">\n<p>arguments passed to a system call</p>\n\n</div>\n", ["ARGUMENTS", "CALL", "PASSED", "SYSTEM"]);
add_ocaml_element("addr", "addr", "field", "Std.addr", "Bap_traces.Std.Chunk.html#TYPEt", "<div class=\"info\">\n<p>an address of the first byte</p>\n\n</div>\n", ["ADDRESS", "BYTE", "FIRST", "THE"]);
add_ocaml_element("data", "data", "field", "string", "Bap_traces.Std.Chunk.html#TYPEt", "<div class=\"info\">\n<p>the bytes</p>\n\n</div>\n", ["BYTES", "THE"]);
add_ocaml_element("cell", "cell", "field", "'a", "Bap_traces.Std.Move.html#TYPEt", "<div class=\"info\">\n<p>source or destination</p>\n\n</div>\n", ["DESTINATION", "SOURCE"]);
add_ocaml_element("data", "data", "field", "Std.word", "Bap_traces.Std.Move.html#TYPEt", "<div class=\"info\">\n<p>moved data</p>\n\n</div>\n", ["DATA", "MOVED"]);
add_ocaml_element("tool", "tool", "field", "Bap_traces.Std.Trace.tool", "Bap_traces.Std.Trace.Reader.html#TYPEt", "<div class=\"info\">\n<p>a tool descriptor read from trace</p>\n\n</div>\n", ["DESCRIPTOR", "FROM", "READ", "TOOL", "TRACE"]);
add_ocaml_element("meta", "meta", "field", "Std.dict", "Bap_traces.Std.Trace.Reader.html#TYPEt", "<div class=\"info\">\n<p>meta information read from trace</p>\n\n</div>\n", ["FROM", "INFORMATION", "META", "READ", "TRACE"]);
add_ocaml_element("next", "next", "field", "unit -> Bap_traces.Std.Trace.event Or_error.t option", "Bap_traces.Std.Trace.Reader.html#TYPEt", "<div class=\"info\">\n<p>a stream function</p>\n\n</div>\n", ["FUNCTION", "STREAM"]);
add_ocaml_element("exec", "exec", "field", "'a0. 'a0 Bap_ida.Std.command -> 'a0", "Bap_ida.Std.Service.html#TYPEt", "", []);
add_ocaml_element("close", "close", "field", "unit -> unit", "Bap_ida.Std.Service.html#TYPEt", "", []);
add_ocaml_element("Addr", "Addr", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("String", "String", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Block", "Block", "constructor", "Bap_dwarf.Std.Dwarf.lenspec", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Const", "Const", "constructor", "Bap_dwarf.Std.Dwarf.lenspec", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Flag_present", "Flag_present", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Strp", "Strp", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Ref", "Ref", "constructor", "Bap_dwarf.Std.Dwarf.lenspec", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Indirect", "Indirect", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Offset", "Offset", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Expr", "Expr", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Sig", "Sig", "constructor", "", "Bap_dwarf.Std.Dwarf.Form.html#TYPEt", "", []);
add_ocaml_element("Name", "Name", "constructor", "", "Bap_dwarf.Std.Dwarf.Attr.html#TYPEt", "", []);
add_ocaml_element("Low_pc", "Low_pc", "constructor", "", "Bap_dwarf.Std.Dwarf.Attr.html#TYPEt", "", []);
add_ocaml_element("High_pc", "High_pc", "constructor", "", "Bap_dwarf.Std.Dwarf.Attr.html#TYPEt", "", []);
add_ocaml_element("Entry_pc", "Entry_pc", "constructor", "", "Bap_dwarf.Std.Dwarf.Attr.html#TYPEt", "", []);
add_ocaml_element("Unknown", "Unknown", "constructor", "int", "Bap_dwarf.Std.Dwarf.Attr.html#TYPEt", "", []);
add_ocaml_element("Compile_unit", "Compile_unit", "constructor", "", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("Partial_unit", "Partial_unit", "constructor", "", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("Subprogram", "Subprogram", "constructor", "", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("Entry_point", "Entry_point", "constructor", "", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("Inlined_subroutine", "Inlined_subroutine", "constructor", "", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("Unknown", "Unknown", "constructor", "int", "Bap_dwarf.Std.Dwarf.Tag.html#TYPEt", "", []);
add_ocaml_element("Info", "Info", "constructor", "", "Bap_dwarf.Std.Dwarf.Section.html#TYPEt", "", []);
add_ocaml_element("Abbrev", "Abbrev", "constructor", "", "Bap_dwarf.Std.Dwarf.Section.html#TYPEt", "", []);
add_ocaml_element("Str", "Str", "constructor", "", "Bap_dwarf.Std.Dwarf.Section.html#TYPEt", "", []);
add_ocaml_element("Leb128", "Leb128", "constructor", "", "Bap_dwarf.Std.Dwarf.html#TYPElenspec", "", []);
add_ocaml_element("One", "One", "constructor", "", "Bap_dwarf.Std.Dwarf.html#TYPElenspec", "", []);
add_ocaml_element("Two", "Two", "constructor", "", "Bap_dwarf.Std.Dwarf.html#TYPElenspec", "", []);
add_ocaml_element("Four", "Four", "constructor", "", "Bap_dwarf.Std.Dwarf.html#TYPElenspec", "", []);
add_ocaml_element("Eight", "Eight", "constructor", "", "Bap_dwarf.Std.Dwarf.html#TYPElenspec", "", []);
add_ocaml_element("insert_args", "insert_args", "field", "Std.sub Std.term ->\n  Bap_c_type.attr list -> Bap_c_type.proto -> Bap_c_abi.args option", "Bap_c_abi.html#TYPEt", "", []);
add_ocaml_element("apply_attrs", "apply_attrs", "field", "Bap_c_type.attr list -> Std.sub Std.term -> Std.sub Std.term", "Bap_c_abi.html#TYPEt", "", []);
add_ocaml_element("return", "return", "field", "Bap_c_abi.param option", "Bap_c_abi.html#TYPEargs", "", []);
add_ocaml_element("hidden", "hidden", "field", "(Bap_c_type.t * Bap_c_abi.param) list", "Bap_c_abi.html#TYPEargs", "", []);
add_ocaml_element("params", "params", "field", "Bap_c_abi.param list", "Bap_c_abi.html#TYPEargs", "", []);
add_ocaml_element("Imm", "Imm", "constructor", "Std.Size.t * Bap_c_data.value", "Bap_c_data.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Imm</span>&nbsp;(size,value)</code></p>\n\n</div>\n", ["IMM", "SIZE", "VALUE"]);
add_ocaml_element("Seq", "Seq", "constructor", "Bap_c_data.t list", "Bap_c_data.html#TYPEt", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Seq</span>&nbsp;(t1,..,tN)</code></p>\n\n</div>\n", ["SEQ"]);
add_ocaml_element("Ptr", "Ptr", "constructor", "Bap_c_data.t", "Bap_c_data.html#TYPEt", "", []);
add_ocaml_element("Top", "Top", "constructor", "", "Bap_c_data.html#TYPEvalue", "<div class=\"info\">\n<p>any possible value</p>\n\n</div>\n", ["ANY", "POSSIBLE", "VALUE"]);
add_ocaml_element("Set", "Set", "constructor", "Std.word list", "Bap_c_data.html#TYPEvalue", "", []);
add_ocaml_element("element", "element", "field", "'a0", "Bap_c_type.Array.html#TYPEt", "", []);
add_ocaml_element("size", "size", "field", "Int.t option", "Bap_c_type.Array.html#TYPEt", "", []);
add_ocaml_element("name", "name", "field", "string", "Bap_c_type.Compound.html#TYPEt", "", []);
add_ocaml_element("fields", "fields", "field", "(string * 'a1) list", "Bap_c_type.Compound.html#TYPEt", "", []);
add_ocaml_element("return", "return", "field", "'a2", "Bap_c_type.Proto.html#TYPEt", "", []);
add_ocaml_element("args", "args", "field", "(string * 'a2) list", "Bap_c_type.Proto.html#TYPEt", "", []);
add_ocaml_element("variadic", "variadic", "field", "Bool.t", "Bap_c_type.Proto.html#TYPEt", "", []);
add_ocaml_element("qualifier", "qualifier", "field", "'a3", "Bap_c_type.Spec.html#TYPEt", "", []);
add_ocaml_element("t", "t", "field", "'b", "Bap_c_type.Spec.html#TYPEt", "", []);
add_ocaml_element("attrs", "attrs", "field", "Bap_c_type.attr sexp_list", "Bap_c_type.Spec.html#TYPEt", "", []);
add_ocaml_element("name", "name", "field", "string", "Bap_c_type.Attr.html#TYPEt", "", []);
add_ocaml_element("args", "args", "field", "string sexp_list", "Bap_c_type.Attr.html#TYPEt", "", []);
add_ocaml_element("const", "const", "field", "Bool.t", "Bap_c_type.Qualifier.html#TYPEt", "", []);
add_ocaml_element("volatile", "volatile", "field", "Bool.t", "Bap_c_type.Qualifier.html#TYPEt", "", []);
add_ocaml_element("restrict", "restrict", "field", "'a4", "Bap_c_type.Qualifier.html#TYPEt", "", []);
add_ocaml_element("out", "out", "field", "X86_types.Pcmpstr.out", "X86_types.Pcmpstr.html#TYPEpcmpinfo", "", []);
add_ocaml_element("len", "len", "field", "X86_types.Pcmpstr.len", "X86_types.Pcmpstr.html#TYPEpcmpinfo", "", []);
add_ocaml_element("Implicit", "Implicit", "constructor", "", "X86_types.Pcmpstr.html#TYPElen", "", []);
add_ocaml_element("Explicit", "Explicit", "constructor", "", "X86_types.Pcmpstr.html#TYPElen", "", []);
add_ocaml_element("Index", "Index", "constructor", "", "X86_types.Pcmpstr.html#TYPEout", "", []);
add_ocaml_element("Mask", "Mask", "constructor", "", "X86_types.Pcmpstr.html#TYPEout", "", []);
add_ocaml_element("ssize", "ssize", "field", "X86_types.Pcmpstr.ssize", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("ssign", "ssign", "field", "X86_types.Pcmpstr.ssign", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("agg", "agg", "field", "X86_types.Pcmpstr.agg", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("negintres1", "negintres1", "field", "bool", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("maskintres1", "maskintres1", "field", "bool", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("outselectsig", "outselectsig", "field", "X86_types.Pcmpstr.outselectsig", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("outselectmask", "outselectmask", "field", "X86_types.Pcmpstr.outselectmask", "X86_types.Pcmpstr.html#TYPEimm8cb", "", []);
add_ocaml_element("Bitmask", "Bitmask", "constructor", "", "X86_types.Pcmpstr.html#TYPEoutselectmask", "", []);
add_ocaml_element("Bytemask", "Bytemask", "constructor", "", "X86_types.Pcmpstr.html#TYPEoutselectmask", "", []);
add_ocaml_element("LSB", "LSB", "constructor", "", "X86_types.Pcmpstr.html#TYPEoutselectsig", "", []);
add_ocaml_element("MSB", "MSB", "constructor", "", "X86_types.Pcmpstr.html#TYPEoutselectsig", "", []);
add_ocaml_element("EqualAny", "EqualAny", "constructor", "", "X86_types.Pcmpstr.html#TYPEagg", "", []);
add_ocaml_element("Ranges", "Ranges", "constructor", "", "X86_types.Pcmpstr.html#TYPEagg", "", []);
add_ocaml_element("EqualEach", "EqualEach", "constructor", "", "X86_types.Pcmpstr.html#TYPEagg", "", []);
add_ocaml_element("EqualOrdered", "EqualOrdered", "constructor", "", "X86_types.Pcmpstr.html#TYPEagg", "", []);
add_ocaml_element("Signed", "Signed", "constructor", "", "X86_types.Pcmpstr.html#TYPEssign", "", []);
add_ocaml_element("Unsigned", "Unsigned", "constructor", "", "X86_types.Pcmpstr.html#TYPEssign", "", []);
add_ocaml_element("Bytes", "Bytes", "constructor", "", "X86_types.Pcmpstr.html#TYPEssize", "", []);
add_ocaml_element("Words", "Words", "constructor", "", "X86_types.Pcmpstr.html#TYPEssize", "", []);
add_ocaml_element("addrsize", "addrsize", "field", "Std.typ", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("opsize", "opsize", "field", "Std.typ", "X86_types.html#TYPEprefix", "<div class=\"info\">\n<p>General operand size</p>\n\n</div>\n", ["GENERAL", "OPERAND", "SIZE"]);
add_ocaml_element("bopsize", "bopsize", "field", "Std.typ", "X86_types.html#TYPEprefix", "<div class=\"info\">\n<p>Operand size that defaults to machine size\n                     (e.g.</p>\n\n</div>\n", ["DEFAULTS", "FOR", "MACHINE", "OPERAND", "POP", "SIZE", "THAT"]);
add_ocaml_element("mopsize", "mopsize", "field", "Std.typ", "X86_types.html#TYPEprefix", "<div class=\"info\">\n<p>Multi-scalar operand size</p>\n\n</div>\n", ["MULTI", "OPERAND", "SCALAR", "SIZE"]);
add_ocaml_element("repeat", "repeat", "field", "bool", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("nrepeat", "nrepeat", "field", "bool", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("addrsize_override", "addrsize_override", "field", "bool", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("opsize_override", "opsize_override", "field", "bool", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("rex", "rex", "field", "X86_types.rex option", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("vex", "vex", "field", "X86_types.vex option", "X86_types.html#TYPEprefix", "", []);
add_ocaml_element("r_extend", "r_extend", "field", "int", "X86_types.html#TYPEprefix", "<div class=\"info\">\n<p>extended r bit</p>\n\n</div>\n", ["BIT", "EXTENDED"]);
add_ocaml_element("rm_extend", "rm_extend", "field", "int", "X86_types.html#TYPEprefix", "<div class=\"info\">\n<p>extended rm bit or sib base</p>\n\n</div>\n", ["BASE", "BIT", "EXTENDED", "SIB"]);
add_ocaml_element("sib_extend", "sib_extend", "field", "int", "X86_types.html#TYPEprefix", "<div class=\"info\">\n<p>extended sib index bit</p>\n\n</div>\n", ["BIT", "EXTENDED", "INDEX", "SIB"]);
add_ocaml_element("vex_nr", "vex_nr", "field", "bool", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>inverted rex_r bit</p>\n\n</div>\n", ["BIT", "INVERTED", "REX_R"]);
add_ocaml_element("vex_nx", "vex_nx", "field", "bool", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>inverted rex_x bit</p>\n\n</div>\n", ["BIT", "INVERTED", "REX_X"]);
add_ocaml_element("vex_nb", "vex_nb", "field", "bool", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>inverted rex_b bit</p>\n\n</div>\n", ["BIT", "INVERTED", "REX_B"]);
add_ocaml_element("vex_map_select", "vex_map_select", "field", "int", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>Specifies the opcode map to use</p>\n\n</div>\n", ["MAP", "OPCODE", "SPECIFIES", "THE", "USE"]);
add_ocaml_element("vex_we", "vex_we", "field", "bool", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>For int instructions, equivalent to rex.w.</p>\n\n</div>\n", ["BIT", "EQUIVALENT", "EXTENSION", "FOR", "INSTRUCTIONS", "INT", "NON", "OPCODE", "REX"]);
add_ocaml_element("vex_v", "vex_v", "field", "int", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>additional instruction operand (XMM or YMM register)</p>\n\n</div>\n", ["ADDITIONAL", "INSTRUCTION", "OPERAND", "REGISTER", "XMM", "YMM"]);
add_ocaml_element("vex_l", "vex_l", "field", "bool", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>0 = 128-bit operands (xmm), 1 = 256-bit vector operands (ymm)</p>\n\n</div>\n", ["128", "256", "BIT", "OPERANDS", "VECTOR", "XMM", "YMM"]);
add_ocaml_element("vex_pp", "vex_pp", "field", "int", "X86_types.html#TYPEvex", "<div class=\"info\">\n<p>Specifies mandatory prefix (0=none, 1=pref_opsize 2=repz 3=repnz)</p>\n\n</div>\n", ["MANDATORY", "NONE", "PREFIX", "PREF_OPSIZE", "REPNZ", "REPZ", "SPECIFIES"]);
add_ocaml_element("rex_w", "rex_w", "field", "bool", "X86_types.html#TYPErex", "<div class=\"info\">\n<p>Bit 3: 1 = 64-bit operand size</p>\n\n</div>\n", ["BIT", "OPERAND", "SIZE"]);
add_ocaml_element("rex_r", "rex_r", "field", "bool", "X86_types.html#TYPErex", "<div class=\"info\">\n<p>Bit 2: Extension of ModR/M reg field</p>\n\n</div>\n", ["BIT", "EXTENSION", "FIELD", "MODR", "REG"]);
add_ocaml_element("rex_x", "rex_x", "field", "bool", "X86_types.html#TYPErex", "<div class=\"info\">\n<p>Bit 1: Extension of SIB index field</p>\n\n</div>\n", ["BIT", "EXTENSION", "FIELD", "INDEX", "SIB"]);
add_ocaml_element("rex_b", "rex_b", "field", "bool", "X86_types.html#TYPErex", "<div class=\"info\">\n<p>Bit 0: Extension of ModR/M r/m field, SIB base\n                   field, or opcode reg field</p>\n\n</div>\n", ["BASE", "BIT", "EXTENSION", "FIELD", "MODR", "OPCODE", "REG", "SIB"]);
add_ocaml_element("Bswap", "Bswap", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Retn", "Retn", "constructor", "(Std.typ * X86_types.operand) option * bool", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>bytes to release, far/near ret</p>\n\n</div>\n", ["BYTES", "FAR", "NEAR", "RELEASE", "RET"]);
add_ocaml_element("Nop", "Nop", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Mov", "Mov", "constructor", "Std.typ * X86_types.operand * X86_types.operand * Std.Exp.t option", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>dst, src, condition</p>\n\n</div>\n", ["CONDITION", "DST", "SRC"]);
add_ocaml_element("Movs", "Movs", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Movzx", "Movzx", "constructor", "Std.typ * X86_types.operand * Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>dsttyp, dst, srctyp, src</p>\n\n</div>\n", ["DST", "DSTTYP", "SRC", "SRCTYP"]);
add_ocaml_element("Movsx", "Movsx", "constructor", "Std.typ * X86_types.operand * Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>dsttyp, dst, srctyp, src</p>\n\n</div>\n", ["DST", "DSTTYP", "SRC", "SRCTYP"]);
add_ocaml_element("Movdq", "Movdq", "constructor", "Std.typ * X86_types.operand * Std.typ * X86_types.operand * bool", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>dst type, dst op, src type, src op, aligned</p>\n\n</div>\n", ["ALIGNED", "DST", "SRC", "TYPE"]);
add_ocaml_element("Movoffset", "Movoffset", "constructor", "Std.typ * X86_types.operand * X86_types.offsetinfo list", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>dest type, dest, (src copy length, src type, src, src src offset, src dest offset)*</p>\n\n</div>\n", ["COPY", "DEST", "LENGTH", "OFFSET", "SRC", "TYPE"]);
add_ocaml_element("Lea", "Lea", "constructor", "Std.typ * X86_types.operand * Std.Exp.t", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Call", "Call", "constructor", "X86_types.operand * Std.addr", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>addr is RA</p>\n\n</div>\n", ["ADDR"]);
add_ocaml_element("Shift", "Shift", "constructor", "Std.binop * Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Shiftd", "Shiftd", "constructor", "Std.binop * Std.typ * X86_types.operand * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Rotate", "Rotate", "constructor", "Std.binop * Std.typ * X86_types.operand * X86_types.operand * bool", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>left or right, type, src/dest op, shift op, use carry flag</p>\n\n</div>\n", ["CARRY", "DEST", "FLAG", "LEFT", "RIGHT", "SHIFT", "SRC", "TYPE", "USE"]);
add_ocaml_element("Bt", "Bt", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Bs", "Bs", "constructor", "Std.typ * X86_types.operand * X86_types.operand * X86_types.direction", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Jump", "Jump", "constructor", "X86_types.jumptarget", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Jcc", "Jcc", "constructor", "X86_types.jumptarget * Std.Exp.t", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Setcc", "Setcc", "constructor", "Std.typ * X86_types.operand * Std.Exp.t", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Hlt", "Hlt", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Cmps", "Cmps", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Scas", "Scas", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Stos", "Stos", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Push", "Push", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pop", "Pop", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pushf", "Pushf", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Popf", "Popf", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Popcnt", "Popcnt", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>size, src, dest</p>\n\n</div>\n", ["DEST", "SIZE", "SRC"]);
add_ocaml_element("Sahf", "Sahf", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Lahf", "Lahf", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Add", "Add", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Adc", "Adc", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Inc", "Inc", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Dec", "Dec", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Sub", "Sub", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Sbb", "Sbb", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Cmp", "Cmp", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Cmpxchg", "Cmpxchg", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Cmpxchg8b", "Cmpxchg8b", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Xadd", "Xadd", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Xchg", "Xchg", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("And", "And", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Or", "Or", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Xor", "Xor", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Test", "Test", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Ptest", "Ptest", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Not", "Not", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Neg", "Neg", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Mul", "Mul", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>typ, src</p>\n\n</div>\n", ["SRC", "TYP"]);
add_ocaml_element("Imul", "Imul", "constructor", "Std.typ * bool * X86_types.operand * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>typ, (true if one operand form, dst operand), src1, src2</p>\n\n</div>\n", ["DST", "FORM", "ONE", "OPERAND", "SRC1", "SRC2", "TRUE", "TYP"]);
add_ocaml_element("Div", "Div", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>typ, src</p>\n\n</div>\n", ["SRC", "TYP"]);
add_ocaml_element("Idiv", "Idiv", "constructor", "Std.typ * X86_types.operand", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>typ, src</p>\n\n</div>\n", ["SRC", "TYP"]);
add_ocaml_element("Cld", "Cld", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Rdtsc", "Rdtsc", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Cpuid", "Cpuid", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Xgetbv", "Xgetbv", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Stmxcsr", "Stmxcsr", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Ldmxcsr", "Ldmxcsr", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Fnstcw", "Fnstcw", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Fldcw", "Fldcw", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Fld", "Fld", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Fst", "Fst", "constructor", "X86_types.operand * bool", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Punpck", "Punpck", "constructor", "Std.typ * Std.typ * X86_types.order * X86_types.operand *\n  X86_types.operand * X86_types.operand option", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>dest size, element size, low/high elements, dest, src, optional VEX src</p>\n\n</div>\n", ["DEST", "ELEMENT", "ELEMENTS", "HIGH", "LOW", "OPTIONAL", "SIZE", "SRC", "VEX"]);
add_ocaml_element("Ppackedbinop", "Ppackedbinop", "constructor", "Std.typ * Std.typ * X86_types.binopf * string * X86_types.operand *\n  X86_types.operand * X86_types.operand option", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>Perform a generic packed binary operation.</p>\n\n</div>\n", ["ASSEMBLY", "BINARY", "BINOP", "DEST", "ELEMENT", "GENERIC", "OPERATION", "OPTIONAL", "PACKED", "PERFORM", "SIZE", "SRC", "STRING", "VEX"]);
add_ocaml_element("Pbinop", "Pbinop", "constructor", "Std.typ * X86_types.binopf * string * X86_types.operand *\n  X86_types.operand * X86_types.operand option", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pmov", "Pmov", "constructor", "Std.typ * Std.typ * Std.typ * X86_types.operand *\n  X86_types.operand * X86_types.cast_type * string", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>Packed move.</p>\n\n</div>\n", ["DEST", "ELT", "EXT", "MOVE", "NAME", "PACKED", "SIGNED", "SIZE", "SRC", "ZERO"]);
add_ocaml_element("Pmovmskb", "Pmovmskb", "constructor", "Std.typ * X86_types.operand * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pcmp", "Pcmp", "constructor", "Std.typ * Std.typ * Std.binop * string * X86_types.operand *\n  X86_types.operand * X86_types.operand option", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Palignr", "Palignr", "constructor", "Std.typ * X86_types.operand * X86_types.operand *\n  X86_types.operand option * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pcmpstr", "Pcmpstr", "constructor", "Std.typ * X86_types.operand * X86_types.operand * X86_types.operand *\n  X86_types.Pcmpstr.imm8cb * X86_types.Pcmpstr.pcmpinfo", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pshufb", "Pshufb", "constructor", "Std.typ * X86_types.operand * X86_types.operand * X86_types.operand option", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Pshufd", "Pshufd", "constructor", "Std.typ * X86_types.operand * X86_types.operand * X86_types.operand option * X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Leave", "Leave", "constructor", "Std.typ", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Interrupt", "Interrupt", "constructor", "X86_types.operand", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Interrupt3", "Interrupt3", "constructor", "", "X86_types.html#TYPEopcode", "<div class=\"info\">\n<p>Trap to debugger</p>\n\n</div>\n", ["DEBUGGER", "TRAP"]);
add_ocaml_element("Sysenter", "Sysenter", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("Syscall", "Syscall", "constructor", "", "X86_types.html#TYPEopcode", "", []);
add_ocaml_element("offlen", "offlen", "field", "Std.typ", "X86_types.html#TYPEoffsetinfo", "", []);
add_ocaml_element("offtyp", "offtyp", "field", "Std.typ", "X86_types.html#TYPEoffsetinfo", "", []);
add_ocaml_element("offop", "offop", "field", "X86_types.operand", "X86_types.html#TYPEoffsetinfo", "", []);
add_ocaml_element("offsrcoffset", "offsrcoffset", "field", "int", "X86_types.html#TYPEoffsetinfo", "", []);
add_ocaml_element("offdstoffset", "offdstoffset", "field", "int", "X86_types.html#TYPEoffsetinfo", "", []);
add_ocaml_element("Jabs", "Jabs", "constructor", "X86_types.operand", "X86_types.html#TYPEjumptarget", "", []);
add_ocaml_element("Jrel", "Jrel", "constructor", "Std.addr * Std.addr", "X86_types.html#TYPEjumptarget", "", []);
add_ocaml_element("Oreg", "Oreg", "constructor", "int", "X86_types.html#TYPEoperand", "", []);
add_ocaml_element("Ovec", "Ovec", "constructor", "int", "X86_types.html#TYPEoperand", "", []);
add_ocaml_element("Oseg", "Oseg", "constructor", "int", "X86_types.html#TYPEoperand", "", []);
add_ocaml_element("Oaddr", "Oaddr", "constructor", "Std.Exp.t", "X86_types.html#TYPEoperand", "", []);
add_ocaml_element("Oimm", "Oimm", "constructor", "Std.addr", "X86_types.html#TYPEoperand", "", []);
add_ocaml_element("Forward", "Forward", "constructor", "", "X86_types.html#TYPEdirection", "", []);
add_ocaml_element("Backward", "Backward", "constructor", "", "X86_types.html#TYPEdirection", "", []);
add_ocaml_element("Low", "Low", "constructor", "", "X86_types.html#TYPEorder", "", []);
add_ocaml_element("High", "High", "constructor", "", "X86_types.html#TYPEorder", "", []);
add_ocaml_element("X86", "X86", "constructor", "", "X86_types.html#TYPEmode", "", []);
add_ocaml_element("X8664", "X8664", "constructor", "", "X86_types.html#TYPEmode", "", []);
add_ocaml_element("BB", "BB", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("BT", "BT", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("TB", "TB", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("TT", "TT", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("D", "D", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("DX", "DX", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("WB", "WB", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("WT", "WT", "constructor", "", "Arm_types.html#TYPEsmul_size", "", []);
add_ocaml_element("Update", "Update", "constructor", "", "Arm_types.html#TYPEupdate_m", "", []);
add_ocaml_element("NoUpdate", "NoUpdate", "constructor", "", "Arm_types.html#TYPEupdate_m", "", []);
add_ocaml_element("IA", "IA", "constructor", "", "Arm_types.html#TYPEmode_m", "", []);
add_ocaml_element("IB", "IB", "constructor", "", "Arm_types.html#TYPEmode_m", "", []);
add_ocaml_element("DA", "DA", "constructor", "", "Arm_types.html#TYPEmode_m", "", []);
add_ocaml_element("DB", "DB", "constructor", "", "Arm_types.html#TYPEmode_m", "", []);
add_ocaml_element("B", "B", "constructor", "", "Arm_types.html#TYPEsize", "", []);
add_ocaml_element("H", "H", "constructor", "", "Arm_types.html#TYPEsize", "", []);
add_ocaml_element("W", "W", "constructor", "", "Arm_types.html#TYPEsize", "", []);
add_ocaml_element("D", "D", "constructor", "", "Arm_types.html#TYPEsize", "", []);
add_ocaml_element("Ld", "Ld", "constructor", "", "Arm_types.html#TYPEoperation", "", []);
add_ocaml_element("St", "St", "constructor", "", "Arm_types.html#TYPEoperation", "", []);
add_ocaml_element("Signed", "Signed", "constructor", "", "Arm_types.html#TYPEsign", "", []);
add_ocaml_element("Unsigned", "Unsigned", "constructor", "", "Arm_types.html#TYPEsign", "", []);
add_ocaml_element("Offset", "Offset", "constructor", "", "Arm_types.html#TYPEmode_r", "", []);
add_ocaml_element("PreIndex", "PreIndex", "constructor", "", "Arm_types.html#TYPEmode_r", "", []);
add_ocaml_element("PostIndex", "PostIndex", "constructor", "", "Arm_types.html#TYPEmode_r", "", []);
add_ocaml_element("Top", "Top", "constructor", "Std.Primus.Pos.level3", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a program</p>\n\n</div>\n", ["PROGRAM"]);
add_ocaml_element("Sub", "Sub", "constructor", "Std.Primus.Pos.level2", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a subroutine</p>\n\n</div>\n", ["SUBROUTINE"]);
add_ocaml_element("Arg", "Arg", "constructor", "Std.arg Std.Primus.Pos.level1", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>subroutine argument</p>\n\n</div>\n", ["ARGUMENT", "SUBROUTINE"]);
add_ocaml_element("Blk", "Blk", "constructor", "Std.blk Std.Primus.Pos.level1", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a basic block</p>\n\n</div>\n", ["BASIC", "BLOCK"]);
add_ocaml_element("Phi", "Phi", "constructor", "Std.phi Std.Primus.Pos.level0", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a phi-node</p>\n\n</div>\n", ["NODE", "PHI"]);
add_ocaml_element("Def", "Def", "constructor", "Std.def Std.Primus.Pos.level0", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a definition</p>\n\n</div>\n", ["DEFINITION"]);
add_ocaml_element("Jmp", "Jmp", "constructor", "Std.jmp Std.Primus.Pos.level0", "Bap_primus.Std.Primus.Pos.html#TYPEt", "<div class=\"info\">\n<p>a jump term</p>\n\n</div>\n", ["JUMP", "TERM"]);
add_ocaml_element("me", "me", "field", "'a5 Std.term", "Bap_primus.Std.Primus.Pos.html#TYPElevel", "<div class=\"info\">\n<p><code class=\"code\">me</code> current position</p>\n\n</div>\n", ["CURRENT", "POSITION"]);
add_ocaml_element("up", "up", "field", "'b0", "Bap_primus.Std.Primus.Pos.html#TYPElevel", "<div class=\"info\">\n<p><code class=\"code\">up</code> parent cursor</p>\n\n</div>\n", ["CURSOR", "PARENT"]);
add_ocaml_element("Normal", "Normal", "constructor", "", "Bap_primus.Std.Primus.html#TYPEexit_status", "", []);
add_ocaml_element("Exn", "Exn", "constructor", "Std.Primus.exn", "Bap_primus.Std.Primus.html#TYPEexit_status", "", []);
add_ocaml_element("node", "node", "field", "'n", "Graphlib.Std.html#TYPElabeled", "", []);
add_ocaml_element("node_label", "node_label", "field", "'a6", "Graphlib.Std.html#TYPElabeled", "", []);
add_ocaml_element("Ok", "Ok", "constructor", "'a7", "Monads.Std.Monad.Result.html#TYPEresult", "", []);
add_ocaml_element("Error", "Error", "constructor", "'e", "Monads.Std.Monad.Result.html#TYPEresult", "", []);
add_ocaml_element("create", "create", "field", "'a8.\n    'a8 Std.reader ->\n    'a8 Std.writer -> 'a8 Std.Data.Cache.t", "Regular.Std.Data.Cache.html#TYPEservice", "", []);
add_ocaml_element("name", "name", "field", "string", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>program name</p>\n\n</div>\n", ["NAME", "PROGRAM"]);
add_ocaml_element("version", "version", "field", "string", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>program version</p>\n\n</div>\n", ["PROGRAM", "VERSION"]);
add_ocaml_element("desc", "desc", "field", "string", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>one line description</p>\n\n</div>\n", ["DESCRIPTION", "LINE", "ONE"]);
add_ocaml_element("main", "main", "field", "string", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>entry point</p>\n\n</div>\n", ["ENTRY", "POINT"]);
add_ocaml_element("author", "author", "field", "string", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>program author</p>\n\n</div>\n", ["AUTHOR", "PROGRAM"]);
add_ocaml_element("date", "date", "field", "float", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>last update date</p>\n\n</div>\n", ["DATE", "LAST", "UPDATE"]);
add_ocaml_element("requires", "requires", "field", "string list", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>required libraries</p>\n\n</div>\n", ["LIBRARIES", "REQUIRED"]);
add_ocaml_element("provides", "provides", "field", "string list", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>provided features</p>\n\n</div>\n", ["FEATURES", "PROVIDED"]);
add_ocaml_element("url", "url", "field", "string option", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>project URL</p>\n\n</div>\n", ["PROJECT", "URL"]);
add_ocaml_element("license", "license", "field", "string option", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>project license</p>\n\n</div>\n", ["LICENSE", "PROJECT"]);
add_ocaml_element("copyrights", "copyrights", "field", "string option", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>copyright holders</p>\n\n</div>\n", ["COPYRIGHT", "HOLDERS"]);
add_ocaml_element("tags", "tags", "field", "string list", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>bundle tags</p>\n\n</div>\n", ["BUNDLE", "TAGS"]);
add_ocaml_element("cons", "cons", "field", "string list", "Bap_bundle.Std.Manifest.html#TYPEt", "<div class=\"info\">\n<p>bundle constraints</p>\n\n</div>\n", ["BUNDLE", "CONSTRAINTS"]);
add_ocaml_element("get", "get", "field", "'a8. 'a8 Std.Self.Config.param -> 'a8", "Bap.Std.Self.Config.html#TYPEreader", "", []);
add_ocaml_element("Unsat_dep", "Unsat_dep", "constructor", "Std.Project.pass * string", "Bap.Std.Project.Pass.html#TYPEerror", "", []);
add_ocaml_element("Runtime_error", "Runtime_error", "constructor", "Std.Project.pass * exn", "Bap.Std.Project.Pass.html#TYPEerror", "", []);
add_ocaml_element("level", "level", "field", "Std.Event.Log.level", "Bap.Std.Event.Log.html#TYPEinfo", "", []);
add_ocaml_element("section", "section", "field", "string", "Bap.Std.Event.Log.html#TYPEinfo", "", []);
add_ocaml_element("message", "message", "field", "string", "Bap.Std.Event.Log.html#TYPEinfo", "", []);
add_ocaml_element("Debug", "Debug", "constructor", "", "Bap.Std.Event.Log.html#TYPElevel", "", []);
add_ocaml_element("Info", "Info", "constructor", "", "Bap.Std.Event.Log.html#TYPElevel", "", []);
add_ocaml_element("Warning", "Warning", "constructor", "", "Bap.Std.Event.Log.html#TYPElevel", "", []);
add_ocaml_element("Error", "Error", "constructor", "", "Bap.Std.Event.Log.html#TYPElevel", "", []);
add_ocaml_element("May", "May", "constructor", "", "Bap.Std.Insn.html#TYPEmay", "", []);
add_ocaml_element("Must", "Must", "constructor", "", "Bap.Std.Insn.html#TYPEmust", "", []);
add_ocaml_element("Reg", "Reg", "constructor", "Std.reg", "Bap.Std.Op.html#TYPEt", "", []);
add_ocaml_element("Imm", "Imm", "constructor", "Std.imm", "Bap.Std.Op.html#TYPEt", "", []);
add_ocaml_element("Fmm", "Fmm", "constructor", "Std.fmm", "Bap.Std.Op.html#TYPEt", "", []);
add_ocaml_element("addr", "addr", "field", "Std.Image.Scheme.addr", "Bap.Std.Image.Scheme.html#TYPEregion", "<div class=\"info\">\n<p>a staring address</p>\n\n</div>\n", ["ADDRESS", "STARING"]);
add_ocaml_element("size", "size", "field", "Std.Image.Scheme.size", "Bap.Std.Image.Scheme.html#TYPEregion", "<div class=\"info\">\n<p>a size of the segment</p>\n\n</div>\n", ["SEGMENT", "SIZE", "THE"]);
add_ocaml_element("info", "info", "field", "'a8", "Bap.Std.Image.Scheme.html#TYPEregion", "<div class=\"info\">\n<p>the attached information</p>\n\n</div>\n", ["ATTACHED", "INFORMATION", "THE"]);
add_ocaml_element("arch", "arch", "field", "Std.arch", "Bap.Std.Backend.Img.html#TYPEt", "", []);
add_ocaml_element("entry", "entry", "field", "Std.addr", "Bap.Std.Backend.Img.html#TYPEt", "", []);
add_ocaml_element("segments", "segments", "field", "Std.Backend.Segment.t * Std.Backend.Segment.t list", "Bap.Std.Backend.Img.html#TYPEt", "", []);
add_ocaml_element("symbols", "symbols", "field", "Std.Backend.Symbol.t list", "Bap.Std.Backend.Img.html#TYPEt", "", []);
add_ocaml_element("sections", "sections", "field", "Std.Backend.Section.t list", "Bap.Std.Backend.Img.html#TYPEt", "", []);
add_ocaml_element("name", "name", "field", "string", "Bap.Std.Backend.Section.html#TYPEt", "", []);
add_ocaml_element("location", "location", "field", "Std.location", "Bap.Std.Backend.Section.html#TYPEt", "", []);
add_ocaml_element("name", "name", "field", "string", "Bap.Std.Backend.Symbol.html#TYPEt", "", []);
add_ocaml_element("is_function", "is_function", "field", "bool", "Bap.Std.Backend.Symbol.html#TYPEt", "", []);
add_ocaml_element("is_debug", "is_debug", "field", "bool", "Bap.Std.Backend.Symbol.html#TYPEt", "", []);
add_ocaml_element("locations", "locations", "field", "Std.location * Std.location list", "Bap.Std.Backend.Symbol.html#TYPEt", "", []);
add_ocaml_element("name", "name", "field", "string", "Bap.Std.Backend.Segment.html#TYPEt", "", []);
add_ocaml_element("perm", "perm", "field", "Std.Backend.perm", "Bap.Std.Backend.Segment.html#TYPEt", "<div class=\"info\">\n<p>segment's permissions</p>\n\n</div>\n", ["PERMISSIONS", "SEGMENT"]);
add_ocaml_element("off", "off", "field", "int", "Bap.Std.Backend.Segment.html#TYPEt", "", []);
add_ocaml_element("location", "location", "field", "Std.location", "Bap.Std.Backend.Segment.html#TYPEt", "", []);
add_ocaml_element("R", "R", "constructor", "", "Bap.Std.Backend.html#TYPEperm", "", []);
add_ocaml_element("W", "W", "constructor", "", "Bap.Std.Backend.html#TYPEperm", "", []);
add_ocaml_element("X", "X", "constructor", "", "Bap.Std.Backend.html#TYPEperm", "", []);
add_ocaml_element("Or", "Or", "constructor", "Std.Backend.perm * Std.Backend.perm", "Bap.Std.Backend.html#TYPEperm", "", []);
add_ocaml_element("addr", "addr", "field", "Std.addr", "Bap.Std.Location.html#TYPEt", "", []);
add_ocaml_element("len", "len", "field", "int", "Bap.Std.Location.html#TYPEt", "", []);
add_ocaml_element("Imm", "Imm", "constructor", "int", "Bap.Std.Type.html#TYPEt", "", []);
add_ocaml_element("Mem", "Mem", "constructor", "Std.addr_size * Std.size", "Bap.Std.Type.html#TYPEt", "", []);
add_ocaml_element("Move", "Move", "constructor", "Std.Bil.Types.var * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEstmt", "<div class=\"info\">\n<p>assign value of expression to variable</p>\n\n</div>\n", ["ASSIGN", "EXPRESSION", "VALUE", "VARIABLE"]);
add_ocaml_element("Jmp", "Jmp", "constructor", "Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEstmt", "<div class=\"info\">\n<p>jump to absolute address</p>\n\n</div>\n", ["ABSOLUTE", "ADDRESS", "JUMP"]);
add_ocaml_element("Special", "Special", "constructor", "string", "Bap.Std.Bil.Types.html#TYPEstmt", "<div class=\"info\">\n<p>Statement with semantics not expressible in BIL</p>\n\n</div>\n", ["BIL", "EXPRESSIBLE", "NOT", "SEMANTICS", "STATEMENT", "WITH"]);
add_ocaml_element("While", "While", "constructor", "Std.Bil.Types.exp * Std.Bil.Types.stmt list", "Bap.Std.Bil.Types.html#TYPEstmt", "<div class=\"info\">\n<p>while loops</p>\n\n</div>\n", ["LOOPS", "WHILE"]);
add_ocaml_element("If", "If", "constructor", "Std.Bil.Types.exp * Std.Bil.Types.stmt list * Std.Bil.Types.stmt list", "Bap.Std.Bil.Types.html#TYPEstmt", "<div class=\"info\">\n<p>if/then/else statement</p>\n\n</div>\n", ["ELSE", "STATEMENT", "THEN"]);
add_ocaml_element("CpuExn", "CpuExn", "constructor", "int", "Bap.Std.Bil.Types.html#TYPEstmt", "", []);
add_ocaml_element("Imm", "Imm", "constructor", "int", "Bap.Std.Bil.Types.html#TYPEtyp", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Imm</span>&nbsp;n</code> - n-bit immediate</p>\n\n</div>\n", ["BIT", "IMM", "IMMEDIATE"]);
add_ocaml_element("Mem", "Mem", "constructor", "Std.addr_size * Std.size", "Bap.Std.Bil.Types.html#TYPEtyp", "", []);
add_ocaml_element("Load", "Load", "constructor", "Std.Bil.Types.exp * Std.Bil.Types.exp * Std.endian * Std.size", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>load from memory</p>\n\n</div>\n", ["FROM", "LOAD", "MEMORY"]);
add_ocaml_element("Store", "Store", "constructor", "Std.Bil.Types.exp * Std.Bil.Types.exp * Std.Bil.Types.exp * Std.endian * Std.size", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>store to memory</p>\n\n</div>\n", ["MEMORY", "STORE"]);
add_ocaml_element("BinOp", "BinOp", "constructor", "Std.Bil.Types.binop * Std.Bil.Types.exp * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>binary operation</p>\n\n</div>\n", ["BINARY", "OPERATION"]);
add_ocaml_element("UnOp", "UnOp", "constructor", "Std.Bil.Types.unop * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>unary operation</p>\n\n</div>\n", ["OPERATION", "UNARY"]);
add_ocaml_element("Var", "Var", "constructor", "Std.Bil.Types.var", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>variable</p>\n\n</div>\n", ["VARIABLE"]);
add_ocaml_element("Int", "Int", "constructor", "Std.word", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>immediate value</p>\n\n</div>\n", ["IMMEDIATE", "VALUE"]);
add_ocaml_element("Cast", "Cast", "constructor", "Std.Bil.Types.cast * int * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>casting</p>\n\n</div>\n", ["CASTING"]);
add_ocaml_element("Let", "Let", "constructor", "Std.Bil.Types.var * Std.Bil.Types.exp * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>let-binding</p>\n\n</div>\n", ["BINDING", "LET"]);
add_ocaml_element("Unknown", "Unknown", "constructor", "string * Std.Bil.Types.typ", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>unknown or undefined value</p>\n\n</div>\n", ["UNDEFINED", "UNKNOWN", "VALUE"]);
add_ocaml_element("Ite", "Ite", "constructor", "Std.Bil.Types.exp * Std.Bil.Types.exp * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>if-then-else expression</p>\n\n</div>\n", ["ELSE", "EXPRESSION", "THEN"]);
add_ocaml_element("Extract", "Extract", "constructor", "int * int * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>extract portion of word</p>\n\n</div>\n", ["EXTRACT", "PORTION", "WORD"]);
add_ocaml_element("Concat", "Concat", "constructor", "Std.Bil.Types.exp * Std.Bil.Types.exp", "Bap.Std.Bil.Types.html#TYPEexp", "<div class=\"info\">\n<p>concatenate two words</p>\n\n</div>\n", ["CONCATENATE", "TWO", "WORDS"]);
add_ocaml_element("NEG", "NEG", "constructor", "", "Bap.Std.Bil.Types.html#TYPEunop", "<div class=\"info\">\n<p>Negate.</p>\n\n</div>\n", ["COMPLEMENT", "NEGATE"]);
add_ocaml_element("NOT", "NOT", "constructor", "", "Bap.Std.Bil.Types.html#TYPEunop", "", []);
add_ocaml_element("PLUS", "PLUS", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Integer addition.</p>\n\n</div>\n", ["ADDITION", "ASSOCIATIVE", "COMMUTATIVE", "INTEGER"]);
add_ocaml_element("MINUS", "MINUS", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Subtract second integer from first.</p>\n\n</div>\n", ["FIRST", "FROM", "INTEGER", "SECOND", "SUBTRACT"]);
add_ocaml_element("TIMES", "TIMES", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Integer multiplication.</p>\n\n</div>\n", ["ASSOCIATIVE", "COMMUTATIVE", "INTEGER", "MULTIPLICATION"]);
add_ocaml_element("DIVIDE", "DIVIDE", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Unsigned integer division.</p>\n\n</div>\n", ["DIVISION", "INTEGER", "UNSIGNED"]);
add_ocaml_element("SDIVIDE", "SDIVIDE", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Signed integer division.</p>\n\n</div>\n", ["DIVISION", "INTEGER", "SIGNED"]);
add_ocaml_element("MOD", "MOD", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Unsigned modulus.</p>\n\n</div>\n", ["MODULUS", "UNSIGNED"]);
add_ocaml_element("SMOD", "SMOD", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Signed modulus.</p>\n\n</div>\n", ["MODULUS", "SIGNED"]);
add_ocaml_element("LSHIFT", "LSHIFT", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Left shift.</p>\n\n</div>\n", ["LEFT", "SHIFT"]);
add_ocaml_element("RSHIFT", "RSHIFT", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Right shift, zero padding.</p>\n\n</div>\n", ["PADDING", "RIGHT", "SHIFT", "ZERO"]);
add_ocaml_element("ARSHIFT", "ARSHIFT", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Right shift, sign extend.</p>\n\n</div>\n", ["EXTEND", "RIGHT", "SHIFT", "SIGN"]);
add_ocaml_element("AND", "AND", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Bitwise and.</p>\n\n</div>\n", ["AND", "ASSOCIATIVE", "BITWISE", "COMMUTATIVE"]);
add_ocaml_element("OR", "OR", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Bitwise or.</p>\n\n</div>\n", ["ASSOCIATIVE", "BITWISE", "COMMUTATIVE"]);
add_ocaml_element("XOR", "XOR", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Bitwise xor.</p>\n\n</div>\n", ["ASSOCIATIVE", "BITWISE", "COMMUTATIVE", "XOR"]);
add_ocaml_element("EQ", "EQ", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Equals.</p>\n\n</div>\n", ["ASSOCIATIVE", "BOOLEANS", "COMMUTATIVE", "EQUALS"]);
add_ocaml_element("NEQ", "NEQ", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Not equals.</p>\n\n</div>\n", ["ASSOCIATIVE", "BOOLEANS", "COMMUTATIVE", "EQUALS", "NOT"]);
add_ocaml_element("LT", "LT", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Unsigned less than.</p>\n\n</div>\n", ["LESS", "THAN", "UNSIGNED"]);
add_ocaml_element("LE", "LE", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Unsigned less than or equal to.</p>\n\n</div>\n", ["EQUAL", "LESS", "THAN", "UNSIGNED"]);
add_ocaml_element("SLT", "SLT", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "<div class=\"info\">\n<p>Signed less than.</p>\n\n</div>\n", ["LESS", "SIGNED", "THAN"]);
add_ocaml_element("SLE", "SLE", "constructor", "", "Bap.Std.Bil.Types.html#TYPEbinop", "", []);
add_ocaml_element("UNSIGNED", "UNSIGNED", "constructor", "", "Bap.Std.Bil.Types.html#TYPEcast", "<div class=\"info\">\n<p>0-padding widening cast.</p>\n\n</div>\n", ["CAST", "PADDING", "WIDENING"]);
add_ocaml_element("SIGNED", "SIGNED", "constructor", "", "Bap.Std.Bil.Types.html#TYPEcast", "<div class=\"info\">\n<p>Sign-extending widening cast.</p>\n\n</div>\n", ["CAST", "EXTENDING", "SIGN", "WIDENING"]);
add_ocaml_element("HIGH", "HIGH", "constructor", "", "Bap.Std.Bil.Types.html#TYPEcast", "<div class=\"info\">\n<p>Narrowing cast.</p>\n\n</div>\n", ["BITS", "CAST", "HIGH", "KEEPS", "NARROWING", "THE"]);
add_ocaml_element("LOW", "LOW", "constructor", "", "Bap.Std.Bil.Types.html#TYPEcast", "", []);
add_ocaml_element("Imm", "Imm", "constructor", "Std.word", "Bap.Std.Bil.html#TYPEvalue", "<div class=\"info\">\n<p>immediate value</p>\n\n</div>\n", ["IMMEDIATE", "VALUE"]);
add_ocaml_element("Mem", "Mem", "constructor", "Std.Bil.storage", "Bap.Std.Bil.html#TYPEvalue", "<div class=\"info\">\n<p>memory storage</p>\n\n</div>\n", ["MEMORY", "STORAGE"]);
add_ocaml_element("Bot", "Bot", "constructor", "", "Bap.Std.Bil.html#TYPEvalue", "<div class=\"info\">\n<p>undefined value</p>\n\n</div>\n", ["UNDEFINED", "VALUE"]);
add_ocaml_element("LittleEndian", "LittleEndian", "constructor", "", "Bap.Std.Bitvector.html#TYPEendian", "<div class=\"info\">\n<p>least significant byte comes first</p>\n\n</div>\n", ["BYTE", "COMES", "FIRST", "LEAST", "SIGNIFICANT"]);
add_ocaml_element("BigEndian", "BigEndian", "constructor", "", "Bap.Std.Bitvector.html#TYPEendian", "", []);
add_ocaml_element("In", "In", "constructor", "", "Bap.Std.html#TYPEintent", "<div class=\"info\">\n<p>input argument</p>\n\n</div>\n", ["ARGUMENT", "INPUT"]);
add_ocaml_element("Out", "Out", "constructor", "", "Bap.Std.html#TYPEintent", "<div class=\"info\">\n<p>output argument</p>\n\n</div>\n", ["ARGUMENT", "OUTPUT"]);
add_ocaml_element("Both", "Both", "constructor", "", "Bap.Std.html#TYPEintent", "", []);
add_ocaml_element("Call", "Call", "constructor", "Std.call", "Bap.Std.html#TYPEjmp_kind", "<div class=\"info\">\n<p>call to subroutine</p>\n\n</div>\n", ["CALL", "SUBROUTINE"]);
add_ocaml_element("Goto", "Goto", "constructor", "Std.label", "Bap.Std.html#TYPEjmp_kind", "<div class=\"info\">\n<p>jump inside subroutine</p>\n\n</div>\n", ["INSIDE", "JUMP", "SUBROUTINE"]);
add_ocaml_element("Ret", "Ret", "constructor", "Std.label", "Bap.Std.html#TYPEjmp_kind", "<div class=\"info\">\n<p>return from call to label</p>\n\n</div>\n", ["CALL", "FROM", "LABEL", "RETURN"]);
add_ocaml_element("Int", "Int", "constructor", "int * Std.tid", "Bap.Std.html#TYPEjmp_kind", "", []);
add_ocaml_element("Direct", "Direct", "constructor", "Std.tid", "Bap.Std.html#TYPElabel", "<div class=\"info\">\n<p>direct jump</p>\n\n</div>\n", ["DIRECT", "JUMP"]);
add_ocaml_element("Indirect", "Indirect", "constructor", "Std.exp", "Bap.Std.html#TYPElabel", "", []);
add_ocaml_element("LittleEndian", "LittleEndian", "constructor", "", "Bap.Std.html#TYPEendian", "", []);
add_ocaml_element("BigEndian", "BigEndian", "constructor", "", "Bap.Std.html#TYPEendian", "", []);
add_ocaml_element("in_loop", "Std.Stmt.state.in_loop", "attribute", "bool", "Bap.Std.Stmt.state-c.html#ATTin_loop", "<div class=\"info\">\n<p>is <code class=\"code\"><span class=\"keyword\">true</span></code> if currently visiting expression or statement is\n          executed under loop.</p>\n\n</div>\n", ["CURRENTLY", "EXECUTED", "EXPRESSION", "LOOP", "STATEMENT", "TRUE", "UNDER", "VISITING"]);
add_ocaml_element("in_move", "Std.Stmt.state.in_move", "attribute", "bool", "Bap.Std.Stmt.state-c.html#ATTin_move", "<div class=\"info\">\n<p>is <code class=\"code\"><span class=\"keyword\">true</span></code> if we're visiting expression that is on the left or\n          right side of the assignment.</p>\n\n</div>\n", ["ASSIGNMENT", "EXPRESSION", "LEFT", "RIGHT", "SIDE", "THAT", "THE", "TRUE", "VISITING"]);
add_ocaml_element("in_jmp", "Std.Stmt.state.in_jmp", "attribute", "bool", "Bap.Std.Stmt.state-c.html#ATTin_jmp", "<div class=\"info\">\n<p>is <code class=\"code\"><span class=\"keyword\">true</span></code> if we're visiting expression that is a jump target</p>\n\n</div>\n", ["EXPRESSION", "JUMP", "TARGET", "THAT", "TRUE", "VISITING"]);
add_ocaml_element("stmts_stack", "Std.Stmt.state.stmts_stack", "attribute", "Std.stmt list", "Bap.Std.Stmt.state-c.html#ATTstmts_stack", "<div class=\"info\">\n<p>a stack of stmts that are parents for the currently visiting\n          entity.</p>\n\n</div>\n", ["ARE", "CURRENTLY", "ENTITY", "FOR", "ONE", "PARENTS", "STACK", "STMTS", "THAT", "THE", "TOP", "VISITING"]);
add_ocaml_element("succs", "Std.Stmt.state.succs", "attribute", "Std.stmt list", "Bap.Std.Stmt.state-c.html#ATTsuccs", "<div class=\"info\">\n<p>stmts that are not yet visited</p>\n\n</div>\n", ["ARE", "NOT", "STMTS", "THAT", "VISITED", "YET"]);
add_ocaml_element("preds", "Std.Stmt.state.preds", "attribute", "Std.stmt list", "Bap.Std.Stmt.state-c.html#ATTpreds", "<div class=\"info\">\n<p>the stack of stmts that was already visited, with the last on\n          the top.</p>\n\n</div>\n", ["ALREADY", "CURRENTLY", "INCLUDING", "LAST", "NOT", "STACK", "STMT", "STMTS", "THAT", "THE", "TOP", "VISITED", "VISITING", "WAS", "WITH"]);
add_ocaml_element("under_condition", "Std.Exp.state.under_condition", "attribute", "bool", "Bap.Std.Exp.state-c.html#ATTunder_condition", "<div class=\"info\">\n<p>is <code class=\"code\"><span class=\"keyword\">true</span></code> if currently visiting entry is executed conditionally</p>\n\n</div>\n", ["CONDITIONALLY", "CURRENTLY", "ENTRY", "EXECUTED", "TRUE", "VISITING"]);
add_ocaml_element("exps_stack", "Std.Exp.state.exps_stack", "attribute", "Std.exp list", "Bap.Std.Exp.state-c.html#ATTexps_stack", "<div class=\"info\">\n<p>a stack of expr, that are parents for the currenly visiting\n          expression</p>\n\n</div>\n", ["ARE", "CURRENLY", "EXPR", "EXPRESSION", "FOR", "PARENTS", "STACK", "THAT", "THE", "VISITING"]);
add_ocaml_element("scalar", "Bap_c_size.base.scalar", "method", "Bap_c_type.scalar -> Std.size", "Bap_c_size.base-c.html#METHODscalar", "", []);
add_ocaml_element("basic", "Bap_c_size.base.basic", "method", "Bap_c_type.basic -> Std.size", "Bap_c_size.base-c.html#METHODbasic", "", []);
add_ocaml_element("floating", "Bap_c_size.base.floating", "method", "Bap_c_type.floating -> Std.size", "Bap_c_size.base-c.html#METHODfloating", "", []);
add_ocaml_element("complex", "Bap_c_size.base.complex", "method", "Bap_c_type.complex -> Std.size", "Bap_c_size.base-c.html#METHODcomplex", "", []);
add_ocaml_element("real", "Bap_c_size.base.real", "method", "Bap_c_type.real -> [ `r128 | `r32 | `r64 ]", "Bap_c_size.base-c.html#METHODreal", "", []);
add_ocaml_element("enum", "Bap_c_size.base.enum", "method", "(string * int64 option) list -> Std.size", "Bap_c_size.base-c.html#METHODenum", "", []);
add_ocaml_element("pointer", "Bap_c_size.base.pointer", "method", "Std.addr_size", "Bap_c_size.base-c.html#METHODpointer", "", []);
add_ocaml_element("integer", "Bap_c_size.base.integer", "method", "Bap_c_type.integer -> Std.size", "Bap_c_size.base-c.html#METHODinteger", "", []);
add_ocaml_element("structure", "Bap_c_size.base.structure", "method", "(Bap_c_type.no_qualifier, Bap_c_type.compound) Bap_c_type.spec ->\n  Bap_c_size.bits option", "Bap_c_size.base-c.html#METHODstructure", "<div class=\"info\">\n<p>if spec is complete then returns a total size of the\n    structure, including padding.</p>\n\n</div>\n", ["COMPLETE", "INCLUDING", "PADDING", "RETURNS", "SIZE", "SPEC", "STRUCTURE", "THE", "THEN", "TOTAL"]);
add_ocaml_element("union", "Bap_c_size.base.union", "method", "(Bap_c_type.no_qualifier, Bap_c_type.compound) Bap_c_type.spec ->\n  Bap_c_size.bits option", "Bap_c_size.base-c.html#METHODunion", "<div class=\"info\">\n<p>if spec is complete then returns a size of the biggest\n        element, including padding</p>\n\n</div>\n", ["BIGGEST", "COMPLETE", "ELEMENT", "INCLUDING", "PADDING", "RETURNS", "SIZE", "SPEC", "THE", "THEN"]);
add_ocaml_element("array", "Bap_c_size.base.array", "method", "(Bap_c_type.cvr Bap_c_type.qualifier, Bap_c_type.array) Bap_c_type.spec ->\n  Bap_c_size.bits option", "Bap_c_size.base-c.html#METHODarray", "<div class=\"info\">\n<p><code class=\"code\">array&nbsp;spec</code> if array <code class=\"code\">spec</code> is complete, then returns a\n        product of the bitwidth of array size and array's element\n        type, otherwise returns <code class=\"code\"><span class=\"constructor\">None</span></code></p>\n\n</div>\n", ["AND", "ARRAY", "BITWIDTH", "COMPLETE", "ELEMENT", "NONE", "OTHERWISE", "PRODUCT", "RETURNS", "SIZE", "SPEC", "THE", "THEN", "TYPE"]);
add_ocaml_element("padding", "Bap_c_size.base.padding", "method", "Bap_c_type.t -> Bap_c_size.bits -> Std.size option", "Bap_c_size.base-c.html#METHODpadding", "<div class=\"info\">\n<p><code class=\"code\">padding&nbsp;t&nbsp;off</code> computes a required padding at given offset\n        that should be inserted before value of type <code class=\"code\">t</code> to satisfy\n        the aligment restriction for <code class=\"code\">t</code>, as determined by the\n        <code class=\"code\">alignment</code> method.</p>\n\n</div>\n", ["ALIGMENT", "ALIGNMENT", "BEFORE", "COMPUTES", "DETERMINED", "FOR", "GIVEN", "INSERTED", "METHOD", "OFF", "OFFSET", "PADDING", "REQUIRED", "RESTRICTION", "SATISFY", "SHOULD", "THAT", "THE", "TYPE", "VALUE"]);
add_ocaml_element("alignment", "Bap_c_size.base.alignment", "method", "Bap_c_type.t -> Std.size", "Bap_c_size.base-c.html#METHODalignment", "<div class=\"info\">\n<p><code class=\"code\">alignment&nbsp;t</code> calculates an alignment restriction for data\n        type <code class=\"code\">t</code>.</p>\n\n</div>\n", ["ALIGMENT", "ALIGNMENT", "ARE", "BITS", "CALCULATES", "DATA", "DEFAULT", "ELT", "EQUAL", "FIELD", "FOLLOWING", "FOR", "FUNCTION", "MAXIMUM", "POINTER", "RESTRICTION", "RULES", "SCALAR", "SIZEOF", "STRUCTURE", "THE", "THEN", "TYPE", "UNION", "VOID"]);
add_ocaml_element("bits", "Bap_c_size.base.bits", "method", "Bap_c_type.t -> Bap_c_size.bits option", "Bap_c_size.base-c.html#METHODbits", "<div class=\"info\">\n<p>returns a size of the data type representation if type\n        definition is complete.</p>\n\n</div>\n", ["ALIGNMENT", "AND", "COMPLETE", "COMPUTED", "DATA", "DEFINITION", "NONE", "OTHERWISE", "PADDING", "REPRESENTATION", "RESPECT", "RESTRUCTIONS", "RETURNED", "RETURNS", "SIZE", "THE", "TYPE", "WITH"]);
add_ocaml_element("leave_name", "Bap_c_type_mapper_intf.S.base.leave_name", "method", "string -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_name", "", []);
add_ocaml_element("map_name", "Bap_c_type_mapper_intf.S.base.map_name", "method", "string -> (string, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_name", "", []);
add_ocaml_element("enter_name", "Bap_c_type_mapper_intf.S.base.enter_name", "method", "string -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_name", "", []);
add_ocaml_element("leave_attr", "Bap_c_type_mapper_intf.S.base.leave_attr", "method", "Bap_c_type.attr -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_attr", "", []);
add_ocaml_element("map_attr", "Bap_c_type_mapper_intf.S.base.map_attr", "method", "Bap_c_type.attr -> (Bap_c_type.attr, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_attr", "", []);
add_ocaml_element("enter_attr", "Bap_c_type_mapper_intf.S.base.enter_attr", "method", "Bap_c_type.attr -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_attr", "", []);
add_ocaml_element("leave_attrs", "Bap_c_type_mapper_intf.S.base.leave_attrs", "method", "Bap_c_type.attr list -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_attrs", "", []);
add_ocaml_element("map_attrs", "Bap_c_type_mapper_intf.S.base.map_attrs", "method", "Bap_c_type.attr list -> (Bap_c_type.attr list, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_attrs", "", []);
add_ocaml_element("enter_attrs", "Bap_c_type_mapper_intf.S.base.enter_attrs", "method", "Bap_c_type.attr list -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_attrs", "", []);
add_ocaml_element("leave_complex", "Bap_c_type_mapper_intf.S.base.leave_complex", "method", "Bap_c_type.complex -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_complex", "", []);
add_ocaml_element("map_complex", "Bap_c_type_mapper_intf.S.base.map_complex", "method", "Bap_c_type.complex -> (Bap_c_type.complex, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_complex", "", []);
add_ocaml_element("enter_complex", "Bap_c_type_mapper_intf.S.base.enter_complex", "method", "Bap_c_type.complex -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_complex", "", []);
add_ocaml_element("leave_real", "Bap_c_type_mapper_intf.S.base.leave_real", "method", "Bap_c_type.real -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_real", "", []);
add_ocaml_element("map_real", "Bap_c_type_mapper_intf.S.base.map_real", "method", "Bap_c_type.real -> (Bap_c_type.real, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_real", "", []);
add_ocaml_element("enter_real", "Bap_c_type_mapper_intf.S.base.enter_real", "method", "Bap_c_type.real -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_real", "", []);
add_ocaml_element("leave_floating", "Bap_c_type_mapper_intf.S.base.leave_floating", "method", "Bap_c_type.floating -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_floating", "", []);
add_ocaml_element("map_floating", "Bap_c_type_mapper_intf.S.base.map_floating", "method", "Bap_c_type.floating -> (Bap_c_type.floating, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_floating", "", []);
add_ocaml_element("enter_floating", "Bap_c_type_mapper_intf.S.base.enter_floating", "method", "Bap_c_type.floating -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_floating", "", []);
add_ocaml_element("leave_enum", "Bap_c_type_mapper_intf.S.base.leave_enum", "method", "(string * int64 option) list -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_enum", "", []);
add_ocaml_element("map_enum", "Bap_c_type_mapper_intf.S.base.map_enum", "method", "(string * int64 option) list ->\n  ((string * int64 option) list, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_enum", "", []);
add_ocaml_element("enter_enum", "Bap_c_type_mapper_intf.S.base.enter_enum", "method", "(string * int64 option) list -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_enum", "", []);
add_ocaml_element("leave_unsigned", "Bap_c_type_mapper_intf.S.base.leave_unsigned", "method", "Bap_c_type.unsigned -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_unsigned", "", []);
add_ocaml_element("map_unsigned", "Bap_c_type_mapper_intf.S.base.map_unsigned", "method", "Bap_c_type.unsigned -> (Bap_c_type.unsigned, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_unsigned", "", []);
add_ocaml_element("enter_unsigned", "Bap_c_type_mapper_intf.S.base.enter_unsigned", "method", "Bap_c_type.unsigned -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_unsigned", "", []);
add_ocaml_element("leave_signed", "Bap_c_type_mapper_intf.S.base.leave_signed", "method", "Bap_c_type.signed -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_signed", "", []);
add_ocaml_element("map_signed", "Bap_c_type_mapper_intf.S.base.map_signed", "method", "Bap_c_type.signed -> (Bap_c_type.signed, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_signed", "", []);
add_ocaml_element("enter_signed", "Bap_c_type_mapper_intf.S.base.enter_signed", "method", "Bap_c_type.signed -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_signed", "", []);
add_ocaml_element("leave_char", "Bap_c_type_mapper_intf.S.base.leave_char", "method", "Bap_c_type.char -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_char", "", []);
add_ocaml_element("map_char", "Bap_c_type_mapper_intf.S.base.map_char", "method", "Bap_c_type.char -> (Bap_c_type.char, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_char", "", []);
add_ocaml_element("enter_char", "Bap_c_type_mapper_intf.S.base.enter_char", "method", "Bap_c_type.char -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_char", "", []);
add_ocaml_element("leave_integer", "Bap_c_type_mapper_intf.S.base.leave_integer", "method", "Bap_c_type.integer -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_integer", "", []);
add_ocaml_element("map_integer", "Bap_c_type_mapper_intf.S.base.map_integer", "method", "Bap_c_type.integer -> (Bap_c_type.integer, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_integer", "", []);
add_ocaml_element("enter_integer", "Bap_c_type_mapper_intf.S.base.enter_integer", "method", "Bap_c_type.integer -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_integer", "", []);
add_ocaml_element("leave_basic", "Bap_c_type_mapper_intf.S.base.leave_basic", "method", "Bap_c_type.basic -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_basic", "", []);
add_ocaml_element("map_basic", "Bap_c_type_mapper_intf.S.base.map_basic", "method", "Bap_c_type.basic -> (Bap_c_type.basic, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_basic", "", []);
add_ocaml_element("enter_basic", "Bap_c_type_mapper_intf.S.base.enter_basic", "method", "Bap_c_type.basic -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_basic", "", []);
add_ocaml_element("leave_cvr_qualifier", "Bap_c_type_mapper_intf.S.base.leave_cvr_qualifier", "method", "Bap_c_type.cvr Bap_c_type.qualifier -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_cvr_qualifier", "", []);
add_ocaml_element("map_cvr_qualifier", "Bap_c_type_mapper_intf.S.base.map_cvr_qualifier", "method", "Bap_c_type.cvr Bap_c_type.qualifier ->\n  (Bap_c_type.cvr Bap_c_type.qualifier, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_cvr_qualifier", "", []);
add_ocaml_element("enter_cvr_qualifier", "Bap_c_type_mapper_intf.S.base.enter_cvr_qualifier", "method", "Bap_c_type.cvr Bap_c_type.qualifier -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_cvr_qualifier", "", []);
add_ocaml_element("leave_cv_qualifier", "Bap_c_type_mapper_intf.S.base.leave_cv_qualifier", "method", "Bap_c_type.cv Bap_c_type.qualifier -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_cv_qualifier", "", []);
add_ocaml_element("map_cv_qualifier", "Bap_c_type_mapper_intf.S.base.map_cv_qualifier", "method", "Bap_c_type.cv Bap_c_type.qualifier ->\n  (Bap_c_type.cv Bap_c_type.qualifier, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_cv_qualifier", "", []);
add_ocaml_element("enter_cv_qualifier", "Bap_c_type_mapper_intf.S.base.enter_cv_qualifier", "method", "Bap_c_type.cv Bap_c_type.qualifier -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_cv_qualifier", "", []);
add_ocaml_element("leave_structure", "Bap_c_type_mapper_intf.S.base.leave_structure", "method", "Bap_c_type.compound -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_structure", "", []);
add_ocaml_element("map_structure", "Bap_c_type_mapper_intf.S.base.map_structure", "method", "Bap_c_type.compound -> (Bap_c_type.compound, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_structure", "", []);
add_ocaml_element("enter_structure", "Bap_c_type_mapper_intf.S.base.enter_structure", "method", "Bap_c_type.compound -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_structure", "", []);
add_ocaml_element("leave_union", "Bap_c_type_mapper_intf.S.base.leave_union", "method", "Bap_c_type.compound -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_union", "", []);
add_ocaml_element("map_union", "Bap_c_type_mapper_intf.S.base.map_union", "method", "Bap_c_type.compound -> (Bap_c_type.compound, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_union", "", []);
add_ocaml_element("enter_union", "Bap_c_type_mapper_intf.S.base.enter_union", "method", "Bap_c_type.compound -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_union", "", []);
add_ocaml_element("leave_function", "Bap_c_type_mapper_intf.S.base.leave_function", "method", "Bap_c_type.proto -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_function", "", []);
add_ocaml_element("map_function", "Bap_c_type_mapper_intf.S.base.map_function", "method", "Bap_c_type.proto -> (Bap_c_type.proto, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_function", "", []);
add_ocaml_element("enter_function", "Bap_c_type_mapper_intf.S.base.enter_function", "method", "Bap_c_type.proto -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_function", "", []);
add_ocaml_element("leave_pointer", "Bap_c_type_mapper_intf.S.base.leave_pointer", "method", "Bap_c_type.t -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_pointer", "", []);
add_ocaml_element("map_pointer", "Bap_c_type_mapper_intf.S.base.map_pointer", "method", "Bap_c_type.t -> (Bap_c_type.t, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_pointer", "", []);
add_ocaml_element("enter_pointer", "Bap_c_type_mapper_intf.S.base.enter_pointer", "method", "Bap_c_type.t -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_pointer", "", []);
add_ocaml_element("leave_array", "Bap_c_type_mapper_intf.S.base.leave_array", "method", "Bap_c_type.array -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_array", "", []);
add_ocaml_element("map_array", "Bap_c_type_mapper_intf.S.base.map_array", "method", "Bap_c_type.array -> (Bap_c_type.array, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_array", "", []);
add_ocaml_element("enter_array", "Bap_c_type_mapper_intf.S.base.enter_array", "method", "Bap_c_type.array -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_array", "", []);
add_ocaml_element("leave_void", "Bap_c_type_mapper_intf.S.base.leave_void", "method", "Bap_c_type.t -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_void", "", []);
add_ocaml_element("map_void", "Bap_c_type_mapper_intf.S.base.map_void", "method", "Bap_c_type.t -> (Bap_c_type.t, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_void", "", []);
add_ocaml_element("enter_void", "Bap_c_type_mapper_intf.S.base.enter_void", "method", "Bap_c_type.t -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_void", "", []);
add_ocaml_element("leave_type", "Bap_c_type_mapper_intf.S.base.leave_type", "method", "Bap_c_type.t -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODleave_type", "", []);
add_ocaml_element("map_type", "Bap_c_type_mapper_intf.S.base.map_type", "method", "Bap_c_type.t -> (Bap_c_type.t, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODmap_type", "", []);
add_ocaml_element("enter_type", "Bap_c_type_mapper_intf.S.base.enter_type", "method", "Bap_c_type.t -> (unit, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODenter_type", "", []);
add_ocaml_element("run", "Bap_c_type_mapper_intf.S.base.run", "method", "Bap_c_type.t -> (Bap_c_type.t, 'e) Bap_c_type_mapper_intf.S.m", "Bap_c_type_mapper_intf.S.base-c.html#METHODrun", "", []);
add_ocaml_element("leave_edge", "Std.dfs_visitor.leave_edge", "method", "Std.edge_kind -> 'e -> 's -> 's", "Graphlib.Std.dfs_visitor-c.html#METHODleave_edge", "", []);
add_ocaml_element("enter_edge", "Std.dfs_visitor.enter_edge", "method", "Std.edge_kind -> 'e -> 's -> 's", "Graphlib.Std.dfs_visitor-c.html#METHODenter_edge", "", []);
add_ocaml_element("leave_node", "Std.dfs_visitor.leave_node", "method", "int -> 'n -> 's -> 's", "Graphlib.Std.dfs_visitor-c.html#METHODleave_node", "", []);
add_ocaml_element("enter_node", "Std.dfs_visitor.enter_node", "method", "int -> 'n -> 's -> 's", "Graphlib.Std.dfs_visitor-c.html#METHODenter_node", "", []);
add_ocaml_element("start_tree", "Std.dfs_visitor.start_tree", "method", "'n -> 's -> 's", "Graphlib.Std.dfs_visitor-c.html#METHODstart_tree", "", []);
add_ocaml_element("all_taints", "Std.Taint.context.all_taints", "method", "Std.Taint.set", "Bap.Std.Taint.context-c.html#METHODall_taints", "<div class=\"info\">\n<p>returns all known taints.</p>\n\n</div>\n", ["ALL", "KNOWN", "RETURNS", "TAINTS"]);
add_ocaml_element("ptr_taints", "Std.Taint.context.ptr_taints", "method", "Std.addr -> Std.Taint.set", "Bap.Std.Taint.context-c.html#METHODptr_taints", "<div class=\"info\">\n<p>returns a set of taints associated with a given address</p>\n\n</div>\n", ["ADDRESS", "ASSOCIATED", "GIVEN", "RETURNS", "SET", "TAINTS", "WITH"]);
add_ocaml_element("reg_taints", "Std.Taint.context.reg_taints", "method", "Std.Bil.result -> Std.Taint.set", "Bap.Std.Taint.context-c.html#METHODreg_taints", "<div class=\"info\">\n<p>returns a set of taints associated with a given result of computation</p>\n\n</div>\n", ["ASSOCIATED", "COMPUTATION", "GIVEN", "RESULT", "RETURNS", "SET", "TAINTS", "WITH"]);
add_ocaml_element("taint_ptr", "Std.Taint.context.taint_ptr", "method", "Std.addr ->\n  Std.size ->\n  Std.Taint.set ->\n  (< all_taints : Std.Taint.set;\n     ptr_taints : Std.addr -> Std.Taint.set;\n     reg_taints : Std.Bil.result -> Std.Taint.set; taint_ptr : 'a;\n     taint_reg : Std.Bil.result -> Std.Taint.set -> 'b; .. >\n   as 'b)\n  as 'a", "Bap.Std.Taint.context-c.html#METHODtaint_ptr", "<div class=\"info\">\n<p>taint memory region <code class=\"code\">addr,&nbsp;addr+size</code> with the given set of taints</p>\n\n</div>\n", ["ADDR", "GIVEN", "MEMORY", "REGION", "SET", "SIZE", "TAINT", "TAINTS", "THE", "WITH"]);
add_ocaml_element("taint_reg", "Std.Taint.context.taint_reg", "method", "Std.Bil.result ->\n  Std.Taint.set ->\n  (< all_taints : Std.Taint.set;\n     ptr_taints : Std.addr -> Std.Taint.set;\n     reg_taints : Std.Bil.result -> Std.Taint.set;\n     taint_ptr : Std.addr -> Std.size -> Std.Taint.set -> 'b;\n     taint_reg : 'a; .. >\n   as 'b)\n  as 'a", "Bap.Std.Taint.context-c.html#METHODtaint_reg", "<div class=\"info\">\n<p>taint result with the given set of taints</p>\n\n</div>\n", ["GIVEN", "RESULT", "SET", "TAINT", "TAINTS", "THE", "WITH"]);
add_ocaml_element("leave_jmp", "Std.Term.visitor.leave_jmp", "method", "Std.jmp Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_jmp", "", []);
add_ocaml_element("visit_jmp", "Std.Term.visitor.visit_jmp", "method", "Std.jmp Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_jmp", "", []);
add_ocaml_element("enter_jmp", "Std.Term.visitor.enter_jmp", "method", "Std.jmp Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_jmp", "", []);
add_ocaml_element("leave_def", "Std.Term.visitor.leave_def", "method", "Std.def Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_def", "", []);
add_ocaml_element("visit_def", "Std.Term.visitor.visit_def", "method", "Std.def Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_def", "", []);
add_ocaml_element("enter_def", "Std.Term.visitor.enter_def", "method", "Std.def Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_def", "", []);
add_ocaml_element("leave_phi", "Std.Term.visitor.leave_phi", "method", "Std.phi Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_phi", "", []);
add_ocaml_element("visit_phi", "Std.Term.visitor.visit_phi", "method", "Std.phi Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_phi", "", []);
add_ocaml_element("enter_phi", "Std.Term.visitor.enter_phi", "method", "Std.phi Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_phi", "", []);
add_ocaml_element("leave_arg", "Std.Term.visitor.leave_arg", "method", "Std.arg Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_arg", "", []);
add_ocaml_element("visit_arg", "Std.Term.visitor.visit_arg", "method", "Std.arg Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_arg", "", []);
add_ocaml_element("enter_arg", "Std.Term.visitor.enter_arg", "method", "Std.arg Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_arg", "", []);
add_ocaml_element("leave_blk", "Std.Term.visitor.leave_blk", "method", "Std.blk Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_blk", "", []);
add_ocaml_element("visit_blk", "Std.Term.visitor.visit_blk", "method", "Std.blk Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_blk", "", []);
add_ocaml_element("enter_blk", "Std.Term.visitor.enter_blk", "method", "Std.blk Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_blk", "", []);
add_ocaml_element("leave_sub", "Std.Term.visitor.leave_sub", "method", "Std.sub Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_sub", "", []);
add_ocaml_element("visit_sub", "Std.Term.visitor.visit_sub", "method", "Std.sub Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_sub", "", []);
add_ocaml_element("enter_sub", "Std.Term.visitor.enter_sub", "method", "Std.sub Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_sub", "", []);
add_ocaml_element("leave_program", "Std.Term.visitor.leave_program", "method", "Std.program Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_program", "", []);
add_ocaml_element("run", "Std.Term.visitor.run", "method", "Std.program Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODrun", "", []);
add_ocaml_element("enter_program", "Std.Term.visitor.enter_program", "method", "Std.program Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_program", "", []);
add_ocaml_element("leave_term", "Std.Term.visitor.leave_term", "method", "'t 'p. ('p, 't) Std.cls -> 't Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODleave_term", "", []);
add_ocaml_element("visit_term", "Std.Term.visitor.visit_term", "method", "'t 'p. ('p, 't) Std.cls -> 't Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODvisit_term", "", []);
add_ocaml_element("enter_term", "Std.Term.visitor.enter_term", "method", "'t 'p. ('p, 't) Std.cls -> 't Std.term -> 'a -> 'a", "Bap.Std.Term.visitor-c.html#METHODenter_term", "<div class=\"info\">\n<p><code class=\"code\">visit_term&nbsp;cls&nbsp;t</code> dispatch term <code class=\"code\">t</code> to corresponding method</p>\n\n</div>\n", ["CLS", "CORRESPONDING", "DISPATCH", "METHOD", "TERM", "VISIT_TERM"]);
add_ocaml_element("map_jmp", "Std.Term.mapper.map_jmp", "method", "Std.jmp Std.term -> Std.jmp Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_jmp", "<div class=\"info\">\n<p><code class=\"code\">map_jmp&nbsp;jmp</code> is <code class=\"code\">jmp</code></p>\n\n</div>\n", ["JMP", "MAP_JMP"]);
add_ocaml_element("map_def", "Std.Term.mapper.map_def", "method", "Std.def Std.term -> Std.def Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_def", "<div class=\"info\">\n<p><code class=\"code\">map_def&nbsp;def</code> is <code class=\"code\">def</code></p>\n\n</div>\n", ["DEF", "MAP_DEF"]);
add_ocaml_element("map_phi", "Std.Term.mapper.map_phi", "method", "Std.phi Std.term -> Std.phi Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_phi", "<div class=\"info\">\n<p><code class=\"code\">map_phi&nbsp;phi</code> is <code class=\"code\">phi</code></p>\n\n</div>\n", ["MAP_PHI", "PHI"]);
add_ocaml_element("map_blk", "Std.Term.mapper.map_blk", "method", "Std.blk Std.term -> Std.blk Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_blk", "<div class=\"info\">\n<p><code class=\"code\">map_blk&nbsp;blk</code> is <code class=\"code\">blk</code></p>\n\n</div>\n", ["BLK", "MAP_BLK"]);
add_ocaml_element("map_arg", "Std.Term.mapper.map_arg", "method", "Std.arg Std.term -> Std.arg Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_arg", "<div class=\"info\">\n<p><code class=\"code\">map_arg&nbsp;arg</code> is <code class=\"code\">arg</code></p>\n\n</div>\n", ["ARG", "MAP_ARG"]);
add_ocaml_element("map_sub", "Std.Term.mapper.map_sub", "method", "Std.sub Std.term -> Std.sub Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_sub", "<div class=\"info\">\n<p><code class=\"code\">map_sub&nbsp;sub</code> maps each arg and blk in <code class=\"code\">sub</code></p>\n\n</div>\n", ["AND", "ARG", "BLK", "EACH", "MAPS", "MAP_SUB", "SUB"]);
add_ocaml_element("run", "Std.Term.mapper.run", "method", "Std.program Std.term -> Std.program Std.term", "Bap.Std.Term.mapper-c.html#METHODrun", "<div class=\"info\">\n<p><code class=\"code\">run&nbsp;p</code> maps each sub in program <code class=\"code\">p</code></p>\n\n</div>\n", ["EACH", "MAPS", "PROGRAM", "RUN", "SUB"]);
add_ocaml_element("map_term", "Std.Term.mapper.map_term", "method", "'t 'p. ('p, 't) Std.cls -> 't Std.term -> 't Std.term", "Bap.Std.Term.mapper-c.html#METHODmap_term", "<div class=\"info\">\n<p><code class=\"code\">map_term&nbsp;cls&nbsp;t</code> dispatches <code class=\"code\">t</code> to corresponding method</p>\n\n</div>\n", ["CLS", "CORRESPONDING", "DISPATCHES", "MAP_TERM", "METHOD"]);
add_ocaml_element("next", "Std.Biri.context.next", "method", "Std.tid option", "Bap.Std.Biri.context-c.html#METHODnext", "<div class=\"info\">\n<p>The <code class=\"code\">next</code> term identifier is the identifier of a term,\n            that should be executed next.</p>\n\n</div>\n", ["AND", "BELONG", "BLOCK", "EITHER", "EXECUTED", "IDENTIFIER", "INTERPRETATION", "MUST", "NEXT", "NONE", "PROGRAM", "SHOULD", "STOP", "SUBROUTINE", "TERM", "THAT", "THE", "THEN", "WILL"]);
add_ocaml_element("set_next", "Std.Biri.context.set_next", "method", "Std.tid option ->\n  (< bindings : (Std.var * Std.Bil.result) Std.seq;\n     create_storage : Std.Bil.storage -> 'b * Std.Bil.result;\n     create_undefined : 'b * Std.Bil.result;\n     create_word : Std.word -> 'b * Std.Bil.result;\n     enter_term : Std.tid -> 'b;\n     lookup : Std.var -> Std.Bil.result option;\n     main : Std.sub Std.term option; next : Std.tid option;\n     program : Std.program Std.term; set_next : 'a;\n     trace : Std.tid list;\n     update : Std.var -> Std.Bil.result -> 'b; .. >\n   as 'b)\n  as 'a", "Bap.Std.Biri.context-c.html#METHODset_next", "<div class=\"info\">\n<p><code class=\"code\">set_next&nbsp;tid</code> set the identifier of the next term.</p>\n\n</div>\n", ["IDENTIFIER", "NEXT", "SET", "SET_NEXT", "TERM", "THE", "TID"]);
add_ocaml_element("enter_term", "Std.Biri.context.enter_term", "method", "Std.tid ->\n  (< bindings : (Std.var * Std.Bil.result) Std.seq;\n     create_storage : Std.Bil.storage -> 'b * Std.Bil.result;\n     create_undefined : 'b * Std.Bil.result;\n     create_word : Std.word -> 'b * Std.Bil.result; enter_term : 'a;\n     lookup : Std.var -> Std.Bil.result option;\n     main : Std.sub Std.term option; next : Std.tid option;\n     program : Std.program Std.term;\n     set_next : Std.tid option -> 'b; trace : Std.tid list;\n     update : Std.var -> Std.Bil.result -> 'b; .. >\n   as 'b)\n  as 'a", "Bap.Std.Biri.context-c.html#METHODenter_term", "<div class=\"info\">\n<p>Should be called when a new term is entered.</p>\n\n</div>\n", ["ARGUMENT", "CALLED", "ENTERED", "IMPLEMENTATION", "LIST", "NEW", "PASSED", "SHOULD", "TERM", "THE", "THIS", "TRACE", "UPDATE", "WHEN", "WILL", "WITH"]);
add_ocaml_element("trace", "Std.Biri.context.trace", "method", "Std.tid list", "Bap.Std.Biri.context-c.html#METHODtrace", "<div class=\"info\">\n<p>list of term that were already executed (may be long)</p>\n\n</div>\n", ["ALREADY", "EXECUTED", "LIST", "LONG", "MAY", "TERM", "THAT", "WERE"]);
add_ocaml_element("main", "Std.Biri.context.main", "method", "Std.sub Std.term option", "Bap.Std.Biri.context-c.html#METHODmain", "<div class=\"info\">\n<p>the entry point of evaluation</p>\n\n</div>\n", ["ENTRY", "EVALUATION", "POINT", "THE"]);
add_ocaml_element("program", "Std.Biri.context.program", "method", "Std.program Std.term", "Bap.Std.Biri.context-c.html#METHODprogram", "<div class=\"info\">\n<p>current model of a program.</p>\n\n</div>\n", ["CURRENT", "MODEL", "PROGRAM"]);
add_ocaml_element("eval_indirect", "Std.Biri.S.t.eval_indirect", "method", "Std.exp -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_indirect", "<div class=\"info\">\n<p>ignore argument and set context#next to None</p>\n\n</div>\n", ["AND", "ARGUMENT", "CONTEXT", "IGNORE", "NEXT", "NONE", "SET"]);
add_ocaml_element("eval_direct", "Std.Biri.S.t.eval_direct", "method", "Std.tid -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_direct", "<div class=\"info\">\n<p>set context#next to the a given tid</p>\n\n</div>\n", ["CONTEXT", "GIVEN", "NEXT", "SET", "THE", "TID"]);
add_ocaml_element("eval_exn", "Std.Biri.S.t.eval_exn", "method", "int -> Std.tid -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_exn", "<div class=\"info\">\n<p>ignore arguments and set context#next to None</p>\n\n</div>\n", ["AND", "ARGUMENTS", "CONTEXT", "IGNORE", "NEXT", "NONE", "SET"]);
add_ocaml_element("eval_ret", "Std.Biri.S.t.eval_ret", "method", "Std.label -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_ret", "<div class=\"info\">\n<p>evaluate label, using <code class=\"code\">eval_direct</code> or <code class=\"code\">eval_indirect</code>, based\n            on the label variant</p>\n\n</div>\n", ["BASED", "EVALUATE", "EVAL_DIRECT", "EVAL_INDIRECT", "LABEL", "THE", "USING", "VARIANT"]);
add_ocaml_element("eval_call", "Std.Biri.S.t.eval_call", "method", "Std.call -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_call", "<div class=\"info\">\n<p>evaluate target label, using <code class=\"code\">eval_direct</code> or\n            <code class=\"code\">eval_indirect</code>, based on the label variant.</p>\n\n</div>\n", ["BASED", "EVALUATE", "EVAL_DIRECT", "EVAL_INDIRECT", "IGNORES", "LABEL", "RETURN", "TARGET", "THE", "USING", "VARIANT"]);
add_ocaml_element("eval_goto", "Std.Biri.S.t.eval_goto", "method", "Std.label -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_goto", "<div class=\"info\">\n<p>evaluate label, using <code class=\"code\">eval_direct</code> or <code class=\"code\">eval_indirect</code>, based\n            on the label variant</p>\n\n</div>\n", ["BASED", "EVALUATE", "EVAL_DIRECT", "EVAL_INDIRECT", "LABEL", "THE", "USING", "VARIANT"]);
add_ocaml_element("eval_jmp", "Std.Biri.S.t.eval_jmp", "method", "Std.jmp Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_jmp", "<div class=\"info\">\n<p>evaluate condition, and if it is false, then do nothing,\n            otherwise evaluate jump target (see below)</p>\n\n</div>\n", ["AND", "BELOW", "CONDITION", "EVALUATE", "FALSE", "JUMP", "NOTHING", "OTHERWISE", "SEE", "TARGET", "THEN"]);
add_ocaml_element("eval_phi", "Std.Biri.S.t.eval_phi", "method", "Std.phi Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_phi", "<div class=\"info\">\n<p>based on trace select an expression and assign its\n            value to the left hand side of phi node.</p>\n\n</div>\n", ["AND", "ASSIGN", "BASED", "EXPRESSION", "HAND", "ITS", "LEFT", "NODE", "PHI", "SELECT", "SIDE", "THE", "TRACE", "VALUE"]);
add_ocaml_element("eval_def", "Std.Biri.S.t.eval_def", "method", "Std.def Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_def", "<div class=\"info\">\n<p>evaluate definition by assigning the result of the right\n            hand side to the definition variable</p>\n\n</div>\n", ["ASSIGNING", "DEFINITION", "EVALUATE", "HAND", "RESULT", "RIGHT", "SIDE", "THE", "VARIABLE"]);
add_ocaml_element("eval_blk", "Std.Biri.S.t.eval_blk", "method", "Std.blk Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_blk", "<div class=\"info\">\n<p>evaluate all terms in a given block, starting with phi\n            nodes, then proceeding to def nodes and finally evaluating\n            all jmp terms until either jump is taken or jump condition\n            is undefined.</p>\n\n</div>\n", ["AFTER", "ALL", "AND", "BLOCK", "CONDITION", "CONTEXT", "DEF", "DESTINATION", "EITHER", "EVALUATE", "EVALUATING", "EVALUATION", "FINALLY", "GIVEN", "JMP", "JUMP", "NEXT", "NODES", "PHI", "POINT", "PROCEEDING", "STARTING", "TAKEN", "TERMS", "THE", "THEN", "UNDEFINED", "UNTIL", "WILL", "WITH"]);
add_ocaml_element("eval_arg", "Std.Biri.S.t.eval_arg", "method", "Std.arg Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_arg", "<div class=\"info\">\n<p>evaluate argument by first evaluating its right hand side,\n            and then assigning the result to the left hand side.</p>\n\n</div>\n", ["AND", "ARGUMENT", "ASSIGNING", "EVALUATE", "EVALUATING", "FIRST", "HAND", "ITS", "LEFT", "RESULT", "RIGHT", "SIDE", "THE", "THEN"]);
add_ocaml_element("eval_sub", "Std.Biri.S.t.eval_sub", "method", "Std.sub Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval_sub", "<div class=\"info\">\n<p>Evaluates a subroutine with the following algorithm:</p>\n\n</div>\n", ["ALGORITHM", "ALL", "AND", "ARGUMENTS", "BLK", "BLOCK", "ELSE", "EVAL", "EVALUATES", "FIRST", "FOLLOWING", "GOTO", "NEXT", "OUT", "SOME", "SUB", "SUBROUTINE", "THE", "THEN", "WITH"]);
add_ocaml_element("leave_term", "Std.Biri.S.t.leave_term", "method", "'t 'p.\n    ('p, 't) Std.cls ->\n    't Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODleave_term", "<div class=\"info\">\n<p>called after all side effects of the term has occurred</p>\n\n</div>\n", ["AFTER", "ALL", "CALLED", "EFFECTS", "HAS", "OCCURRED", "SIDE", "TERM", "THE"]);
add_ocaml_element("eval", "Std.Biri.S.t.eval", "method", "'t 'p.\n    ('p, 't) Std.cls ->\n    't Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODeval", "<div class=\"info\">\n<p><code class=\"code\">eval&nbsp;cls&nbsp;t</code> evaluates a term <code class=\"code\">t</code> of the <code class=\"code\">cls</code> class.</p>\n\n</div>\n", ["AND", "CALL", "CALLED", "CLASS", "CLS", "CORRESPONDING", "DISPATCH", "ENTER_TERM", "EVAL", "EVALUATES", "EVAL_XXX", "FINALLY", "IMPLEMENTATION", "LEAVE_TERM", "METHOD", "NAME", "TERM", "THE", "THEN", "WHERE", "WILL", "XXX"]);
add_ocaml_element("enter_term", "Std.Biri.S.t.enter_term", "method", "'t 'p.\n    ('p, 't) Std.cls ->\n    't Std.term -> #Std.Biri.context Std.Biri.S.u", "Bap.Std.Biri.S.t-c.html#METHODenter_term", "<div class=\"info\">\n<p>called for each term, just after the position is updated,\n            but before any side effect of term evaluation had occurred.</p>\n\n</div>\n", ["AFTER", "ANY", "BEFORE", "BUT", "CALLED", "EACH", "EFFECT", "EVALUATION", "FOR", "HAD", "JUST", "OCCURRED", "POSITION", "SIDE", "TERM", "THE", "UPDATED"]);
add_ocaml_element("map_special", "Std.Stmt.mapper.map_special", "method", "string -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_special", "", []);
add_ocaml_element("map_cpuexn", "Std.Stmt.mapper.map_cpuexn", "method", "int -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_cpuexn", "", []);
add_ocaml_element("map_if", "Std.Stmt.mapper.map_if", "method", "cond:Std.exp ->\n  yes:Std.Stmt.t list -> no:Std.Stmt.t list -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_if", "", []);
add_ocaml_element("map_while", "Std.Stmt.mapper.map_while", "method", "cond:Std.exp -> Std.Stmt.t list -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_while", "", []);
add_ocaml_element("map_jmp", "Std.Stmt.mapper.map_jmp", "method", "Std.exp -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_jmp", "", []);
add_ocaml_element("map_move", "Std.Stmt.mapper.map_move", "method", "Std.var -> Std.exp -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_move", "", []);
add_ocaml_element("map_stmt", "Std.Stmt.mapper.map_stmt", "method", "Std.Stmt.t -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODmap_stmt", "", []);
add_ocaml_element("run", "Std.Stmt.mapper.run", "method", "Std.Stmt.t list -> Std.Stmt.t list", "Bap.Std.Stmt.mapper-c.html#METHODrun", "<div class=\"info\">\n<p>Default entry point.</p>\n\n</div>\n", ["AGAIN", "ANY", "BUT", "CAN", "DEFAULT", "ENTRY", "METHOD", "POINT", "USE", "YOU"]);
add_ocaml_element("find", "Std.Stmt.finder.find", "method", "Std.Stmt.t list -> 'a option", "Bap.Std.Stmt.finder-c.html#METHODfind", "", []);
add_ocaml_element("leave_special", "Std.Stmt.visitor.leave_special", "method", "string -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_special", "", []);
add_ocaml_element("visit_special", "Std.Stmt.visitor.visit_special", "method", "string -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_special", "", []);
add_ocaml_element("enter_special", "Std.Stmt.visitor.enter_special", "method", "string -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_special", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Special</span>&nbsp;string</code></p>\n\n</div>\n", ["SPECIAL", "STRING"]);
add_ocaml_element("leave_cpuexn", "Std.Stmt.visitor.leave_cpuexn", "method", "int -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_cpuexn", "", []);
add_ocaml_element("visit_cpuexn", "Std.Stmt.visitor.visit_cpuexn", "method", "int -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_cpuexn", "", []);
add_ocaml_element("enter_cpuexn", "Std.Stmt.visitor.enter_cpuexn", "method", "int -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_cpuexn", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">CpuExn</span>&nbsp;n</code></p>\n\n</div>\n", ["CPUEXN"]);
add_ocaml_element("leave_if", "Std.Stmt.visitor.leave_if", "method", "cond:Std.exp ->\n  yes:Std.Stmt.t list -> no:Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_if", "", []);
add_ocaml_element("visit_if", "Std.Stmt.visitor.visit_if", "method", "cond:Std.exp ->\n  yes:Std.Stmt.t list -> no:Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_if", "", []);
add_ocaml_element("enter_if", "Std.Stmt.visitor.enter_if", "method", "cond:Std.exp ->\n  yes:Std.Stmt.t list -> no:Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_if", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">If</span>&nbsp;(cond,yes,no)</code></p>\n\n</div>\n", ["COND", "YES"]);
add_ocaml_element("leave_while", "Std.Stmt.visitor.leave_while", "method", "cond:Std.exp -> Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_while", "", []);
add_ocaml_element("visit_while", "Std.Stmt.visitor.visit_while", "method", "cond:Std.exp -> Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_while", "", []);
add_ocaml_element("enter_while", "Std.Stmt.visitor.enter_while", "method", "cond:Std.exp -> Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_while", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">While</span>&nbsp;(cond,bil)</code></p>\n\n</div>\n", ["BIL", "COND", "WHILE"]);
add_ocaml_element("leave_jmp", "Std.Stmt.visitor.leave_jmp", "method", "Std.exp -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_jmp", "", []);
add_ocaml_element("visit_jmp", "Std.Stmt.visitor.visit_jmp", "method", "Std.exp -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_jmp", "", []);
add_ocaml_element("enter_jmp", "Std.Stmt.visitor.enter_jmp", "method", "Std.exp -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_jmp", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Jmp</span>&nbsp;exp</code></p>\n\n</div>\n", ["EXP", "JMP"]);
add_ocaml_element("leave_move", "Std.Stmt.visitor.leave_move", "method", "Std.var -> Std.exp -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_move", "", []);
add_ocaml_element("visit_move", "Std.Stmt.visitor.visit_move", "method", "Std.var -> Std.exp -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_move", "", []);
add_ocaml_element("enter_move", "Std.Stmt.visitor.enter_move", "method", "Std.var -> Std.exp -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_move", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Move</span>(var,exp)</code></p>\n\n</div>\n", ["EXP", "MOVE", "VAR"]);
add_ocaml_element("leave_stmt", "Std.Stmt.visitor.leave_stmt", "method", "Std.Stmt.t -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODleave_stmt", "", []);
add_ocaml_element("visit_stmt", "Std.Stmt.visitor.visit_stmt", "method", "Std.Stmt.t -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODvisit_stmt", "", []);
add_ocaml_element("enter_stmt", "Std.Stmt.visitor.enter_stmt", "method", "Std.Stmt.t -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODenter_stmt", "<div class=\"info\">\n<p>Statements</p>\n\n</div>\n", ["STATEMENTS"]);
add_ocaml_element("run", "Std.Stmt.visitor.run", "method", "Std.Stmt.t list -> 'a -> 'a", "Bap.Std.Stmt.visitor-c.html#METHODrun", "", []);
add_ocaml_element("map_unknown", "Std.Exp.mapper.map_unknown", "method", "string -> Std.typ -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_unknown", "", []);
add_ocaml_element("map_sym", "Std.Exp.mapper.map_sym", "method", "Std.var -> Std.var", "Bap.Std.Exp.mapper-c.html#METHODmap_sym", "", []);
add_ocaml_element("map_var", "Std.Exp.mapper.map_var", "method", "Std.var -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_var", "", []);
add_ocaml_element("map_int", "Std.Exp.mapper.map_int", "method", "Std.word -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_int", "", []);
add_ocaml_element("map_concat", "Std.Exp.mapper.map_concat", "method", "Std.Exp.t -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_concat", "", []);
add_ocaml_element("map_extract", "Std.Exp.mapper.map_extract", "method", "hi:int -> lo:int -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_extract", "", []);
add_ocaml_element("map_ite", "Std.Exp.mapper.map_ite", "method", "cond:Std.Exp.t -> yes:Std.Exp.t -> no:Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_ite", "", []);
add_ocaml_element("map_let", "Std.Exp.mapper.map_let", "method", "Std.var -> exp:Std.Exp.t -> body:Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_let", "", []);
add_ocaml_element("map_cast", "Std.Exp.mapper.map_cast", "method", "Std.cast -> int -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_cast", "", []);
add_ocaml_element("map_unop", "Std.Exp.mapper.map_unop", "method", "Std.unop -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_unop", "", []);
add_ocaml_element("map_binop", "Std.Exp.mapper.map_binop", "method", "Std.binop -> Std.Exp.t -> Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_binop", "", []);
add_ocaml_element("map_store", "Std.Exp.mapper.map_store", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t ->\n  exp:Std.Exp.t -> Std.endian -> Std.size -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_store", "", []);
add_ocaml_element("map_load", "Std.Exp.mapper.map_load", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t -> Std.endian -> Std.size -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_load", "", []);
add_ocaml_element("map_exp", "Std.Exp.mapper.map_exp", "method", "Std.Exp.t -> Std.Exp.t", "Bap.Std.Exp.mapper-c.html#METHODmap_exp", "", []);
add_ocaml_element("find", "Std.Exp.finder.find", "method", "Std.Exp.t -> 'a option", "Bap.Std.Exp.finder-c.html#METHODfind", "", []);
add_ocaml_element("leave_unknown", "Std.Exp.visitor.leave_unknown", "method", "string -> Std.typ -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_unknown", "", []);
add_ocaml_element("visit_unknown", "Std.Exp.visitor.visit_unknown", "method", "string -> Std.typ -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_unknown", "", []);
add_ocaml_element("enter_unknown", "Std.Exp.visitor.enter_unknown", "method", "string -> Std.typ -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_unknown", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Unknown</span>&nbsp;(str,typ)</code></p>\n\n</div>\n", ["STR", "TYP", "UNKNOWN"]);
add_ocaml_element("leave_var", "Std.Exp.visitor.leave_var", "method", "Std.var -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_var", "", []);
add_ocaml_element("visit_var", "Std.Exp.visitor.visit_var", "method", "Std.var -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_var", "", []);
add_ocaml_element("enter_var", "Std.Exp.visitor.enter_var", "method", "Std.var -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_var", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Var</span>&nbsp;v</code></p>\n\n</div>\n", ["VAR"]);
add_ocaml_element("leave_int", "Std.Exp.visitor.leave_int", "method", "Std.word -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_int", "", []);
add_ocaml_element("visit_int", "Std.Exp.visitor.visit_int", "method", "Std.word -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_int", "", []);
add_ocaml_element("enter_int", "Std.Exp.visitor.enter_int", "method", "Std.word -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_int", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Int</span>&nbsp;w</code></p>\n\n</div>\n", ["INT"]);
add_ocaml_element("leave_concat", "Std.Exp.visitor.leave_concat", "method", "Std.Exp.t -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_concat", "", []);
add_ocaml_element("visit_concat", "Std.Exp.visitor.visit_concat", "method", "Std.Exp.t -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_concat", "", []);
add_ocaml_element("enter_concat", "Std.Exp.visitor.enter_concat", "method", "Std.Exp.t -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_concat", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Concat</span>(e1,e2)</code></p>\n\n</div>\n", ["CONCAT"]);
add_ocaml_element("leave_extract", "Std.Exp.visitor.leave_extract", "method", "hi:int -> lo:int -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_extract", "", []);
add_ocaml_element("visit_extract", "Std.Exp.visitor.visit_extract", "method", "hi:int -> lo:int -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_extract", "", []);
add_ocaml_element("enter_extract", "Std.Exp.visitor.enter_extract", "method", "hi:int -> lo:int -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_extract", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Extract</span>&nbsp;(hi,lo,e)</code></p>\n\n</div>\n", ["EXTRACT"]);
add_ocaml_element("leave_ite", "Std.Exp.visitor.leave_ite", "method", "cond:Std.Exp.t -> yes:Std.Exp.t -> no:Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_ite", "", []);
add_ocaml_element("visit_ite", "Std.Exp.visitor.visit_ite", "method", "cond:Std.Exp.t -> yes:Std.Exp.t -> no:Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_ite", "", []);
add_ocaml_element("enter_ite", "Std.Exp.visitor.enter_ite", "method", "cond:Std.Exp.t -> yes:Std.Exp.t -> no:Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_ite", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Ite</span>&nbsp;(cond,yes,no)</code></p>\n\n</div>\n", ["COND", "ITE", "YES"]);
add_ocaml_element("leave_let", "Std.Exp.visitor.leave_let", "method", "Std.var -> exp:Std.Exp.t -> body:Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_let", "", []);
add_ocaml_element("visit_let", "Std.Exp.visitor.visit_let", "method", "Std.var -> exp:Std.Exp.t -> body:Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_let", "", []);
add_ocaml_element("enter_let", "Std.Exp.visitor.enter_let", "method", "Std.var -> exp:Std.Exp.t -> body:Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_let", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Let</span>&nbsp;(v,t,body)</code></p>\n\n</div>\n", ["BODY", "LET"]);
add_ocaml_element("leave_cast", "Std.Exp.visitor.leave_cast", "method", "Std.cast -> int -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_cast", "", []);
add_ocaml_element("visit_cast", "Std.Exp.visitor.visit_cast", "method", "Std.cast -> int -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_cast", "", []);
add_ocaml_element("enter_cast", "Std.Exp.visitor.enter_cast", "method", "Std.cast -> int -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_cast", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Cast</span>(kind,size,e)</code></p>\n\n</div>\n", ["CAST", "KIND", "SIZE"]);
add_ocaml_element("leave_unop", "Std.Exp.visitor.leave_unop", "method", "Std.unop -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_unop", "", []);
add_ocaml_element("visit_unop", "Std.Exp.visitor.visit_unop", "method", "Std.unop -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_unop", "", []);
add_ocaml_element("enter_unop", "Std.Exp.visitor.enter_unop", "method", "Std.unop -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_unop", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Unop</span>&nbsp;(op,e)</code></p>\n\n</div>\n", ["UNOP"]);
add_ocaml_element("leave_binop", "Std.Exp.visitor.leave_binop", "method", "Std.binop -> Std.Exp.t -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_binop", "", []);
add_ocaml_element("visit_binop", "Std.Exp.visitor.visit_binop", "method", "Std.binop -> Std.Exp.t -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_binop", "", []);
add_ocaml_element("enter_binop", "Std.Exp.visitor.enter_binop", "method", "Std.binop -> Std.Exp.t -> Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_binop", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">BinOp</span>&nbsp;(op,e1,e2)</code></p>\n\n</div>\n", ["BINOP"]);
add_ocaml_element("leave_store", "Std.Exp.visitor.leave_store", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t ->\n  exp:Std.Exp.t -> Std.endian -> Std.size -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_store", "", []);
add_ocaml_element("visit_store", "Std.Exp.visitor.visit_store", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t ->\n  exp:Std.Exp.t -> Std.endian -> Std.size -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_store", "", []);
add_ocaml_element("enter_store", "Std.Exp.visitor.enter_store", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t ->\n  exp:Std.Exp.t -> Std.endian -> Std.size -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_store", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Store</span>&nbsp;(dst,addr,src,endian,size)</code></p>\n\n</div>\n", ["ADDR", "DST", "ENDIAN", "SIZE", "SRC", "STORE"]);
add_ocaml_element("leave_load", "Std.Exp.visitor.leave_load", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t -> Std.endian -> Std.size -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_load", "", []);
add_ocaml_element("visit_load", "Std.Exp.visitor.visit_load", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t -> Std.endian -> Std.size -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_load", "", []);
add_ocaml_element("enter_load", "Std.Exp.visitor.enter_load", "method", "mem:Std.Exp.t ->\n  addr:Std.Exp.t -> Std.endian -> Std.size -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_load", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Load</span>&nbsp;(src,addr,endian,size)</code></p>\n\n</div>\n", ["ADDR", "ENDIAN", "LOAD", "SIZE", "SRC"]);
add_ocaml_element("leave_exp", "Std.Exp.visitor.leave_exp", "method", "Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODleave_exp", "", []);
add_ocaml_element("visit_exp", "Std.Exp.visitor.visit_exp", "method", "Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODvisit_exp", "", []);
add_ocaml_element("enter_exp", "Std.Exp.visitor.enter_exp", "method", "Std.Exp.t -> 'a -> 'a", "Bap.Std.Exp.visitor-c.html#METHODenter_exp", "", []);
add_ocaml_element("with_pc", "Std.Bili.context.with_pc", "method", "Std.Bil.value ->\n  (< bindings : (Std.var * Std.Bil.result) Std.seq;\n     create_storage : Std.Bil.storage -> 'b * Std.Bil.result;\n     create_undefined : 'b * Std.Bil.result;\n     create_word : Std.word -> 'b * Std.Bil.result;\n     lookup : Std.var -> Std.Bil.result option; pc : Std.Bil.value;\n     update : Std.var -> Std.Bil.result -> 'b; with_pc : 'a; .. >\n   as 'b)\n  as 'a", "Bap.Std.Bili.context-c.html#METHODwith_pc", "", []);
add_ocaml_element("pc", "Std.Bili.context.pc", "method", "Std.Bil.value", "Bap.Std.Bili.context-c.html#METHODpc", "", []);
add_ocaml_element("eval_special", "Std.Bili.S.t.eval_special", "method", "string -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_special", "", []);
add_ocaml_element("eval_cpuexn", "Std.Bili.S.t.eval_cpuexn", "method", "int -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_cpuexn", "", []);
add_ocaml_element("eval_if", "Std.Bili.S.t.eval_if", "method", "cond:Std.exp ->\n  yes:Std.stmt list ->\n  no:Std.stmt list -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_if", "", []);
add_ocaml_element("eval_while", "Std.Bili.S.t.eval_while", "method", "cond:Std.exp ->\n  body:Std.stmt list -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_while", "", []);
add_ocaml_element("eval_jmp", "Std.Bili.S.t.eval_jmp", "method", "Std.exp -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_jmp", "", []);
add_ocaml_element("eval_move", "Std.Bili.S.t.eval_move", "method", "Std.var -> Std.exp -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_move", "", []);
add_ocaml_element("eval_stmt", "Std.Bili.S.t.eval_stmt", "method", "Std.stmt -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval_stmt", "", []);
add_ocaml_element("eval", "Std.Bili.S.t.eval", "method", "Std.stmt list -> #Std.Bili.context Std.Bili.S.u", "Bap.Std.Bili.S.t-c.html#METHODeval", "", []);
add_ocaml_element("create_storage", "Std.Expi.context.create_storage", "method", "Std.Bil.storage ->\n  (< bindings : (Std.var * Std.Bil.result) Std.seq;\n     create_storage : 'a; create_undefined : 'b * Std.Bil.result;\n     create_word : Std.word -> 'b * Std.Bil.result;\n     lookup : Std.var -> Std.Bil.result option;\n     update : Std.var -> Std.Bil.result -> 'b; .. >\n   as 'b) *\n  Std.Bil.result as 'a", "Bap.Std.Expi.context-c.html#METHODcreate_storage", "<div class=\"info\">\n<p>creates a fresh new result, containing a given storage,\n          and returns it with a modified context.</p>\n\n</div>\n", ["AND", "CONTAINING", "CONTEXT", "CREATES", "FRESH", "GIVEN", "MODIFIED", "NEW", "RESULT", "RETURNS", "STORAGE", "WITH"]);
add_ocaml_element("create_word", "Std.Expi.context.create_word", "method", "Std.word ->\n  (< bindings : (Std.var * Std.Bil.result) Std.seq;\n     create_storage : Std.Bil.storage -> 'b * Std.Bil.result;\n     create_undefined : 'b * Std.Bil.result; create_word : 'a;\n     lookup : Std.var -> Std.Bil.result option;\n     update : Std.var -> Std.Bil.result -> 'b; .. >\n   as 'b) *\n  Std.Bil.result as 'a", "Bap.Std.Expi.context-c.html#METHODcreate_word", "<div class=\"info\">\n<p>creates a fresh new result, containing a given word,\n          and returns it with a modified context.</p>\n\n</div>\n", ["AND", "CONTAINING", "CONTEXT", "CREATES", "FRESH", "GIVEN", "MODIFIED", "NEW", "RESULT", "RETURNS", "WITH", "WORD"]);
add_ocaml_element("create_undefined", "Std.Expi.context.create_undefined", "method", "(< bindings : (Std.var * Std.Bil.result) Std.seq;\n     create_storage : Std.Bil.storage -> 'b * Std.Bil.result;\n     create_undefined : 'a;\n     create_word : Std.word -> 'b * Std.Bil.result;\n     lookup : Std.var -> Std.Bil.result option;\n     update : Std.var -> Std.Bil.result -> 'b; .. >\n   as 'b) *\n  Std.Bil.result as 'a", "Bap.Std.Expi.context-c.html#METHODcreate_undefined", "<div class=\"info\">\n<p>creates a fresh new result, containing an undefined value,\n          and returns it with a modified context.</p>\n\n</div>\n", ["AND", "CONTAINING", "CONTEXT", "CREATES", "FRESH", "MODIFIED", "NEW", "RESULT", "RETURNS", "UNDEFINED", "VALUE", "WITH"]);
add_ocaml_element("undefined_var", "Std.Expi.S.t.undefined_var", "method", "Std.var -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODundefined_var", "<div class=\"info\">\n<p>called when context doesn't know the variable</p>\n\n</div>\n", ["CALLED", "CONTEXT", "DOESN", "KNOW", "THE", "VARIABLE", "WHEN"]);
add_ocaml_element("undefined_addr", "Std.Expi.S.t.undefined_addr", "method", "Std.addr -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODundefined_addr", "<div class=\"info\">\n<p>called when storage doesn't contain the addr</p>\n\n</div>\n", ["ADDR", "CALLED", "CONTAIN", "DOESN", "STORAGE", "THE", "WHEN"]);
add_ocaml_element("division_by_zero", "Std.Expi.S.t.division_by_zero", "method", "unit -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODdivision_by_zero", "<div class=\"info\">\n<p>we can't do this!</p>\n\n</div>\n", ["CAN", "THIS"]);
add_ocaml_element("type_error", "Std.Expi.S.t.type_error", "method", "Std.type_error -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODtype_error", "<div class=\"info\">\n<p>a given typing error has occured</p>\n\n</div>\n", ["ERROR", "GIVEN", "HAS", "OCCURED", "TYPING"]);
add_ocaml_element("store", "Std.Expi.S.t.store", "method", "Std.Bil.storage ->\n  Std.addr -> Std.word -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODstore", "<div class=\"info\">\n<p>a byte is stored to a a given address</p>\n\n</div>\n", ["ADDRESS", "BYTE", "GIVEN", "STORED"]);
add_ocaml_element("load", "Std.Expi.S.t.load", "method", "Std.Bil.storage -> Std.addr -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODload", "<div class=\"info\">\n<p>a byte is loaded from a given address</p>\n\n</div>\n", ["ADDRESS", "BYTE", "FROM", "GIVEN", "LOADED"]);
add_ocaml_element("update", "Std.Expi.S.t.update", "method", "Std.var -> Std.Bil.result -> #Std.Expi.context Std.Expi.S.u", "Bap.Std.Expi.S.t-c.html#METHODupdate", "<div class=\"info\">\n<p>a variable is bind to a value.</p>\n\n</div>\n", ["BIND", "VALUE", "VARIABLE"]);
add_ocaml_element("lookup", "Std.Expi.S.t.lookup", "method", "Std.var -> #Std.Expi.context Std.Expi.S.r", "Bap.Std.Expi.S.t-c.html#METHODlookup", "<div class=\"info\">\n<p>a variable is looked up in a context</p>\n\n</div>\n", ["CONTEXT", "LOOKED", "VARIABLE"]);
add_ocaml_element("empty", "Std.Expi.S.t.empty", "method", "Std.Bil.storage", "Bap.Std.Expi.S.t-c.html#METHODempty", "<div class=\"info\">\n<p>creates an empty storage.</p>\n\n</div>\n", ["CREATES", "DEFINITELY", "EMPTY", "IMPLEMENTATION", "OWN", "PLACE", "PROVIDE", "RIGHT", "STORAGE", "THE", "THEN", "WANT", "YOU", "YOUR"]);
add_ocaml_element("division_by_zero", "Std.Eval.S.t.division_by_zero", "method", "unit -> 'r Std.Eval.S.m", "Bap.Std.Eval.S.t-c.html#METHODdivision_by_zero", "", []);
add_ocaml_element("type_error", "Std.Eval.S.t.type_error", "method", "Std.type_error -> 'r Std.Eval.S.m", "Bap.Std.Eval.S.t-c.html#METHODtype_error", "", []);
add_ocaml_element("division_by_zero", "Std.Eval.S2.t.division_by_zero", "method", "unit -> ('r, 'a) Std.Eval.S2.m", "Bap.Std.Eval.S2.t-c.html#METHODdivision_by_zero", "", []);
add_ocaml_element("type_error", "Std.Eval.S2.t.type_error", "method", "Std.type_error -> ('r, 'a) Std.Eval.S2.m", "Bap.Std.Eval.S2.t-c.html#METHODtype_error", "", []);
add_ocaml_element("store", "Std.Eval.T2.eff.store", "method", "'s -> Std.addr -> Std.word -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.eff-c.html#METHODstore", "", []);
add_ocaml_element("load", "Std.Eval.T2.eff.load", "method", "'s -> Std.addr -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.eff-c.html#METHODload", "", []);
add_ocaml_element("update", "Std.Eval.T2.eff.update", "method", "Std.var -> 'r -> (unit, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.eff-c.html#METHODupdate", "", []);
add_ocaml_element("lookup", "Std.Eval.T2.eff.lookup", "method", "Std.var -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.eff-c.html#METHODlookup", "", []);
add_ocaml_element("storage_of_value", "Std.Eval.T2.domain.storage_of_value", "method", "'r -> ('s option, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.domain-c.html#METHODstorage_of_value", "", []);
add_ocaml_element("word_of_value", "Std.Eval.T2.domain.word_of_value", "method", "'r -> (Std.word option, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.domain-c.html#METHODword_of_value", "", []);
add_ocaml_element("value_of_word", "Std.Eval.T2.domain.value_of_word", "method", "Std.word -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.domain-c.html#METHODvalue_of_word", "", []);
add_ocaml_element("undefined", "Std.Eval.T2.domain.undefined", "method", "('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.domain-c.html#METHODundefined", "", []);
add_ocaml_element("eval_unknown", "Std.Eval.T2.semantics.eval_unknown", "method", "string -> Std.typ -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_unknown", "", []);
add_ocaml_element("eval_extract", "Std.Eval.T2.semantics.eval_extract", "method", "int -> int -> Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_extract", "", []);
add_ocaml_element("eval_concat", "Std.Eval.T2.semantics.eval_concat", "method", "Std.exp -> Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_concat", "", []);
add_ocaml_element("eval_ite", "Std.Eval.T2.semantics.eval_ite", "method", "cond:Std.exp ->\n  yes:Std.exp -> no:Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_ite", "", []);
add_ocaml_element("eval_let", "Std.Eval.T2.semantics.eval_let", "method", "Std.var -> Std.exp -> Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_let", "", []);
add_ocaml_element("eval_cast", "Std.Eval.T2.semantics.eval_cast", "method", "Std.cast -> int -> Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_cast", "", []);
add_ocaml_element("eval_unop", "Std.Eval.T2.semantics.eval_unop", "method", "Std.unop -> Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_unop", "", []);
add_ocaml_element("eval_binop", "Std.Eval.T2.semantics.eval_binop", "method", "Std.binop -> Std.exp -> Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_binop", "", []);
add_ocaml_element("eval_store", "Std.Eval.T2.semantics.eval_store", "method", "mem:Std.exp ->\n  addr:Std.exp ->\n  Std.exp -> Std.endian -> Std.size -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_store", "", []);
add_ocaml_element("eval_load", "Std.Eval.T2.semantics.eval_load", "method", "mem:Std.exp ->\n  addr:Std.exp ->\n  Std.endian -> Std.size -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_load", "", []);
add_ocaml_element("eval_int", "Std.Eval.T2.semantics.eval_int", "method", "Std.word -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_int", "", []);
add_ocaml_element("eval_var", "Std.Eval.T2.semantics.eval_var", "method", "Std.var -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_var", "", []);
add_ocaml_element("eval_exp", "Std.Eval.T2.semantics.eval_exp", "method", "Std.exp -> ('r, 'a) Std.Eval.T2.m", "Bap.Std.Eval.T2.semantics-c.html#METHODeval_exp", "", []);
add_ocaml_element("store", "Std.Eval.T1.eff.store", "method", "'s -> Std.addr -> Std.word -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.eff-c.html#METHODstore", "", []);
add_ocaml_element("load", "Std.Eval.T1.eff.load", "method", "'s -> Std.addr -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.eff-c.html#METHODload", "", []);
add_ocaml_element("update", "Std.Eval.T1.eff.update", "method", "Std.var -> 'r -> unit Std.Eval.T1.m", "Bap.Std.Eval.T1.eff-c.html#METHODupdate", "", []);
add_ocaml_element("lookup", "Std.Eval.T1.eff.lookup", "method", "Std.var -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.eff-c.html#METHODlookup", "", []);
add_ocaml_element("storage_of_value", "Std.Eval.T1.domain.storage_of_value", "method", "'r -> 's option Std.Eval.T1.m", "Bap.Std.Eval.T1.domain-c.html#METHODstorage_of_value", "", []);
add_ocaml_element("word_of_value", "Std.Eval.T1.domain.word_of_value", "method", "'r -> Std.word option Std.Eval.T1.m", "Bap.Std.Eval.T1.domain-c.html#METHODword_of_value", "", []);
add_ocaml_element("value_of_word", "Std.Eval.T1.domain.value_of_word", "method", "Std.word -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.domain-c.html#METHODvalue_of_word", "", []);
add_ocaml_element("undefined", "Std.Eval.T1.domain.undefined", "method", "'r Std.Eval.T1.m", "Bap.Std.Eval.T1.domain-c.html#METHODundefined", "", []);
add_ocaml_element("eval_unknown", "Std.Eval.T1.semantics.eval_unknown", "method", "string -> Std.typ -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_unknown", "", []);
add_ocaml_element("eval_extract", "Std.Eval.T1.semantics.eval_extract", "method", "int -> int -> Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_extract", "", []);
add_ocaml_element("eval_concat", "Std.Eval.T1.semantics.eval_concat", "method", "Std.exp -> Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_concat", "", []);
add_ocaml_element("eval_ite", "Std.Eval.T1.semantics.eval_ite", "method", "cond:Std.exp -> yes:Std.exp -> no:Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_ite", "", []);
add_ocaml_element("eval_let", "Std.Eval.T1.semantics.eval_let", "method", "Std.var -> Std.exp -> Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_let", "", []);
add_ocaml_element("eval_cast", "Std.Eval.T1.semantics.eval_cast", "method", "Std.cast -> int -> Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_cast", "", []);
add_ocaml_element("eval_unop", "Std.Eval.T1.semantics.eval_unop", "method", "Std.unop -> Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_unop", "", []);
add_ocaml_element("eval_binop", "Std.Eval.T1.semantics.eval_binop", "method", "Std.binop -> Std.exp -> Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_binop", "", []);
add_ocaml_element("eval_store", "Std.Eval.T1.semantics.eval_store", "method", "mem:Std.exp ->\n  addr:Std.exp ->\n  Std.exp -> Std.endian -> Std.size -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_store", "", []);
add_ocaml_element("eval_load", "Std.Eval.T1.semantics.eval_load", "method", "mem:Std.exp ->\n  addr:Std.exp -> Std.endian -> Std.size -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_load", "", []);
add_ocaml_element("eval_int", "Std.Eval.T1.semantics.eval_int", "method", "Std.word -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_int", "", []);
add_ocaml_element("eval_var", "Std.Eval.T1.semantics.eval_var", "method", "Std.var -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_var", "", []);
add_ocaml_element("eval_exp", "Std.Eval.T1.semantics.eval_exp", "method", "Std.exp -> 'r Std.Eval.T1.m", "Bap.Std.Eval.T1.semantics-c.html#METHODeval_exp", "", []);
add_ocaml_element("bindings", "Std.Context.t.bindings", "method", "(Std.var * Std.Bil.result) Std.seq", "Bap.Std.Context.t-c.html#METHODbindings", "<div class=\"info\">\n<p><code class=\"code\">self<span class=\"keywordsign\">#</span>bindings</code> returns a current list of bindings.</p>\n\n</div>\n", ["AND", "BINDINGS", "CURRENT", "DEBUGGING", "FOR", "INTROSPECTION", "LIST", "RETURNS", "SELF", "USEFUL"]);
add_ocaml_element("update", "Std.Context.t.update", "method", "Std.var ->\n  Std.Bil.result ->\n  < bindings : (Std.var * Std.Bil.result) Std.seq;\n    lookup : Std.var -> Std.Bil.result option; update : 'a; .. >\n  as 'a", "Bap.Std.Context.t-c.html#METHODupdate", "<div class=\"info\">\n<p><code class=\"code\">self<span class=\"keywordsign\">#</span>update&nbsp;var&nbsp;x</code> bind variable <code class=\"code\">var</code> to value <code class=\"code\">x</code>.</p>\n\n</div>\n", ["BIND", "BINDING", "CONTEXT", "NEW", "RETURNS", "SELF", "THE", "UPDATE", "UPDATED", "VALUE", "VAR", "VARIABLE", "WITH"]);
add_ocaml_element("lookup", "Std.Context.t.lookup", "method", "Std.var -> Std.Bil.result option", "Bap.Std.Context.t-c.html#METHODlookup", "<div class=\"info\">\n<p><code class=\"code\">self<span class=\"keywordsign\">#</span>lookup&nbsp;var</code> evaluate variable <code class=\"code\">var</code> to a value that was\n          previously bound to it.</p>\n\n</div>\n", ["BOUND", "EVALUATE", "LOOKUP", "NONE", "PREVIOUSLY", "RETURNS", "SELF", "THAT", "UNBOUND", "VALUE", "VAR", "VARIABLE", "WAS"]);
add_ocaml_element("save", "Std.Bil.storage.save", "method", "Std.addr ->\n  Std.word -> < load : Std.addr -> Std.word option; save : 'a; .. >\n  as 'a", "Bap.Std.Bil.storage-c.html#METHODsave", "<div class=\"info\">\n<p><code class=\"code\">save&nbsp;a&nbsp;w</code> stores byte <code class=\"code\">w</code> at address <code class=\"code\">a</code></p>\n\n</div>\n", ["ADDRESS", "BYTE", "SAVE", "STORES"]);
add_ocaml_element("load", "Std.Bil.storage.load", "method", "Std.addr -> Std.word option", "Bap.Std.Bil.storage-c.html#METHODload", "<div class=\"info\">\n<p><code class=\"code\">load&nbsp;a</code> loads a byte from a a given address  <code class=\"code\">a</code></p>\n\n</div>\n", ["ADDRESS", "BYTE", "FROM", "GIVEN", "LOAD", "LOADS"]);
add_ocaml_element("base", "Bap_c_size.base", "class", "<i>(... class ...)</i>", "Bap_c_size.base-c.html", "<div class=\"info\">\n<p>Base class for computing size of C data types.</p>\n\n</div>\n", ["ALGORITHM", "ALLOW", "BASE", "BITS", "CALCULATION", "CLASS", "COMPUTING", "DATA", "ENTRY", "FINE", "FOR", "HERE", "IMPLEMENTATION", "IMPLEMENTED", "INHERENTLY", "METHOD", "NEED", "OPEN", "PARTICULAR", "RECURSION", "RECURSIVE", "SINCE", "SIZE", "THE", "TUNE", "TYPE", "TYPES"]);
add_ocaml_element("base", "Bap_c_type_mapper_intf.S.base", "class", "<i>(... class ...)</i>", "Bap_c_type_mapper_intf.S.base-c.html", "", []);
add_ocaml_element("dfs_identity_visitor", "Std.dfs_identity_visitor", "class", "<i>(... class ...)</i>", "Graphlib.Std.Graphlib.dfs_identity_visitor-c.html", "<div class=\"info\">\n<p>base class with all methods defaults to nothing.</p>\n\n</div>\n", ["ALL", "BASE", "CLASS", "DEFAULTS", "METHODS", "NOTHING", "WITH"]);
add_ocaml_element("biri", "Std.biri", "class", "<i>(... class ...)</i>", "Bap.Std.biri-c.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>BIR <a href=\"Bap.Std.Biri.html\">interpreter</a></p>\n\n</span></div>\n", ["BIR", "DEPRECATED", "FRAMEWORK", "INTERPRETER", "PRIMUS", "THE", "USE"]);
add_ocaml_element("bili", "Std.bili", "class", "<i>(... class ...)</i>", "Bap.Std.bili-c.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>BIL <a href=\"Bap.Std.Bili.html\">interpreter</a></p>\n\n</span></div>\n", ["BIL", "DEPRECATED", "FRAMEWORK", "INTERPRETER", "PRIMUS", "THE", "USE"]);
add_ocaml_element("expi", "Std.expi", "class", "<i>(... class ...)</i>", "Bap.Std.expi-c.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>Expression <a href=\"Bap.Std.Expi.html\">interpreter</a></p>\n\n</span></div>\n", ["DEPRECATED", "EXPRESSION", "FRAMEWORK", "INTERPRETER", "PRIMUS", "THE", "USE"]);
add_ocaml_element("context", "Std.Taint.context", "class", "<i>(... class ...)</i>", "Bap.Std.Taint.context-c.html", "", []);
add_ocaml_element("propagator", "Std.Taint.S.propagator", "class", "<i>(... class ...)</i>", "Bap.Std.Taint.S.propagator-c.html", "<div class=\"info\">\n<p>Propagate taint through expressions.</p>\n\n</div>\n", ["ADDRESS", "ALSO", "ALTHOUGH", "AND", "ARE", "ARGUE", "BIL", "BINARY", "BIR", "BOP", "BRANCHES", "CAN", "CAST", "CHANGE", "CLASS", "CLASSES", "COMPUTES", "CONCAT", "CONDITION", "CONDITIONAL", "CONDITIONALS", "CONSIDER", "CONSISTENCY", "CONTROL", "DATA", "DENOTED", "DEPENDENCY", "DEPENDS", "DERIVED", "DERIVIATION", "DIFFERENT", "ELSE", "EXISTS", "EXP", "EXPRESSION", "EXPRESSIONS", "EXTENSION", "EXTRACT", "FACT", "FOLLOWING", "FOR", "FORMS", "FROM", "GET", "GOOD", "GRAMMAR", "IMMEDIATE", "ITE", "JUMP", "LATTER", "LEAF", "LEAVING", "LOAD", "METHODS", "NON", "NOT", "NOTE", "ONE", "ONLY", "OPERATION", "OVERRIDES", "POSSIBLE", "PROPAGATE", "PROPAGATING", "PROPAGATION", "PROVING", "P_BOP_LHS", "P_BOP_RHS", "P_LOAD", "P_STORE", "P_UOP", "REASON", "REDUCES", "RESULT", "RESULTS", "RULES", "SEMANTICS", "SHOULD", "SINCE", "SPACE", "START", "STATEMENT", "STORE", "SYNTACTIC", "TAINT", "TAINTED", "THAT", "THE", "THEN", "THERE", "THIS", "THROUGH", "UNARY", "UNFORTUNATELLY", "UOP", "USED", "VALUE", "WHERE", "WILL", "WITH"]);
add_ocaml_element("visitor", "Std.Term.visitor", "class", "<i>(... class ...)</i>", "Bap.Std.Term.visitor-c.html", "<div class=\"info\">\n<p>Visitor performs deep visiting.</p>\n\n</div>\n", ["ALWAYS", "ARE", "CALL", "COMES", "DEEP", "DIRECTLY", "DON", "ENTER_T", "FORGET", "FROM", "INHERIT", "LEAVE_T", "MAY", "METHOD", "METHODS", "NOT", "OPS", "OVERRID", "PARENT", "PERFORMS", "THAT", "THE", "THEN", "THIS", "USEFUL", "VISITING", "VISITOR", "WITH", "YOU"]);
add_ocaml_element("mapper", "Std.Term.mapper", "class", "<i>(... class ...)</i>", "Bap.Std.Term.mapper-c.html", "<div class=\"info\">\n<p>Mapper perfoms deep identity term mapping.</p>\n\n</div>\n", ["ANY", "CALL", "DEEP", "DIDN", "FOR", "FORGET", "IDENTITY", "INVOKE", "MAKE", "MAPPER", "MAPPING", "METHOD", "NOT", "OCAML", "OVERRIDE", "PARENT", "PERFOMS", "SURE", "TERM", "THAT", "WILL", "YOU"]);
add_ocaml_element("context", "Std.Biri.context", "class", "<i>(... class ...)</i>", "Bap.Std.Biri.context-c.html", "<div class=\"info\">\n<p>Biri evaluates terms in the context of a whole program (since\n        terms may contain calls and jumps).</p>\n\n</div>\n", ["ALSO", "AND", "BEHAVIOR", "BIRI", "BLOCK", "CALLS", "CAN", "CHANGE", "CONTAIN", "CONTEXT", "CURRENT", "DIFFERENT", "DURING", "EVALUATES", "EVALUATION", "EVEN", "FOR", "IMPLEMENTATIONS", "INSIDE", "JUMPS", "MAY", "NOT", "NOTE", "OTHER", "OVERRIDE", "POSITION", "PRECEDING", "PROGRAM", "PROPERTIES", "PROVIDE", "SETTERS", "SINCE", "SOME", "STILL", "TERMS", "THAT", "THE", "THEM", "THEY", "TRACKS", "WHOLE"]);
add_ocaml_element("t", "Std.Biri.S.t", "class", "<i>(... class ...)</i>", "Bap.Std.Biri.S.t-c.html", "<div class=\"info\">\n<p>base class for BIR interpreters</p>\n\n</div>\n", ["BASE", "BIR", "CLASS", "FOR", "INTERPRETERS"]);
add_ocaml_element("constant_folder", "Std.Stmt.constant_folder", "class", "<i>(... class ...)</i>", "Bap.Std.Stmt.constant_folder-c.html", "<div class=\"info\">\n<p><code class=\"code\">constant_folder</code> is a class that implements the <code class=\"code\">fold_consts</code></p>\n\n</div>\n", ["CLASS", "CONSTANT_FOLDER", "FOLD_CONSTS", "IMPLEMENTS", "THAT", "THE"]);
add_ocaml_element("mapper", "Std.Stmt.mapper", "class", "<i>(... class ...)</i>", "Bap.Std.Stmt.mapper-c.html", "<div class=\"info\">\n<p>AST transformation.</p>\n\n</div>\n", ["ALLOWING", "ALLOWS", "AMOUNT", "AST", "EMPTY", "EXTRA", "FLEXIBILITY", "FROM", "LIMITED", "LIST", "MAP", "MAPPER", "MAPPING", "ONE", "OUTPUT", "PARTICULARLY", "PERFORMING", "PROVIDES", "REMOVE", "SEVERAL", "SOME", "STATEMENT", "STATEMENTS", "STMT", "THE", "THIS", "THUS", "TRANSFORMATION", "TRANSFORMATIONS", "USEFUL", "WHEN", "WHILE", "YOU"]);
add_ocaml_element("finder", "Std.Stmt.finder", "class", "<i>(... class ...)</i>", "Bap.Std.Stmt.finder-c.html", "<div class=\"info\">\n<p>A visitor with a shortcut.</p>\n\n</div>\n", ["ACCEPTING", "ACCEPTS", "ADDITION", "AKA", "ANY", "ARGUMENT", "ASSIGNED", "ASSIGNMENT", "BIL", "CALLING", "CAN", "CHECK", "DIRECTLY", "END", "ENTER_MOVE", "ENTRY", "EXAMPLE", "EXP", "FIELD", "FIND", "FINDER", "FOLDING", "FOLLOWING", "FOR", "FUNCTION", "FUNCTIONS", "INHERIT", "IS_ASSIGNED", "ITS", "ITSELF", "LEFT", "LET", "LIBRARY", "LIST", "METHOD", "OBJECT", "OCCURS", "ONE", "OPERATOR", "OPTION", "POINTS", "PROVIDED", "RECORD", "RETURN", "SCOPE", "SEARCHES", "SELF", "SHORTCUT", "SOME", "SPECIALIZATION", "STMT", "STOP", "THAT", "THE", "THEN", "THERE", "THIS", "THREE", "TIME", "TRAVERSING", "TWO", "TYPE", "UNIT", "USE", "USES", "USING", "VAR", "VARIABLE", "VISITOR", "WHETHER", "WHICH", "WILL", "WITH", "YOU"]);
add_ocaml_element("visitor", "Std.Stmt.visitor", "class", "<i>(... class ...)</i>", "Bap.Std.Stmt.visitor-c.html", "<div class=\"info\">\n<p>Visitor.</p>\n\n</div>\n", ["ALL", "AND", "ANY", "ARGUMENT", "AST", "BIL", "BUT", "CALL", "CAN", "CHANGING", "CHILDREN", "COLLECT", "COLLECT_CALLS", "CONSTRUCTOR", "COULD", "DEFAULT", "EACH", "ELSE", "END", "ENTER_C", "ENTER_INT", "ENTRY", "EXAMPLE", "EXPRESSION", "FOLLOWING", "FOR", "FUNCTION", "HAVE", "HOOKS", "IMPLEMENTATION", "INHERIT", "IN_JMP", "ITS", "JUMPS", "LEAVE_C", "LET", "LIST", "LOTS", "METHOD", "METHODS", "NEED", "NOT", "OBJECT", "ONE", "ONLY", "OTHER", "OVERRIDE", "POINT", "PROVIDES", "PROVIDING", "RECOMMENDED", "RESOLVED", "RETURN", "RUN", "SELF", "STATEMENT", "THE", "THEN", "THREE", "TREE", "USE", "VISIT", "VISITING", "VISITOR", "VISITS", "VISIT_C", "WANT", "WAY", "WELL", "WITHOUT", "WORD", "WRITE", "YOU"]);
add_ocaml_element("state", "Std.Stmt.state", "class", "<i>(... class ...)</i>", "Bap.Std.Stmt.state-c.html", "<div class=\"info\">\n<p>All visitors provide some information about the current\n        position of the visitor</p>\n\n</div>\n", ["ABOUT", "ALL", "CURRENT", "INFORMATION", "POSITION", "PROVIDE", "SOME", "THE", "VISITOR", "VISITORS"]);
add_ocaml_element("mapper", "Std.Exp.mapper", "class", "<i>(... class ...)</i>", "Bap.Std.Exp.mapper-c.html", "<div class=\"info\">\n<p>Exp mapper.</p>\n\n</div>\n", ["AND", "ARG", "BACK", "CALLED", "CALLS", "CONSTRUCTS", "CORRESPONDING", "DECONSTRUCTS", "DEEP", "DEFAULT", "DO_MAPPING", "END", "EXP", "FOR", "IDENTITY", "INHERIT", "ITS", "LEAF", "LET", "MAKE", "MAPPER", "MAPPING", "MAP_X", "METHOD", "METHODS", "NON", "NORMAL", "OBJECT", "OVERRIDING", "PARENT", "PARTS", "PERFORMS", "SELF", "SUPER", "SURE", "TEMPLATE", "TERMS", "THAT", "THE", "THEN", "TRAVERSAL", "USUAL", "WANT", "YOU"]);
add_ocaml_element("finder", "Std.Exp.finder", "class", "<i>(... class ...)</i>", "Bap.Std.Exp.finder-c.html", "<div class=\"info\">\n<p>A visitor with a shortcut.</p>\n\n</div>\n", ["ACCEPTING", "ANY", "ARGUMENT", "CALLING", "CAN", "FIELD", "FINDER", "FOLDING", "FUNCTION", "ITS", "ITSELF", "ONE", "OPTION", "PROVIDED", "RECORD", "RETURN", "SHORTCUT", "SPECIALIZATION", "STOP", "THAT", "THE", "TIME", "TRAVERSING", "TYPE", "USES", "VISITOR", "WHICH", "WITH", "YOU"]);
add_ocaml_element("visitor", "Std.Exp.visitor", "class", "<i>(... class ...)</i>", "Bap.Std.Exp.visitor-c.html", "<div class=\"info\">\n<p>expression visitor.</p>\n\n</div>\n", ["ALL", "ALSO", "AND", "ARGUMENT", "AST", "BAP", "BIL", "CALL", "CHANGING", "CHILDREN", "CLASS", "CONSTRUCTOR", "DEFAULT", "EACH", "ENTER_C", "EXPRESSION", "FOLLOWING", "FOR", "GRAPH", "HOOKS", "IMPLEMENTATION", "ITS", "LEAVE_C", "LOTS", "METHOD", "METHODS", "NEED", "OBSERVING", "ONLY", "OVERRIDE", "PROGRAM", "PROVIDES", "PROVIDING", "RECOMMENDED", "REPRESENTATION", "RESPECTIVELY", "RETURN", "SEE", "STD", "TERM", "THE", "THREE", "TREE", "TREES", "VISIT", "VISITING", "VISITOR", "VISITS", "VISIT_C", "WAY", "WITHOUT", "YOU"]);
add_ocaml_element("state", "Std.Exp.state", "class", "<i>(... class ...)</i>", "Bap.Std.Exp.state-c.html", "<div class=\"info\">\n<p>All visitors provide some information about the current\n        position of the visitor</p>\n\n</div>\n", ["ABOUT", "ALL", "CURRENT", "INFORMATION", "POSITION", "PROVIDE", "SOME", "THE", "VISITOR", "VISITORS"]);
add_ocaml_element("context", "Std.Bili.context", "class", "<i>(... class ...)</i>", "Bap.Std.Bili.context-c.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Bili</span>.context</code> extends <code class=\"code\"><span class=\"constructor\">Expi</span>.context</code> with PC (Program\n        Counter).</p>\n\n</div>\n", ["BILI", "CONTEXT", "COUNTER", "EXPI", "EXTENDS", "PROGRAM", "WITH"]);
add_ocaml_element("t", "Std.Bili.S.t", "class", "<i>(... class ...)</i>", "Bap.Std.Bili.S.t-c.html", "<div class=\"info\">\n<p>Base class for BIL interpreters</p>\n\n</div>\n", ["BASE", "BIL", "CLASS", "FOR", "INTERPRETERS"]);
add_ocaml_element("context", "Std.Expi.context", "class", "<i>(... class ...)</i>", "Bap.Std.Expi.context-c.html", "<div class=\"info\">\n<p>Context for expression evaluation.</p>\n\n</div>\n", ["CONTEXT", "CREATED", "EACH", "EVALUATION", "EXPRESSION", "FOR", "FRESHLY", "IDENTIFIER", "PROVIDES", "UNIQUE", "VALUE"]);
add_ocaml_element("t", "Std.Expi.S.t", "class", "<i>(... class ...)</i>", "Bap.Std.Expi.S.t-c.html", "<div class=\"info\">\n<p>Expression interpreter.</p>\n\n</div>\n", ["0X1", "0X2", "0X3", "ABSTR", "ACCEPTS", "ACCESSIBLE", "ADD_EVENT", "AFTERWARDS", "ALL", "ALSO", "AND", "ANY", "APPROXIMATION", "ARBITRARY", "ASSIGNS", "AUTOMATICALLY", "BAP", "BASE", "BASICALLY", "BIL", "BILI", "BIRI", "BOTH", "CAN", "CHAIN", "CHANGED", "CLASS", "COMPUTATION", "COMPUTATIONS", "CONSTRAINT", "CONTEXT", "CONTEXT1", "COURTESY", "CREATE", "CREATED", "CTXT", "DEFINE", "DEFINED", "EACH", "END", "EVAL", "EVALUATE", "EVALUATED", "EVALUATES", "EVALUATION", "EVALUATOR", "EVAL_EXP", "EVENTS", "EXEC", "EXP", "EXPI", "EXPRESSION", "EXPRESSIONS", "EXP_TRACER", "EXTENSIBILITY", "FALSE", "FELLOW", "FIRST", "FIXED", "FOR", "FRESHLY", "FROM", "FUN", "FUNCTION", "GENERALIZED", "GET", "HARD", "HERE", "IDENTIFIER", "INFERRED", "INHERIT", "INHERITING", "INITIAL", "INSIDE", "INSTANTIATED", "INT", "INTERESTED", "INTERPRETER", "INTERPRETERS", "INTRODUCED", "INVARIANT", "ITS", "JUST", "LANGUAGE", "LET", "LIKE", "LIST", "LOR", "MADE", "MAIN", "MAY", "MEANS", "MERELY", "METHOD", "MONAD", "NEED", "NEW", "NOT", "NOTE", "NOW", "OBJ", "OBJECT", "ONLY", "OPEN", "OPERATOR", "OTHER", "OUR", "PAIRED", "PARAMETRIZED", "POLYMORPHIC", "PROGRAMMER", "PROVIDE", "PROVIDED", "PUT", "RECOGNIZES", "RECORD", "RELAXED", "RES", "RESTRICTION", "RESULT", "RETURN", "RETURNED", "RETURNS", "REUSE", "REV", "RUN", "SEE", "SHOW_EVENTS", "SINCE", "START", "STATE", "STD", "STRENGTH", "SUBTYPE", "SUPER", "TAG", "TAGGED", "THAT", "THE", "THEN", "THERE", "THING", "THIRD", "THIS", "TRACE", "TRACER", "TRUE", "TRY", "TYPE", "UNDER", "UNIQUE", "USE", "USED", "VAL", "VALUE", "VARIABLE", "WANT", "WAS", "WEAKLY", "WEAKNESS", "WHEN", "WHERE", "WILL", "WITH", "WORD", "WORK", "WRITE", "YOU"]);
add_ocaml_element("t", "Std.Eval.S.t", "class", "<i>(... class ...)</i>", "Bap.Std.Eval.S.t-c.html", "<div class=\"info\">\n<p>a virtual base class for all evaluators</p>\n\n</div>\n", ["ALL", "BASE", "CLASS", "EVALUATORS", "FOR", "VIRTUAL"]);
add_ocaml_element("t", "Std.Eval.S2.t", "class", "<i>(... class ...)</i>", "Bap.Std.Eval.S2.t-c.html", "<div class=\"info\">\n<p>a virtual base class for all evaluators</p>\n\n</div>\n", ["ALL", "BASE", "CLASS", "EVALUATORS", "FOR", "VIRTUAL"]);
add_ocaml_element("t", "Std.Context.t", "class", "<i>(... class ...)</i>", "Bap.Std.Context.t-c.html", "", []);
add_ocaml_element("sparse", "Std.Bil.Storage.sparse", "class", "<i>(... class ...)</i>", "Bap.Std.Bil.Storage.sparse-c.html", "<div class=\"info\">\n<p>sparse storage is slightly more efficient storage,\n          in comparison with linear.</p>\n\n</div>\n", ["AND", "BALANCED", "COMPARISON", "DATA", "EFFICIENT", "LINEAR", "LOGARITHMIC", "LOOKUP", "METHOD", "MORE", "PROVIDES", "SLIGHTLY", "SPARSE", "STORAGE", "STRUCTURE", "TREE", "UPDATE", "USES", "WITH"]);
add_ocaml_element("linear", "Std.Bil.Storage.linear", "class", "<i>(... class ...)</i>", "Bap.Std.Bil.Storage.linear-c.html", "<div class=\"info\">\n<p>linear storage literally implements operational\n          semantics, but has O(N) lookup and uses space\n          very ineffectively, as it is implemented as a list\n          of assignments.</p>\n\n</div>\n", ["AND", "ASSIGNMENTS", "BUT", "HAS", "IMPLEMENTED", "IMPLEMENTS", "INEFFECTIVELY", "LINEAR", "LIST", "LITERALLY", "LOOKUP", "OPERATIONAL", "SEMANTICS", "SPACE", "STORAGE", "USES", "VERY"]);
add_ocaml_element("dfs_visitor", "Std.dfs_visitor", "class type", "<i>(... class type ...)</i>", "Graphlib.Std.dfs_visitor-c.html", "", []);
add_ocaml_element("eff", "Std.Eval.S.eff", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.S.eff-c.html", "", []);
add_ocaml_element("domain", "Std.Eval.S.domain", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.S.domain-c.html", "", []);
add_ocaml_element("semantics", "Std.Eval.S.semantics", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.S.semantics-c.html", "", []);
add_ocaml_element("eff", "Std.Eval.S2.eff", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.S2.eff-c.html", "", []);
add_ocaml_element("domain", "Std.Eval.S2.domain", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.S2.domain-c.html", "", []);
add_ocaml_element("semantics", "Std.Eval.S2.semantics", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.S2.semantics-c.html", "", []);
add_ocaml_element("eff", "Std.Eval.T2.eff", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.T2.eff-c.html", "<div class=\"info\">\n<p>interface of the computation effects</p>\n\n</div>\n", ["COMPUTATION", "EFFECTS", "INTERFACE", "THE"]);
add_ocaml_element("domain", "Std.Eval.T2.domain", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.T2.domain-c.html", "<div class=\"info\">\n<p>interface of the evaluation value domain</p>\n\n</div>\n", ["DOMAIN", "EVALUATION", "INTERFACE", "THE", "VALUE"]);
add_ocaml_element("semantics", "Std.Eval.T2.semantics", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.T2.semantics-c.html", "<div class=\"info\">\n<p>interface that describes semantics of an expression</p>\n\n</div>\n", ["DESCRIBES", "EXPRESSION", "INTERFACE", "SEMANTICS", "THAT"]);
add_ocaml_element("eff", "Std.Eval.T1.eff", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.T1.eff-c.html", "<div class=\"info\">\n<p>interface of the computation effects</p>\n\n</div>\n", ["COMPUTATION", "EFFECTS", "INTERFACE", "THE"]);
add_ocaml_element("domain", "Std.Eval.T1.domain", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.T1.domain-c.html", "<div class=\"info\">\n<p>interface of the evaluation value domain</p>\n\n</div>\n", ["DOMAIN", "EVALUATION", "INTERFACE", "THE", "VALUE"]);
add_ocaml_element("semantics", "Std.Eval.T1.semantics", "class type", "<i>(... class type ...)</i>", "Bap.Std.Eval.T1.semantics-c.html", "<div class=\"info\">\n<p>interface that describes semantics of an expression</p>\n\n</div>\n", ["DESCRIBES", "EXPRESSION", "INTERFACE", "SEMANTICS", "THAT"]);
add_ocaml_element("storage", "Std.Bil.storage", "class type", "<i>(... class type ...)</i>", "Bap.Std.Bil.storage-c.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>An interface to a memory storage.</p>\n\n</span></div>\n", ["ADDRESSABLE", "ADDRESSES", "ALIASING", "ALL", "AND", "ARE", "BILI", "BITVECTORS", "BYTE", "BYTES", "CARE", "CONSISTENCY", "DEPRECATED", "EFFICIENCY", "ENDIANNES", "FOR", "FRAMEWORK", "FROM", "INTERFACE", "MAPPING", "MEMORY", "NORMALIZED", "NOT", "OPERATIONS", "PRIMUS", "REPRENTED", "SHOULD", "STILL", "STORAGE", "STORAGES", "TAKE", "THE", "THEY", "USE", "WITH"]);
add_ocaml_element("Attr", "Text_tags.Attr", "module", "<i>(... module ...)</i>", "Text_tags.Attr.html", "<div class=\"info\">\n<p>Attributes mode.</p>\n\n</div>\n", ["ATTRIBUTES", "COLORS", "DESCRIPTION", "FOR", "MODE", "SEE", "TEXT_TAGS", "THE"]);
add_ocaml_element("Text_tags", "Text_tags", "module", "<i>(... module ...)</i>", "Text_tags.html", "", []);
add_ocaml_element("Bap_strings_unscrambler", "Bap_strings_unscrambler", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.html", "", []);
add_ocaml_element("Bap_strings_detector", "Bap_strings_detector", "module", "<i>(... module ...)</i>", "Bap_strings_detector.html", "<div class=\"info\">\n<p>String computation detector.</p>\n\n</div>\n", ["ACCESSED", "AFTER", "ALL", "ALPHABET", "ALTERNATIVE", "AND", "ANY", "APOSTERIORI", "ARE", "ASSUME", "ASSUMPTION", "ATTRIBUTE", "BETWEEN", "BLOCKS", "BUILT", "CALLED", "CHARACTERS", "CODE", "COMPETING", "COMPUTATION", "CONSIDERED", "CONTIGIOUS", "DATA", "DEFINE", "DEPEND", "DETECT", "DETECTION", "DETECTOR", "DIFFERENT", "DISTINGUISHES", "DISTINGUISHING", "DISTRIBUTION", "DOESN", "DURING", "EACH", "EITHER", "END", "ESTIMATOR", "FACT", "FIND", "FINISHED", "FINITE", "FOR", "FOUND", "FROM", "GRANULARITY", "HAVE", "HYPOTHESES", "HYPOTHESIS", "IMPLEMENTATION", "INSTEAD", "INSTRUCTION", "INSTRUCTIONS", "INTERACT", "LENGTHS", "LIKELIHOOD", "LONGER", "LOOKING", "LOOKS", "MAP", "MAXIMUM", "MODE", "MODEL", "MODES", "MORE", "MOREOVER", "NOT", "NOW", "NULL", "OBSERVED", "OBSERVING", "OCCURS", "OFTEN", "ONCE", "ONE", "OPERATES", "OPERATION", "OUR", "PARTICULAR", "PREFERS", "PRESCRIBED", "PROCESSES", "PROCESSING", "PRODUCED", "READ", "READS", "RELIES", "SEARCH", "SECOND", "SEQUENCE", "SEQUENCES", "SET", "SHOULD", "SLIGHTLY", "SOME", "SPECIFIED", "START", "STATES", "STEP", "STILL", "STRING", "SUBSEQUENCE", "SWITCHES", "SWITCHING", "TEXTUAL", "THAT", "THE", "THEN", "THERE", "THESE", "THIS", "TRIES", "TWO", "UNDER", "UNIFORM", "UNKNOWN", "USED", "USER", "USES", "VALUE", "VALUES", "WAS", "WELL", "WERE", "WHATEVER", "WHEN", "WHETHER", "WITH", "WITHOUT", "WORK", "WORKS", "WRITE", "WRITES"]);
add_ocaml_element("Index", "Bap_strings.Std.Strings.Index", "module", "<i>(... module ...)</i>", "Bap_strings.Std.Strings.Index.html", "", []);
add_ocaml_element("Scanner", "Bap_strings.Std.Strings.Scanner", "module", "<i>(... module ...)</i>", "Bap_strings.Std.Strings.Scanner.html", "", []);
add_ocaml_element("Make", "Bap_strings_unscrambler.Make", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Alphabet</span>)</code> creates an unscrambler for the given alphabet.</p>\n\n</div>\n", ["ALL", "ALPHABET", "AND", "ARE", "BECAUSE", "BEFOREHAND", "BUILD", "CHARACTERS", "CREATES", "DICTIONARY", "EFFICIENT", "ELL", "ENABLES", "ESSENTIALLY", "EXAMPLE", "FOR", "FROM", "GIVEN", "HELL", "HELLO", "HOE", "ITS", "KNOW", "KNOWN", "LANGUAGE", "LIKE", "MAKE", "PLAYING", "PRESENT", "PROVIDED", "REPRESENTATION", "REQUIRES", "SAME", "SCRABBLE", "SEARCH", "SEQUENCE", "SIZE", "TERMS", "THAT", "THE", "THEY", "TRIE", "UNSCRAMBLER", "USES", "WILL", "WORDS"]);
add_ocaml_element("Printable", "Bap_strings_unscrambler.Ascii.Printable", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.Printable.html", "<div class=\"info\">\n<p>All printable ASCII characters</p>\n\n</div>\n", ["ALL", "ASCII", "CHARACTERS", "PRINTABLE"]);
add_ocaml_element("Digits", "Bap_strings_unscrambler.Ascii.Digits", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.Digits.html", "<div class=\"info\">\n<p>Digits</p>\n\n</div>\n", ["DIGITS"]);
add_ocaml_element("Caseless", "Bap_strings_unscrambler.Ascii.Alphanum.Caseless", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.Alphanum.Caseless.html", "<div class=\"info\">\n<p>Caseless Letters</p>\n\n</div>\n", ["CASELESS", "LETTERS"]);
add_ocaml_element("Alphanum", "Bap_strings_unscrambler.Ascii.Alphanum", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.Alphanum.html", "<div class=\"info\">\n<p>Letters and Numbers</p>\n\n</div>\n", ["AND", "LETTERS", "NUMBERS"]);
add_ocaml_element("Caseless", "Bap_strings_unscrambler.Ascii.Alpha.Caseless", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.Alpha.Caseless.html", "<div class=\"info\">\n<p>Caseless Letters</p>\n\n</div>\n", ["CASELESS", "LETTERS"]);
add_ocaml_element("Alpha", "Bap_strings_unscrambler.Ascii.Alpha", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.Alpha.html", "<div class=\"info\">\n<p>Letters</p>\n\n</div>\n", ["LETTERS"]);
add_ocaml_element("Ascii", "Bap_strings_unscrambler.Ascii", "module", "<i>(... module ...)</i>", "Bap_strings_unscrambler.Ascii.html", "<div class=\"info\">\n<p>ASCII Characters</p>\n\n</div>\n", ["ALSO", "ASCII", "CHARACTER", "CHARACTERS", "DIFFERENT", "DIGITS", "PROVIDES", "SET", "SUBSETS", "THE"]);
add_ocaml_element("Unscrambler", "Bap_strings.Std.Strings.Unscrambler", "module", "<i>(... module ...)</i>", "Bap_strings.Std.Strings.Unscrambler.html", "", []);
add_ocaml_element("Detector", "Bap_strings.Std.Strings.Detector", "module", "<i>(... module ...)</i>", "Bap_strings.Std.Strings.Detector.html", "", []);
add_ocaml_element("Strings", "Bap_strings.Std.Strings", "module", "<i>(... module ...)</i>", "Bap_strings.Std.Strings.html", "", []);
add_ocaml_element("Std", "Bap_strings.Std", "module", "<i>(... module ...)</i>", "Bap_strings.Std.html", "", []);
add_ocaml_element("Bap_strings", "Bap_strings", "module", "<i>(... module ...)</i>", "Bap_strings.html", "", []);
add_ocaml_element("Bap_strings_scanner", "Bap_strings_scanner", "module", "<i>(... module ...)</i>", "Bap_strings_scanner.html", "", []);
add_ocaml_element("Make", "Bap_strings_index.Persistent.Make", "module", "<i>(... module ...)</i>", "Bap_strings_index.Persistent.Make.html", "<div class=\"info\">\n<p>Make(Key) creates an index with the given <code class=\"code\"><span class=\"constructor\">Key</span></code>.</p>\n\n</div>\n", ["CREATES", "GIVEN", "INDEX", "KEY", "MAKE", "THE", "WITH"]);
add_ocaml_element("Persistent", "Bap_strings_index.Persistent", "module", "<i>(... module ...)</i>", "Bap_strings_index.Persistent.html", "", []);
add_ocaml_element("Bap_strings_index", "Bap_strings_index", "module", "<i>(... module ...)</i>", "Bap_strings_index.html", "", []);
add_ocaml_element("Meta", "Bap_traces.Std.Meta", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Meta.html", "<div class=\"info\">\n<p>Types of meta information.</p>\n\n</div>\n", ["INFORMATION", "META", "TYPES"]);
add_ocaml_element("Trace_stats", "Bap_traces.Std.Trace_stats", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Trace_stats.html", "<div class=\"info\">\n<p>Information about the trace itself</p>\n\n</div>\n", ["ABOUT", "INFORMATION", "ITSELF", "THE", "TRACE"]);
add_ocaml_element("File_stats", "Bap_traces.Std.File_stats", "module", "<i>(... module ...)</i>", "Bap_traces.Std.File_stats.html", "<div class=\"info\">\n<p>File information.</p>\n\n</div>\n", ["FILE", "INFORMATION"]);
add_ocaml_element("Binary", "Bap_traces.Std.Binary", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Binary.html", "<div class=\"info\">\n<p>Information about a traced binary.</p>\n\n</div>\n", ["ABOUT", "BINARY", "INFORMATION", "TRACED"]);
add_ocaml_element("Tracer", "Bap_traces.Std.Tracer", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Tracer.html", "<div class=\"info\">\n<p>Information about a tracer tool.</p>\n\n</div>\n", ["ABOUT", "INFORMATION", "TOOL", "TRACER"]);
add_ocaml_element("Event", "Bap_traces.Std.Event", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Event.html", "<div class=\"info\">\n<p>Types of events.</p>\n\n</div>\n", ["EVENTS", "TYPES"]);
add_ocaml_element("Modload", "Bap_traces.Std.Modload", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Modload.html", "<div class=\"info\">\n<p>linking event</p>\n\n</div>\n", ["EVENT", "LINKING"]);
add_ocaml_element("Return", "Bap_traces.Std.Return", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Return.html", "<div class=\"info\">\n<p>A return from a call.</p>\n\n</div>\n", ["CALL", "FROM", "RETURN"]);
add_ocaml_element("Call", "Bap_traces.Std.Call", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Call.html", "<div class=\"info\">\n<p>A subroutine call.</p>\n\n</div>\n", ["CALL", "SUBROUTINE"]);
add_ocaml_element("Location", "Bap_traces.Std.Location", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Location.html", "<div class=\"info\">\n<p>A code location</p>\n\n</div>\n", ["CODE", "LOCATION"]);
add_ocaml_element("Exn", "Bap_traces.Std.Exn", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Exn.html", "<div class=\"info\">\n<p>hardware exception</p>\n\n</div>\n", ["EXCEPTION", "HARDWARE"]);
add_ocaml_element("Syscall", "Bap_traces.Std.Syscall", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Syscall.html", "<div class=\"info\">\n<p>a system call</p>\n\n</div>\n", ["CALL", "SYSTEM"]);
add_ocaml_element("Chunk", "Bap_traces.Std.Chunk", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Chunk.html", "<div class=\"info\">\n<p>Represent a memory chunk.</p>\n\n</div>\n", ["CHUNK", "MEMORY", "REPRESENT"]);
add_ocaml_element("Move", "Bap_traces.Std.Move", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Move.html", "<div class=\"info\">\n<p>Represent a movement of data</p>\n\n</div>\n", ["DATA", "MOVEMENT", "REPRESENT"]);
add_ocaml_element("Traces", "Bap_traces.Std.Traces", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Traces.html", "<div class=\"info\">\n<p>Loaded traces.</p>\n\n</div>\n", ["ADD", "AND", "CAN", "CONTAINER", "FOR", "FRONTENDS", "LOAD", "LOADED", "PLUGINS", "REPOSITORY", "STATIC", "THE", "THIS", "TRACES"]);
add_ocaml_element("Monitor", "Bap_traces.Std.Trace.Monitor", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Trace.Monitor.html", "<div class=\"info\">\n<p>Monitor defines an error handling policy.</p>\n\n</div>\n", ["DEFINES", "ERROR", "HANDLING", "MONITOR", "POLICY"]);
add_ocaml_element("Id", "Bap_traces.Std.Trace.Id", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Trace.Id.html", "", []);
add_ocaml_element("Reader", "Bap_traces.Std.Trace.Reader", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Trace.Reader.html", "<div class=\"info\">\n<p>Reader interface.</p>\n\n</div>\n", ["INTERFACE", "READER"]);
add_ocaml_element("Trace", "Bap_traces.Std.Trace", "module", "<i>(... module ...)</i>", "Bap_traces.Std.Trace.html", "<div class=\"info\">\n<p>Trace is a stream of events plus meta data.</p>\n\n</div>\n", ["ABSTRACT", "ALSO", "AND", "ANY", "ARE", "BECAUSE", "BUT", "CAN", "CHANGED", "CHANNEL", "CODATA", "CONTAIN", "CREATION", "DATA", "DETECTED", "DIDN", "DROPPED", "DURING", "ENTITY", "EVENT", "EVENTS", "EXECUTION", "FACT", "FILE", "FROM", "FUNCTION", "GIVEN", "HIDDEN", "INDEXED", "INFORMATION", "INHABITED", "INPUT", "INTERFACE", "JUST", "KNOW", "LIFETIME", "MACHINE", "MAGICALLY", "MAY", "META", "MIGHT", "NOT", "OBTAINED", "OCCUR", "PARTICULAR", "PLUS", "PROGRAM", "PROVIDE", "QUERY", "REALLY", "REGULAR", "REMOTE", "REPRESENTED", "SERVER", "SINCE", "SOME", "SOMETHING", "SOURCE", "STATE", "STREAM", "SUPPORTED", "SUPPORTS", "TAG", "THAT", "THE", "THUS", "TIME", "TOOL", "TRACE", "TRANSPORT", "TREAT", "TYPE", "UNLIKE", "USING", "USUALLY", "VALUE", "VIEWED", "VIRTUAL", "VIRTUALLY", "WASN", "WHETHER", "WITH", "WORKS", "WORTHWHILE"]);
add_ocaml_element("Std", "Bap_traces.Std", "module", "<i>(... module ...)</i>", "Bap_traces.Std.html", "<div class=\"info\">\n<p>Traces of execution.</p>\n\n</div>\n", ["EXECUTION", "TRACES"]);
add_ocaml_element("Bap_traces", "Bap_traces", "module", "<i>(... module ...)</i>", "Bap_traces.html", "", []);
add_ocaml_element("Bap_llvm_loader", "Bap_llvm_loader", "module", "<i>(... module ...)</i>", "Bap_llvm_loader.html", "", []);
add_ocaml_element("Std", "Bap_llvm.Std", "module", "<i>(... module ...)</i>", "Bap_llvm.Std.html", "<div class=\"info\">\n<p>Initialize LLVM backend.</p>\n\n</div>\n", ["BACKEND", "EXTEND", "FAR", "FUNCTIONS", "INITIALIZE", "INTERFACE", "KEEP", "LATER", "LLVM", "MAY", "MORE", "PUBLISHING", "THE", "THOUGH", "TIGHT", "VERY"]);
add_ocaml_element("Bap_llvm", "Bap_llvm", "module", "<i>(... module ...)</i>", "Bap_llvm.html", "", []);
add_ocaml_element("Service", "Bap_ida.Std.Service", "module", "<i>(... module ...)</i>", "Bap_ida.Std.Service.html", "<div class=\"info\">\n<p>Allow plugins to specify that they can provide IDA service</p>\n\n</div>\n", ["ALLOW", "CAN", "IDA", "PLUGINS", "PROVIDE", "SERVICE", "SPECIFY", "THAT", "THEY"]);
add_ocaml_element("Command", "Bap_ida.Std.Command", "module", "<i>(... module ...)</i>", "Bap_ida.Std.Command.html", "<div class=\"info\">\n<p>Commands that can be passed into an IDA session</p>\n\n</div>\n", ["CAN", "COMMANDS", "IDA", "INTO", "PASSED", "SESSION", "THAT"]);
add_ocaml_element("Ida", "Bap_ida.Std.Ida", "module", "<i>(... module ...)</i>", "Bap_ida.Std.Ida.html", "<div class=\"info\">\n<p>Interaction with ida instance</p>\n\n</div>\n", ["IDA", "INSTANCE", "INTERACTION", "WITH"]);
add_ocaml_element("Std", "Bap_ida.Std", "module", "<i>(... module ...)</i>", "Bap_ida.Std.html", "", []);
add_ocaml_element("Bap_ida", "Bap_ida", "module", "<i>(... module ...)</i>", "Bap_ida.html", "<div class=\"info\">\n<p>IDA integration.</p>\n\n</div>\n", ["BATCH", "CAN", "DATABASE", "FOR", "IDA", "INGEGRATE", "INTEGRATION", "INTERFACE", "MODE", "MODULE", "OBTAIN", "OTHER", "PLUGINS", "PROVIDE", "PROVIDED", "PROVIDES", "RUN", "RUNNING", "SCRIPT", "SERVICE", "THE", "THIS", "THROUGH", "USE", "USUALLY", "WITH", "WRITTEN"]);
add_ocaml_element("Leb128", "Bap_dwarf.Std.Leb128", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Leb128.html", "", []);
add_ocaml_element("Fbi", "Bap_dwarf.Std.Dwarf.Fbi", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Fbi.html", "<div class=\"info\">\n<p>Function boundary identification.</p>\n\n</div>\n", ["BOUNDARY", "FUNCTION", "IDENTIFICATION"]);
add_ocaml_element("Data", "Bap_dwarf.Std.Dwarf.Data", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Data.html", "", []);
add_ocaml_element("Buffer", "Bap_dwarf.Std.Dwarf.Buffer", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Buffer.html", "<div class=\"info\">\n<p>Buffer is a light abstraction over <code class=\"code\">string</code> and <code class=\"code\">bigstring</code>,\n        that can allow one to share the same string for different sections\n        without explicit copying.</p>\n\n</div>\n", ["ABSTRACTION", "ALLOW", "AND", "BIGSTRING", "BUFFER", "CAN", "COPYING", "DIFFERENT", "EXPLICIT", "FOR", "LIGHT", "ONE", "OVER", "SAME", "SECTIONS", "SHARE", "STRING", "THAT", "THE", "WITHOUT"]);
add_ocaml_element("Fn", "Bap_dwarf.Std.Dwarf.Fn", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Fn.html", "<div class=\"info\">\n<p>Function representation.</p>\n\n</div>\n", ["FUNCTION", "REPRESENTATION"]);
add_ocaml_element("Form", "Bap_dwarf.Std.Dwarf.Form", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Form.html", "<div class=\"info\">\n<p>Attribute form</p>\n\n</div>\n", ["ATTRIBUTE", "FORM"]);
add_ocaml_element("Attr", "Bap_dwarf.Std.Dwarf.Attr", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Attr.html", "<div class=\"info\">\n<p>Attribute</p>\n\n</div>\n", ["ATTRIBUTE"]);
add_ocaml_element("Tag", "Bap_dwarf.Std.Dwarf.Tag", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Tag.html", "<div class=\"info\">\n<p>Debug Entry Tag</p>\n\n</div>\n", ["DEBUG", "ENTRY", "TAG"]);
add_ocaml_element("Section", "Bap_dwarf.Std.Dwarf.Section", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.Section.html", "<div class=\"info\">\n<p>File sections</p>\n\n</div>\n", ["FILE", "SECTIONS"]);
add_ocaml_element("Dwarf", "Bap_dwarf.Std.Dwarf", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.Dwarf.html", "<div class=\"info\">\n<p>Dwarf library\n      This library gives an access to debugging information stored\n      in a binary program.</p>\n\n</div>\n", ["ACCESS", "BINARY", "DEBUGGING", "DWARF", "GIVES", "INFORMATION", "LIBRARY", "PROGRAM", "STORED", "THIS"]);
add_ocaml_element("Std", "Bap_dwarf.Std", "module", "<i>(... module ...)</i>", "Bap_dwarf.Std.html", "<div class=\"info\">\n<p>DWARF parser</p>\n\n</div>\n", ["DWARF", "PARSER"]);
add_ocaml_element("Bap_dwarf", "Bap_dwarf", "module", "<i>(... module ...)</i>", "Bap_dwarf.html", "", []);
add_ocaml_element("Demanglers", "Bap_demangle.Std.Demanglers", "module", "<i>(... module ...)</i>", "Bap_demangle.Std.Demanglers.html", "<div class=\"info\">\n<p>Registry of demanglers.</p>\n\n</div>\n", ["DEMANGLERS", "REGISTRY"]);
add_ocaml_element("Demangler", "Bap_demangle.Std.Demangler", "module", "<i>(... module ...)</i>", "Bap_demangle.Std.Demangler.html", "<div class=\"info\">\n<p>Demangler is a named string transformation.</p>\n\n</div>\n", ["DEMANGLER", "NAMED", "STRING", "TRANSFORMATION"]);
add_ocaml_element("Std", "Bap_demangle.Std", "module", "<i>(... module ...)</i>", "Bap_demangle.Std.html", "", []);
add_ocaml_element("Bap_demangle", "Bap_demangle", "module", "<i>(... module ...)</i>", "Bap_demangle.html", "<div class=\"info\">\n<p>Name demangling.</p>\n\n</div>\n", ["AND", "CAN", "CREATING", "DEMAND", "DEMANGLERS", "DEMANGLING", "FOR", "FRONENDS", "INTERFACE", "LIBRARY", "NAME", "PLUGINS", "PROVIDES", "REGISTERING", "THAT", "THIS", "USED"]);
add_ocaml_element("Bytes", "Bap_byteweight.Bytes", "module", "<i>(... module ...)</i>", "Bap_byteweight.Bytes.html", "<div class=\"info\">\n<p>Default implementation that uses memory chunk as the domain.</p>\n\n</div>\n", ["CHUNK", "DEFAULT", "DOMAIN", "IMPLEMENTATION", "MEMORY", "THAT", "THE", "USES"]);
add_ocaml_element("Make", "Bap_byteweight.Make", "module", "<i>(... module ...)</i>", "Bap_byteweight.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Corpus</span>)(<span class=\"constructor\">Trie</span>)</code> creates a Byteweight procedure,\n    that works in the <code class=\"code\"><span class=\"constructor\">Corpus</span></code> domain and uses <code class=\"code\"><span class=\"constructor\">Trie</span></code> for its\n    implementation.</p>\n\n</div>\n", ["AND", "ARE", "BYTEWEIGHT", "COMPARED", "COMPARISON", "CORPUS", "CREATES", "DOMAIN", "FOR", "GIVES", "HOW", "IMPLEMENT", "IMPLEMENTATION", "ITS", "MAKE", "MODULE", "NORMALIZED", "OPPORTUNITY", "PARTICULAR", "PROCEDURE", "SPECIFIES", "STRING", "SUBSTRINGS", "THAT", "THE", "TRIE", "USES", "WORKS"]);
add_ocaml_element("Bap_byteweight", "Bap_byteweight", "module", "<i>(... module ...)</i>", "Bap_byteweight.html", "<div class=\"info\">\n<p>Byteweight library.</p>\n\n</div>\n", ["ACCESS", "AUXILIARY", "BAP_BYTEWEIGHT_SIGNATURES", "BINARY", "BYTEWEIGHT", "FUNCTION", "FUNCTORIZED", "IDENTIFICATION", "IMPLEMENTATION", "LIBRARY", "MECHANISM", "PROVIDES", "REPOSITORY", "SIGNATURES", "START", "THE", "THIS"]);
add_ocaml_element("Bap_byteweight_signatures", "Bap_byteweight_signatures", "module", "<i>(... module ...)</i>", "Bap_byteweight_signatures.html", "<div class=\"info\">\n<p>Provides signatures storage</p>\n\n</div>\n", ["PROVIDES", "SIGNATURES", "STORAGE"]);
add_ocaml_element("Plugin_options", "Bap_build.Std.Plugin_options", "module", "<i>(... module ...)</i>", "Bap_build.Std.Plugin_options.html", "", []);
add_ocaml_element("Plugin_rules", "Bap_build.Std.Plugin_rules", "module", "<i>(... module ...)</i>", "Bap_build.Std.Plugin_rules.html", "", []);
add_ocaml_element("Std", "Bap_build.Std", "module", "<i>(... module ...)</i>", "Bap_build.Std.html", "<div class=\"info\">\n<p>bapbuild support library.</p>\n\n</div>\n", ["ACTIVATE", "AND", "BAPBUILD", "BAP_BUILD", "BEFORE_RULES", "BEHAVIOR", "CALL", "CASE", "CUSTOM", "DISPATCH", "FUNCTION", "HOOD", "INSTALL", "INSTEAD", "JUST", "LET", "LIBRARY", "MYOCAMLBUILD", "NEEDED", "OCAMLBUILD", "OCAMLBUILD_PLUGIN", "OPEN", "PHASES", "PLUGIN", "PLUGIN_OPTIONS", "PLUGIN_RULES", "POSSIBLE", "RULES", "SET", "STD", "SUPPORT", "THAT", "THE", "UNDERNEATH", "USE", "USING", "UTILITY"]);
add_ocaml_element("Bap_build", "Bap_build", "module", "<i>(... module ...)</i>", "Bap_build.html", "<div class=\"info\">\n<p>bapbuild implentation library</p>\n\n</div>\n", ["BAPBUILD", "IMPLENTATION", "LIBRARY"]);
add_ocaml_element("Mappers", "Bap_bml.Mappers", "module", "<i>(... module ...)</i>", "Bap_bml.Mappers.html", "", []);
add_ocaml_element("Unary", "Bap_bml.Ops.Unary", "module", "<i>(... module ...)</i>", "Bap_bml.Ops.Unary.html", "", []);
add_ocaml_element("Nullary", "Bap_bml.Ops.Nullary", "module", "<i>(... module ...)</i>", "Bap_bml.Ops.Nullary.html", "", []);
add_ocaml_element("Predicates", "Bap_bml.Predicates", "module", "<i>(... module ...)</i>", "Bap_bml.Predicates.html", "", []);
add_ocaml_element("Bap_bml", "Bap_bml", "module", "<i>(... module ...)</i>", "Bap_bml.html", "", []);
add_ocaml_element("Bap_c_size", "Bap_c_size", "module", "<i>(... module ...)</i>", "Bap_c_size.html", "<div class=\"info\">\n<p>An abstraction of sizeof operator.</p>\n\n</div>\n", ["ABSTRACTION", "OPERATOR", "SIZEOF"]);
add_ocaml_element("Bap_c_parser", "Bap_c_parser", "module", "<i>(... module ...)</i>", "Bap_c_parser.html", "<div class=\"info\">\n<p>A parser interface.</p>\n\n</div>\n", ["ALLOWS", "ANY", "BUT", "DOESN", "INTERFACE", "ITSELF", "MODULE", "PARSER", "PARSERS", "PARTY", "PROVIDE", "PROVIDED", "THE", "THIRD"]);
add_ocaml_element("Parser", "Bap_c.Std.C.Parser", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Parser.html", "", []);
add_ocaml_element("Mapper", "Bap_c.Std.C.Type.Mapper", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Type.Mapper.html", "", []);
add_ocaml_element("Type", "Bap_c.Std.C.Type", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Type.html", "", []);
add_ocaml_element("Size", "Bap_c.Std.C.Size", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Size.html", "", []);
add_ocaml_element("Data", "Bap_c.Std.C.Data", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Data.html", "", []);
add_ocaml_element("Attr", "Bap_c.Std.C.Attr", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Attr.html", "", []);
add_ocaml_element("Abi", "Bap_c.Std.C.Abi", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.Abi.html", "", []);
add_ocaml_element("C", "Bap_c.Std.C", "module", "<i>(... module ...)</i>", "Bap_c.Std.C.html", "", []);
add_ocaml_element("Std", "Bap_c.Std", "module", "<i>(... module ...)</i>", "Bap_c.Std.html", "", []);
add_ocaml_element("Bap_c", "Bap_c", "module", "<i>(... module ...)</i>", "Bap_c.html", "<div class=\"info\">\n<p>C language support library.</p>\n\n</div>\n", ["ABI", "ABSTRACT", "ADDS", "ALSO", "AND", "BAP_C", "BRINGS", "COMPLETE", "DATA", "DEFINES", "FAIRLY", "FOR", "INCLUDES", "INTERFACE", "LANGUAGE", "LIBRARY", "MACHINE", "MAYBE", "MODEL", "MODULE", "ONE", "ONLY", "OPEN", "PARSER", "PARTICULAR", "PARTY", "PROVIDED", "REST", "STD", "SUPPORT", "SYSTEM", "THAT", "THE", "THIRD", "THIS", "TYPE", "USE"]);
add_ocaml_element("Make", "Bap_c_type_mapper.Make", "module", "<i>(... module ...)</i>", "Bap_c_type_mapper.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> lifts the visitor into monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["INTO", "LIFTS", "MAKE", "MONAD", "THE", "VISITOR"]);
add_ocaml_element("Finder", "Bap_c_type_mapper.Finder", "module", "<i>(... module ...)</i>", "Bap_c_type_mapper.Finder.html", "<div class=\"info\">\n<p>the visitor lifted into the search monad.</p>\n\n</div>\n", ["BASE", "CODE", "END", "ENTER_POINTER", "EXAMPLE", "FIND", "FINDER", "FIND_POINTER", "FINISHED", "FIRST", "FOLLOWING", "FOR", "INHERIT", "INTO", "LET", "LIFTED", "MAPPER", "METHOD", "MODULE", "MONAD", "OBJECT", "POINTER", "RESULT", "RUN", "SEARCH", "THE", "TYPE", "VISITOR", "WILL"]);
add_ocaml_element("State", "Bap_c_type_mapper.State", "module", "<i>(... module ...)</i>", "Bap_c_type_mapper.State.html", "<div class=\"info\">\n<p>the mapper lifted into a regular state monad.</p>\n\n</div>\n", ["INTO", "LIFTED", "MAPPER", "MONAD", "REGULAR", "STATE", "THE"]);
add_ocaml_element("Search", "Bap_c_type_mapper.Search", "module", "<i>(... module ...)</i>", "Bap_c_type_mapper.Search.html", "<div class=\"info\">\n<p>Search Monad.</p>\n\n</div>\n", ["ABNORMAL", "COMPUTATION", "EXIT", "FOR", "FOUND", "ITEM", "MONAD", "SEARCH", "SEARCHING", "SOON", "TERMINATES", "THE", "WITH"]);
add_ocaml_element("Bap_c_type_mapper", "Bap_c_type_mapper", "module", "<i>(... module ...)</i>", "Bap_c_type_mapper.html", "", []);
add_ocaml_element("Stack", "Bap_c_abi.Stack", "module", "<i>(... module ...)</i>", "Bap_c_abi.Stack.html", "<div class=\"info\">\n<p>An abstraction of a stack, commonly used in C compilers.</p>\n\n</div>\n", ["ABSTRACTION", "COMMONLY", "COMPILERS", "STACK", "USED"]);
add_ocaml_element("Bap_c_abi", "Bap_c_abi", "module", "<i>(... module ...)</i>", "Bap_c_abi.html", "<div class=\"info\">\n<p>C language ABI.</p>\n\n</div>\n", ["ABI", "BUILDING", "COMMON", "FOR", "INTERFACE", "LANGUAGE", "MODULE", "MODULES", "PROVIDES", "SUPPORT", "THIS"]);
add_ocaml_element("Bap_c_term_attributes", "Bap_c_term_attributes", "module", "<i>(... module ...)</i>", "Bap_c_term_attributes.html", "<div class=\"info\">\n<p>BIR attributes.</p>\n\n</div>\n", ["ATTRIBUTES", "BIR"]);
add_ocaml_element("Bap_c_type_printer", "Bap_c_type_printer", "module", "<i>(... module ...)</i>", "Bap_c_type_printer.html", "", []);
add_ocaml_element("Bap_c_type_mapper_intf", "Bap_c_type_mapper_intf", "module", "<i>(... module ...)</i>", "Bap_c_type_mapper_intf.html", "", []);
add_ocaml_element("Bap_c_attr", "Bap_c_attr", "module", "<i>(... module ...)</i>", "Bap_c_attr.html", "<div class=\"info\">\n<p>Attribute processing.</p>\n\n</div>\n", ["ACTION", "ALLOWS", "ATTACH", "ATTRIBUTE", "ATTRIBUTES", "EACH", "FOR", "HIM", "KNOWN", "MODULE", "NOT", "NOTHING", "PROCESSING", "SEMANTIC", "SHOULD", "TERM", "THAT", "THIS", "TRANSFORMATION"]);
add_ocaml_element("Bap_c_data", "Bap_c_data", "module", "<i>(... module ...)</i>", "Bap_c_data.html", "<div class=\"info\">\n<p>C Data model.</p>\n\n</div>\n", ["ABSTRACTIONS", "ALSO", "BACKED", "BITS", "DATA", "DATUM", "DEFINES", "FOR", "INTEGER", "MODEL", "MODELS", "MODULE", "REPRESENTATION", "REPRESENTS", "SEQUENCE", "THAT", "THE", "THIS", "VALUE", "VALUES"]);
add_ocaml_element("Array", "Bap_c_type.Array", "module", "<i>(... module ...)</i>", "Bap_c_type.Array.html", "", []);
add_ocaml_element("Compound", "Bap_c_type.Compound", "module", "<i>(... module ...)</i>", "Bap_c_type.Compound.html", "", []);
add_ocaml_element("Proto", "Bap_c_type.Proto", "module", "<i>(... module ...)</i>", "Bap_c_type.Proto.html", "", []);
add_ocaml_element("Spec", "Bap_c_type.Spec", "module", "<i>(... module ...)</i>", "Bap_c_type.Spec.html", "", []);
add_ocaml_element("Attr", "Bap_c_type.Attr", "module", "<i>(... module ...)</i>", "Bap_c_type.Attr.html", "", []);
add_ocaml_element("Qualifier", "Bap_c_type.Qualifier", "module", "<i>(... module ...)</i>", "Bap_c_type.Qualifier.html", "", []);
add_ocaml_element("Bap_c_type", "Bap_c_type", "module", "<i>(... module ...)</i>", "Bap_c_type.html", "<div class=\"info\">\n<p>C Type System.</p>\n\n</div>\n", ["AND", "ANY", "ARE", "ARGS", "ATTACH", "ATTR", "ATTRIBUTES", "CONSTRUCTORS", "CONTAINTED", "DECLARATIONS", "DOESN", "EXTENDED", "FORM", "GROUPS", "POLYMORPHIC", "POSSIBLE", "REPRESENT", "REPRESENTATION", "REQUIRE", "REQUIREMENT", "SELF", "STRUCTURALLY", "SYSTEM", "THE", "TYPE", "TYPING", "USED", "VARIANTS", "WITH"]);
add_ocaml_element("Bap_abi", "Bap_abi", "module", "<i>(... module ...)</i>", "Bap_abi.html", "<div class=\"info\">\n<p>ABI dispatcher.</p>\n\n</div>\n", ["ABI", "ACCOMPANIES", "ALLOWS", "AND", "API", "ARBITRARY", "ARCHITECTURE", "BEFORE", "COMPILER", "DISPATCHER", "FUNCTIONALITY", "HAVE", "INJECT", "LANGUAGE", "LIBRARY", "MODULES", "OTHER", "PASS", "PASSES", "PHASE", "RECOGNITION", "REGISTERED", "RUN", "RUNNING", "SPECIFIC", "THAN", "THAT", "THE", "THIS", "TRANSFORMATION", "WERE"]);
add_ocaml_element("Bap_api", "Bap_api", "module", "<i>(... module ...)</i>", "Bap_api.html", "<div class=\"info\">\n<p>An interface to the api pass.</p>\n\n</div>\n", ["ABI", "ACTUALLY", "API", "APPLIED", "APPLY", "ARCHITECTURES", "ARE", "CORRESPONDING", "EVEN", "HIGH", "INFORMATION", "INTERFACE", "LANGUAGE", "LANGUAGES", "LEVEL", "LOW", "LOWER", "MODEL", "MODULE", "MODULES", "PASS", "PLUGINS", "PROCESSORS", "PROGRAM", "PROVIDE", "PROVIDED", "REGISTRY", "REPRESENTATION", "REQUIRED", "SOMETIMES", "SPECIFIC", "STATIC", "SUPPORTING", "SUPPORTS", "TERM", "THAT", "THE", "WILL"]);
add_ocaml_element("X86_asm_reg_types", "X86_asm_reg_types", "module", "<i>(... module ...)</i>", "X86_asm_reg_types.html", "<div class=\"info\">\n<p>Basic register types of all supported X86 registers.</p>\n\n</div>\n", ["ALL", "BASIC", "REGISTER", "REGISTERS", "SUPPORTED", "TYPES", "X86"]);
add_ocaml_element("AMD64", "X86_cpu.AMD64", "module", "<i>(... module ...)</i>", "X86_cpu.AMD64.html", "<div class=\"info\">\n<p>AMD64 registers</p>\n\n</div>\n", ["AMD64", "REGISTERS"]);
add_ocaml_element("IA32", "X86_cpu.IA32", "module", "<i>(... module ...)</i>", "X86_cpu.IA32.html", "<div class=\"info\">\n<p>IA32 Architecture Registers.</p>\n\n</div>\n", ["AND", "ARCHITECTURE", "BIT", "BOTH", "CONTRARY", "EXAMPLE", "FOR", "FORMER", "HAS", "HOWEVER", "IA32", "LATTER", "MODE", "NAME", "NAMES", "PROCESSORS", "RAX", "REGISTER", "REGISTERS", "SAME", "SIMPLICITY", "THE", "USING"]);
add_ocaml_element("X86_cpu", "X86_cpu", "module", "<i>(... module ...)</i>", "X86_cpu.html", "", []);
add_ocaml_element("Reg", "X86_asm.Reg", "module", "<i>(... module ...)</i>", "X86_asm.Reg.html", "", []);
add_ocaml_element("X86_asm", "X86_asm", "module", "<i>(... module ...)</i>", "X86_asm.html", "", []);
add_ocaml_element("X86_llvm_env", "X86_llvm_env", "module", "<i>(... module ...)</i>", "X86_llvm_env.html", "<div class=\"info\">\n<p>This module exposes register functionality that is based on\n    LLVM's disassembler.</p>\n\n</div>\n", ["ARE", "BACKEND", "BASED", "DISASSEMBLER", "DISASSEMBLING", "EXPOSES", "FUNCTIONALITY", "LLVM", "MODULE", "ONLY", "REGISTER", "THAT", "THIS", "USEFUL", "USING", "X86", "YOU"]);
add_ocaml_element("R64", "X86_env.R64", "module", "<i>(... module ...)</i>", "X86_env.R64.html", "<div class=\"info\">\n<p>64-bit mode registers</p>\n\n</div>\n", ["BIT", "MODE", "REGISTERS"]);
add_ocaml_element("R32", "X86_env.R32", "module", "<i>(... module ...)</i>", "X86_env.R32.html", "<div class=\"info\">\n<p>32-bit mode registers</p>\n\n</div>\n", ["BIT", "MODE", "REGISTERS"]);
add_ocaml_element("X86_env", "X86_env", "module", "<i>(... module ...)</i>", "X86_env.html", "", []);
add_ocaml_element("Pcmpstr", "X86_types.Pcmpstr", "module", "<i>(... module ...)</i>", "X86_types.Pcmpstr.html", "<div class=\"info\">\n<p>See section 4.1 of the Intel\194\174 64 and IA-32 Architectures Software\n   Developer\226\128\153s Manual, Volumes 2A &amp; 2B: Instruction Set Reference\n   (order numbers 253666 and 253667)</p>\n\n</div>\n", ["253666", "253667", "AND", "ARCHITECTURES", "DEVELOPER", "INSTRUCTION", "INTEL", "MANUAL", "NUMBERS", "ORDER", "REFERENCE", "SECTION", "SEE", "SET", "SOFTWARE", "THE", "VOLUMES"]);
add_ocaml_element("BV", "X86_types.BV", "module", "<i>(... module ...)</i>", "X86_types.BV.html", "", []);
add_ocaml_element("X86_types", "X86_types", "module", "<i>(... module ...)</i>", "X86_types.html", "", []);
add_ocaml_element("X86_asm_reg", "X86_asm_reg", "module", "<i>(... module ...)</i>", "X86_asm_reg.html", "", []);
add_ocaml_element("CPU", "Arm_lifter.CPU", "module", "<i>(... module ...)</i>", "Arm_lifter.CPU.html", "", []);
add_ocaml_element("Arm_lifter", "Arm_lifter", "module", "<i>(... module ...)</i>", "Arm_lifter.html", "", []);
add_ocaml_element("Arm_helpers", "Arm_helpers", "module", "<i>(... module ...)</i>", "Arm_helpers.html", "", []);
add_ocaml_element("Arm_reg", "Arm_reg", "module", "<i>(... module ...)</i>", "Arm_reg.html", "", []);
add_ocaml_element("Basic", "Arm_types.Basic", "module", "<i>(... module ...)</i>", "Arm_types.Basic.html", "", []);
add_ocaml_element("Arm_types", "Arm_types", "module", "<i>(... module ...)</i>", "Arm_types.html", "", []);
add_ocaml_element("Arm_cond", "Arm_cond", "module", "<i>(... module ...)</i>", "Arm_cond.html", "", []);
add_ocaml_element("Arm_mov", "Arm_mov", "module", "<i>(... module ...)</i>", "Arm_mov.html", "", []);
add_ocaml_element("Arm_shift", "Arm_shift", "module", "<i>(... module ...)</i>", "Arm_shift.html", "", []);
add_ocaml_element("Op", "ARM.Op", "module", "<i>(... module ...)</i>", "ARM.Op.html", "", []);
add_ocaml_element("Reg", "ARM.Reg", "module", "<i>(... module ...)</i>", "ARM.Reg.html", "", []);
add_ocaml_element("Cond", "ARM.Cond", "module", "<i>(... module ...)</i>", "ARM.Cond.html", "", []);
add_ocaml_element("Insn", "ARM.Insn", "module", "<i>(... module ...)</i>", "ARM.Insn.html", "", []);
add_ocaml_element("ARM", "ARM", "module", "<i>(... module ...)</i>", "ARM.html", "", []);
add_ocaml_element("Arm_branch", "Arm_branch", "module", "<i>(... module ...)</i>", "Arm_branch.html", "", []);
add_ocaml_element("Arm_bit", "Arm_bit", "module", "<i>(... module ...)</i>", "Arm_bit.html", "", []);
add_ocaml_element("Arm_op", "Arm_op", "module", "<i>(... module ...)</i>", "Arm_op.html", "", []);
add_ocaml_element("Arm_mem", "Arm_mem", "module", "<i>(... module ...)</i>", "Arm_mem.html", "", []);
add_ocaml_element("Arm_env", "Arm_env", "module", "<i>(... module ...)</i>", "Arm_env.html", "", []);
add_ocaml_element("Arm_flags", "Arm_flags", "module", "<i>(... module ...)</i>", "Arm_flags.html", "", []);
add_ocaml_element("Arm_mem_shift", "Arm_mem_shift", "module", "<i>(... module ...)</i>", "Arm_mem_shift.html", "", []);
add_ocaml_element("Arm_utils", "Arm_utils", "module", "<i>(... module ...)</i>", "Arm_utils.html", "", []);
add_ocaml_element("Arm_mul", "Arm_mul", "module", "<i>(... module ...)</i>", "Arm_mul.html", "", []);
add_ocaml_element("Arm_insn", "Arm_insn", "module", "<i>(... module ...)</i>", "Arm_insn.html", "", []);
add_ocaml_element("Rule", "Bare.Rule", "module", "<i>(... module ...)</i>", "Bare.Rule.html", "<div class=\"info\">\n<p>Matching rule specification.</p>\n\n</div>\n", ["ALSO", "AND", "ANOTHER", "APPLYING", "COMPLETION", "CONSISTS", "FACT", "FACTS", "MATCHING", "PARTIAL", "PRODUCE", "REACHED", "RULE", "SEQUENCE", "SOME", "SPECIFICATION", "STATE", "STATES", "STORE", "THAT", "THE", "THUS", "WILL"]);
add_ocaml_element("Bare", "Bare", "module", "<i>(... module ...)</i>", "Bare.html", "", []);
add_ocaml_element("Exn", "Std.Primus.Exn", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Exn.html", "<div class=\"info\">\n<p>Primus error.</p>\n\n</div>\n", ["ERROR", "PRIMUS"]);
add_ocaml_element("Make", "Std.Primus.Lisp.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Make.html", "<div class=\"info\">\n<p>Make(Machine) creates a Lisp machine embedded into the\n          Primus <code class=\"code\"><span class=\"constructor\">Machine</span></code>.</p>\n\n</div>\n", ["CREATES", "EMBEDDED", "INTO", "LISP", "MACHINE", "MAKE", "PRIMUS", "THE"]);
add_ocaml_element("Primitive", "Std.Primus.Lisp.Primitive", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Primitive.html", "", []);
add_ocaml_element("Message", "Std.Primus.Lisp.Message", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Message.html", "<div class=\"info\">\n<p>Lisp Machine Message interface.</p>\n\n</div>\n", ["ABSTRACT", "ARE", "BUT", "COULD", "INTERFACE", "LISP", "MACHINE", "MESSAGE", "MESSAGES", "MSG", "PRIMITIVE", "PRINTED", "SENT", "THE", "THEY", "WITH"]);
add_ocaml_element("Spec", "Std.Primus.Lisp.Type.Spec", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Type.Spec.html", "<div class=\"info\">\n<p>Type Specifier DSL.</p>\n\n</div>\n", ["ALL", "AND", "ANY", "ARE", "ARGUMENTS", "BOOL", "BOUND", "BUILD", "BYTE", "CAN", "CONSISTS", "COULD", "DSL", "EXAMPLES", "FOLLOWED", "FOR", "INT", "LANGUAGE", "LISP", "LIST", "NUMBER", "ONE", "OPERATOR", "PARAMETER", "PARAMETERS", "PARAMS", "PARTS", "PRIMITIVES", "PRIMUS", "PROVIDED", "RETURN", "SAME", "SEPARATED", "SHORTCUTS", "SIGNATURE", "SIGNATURES", "SPECIAL", "SPECIFIED", "SPECIFIER", "SYM", "THE", "THEY", "TUPLE", "TWO", "TYPE", "VALUE", "VARIABLE", "WITH", "WORD"]);
add_ocaml_element("Type", "Std.Primus.Lisp.Type", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Type.html", "<div class=\"info\">\n<p>Lisp Type System.</p>\n\n</div>\n", ["EQUIPPED", "FEATURES", "GRADUAL", "INFERENCE", "LISP", "PRIMUS", "SYSTEM", "THAT", "THE", "TYPE", "WITH"]);
add_ocaml_element("Make", "Std.Primus.Lisp.Doc.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.Make.html", "", []);
add_ocaml_element("Descr", "Std.Primus.Lisp.Doc.Descr", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.Descr.html", "", []);
add_ocaml_element("Name", "Std.Primus.Lisp.Doc.Name", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.Name.html", "", []);
add_ocaml_element("Category", "Std.Primus.Lisp.Doc.Category", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.Category.html", "", []);
add_ocaml_element("Doc", "Std.Primus.Lisp.Doc", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.html", "", []);
add_ocaml_element("Load", "Std.Primus.Lisp.Load", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.Load.html", "<div class=\"info\">\n<p>Primus Lisp program loader</p>\n\n</div>\n", ["LISP", "LOADER", "PRIMUS", "PROGRAM"]);
add_ocaml_element("Lisp", "Std.Primus.Lisp", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Lisp.html", "<div class=\"info\">\n<p>Lisp machine.</p>\n\n</div>\n", ["000", "0X00", "0X0A", "0X20", "0X2C", "0X63", "0X64", "0X65", "0X68", "0X6C", "0X6F", "0X72", "0X75", "0X77", "0XDEAD", "68656C", "6F2C2063", "ABI", "ABOVE", "ABSENCE", "ABSTRACTIONS", "ACCEPTS", "ACCOMPANYING", "ADD", "ADDED", "ADDR", "ADDRESS", "ADDS", "ADVICE", "ADVISED", "ADVISOR", "ADVISORS", "AFTER", "AKA", "ALL", "ALLOWS", "ALONG", "ALREADY", "ALSO", "ALTHOUGH", "ALWAYS", "AND", "ANNOTATIONS", "ANOTHER", "ANY", "ANYMORE", "APPLICABLE", "APPLICATION", "APPLIED", "APPLIES", "APPLYING", "APPROXIMATION", "ARBITRARY", "ARCH", "ARCHITECTURE", "ARE", "ARG", "ARGM", "ARGN", "ARGUMENT", "ARGUMENTS", "ARITY", "ARM", "ARMV7", "ASCII", "ASSEMBLE", "ASSEMBLED", "ASSEMBLER", "ASSOCIATED", "ATOM", "ATOMS", "ATTACHED", "ATTRIBUTE", "ATTRIBUTES", "AVAILABLE", "BACKSLASH", "BASED", "BASIC", "BEAR", "BECOMES", "BEFORE", "BEHAVIOR", "BELOW", "BETTER", "BIGGER", "BIN", "BINARIES", "BINDING", "BINDINGS", "BINDS", "BIT", "BITS", "BLOCK", "BLOCKS", "BNF", "BODY", "BOTH", "BOUND", "BUILDING", "BUT", "BYTE", "BYTES", "CALL", "CALLED", "CAN", "CDECL", "CERTAIN", "CHANGE", "CHAR", "CHARACTER", "CHARACTERS", "CHOSEN", "CLASS", "CLOSE", "CODE", "COLLECTION", "COMBINES", "COMMENT", "COMMON", "COMPENSATED", "COMPLETE", "COMPLEX", "COMPUTATIONAL", "CONCRETE", "COND", "CONDITIONALS", "CONSEQUENT", "CONSIDERED", "CONSTANT", "CONSTANTS", "CONSTITUTES", "CONSTRUCTOR", "CONSTRUCTS", "CONTAIN", "CONTEXT", "CONTEXTS", "CONTROL", "CONVENTIONS", "CORRESPONDING", "COUNTING", "CPU", "CREATED", "CRUEL", "CURRENT", "CURRENTLY", "CYCLES", "DATA", "DEBUGGING", "DECIMAL", "DECLARATION", "DECLARATIONS", "DECLARE", "DECLARED", "DEFCONSTANT", "DEFINE", "DEFINED", "DEFINES", "DEFINITION", "DEFINITIONS", "DEFINITON", "DEFMACRO", "DEFMETHOD", "DEFPARAMETER", "DEFSUBST", "DEFSUBT", "DEFUN", "DELIMITED", "DENOTE", "DENOTED", "DENOTES", "DEPENDENCIES", "DEPENDENT", "DEPENDING", "DERIVED", "DESCRIBED", "DIALECT", "DIFFERENT", "DIGIT", "DIGITS", "DIRECTLY", "DIRECTORIES", "DISPATCHED", "DOCSTRING", "DOCUMENTATION", "DOESN", "DOLLAR", "DOMAIN", "DOUBLE", "DUMPS", "DURING", "EACH", "EITHER", "ELEMENT", "ELSE", "EMACS", "EMBEDDED", "EMPTY", "EMULATOR", "ENABLES", "ENCODE", "ENCODING", "ENTITIES", "ENTITY", "ENVIRONMENT", "EQUAL", "ERROR", "ETC", "EVALUATE", "EVALUATED", "EVALUATES", "EVALUATION", "EVEN", "EVERY", "EXAMPLE", "EXCEPT", "EXISTING", "EXP", "EXPANDED", "EXPANSION", "EXPANSIONS", "EXPECTED", "EXPLORING", "EXPR", "EXPRESSION", "EXPRESSIONS", "EXTENDING", "EXTENSIBLE", "EXTENSION", "EXTERNAL", "EXTRA", "FACILITIES", "FACILITY", "FALSE", "FAMILY", "FEATURE", "FEATURES", "FEWER", "FILE", "FILES", "FINALLY", "FIRST", "FIXED", "FLAT", "FLOW", "FMT", "FOLD", "FOLLOWING", "FOLLOWS", "FOR", "FORALL", "FORM", "FORMAL", "FORMALLY", "FORMAT", "FORMATTING", "FORMED", "FORMS", "FRAGMENTS", "FREE", "FROM", "FUNCTION", "FUNCTIONS", "GATHERED", "GENERAL", "GENERALIZATION", "GENERATES", "GET", "GETOPT", "GIVE", "GIVEN", "GNUEABI", "GOOD", "GRAMMAR", "GREATER", "HANDLER", "HANDLERS", "HAPPEN", "HAPPENS", "HAS", "HAVE", "HEAP", "HELLO", "HEX", "HEXADECIMAL", "HEXDUMP", "HOC", "HOST", "HOWEVER", "IDENT", "IDENTIFIED", "IDENTIFIER", "IGNORED", "IMPLEMENTATION", "IMPLEMENTED", "IMPLEMENTS", "INCLUDE", "INCR", "INDUCES", "INITIALIZATION", "INSIDE", "INSTANCES", "INT", "INTERACT", "INTERPRETER", "INTERPRETS", "INTO", "INTRODUCE", "INTRODUCED", "INTRUSIVE", "INVOKED", "ITERATIONS", "ITERATOR", "ITH", "ITS", "ITSELF", "JUST", "KINDS", "KNOWN", "LANGUAGE", "LANGUAGES", "LAST", "LATTER", "LEFT", "LEN", "LENGTH", "LET", "LEVEL", "LEXICAL", "LIBRARY", "LIKE", "LIMITATION", "LIMITED", "LIMITS", "LIPS", "LISP", "LIST", "LITERALLY", "LOADED", "LOGGING", "LOOPING", "LOOPS", "LOW", "MACHINE", "MACRO", "MACROS", "MAIN", "MAKE", "MAKES", "MAKING", "MALLOC", "MANIPULATED", "MANY", "MATCH", "MATCHES", "MAXIMUM", "MAY", "MAYBE", "MEANS", "MECHANIMS", "MECHANISM", "MEMORY", "MESSAGE", "MESSAGES", "MESSAGING", "META", "METAPROGRAM", "METAPROGRAMMING", "METAVARIABLES", "METHOD", "METHODS", "MITIGATE", "MODEL", "MODULE", "MORE", "MOST", "MSG", "MULTIPLE", "MUST", "NAME", "NAMED", "NAMES", "NAMESPACE", "NATIVE", "NATURAL", "NEED", "NEEDED", "NEITHER", "NEW", "NEWLY", "NEXT", "NON", "NOR", "NORMAL", "NORMALIZED", "NOT", "NOTATION", "NOTE", "NOTHING", "NULL", "NUMBER", "NUMBERS", "OBSERVATION", "OBSERVING", "OCCURRENCE", "OCCURRENCES", "OCCURS", "OCTAL", "OFFSETS", "ONE", "ONLY", "ONTO", "OPERATE", "OPERATES", "OPTIMIZATION", "OPTIONALLY", "ORDER", "ORDINARY", "OTHER", "OTHERWISE", "OUTSIDE", "OVER", "OVERLOADING", "OVERRIDE", "OVERVIEW", "PAIR", "PARAM", "PARAMETER", "PARAMETERS", "PARAMETRIC", "PARENTHESES", "PARSE", "PARSED", "PARSING", "PASSED", "PERSPECTIVE", "PIECE", "POINTED", "POINTS", "POLYMORPHIC", "POLYMORPHISM", "POSIX", "POSSIBLE", "POSSIBLY", "POWERFUL", "POWERFULL", "POWERSET", "PRACTICE", "PREFIXED", "PRIMARILY", "PRIMITIVE", "PRIMUS", "PROCESS", "PROCLAIMS", "PRODUCTION", "PROG", "PROGRAM", "PROGRAMMER", "PROGRAMMING", "PROVIDE", "PROVIDED", "PROVIDES", "PROVIDING", "QUITE", "QUOTES", "RANGES", "READ", "REAL", "REALLY", "RECEIVES", "RECOGNIZED", "RECURSION", "REFLECTED", "RELATION", "RENDERED", "REPRESENT", "REPRESENTED", "REQUEST", "REQUESTED", "REQUESTS", "REQUIRE", "REQUIRED", "RESOLUTION", "RESOLVING", "REST", "RESULT", "RETURN", "RETURNED", "RETURNS", "REWRITES", "REWRITING", "REWRITTEN", "RIGHT", "RULE", "RULES", "RUNTIME", "SAME", "SCALAR", "SCOPE", "SEARCHED", "SECOND", "SECTION", "SEEN", "SELECTION", "SENSE", "SENT", "SEQUENCE", "SEQUENCING", "SERIES", "SET", "SETTING", "SEVERAL", "SHARED", "SHOULD", "SHOULDN", "SIDE", "SIGN", "SIGNAL", "SIGNALING", "SIGNALS", "SIMILAR", "SIMPLEST", "SINCE", "SIZE", "SIZEOF", "SLIGHTLY", "SMALL", "SOME", "SPECIAL", "SPECIFIC", "SPECIFICATION", "SPECIFICATIONS", "SPECIFIED", "SPECIFY", "SPLIT", "SQUARE", "STACK", "STANDARD", "STANDS", "START", "STARTING", "STEP", "STILL", "STOP", "STRING", "STRINGS", "STRLEN", "STRUCTURE", "STUBS", "SUBSEQUENCES", "SUBSET", "SUBSTITUTED", "SUBSTITUTES", "SUBSTITUTION", "SUBSTITUTIONS", "SUBSYSTEM", "SUBTYPE", "SUBTYPING", "SUITABLE", "SUM", "SUMMARIES", "SUPPORT", "SUPPOSE", "SYM", "SYMBOLS", "SYNTACTIC", "SYNTAX", "SYNTAXES", "SYSTEM", "TAG", "TAIL", "TAKES", "TASKS", "TEMPLATE", "TEN", "TERM", "TERMINATED", "TERMS", "TEST", "TEXT", "TEXTUAL", "THAN", "THAT", "THE", "THEM", "THEME", "THEN", "THERE", "THEY", "THIS", "THREE", "THUS", "TIME", "TOP", "TRANSFORMATION", "TRANSFORMATIONS", "TRANSFORMS", "TREATED", "TRIES", "TURING", "TWO", "TYPE", "TYPES", "UNDER", "UNIT", "UNLESS", "UNLIKE", "UNMATCHED", "UNSPECIFIED", "USE", "USED", "USEFUL", "USES", "USING", "USUALLY", "VALUE", "VALUES", "VAR", "VARIABLES", "VERSATILE", "VERY", "VISIBLE", "WAS", "WAY", "WELL", "WHEN", "WHERE", "WHICH", "WHILE", "WIDTH", "WIDTHS", "WILL", "WITH", "WITHOUT", "WORD", "WORDS", "WORLD", "WOULD", "WRITE", "WRITES", "WRITING", "WRITTEN", "X86", "ZERO"]);
add_ocaml_element("Make", "Std.Primus.Memory.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Memory.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Machine</span>)</code> lifts the memory interface into the\n          <code class=\"code\"><span class=\"constructor\">Machine</span></code> monad.</p>\n\n</div>\n", ["INTERFACE", "INTO", "LIFTS", "MACHINE", "MAKE", "MEMORY", "MONAD", "THE"]);
add_ocaml_element("Memory", "Std.Primus.Memory", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Memory.html", "<div class=\"info\">\n<p>Virtual memory.</p>\n\n</div>\n", ["ADDRESSABLE", "BYTE", "MACHINE", "MEMORY", "THE", "VIRTUAL"]);
add_ocaml_element("Make", "Std.Primus.Env.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Env.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Env</span>&nbsp;=&nbsp;<span class=\"constructor\">Make</span>(<span class=\"constructor\">Machine</span>)</code></p>\n\n</div>\n", ["ENV", "MACHINE", "MAKE"]);
add_ocaml_element("Env", "Std.Primus.Env", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Env.html", "<div class=\"info\">\n<p>Evaluation environemnt.</p>\n\n</div>\n", ["BINDS", "ENVIRONEMNT", "ENVIRONMENT", "EVALUATION", "THE", "VALUES", "VARIABLES"]);
add_ocaml_element("Make", "Std.Primus.Generator.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Generator.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Machine</span>)</code> lifts the generator interface into the\n          Machine monad.</p>\n\n</div>\n", ["GENERATOR", "INTERFACE", "INTO", "LIFTS", "MACHINE", "MAKE", "MONAD", "THE"]);
add_ocaml_element("Seeded", "Std.Primus.Generator.Random.Seeded", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Generator.Random.Seeded.html", "<div class=\"info\">\n<p>Self seeded generators.</p>\n\n</div>\n", ["CLONE", "DERIVED", "FROM", "GENERATORS", "IDENTIFIER", "MACHINE", "SEEDED", "SELF", "THE", "THESE", "VALUE", "WILL"]);
add_ocaml_element("Random", "Std.Primus.Generator.Random", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Generator.Random.html", "<div class=\"info\">\n<p>Random Number Generators</p>\n\n</div>\n", ["GENERATORS", "NUMBER", "RANDOM"]);
add_ocaml_element("Generator", "Std.Primus.Generator", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Generator.html", "<div class=\"info\">\n<p>Value generators</p>\n\n</div>\n", ["GENERATORS", "VALUE"]);
add_ocaml_element("Iterator", "Std.Primus.Iterator", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Iterator.html", "<div class=\"info\">\n<p>Iterator is a sequence of values of some domain.</p>\n\n</div>\n", ["ABSTRACTION", "ANOTHER", "DOMAIN", "ITERATOR", "JUST", "REPRESENT", "SEQUENCE", "SOME", "THAT", "VALUES"]);
add_ocaml_element("Make", "Std.Primus.Linker.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Linker.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Machine</span>)</code> parametrize the <code class=\"code\"><span class=\"constructor\">Linker</span></code> with the <code class=\"code\"><span class=\"constructor\">Machine</span></code>.</p>\n\n</div>\n", ["ABSOLUTELY", "ALL", "AND", "ANY", "COMPONENTS", "CONTAIN", "CORRECT", "CREATE", "DOESN", "EFFECT", "FREE", "FUNCTIONAL", "FUNCTOR", "INSTANCES", "INSTATIATION", "ITSELF", "LINKER", "MACHINE", "MAKE", "MULTIPLE", "NEEDED", "NON", "NOTE", "OTHER", "PARAMETRIZE", "PRIMUS", "PURELY", "SAFE", "SIDE", "STATE", "STATELESS", "STORED", "SYNTACTIC", "THAT", "THE", "THEY", "THUS", "TOTALY", "VALUES", "WELL", "WITH"]);
add_ocaml_element("Name", "Std.Primus.Linker.Name", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Linker.Name.html", "", []);
add_ocaml_element("Trace", "Std.Primus.Linker.Trace", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Linker.Trace.html", "<div class=\"info\">\n<p>Call tracing.</p>\n\n</div>\n", ["AND", "ARE", "ARGUMENTS", "BIR", "BOTH", "BUT", "CALL", "CALLED", "CARE", "CHUNKS", "CODE", "COMPUTATION", "CONVENIENT", "CORRESPONDING", "DATA", "DEFAULT", "DOESN", "ENTERED", "EXECUTABLE", "EXTERNALLY", "FLOW", "FREE", "FUNCTION", "FUNCTIONS", "HOWEVER", "INTERPETER", "INTERPRETER", "LEFT", "LINKER", "LISP", "MAKE", "MALLOC", "NAMES", "OBSERVATIONS", "ONLY", "OPERATE", "PRIMUS", "PROVIDE", "PROVIDED", "PROVIDER", "PROVIDES", "RATHER", "RESPONSIBILITY", "SINCE", "SUBROUTINE", "SUBROUTINES", "TERMS", "THE", "THERE", "THOUGH", "TRACING", "TRACK", "UNITERPRETED", "VISIBLE", "WHEN"]);
add_ocaml_element("Linker", "Std.Primus.Linker", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Linker.html", "<div class=\"info\">\n<p>Machine Linker.</p>\n\n</div>\n", ["CODE", "COMPUTATION", "DYNAMICALLY", "EXTENDS", "FUNCTOR", "LINKER", "MACHINE", "NEW", "PERFORMS", "PROGRAM", "PROVIDED", "REPRESENTED", "THAT", "THE", "USING", "WITH"]);
add_ocaml_element("Make", "Std.Primus.Interpreter.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Interpreter.Make.html", "<div class=\"info\">\n<p>Make(Machine) makes an interpreter that computes in the\n          given <code class=\"code\"><span class=\"constructor\">Machine</span></code>.</p>\n\n</div>\n", ["COMPUTES", "GIVEN", "INTERPRETER", "MACHINE", "MAKE", "MAKES", "THAT", "THE"]);
add_ocaml_element("Interpreter", "Std.Primus.Interpreter", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Interpreter.html", "<div class=\"info\">\n<p>The Interpreter.</p>\n\n</div>\n", ["ABILITY", "AFFECT", "AFFECTING", "AND", "ARE", "CAN", "COMPONENTS", "COMPONET", "CORE", "CORRESPONDS", "DENOTE", "DOCUMENTATION", "DURING", "ENVIRONEMNT", "EVALUATION", "EVENT", "EVERY", "FACT", "FUN", "GIVING", "HAPPENS", "INTERPRETER", "LIMITED", "LOTS", "MACHINE", "MEMORY", "NAME", "NOTATION", "NOTE", "OBSERVATION", "OBSERVATIONS", "OTHER", "PRIMUS", "PROGRAM", "PROVIDES", "REPRESENTED", "RESULTS", "STATE", "THAT", "THE", "TRACK", "TUPLE", "USED", "VALUE", "WAY", "WITH"]);
add_ocaml_element("Index", "Std.Primus.Value.Index", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Value.Index.html", "<div class=\"info\">\n<p>Indexing strings by values.</p>\n\n</div>\n", ["INDEXING", "STRINGS", "VALUES"]);
add_ocaml_element("Symbol", "Std.Primus.Value.Make.Symbol", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Value.Make.Symbol.html", "<div class=\"info\">\n<p>Symbol Value Isomorphism.</p>\n\n</div>\n", ["ABSTRACTION", "ALL", "ANALYSIS", "AND", "ARE", "BACK", "BEFORE", "BETWEEN", "BIJECTION", "BIJECTIVE", "CALL", "CAN", "COMPONENTS", "COMPUTATION", "DATA", "DEPENDS", "EACH", "EMBED", "ENCOURAGED", "ENFORCED", "HAVE", "IMPLEMENT", "IMPLEMENTORS", "INDEX", "INJECT", "INTERNED", "INTERNING", "INTO", "ISOMORPHISM", "ITS", "MACHINE", "MAPPED", "MAPPING", "MODULE", "MOREOVER", "NOT", "ORDER", "OWN", "PRIMUS", "RELATION", "REPRESENT", "REPRESENTATION", "REPRESENTED", "SEE", "SHALL", "SINCE", "STATEMENTS", "STRING", "SYMBOL", "SYMBOLIC", "SYMBOLS", "THAT", "THE", "THEIR", "TO_VALUE", "TRANSLATED", "TYPE", "USE", "USEFULL", "USING", "VALUE", "VALUES", "WITH"]);
add_ocaml_element("Syntax", "Std.Primus.Value.Make.Syntax", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Value.Make.Syntax.html", "<div class=\"info\">\n<p>Int-like syntax.</p>\n\n</div>\n", ["INT", "LIKE", "SYNTAX"]);
add_ocaml_element("Make", "Std.Primus.Value.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Value.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Machine</span>)</code> provides an interface to the Value type\n          lifted into the <code class=\"code\"><span class=\"constructor\">Machine</span></code> monad.</p>\n\n</div>\n", ["INTERFACE", "INTO", "LIFTED", "MACHINE", "MAKE", "MONAD", "PROVIDES", "THE", "TYPE", "VALUE"]);
add_ocaml_element("Id", "Std.Primus.Value.Id", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Value.Id.html", "", []);
add_ocaml_element("Value", "Std.Primus.Value", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Value.html", "<div class=\"info\">\n<p>A result of computation.</p>\n\n</div>\n", ["ABSTRACT", "AND", "BASICALLY", "COMPUTATION", "CONSISTS", "EACH", "HAS", "IDENTIFIER", "MACHINE", "NORMALLY", "PAIR", "PRODUCES", "RESULT", "TERMINATES", "THAT", "THE", "UNIQUE", "VALUE", "WORD"]);
add_ocaml_element("Main", "Std.Primus.Machine.Main", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.Main.html", "<div class=\"info\">\n<p>Primus Entry Point.</p>\n\n</div>\n", ["ENTRY", "POINT", "PRIMUS"]);
add_ocaml_element("Global", "Std.Primus.Machine.S.Global", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.S.Global.html", "<div class=\"info\">\n<p>Global state shared across all machine clones.</p>\n\n</div>\n", ["ACROSS", "ALL", "CLONES", "GLOBAL", "MACHINE", "SHARED", "STATE"]);
add_ocaml_element("Local", "Std.Primus.Machine.S.Local", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.S.Local.html", "<div class=\"info\">\n<p>Local state of the machine.</p>\n\n</div>\n", ["LOCAL", "MACHINE", "STATE", "THE"]);
add_ocaml_element("Syntax", "Std.Primus.Machine.S.Syntax", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.S.Syntax.html", "<div class=\"info\">\n<p>Computation Syntax.</p>\n\n</div>\n", ["COMPUTATION", "SYNTAX"]);
add_ocaml_element("Observation", "Std.Primus.Machine.S.Observation", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.S.Observation.html", "<div class=\"info\">\n<p>Observations interface.</p>\n\n</div>\n", ["INTERFACE", "OBSERVATIONS"]);
add_ocaml_element("Make", "Std.Primus.Machine.Make", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Monad</span>)</code> a monad transformer that wraps the Machine\n          into an arbitrary <code class=\"code\"><span class=\"constructor\">Monad</span></code>.</p>\n\n</div>\n", ["ARBITRARY", "INTO", "MACHINE", "MAKE", "MONAD", "THAT", "THE", "TRANSFORMER", "WRAPS"]);
add_ocaml_element("State", "Std.Primus.Machine.State", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.State.html", "<div class=\"info\">\n<p>Machine State.</p>\n\n</div>\n", ["ABSTRACT", "ACROSS", "ALL", "AND", "ANY", "BASICALLY", "BETWEEN", "CAN", "CHANNEL", "CLONE", "CLONED", "CLONES", "COMMUNICATION", "COMPONENT", "COMPONENTS", "DETERMINISTIC", "DUPLICATED", "EACH", "EVENT", "EVERY", "FACT", "FORKED", "GLOBAL", "HAPPENS", "HAVE", "IMPLEMENTATION", "ITS", "LOCAL", "MACHINE", "MORE", "NEVER", "NON", "ONE", "ONLY", "OWN", "PRIMUS", "REPLICATED", "SHARED", "STATE", "THAN", "THAT", "THE", "THUS", "TIME", "USED"]);
add_ocaml_element("Machine", "Std.Primus.Machine", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Machine.html", "<div class=\"info\">\n<p>Primus Machine.</p>\n\n</div>\n", ["ANALYSIS", "AND", "ANY", "BEHAVIOR", "BINARY", "CAN", "CHANGED", "COMPONENT", "COMPONENTS", "CORE", "CREATES", "DIFFERENT", "DURING", "ENTRY", "EVALUATION", "EVENTS", "EXAMPLE", "EXTENDED", "FOR", "FORM", "FRAMEWORK", "FROM", "FUNCTION", "FUNCTOR", "HAPPEN", "IMPLEMENTORS", "INSTANCE", "INSTANTIATED", "INTERPRETER", "MACHINE", "MADE", "MODEL", "OBSERVATIONS", "OBTAINED", "ONCE", "ONLY", "OTHER", "PARAMETERIZED", "POINT", "PRIMUS", "PROVIDE", "RAN", "REACTIONS", "REGISTERED", "REGISTERS", "REGISTER_COMPONENT", "RUN", "RUNS", "SPECIFIED", "STATIC", "SUCH", "TAKES", "TERMINATES", "THAT", "THE", "THEIR", "UNTIL", "USER", "USUALLY", "WITH", "WRITTEN"]);
add_ocaml_element("Pos", "Std.Primus.Pos", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Pos.html", "<div class=\"info\">\n<p>A hierarchical program position.</p>\n\n</div>\n", ["CURSOR", "DATA", "DESCRIBES", "HIERARCHICAL", "HIERARCHY", "LIKE", "POS", "POSITION", "PROGRAM", "STRUCTURE", "TERM", "THAT", "THE"]);
add_ocaml_element("Provider", "Std.Primus.Observation.Provider", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Observation.Provider.html", "<div class=\"info\">\n<p>Data interface to the provider.</p>\n\n</div>\n", ["ACCESS", "ALL", "DATA", "EXPRESSES", "EXPRESSIONS", "INTERFACE", "PROVIDER", "PROVIDERS", "PROVIDES", "STREAM", "THE", "THIS"]);
add_ocaml_element("Observation", "Std.Primus.Observation", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.Observation.html", "<div class=\"info\">\n<p>Machine Observation.</p>\n\n</div>\n", ["ARE", "BASED", "BUILT", "CLASS", "COMPONENTS", "DEPENEND", "EVENT", "FIRST", "FRAMEWORK", "FUNCTOR", "FUNCTORS", "MACHINE", "MADE", "MAKE", "NOT", "OBSERVATION", "OBSERVATIONS", "OTHER", "OWN", "PRIMUS", "REPRESENTATION", "SHOULD", "THE", "THEIR", "TOP", "TYPE", "VALUE", "VALUES", "WHILE"]);
add_ocaml_element("Primus", "Std.Primus", "module", "<i>(... module ...)</i>", "Bap_primus.Std.Primus.html", "", []);
add_ocaml_element("Std", "Std", "module", "<i>(... module ...)</i>", "Bap_primus.Std.html", "", []);
add_ocaml_element("Bap_primus", "Bap_primus", "module", "<i>(... module ...)</i>", "Bap_primus.html", "", []);
add_ocaml_element("Conservative", "Bap_taint.Std.Taint.Gc.Conservative", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Gc.Conservative.html", "<div class=\"info\">\n<p>Conservative Garbage Collector.</p>\n\n</div>\n", ["ADDRESS", "ALIVE", "ALL", "AND", "ANOTHER", "ANY", "APPROXIMATION", "ATTACHED", "BASIC", "BECOME", "BLOCK", "BUT", "CHANGE", "CLAUSE", "COLLECTION", "COLLECTOR", "CONSERVATIVE", "CURRENT", "CURRENTLY", "DEVISE", "EITHER", "ENV", "ESPECIALLY", "EVEN", "EVERY", "FOLLOWING", "FOR", "FROM", "FUTURE", "GARBAGE", "GIVES", "KEEP", "KILL", "LIVE", "LOCATION", "MAY", "MORE", "NOT", "ONCE", "ONLY", "OPERATION", "OVER", "OVERWRITE", "POSSIBILITY", "POSSIBLE", "PRECISE", "PROGRAM", "REACHABLE", "REQUIRED", "RUNS", "SECOND", "SOUNDNESS", "STORE", "STORED", "STRICTLY", "TAINT", "TAINTED", "TAINTS", "THE", "THEY", "THIS", "TRACK", "TRUE", "UNREACHABLE", "USING", "VALUE", "VARIABLE", "WAY", "WHEN", "WHETHER", "WITH"]);
add_ocaml_element("Gc", "Bap_taint.Std.Taint.Gc", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Gc.html", "", []);
add_ocaml_element("Make", "Bap_taint.Std.Taint.Propagation.Policy.Make", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Propagation.Policy.Make.html", "", []);
add_ocaml_element("Policy", "Bap_taint.Std.Taint.Propagation.Policy", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Propagation.Policy.html", "", []);
add_ocaml_element("Propagation", "Bap_taint.Std.Taint.Propagation", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Propagation.html", "<div class=\"info\">\n<p>Policy based propagation.</p>\n\n</div>\n", ["ALL", "ALTHOUGH", "AND", "ARBITRARY", "ASSOCIATING", "ATTACHED", "BASED", "CAN", "CLASS", "CLASSES", "COULD", "DEFINING", "DETACHED", "DISJOIT", "EACH", "ESTABLISHES", "FOR", "FRAMEWORK", "INTO", "ITS", "KIND", "KINDS", "MECHANISM", "OBJECT", "OBJECTS", "ONTO", "OWN", "PARTITIONING", "POLICIES", "POLICY", "PROPAGATION", "PROVIDES", "RULES", "SET", "SPECIFY", "SURJECTION", "TAINT", "TAINTS", "THAT", "THE", "WAY", "WITH"]);
add_ocaml_element("Make", "Bap_taint.Std.Taint.Tracker.Make", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Tracker.Make.html", "", []);
add_ocaml_element("Tracker", "Bap_taint.Std.Taint.Tracker", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Tracker.html", "<div class=\"info\">\n<p>Taint tracker control module.</p>\n\n</div>\n", ["AND", "APPLIED", "CONTROL", "DESIGNED", "FOLLOWS", "FUNCTOR", "INTERFACE", "MACHINE", "MODULE", "SPECIFIC", "TAINT", "THIS", "THUS", "TRACKER"]);
add_ocaml_element("Make", "Bap_taint.Std.Taint.Object.Make", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Object.Make.html", "", []);
add_ocaml_element("Object", "Bap_taint.Std.Taint.Object", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Object.html", "<div class=\"info\">\n<p>Each taint represents an abstract object that we would like\n        to track.</p>\n\n</div>\n", ["ABSTRACT", "ANALYSIS", "AND", "ARE", "ASSOCIATE", "ATTRIBUTES", "CREATE", "EACH", "EVERY", "FRESH", "IDENTITY", "INTRODUCED", "LIKE", "MAY", "NEW", "OBJECT", "REPRESENTS", "TAINT", "THAT", "THE", "THIS", "TIME", "TRACK", "TRACKING", "USE", "VALUE", "VARIOUS", "WITH", "WOULD"]);
add_ocaml_element("Rel", "Bap_taint.Std.Taint.Rel", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Rel.html", "<div class=\"info\">\n<p>Relation between a value and an object that we track.</p>\n\n</div>\n", ["ABSTRACT", "ACTUAL", "AND", "BETWEEN", "BIT", "BYTE", "CAN", "COULD", "DENOTED", "DIFFERENT", "DIRECT", "DISTINGUISH", "EACH", "FAR", "FRAMEWORK", "INDIRECT", "KINDS", "MACHINE", "OBJECT", "RELATED", "RELATION", "RELATIONS", "RUNTIME", "SOMEHOW", "THAT", "THE", "THERE", "THIS", "TRACK", "TRACKS", "TYPE", "VALUE", "VALUES", "WITH", "WORD"]);
add_ocaml_element("Make", "Bap_taint.Std.Taint.Kind.Make", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Kind.Make.html", "", []);
add_ocaml_element("Kind", "Bap_taint.Std.Taint.Kind", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.Kind.html", "<div class=\"info\">\n<p>Each object that the engine tracks has an associated kind,\n        that denotes a class of objects that share the same semantic\n        properties.</p>\n\n</div>\n", ["ALLOWS", "ANALYSES", "ASSOCIATED", "BETWEEN", "CLASS", "COULD", "DENOTES", "DIFFERENT", "DISTINGUISH", "EACH", "ENGINE", "FROM", "HAS", "INTERSECTING", "INTRODUCES", "KIND", "LAYMAN", "NAMESPACING", "OBJECT", "OBJECTS", "OTHER", "PARALLEL", "PROPERTIES", "RAN", "SAME", "SEMANTIC", "SEVERAL", "SHARE", "SINCE", "TAINTS", "TERMS", "THAT", "THE", "THEIR", "TRACKS", "WITH", "WITHOUT"]);
add_ocaml_element("Taint", "Bap_taint.Std.Taint", "module", "<i>(... module ...)</i>", "Bap_taint.Std.Taint.html", "<div class=\"info\">\n<p>Abstract taint.</p>\n\n</div>\n", ["ABSTRACT", "ABSTRACTIONS", "AND", "ARE", "COULD", "DEFINES", "EVEN", "FOR", "INTERFACE", "INTRODUCING", "MODULE", "OBJECTS", "POLICIES", "PROPAGATION", "PROVIDE", "SANITIZING", "SEVERAL", "SPECIFYING", "TAINT", "TAINTS", "THAT", "THE", "THIS", "TRACK", "TRACKER", "USED", "WELL"]);
add_ocaml_element("Std", "Bap_taint.Std", "module", "<i>(... module ...)</i>", "Bap_taint.Std.html", "", []);
add_ocaml_element("Bap_taint", "Bap_taint", "module", "<i>(... module ...)</i>", "Bap_taint.html", "<div class=\"info\">\n<p>Taint Analysis Framework.</p>\n\n</div>\n", ["ABOVE", "ABSTRACT", "ACTUAL", "AFFECTED", "ALL", "ANALYSIS", "AND", "ANY", "APPLICATION", "APPROACHES", "ARBITRARY", "ARE", "ASSUME", "ATTACHED", "ATTACHING", "BELONG", "BEND", "BUILT", "BUT", "CALL", "CALLED", "CALLS", "CAN", "CHECK", "CHECKING", "CLASSICAL", "CLEAR", "CLEARS", "COMPUTATION", "COMPUTE", "CONNOTATION", "CONSIDER", "CORRESPONDINGLY", "COULD", "COURSE", "CREATE", "CUSTOMIZABLE", "DATA", "DECRIBED", "DEFINITION", "DEMAND", "DEPENDENT", "DEPENDS", "DESIGNATES", "DIFFERENT", "DISTINGUISH", "DOESN", "DYNAMIC", "EACH", "EASIER", "EFFECT", "ENGINE", "ENTITY", "ESSENTIALLY", "ETC", "EVERY", "EXAMPLE", "EXISTS", "FINALLY", "FLOW", "FOR", "FRAMEWORK", "FROM", "FUNCTION", "GENERAL", "HAVE", "HOWEVER", "INFLUENCE", "INFLUENCED", "INFORMATION", "INPUT", "INSTEAD", "INTRODUCED", "INTRODUCES", "IRRELEVANT", "ITS", "KIND", "KINDS", "KNOW", "LET", "LIFETIME", "LIKE", "LIVENESS", "LOCATION", "MAKE", "MARKED", "MAY", "MIGHT", "MORE", "MULTIPLE", "NEGATES", "NEGATIVE", "NEW", "NOT", "NOTION", "NOW", "OBJECT", "OBJECTS", "ONE", "ONLY", "OTHER", "OTHERS", "OUR", "PARLANCE", "PARTICULAR", "PASSED", "PLUGGABE", "POLICIES", "POLICY", "POSITIVE", "PRECISE", "PRIVILEGED", "PRODUCED", "PROGRAM", "PROPERTIES", "PROPERTY", "QUERY", "REACHED", "RECV", "RELAXED", "REPRESENT", "REPRESENTATION", "REPRESENTS", "REQUIRES", "RUNTIME", "SAFETY", "SAME", "SANITIZATION", "SANITIZES", "SAY", "SEVERAL", "SINCE", "SOME", "SOMEHOW", "SOURCES", "SPECIFIED", "SQL", "SQL_ESCAPE", "SQL_EXEC", "SUCH", "SUPPOSE", "TAINT", "TAINTED", "TAINTS", "TAKE", "TERMS", "THAN", "THAT", "THE", "THERE", "THESE", "THOSE", "THUS", "TIME", "TRACK", "TRACKING", "TRACKS", "TRADITIONALLY", "TREAT", "TRUST", "UNDERSTAND", "UNDESIRABLE", "UNESCAPED", "UNSAFE", "UNTRUSTWORTHY", "USE", "USED", "VALUE", "VALUES", "WAY", "WELL", "WERE", "WHEN", "WHICH", "WHOSE", "WILL", "WITH", "WORD", "WORDS", "WOULD"]);
add_ocaml_element("Dot", "Std.Dot", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.Dot.html", "<div class=\"info\">\n<p>Generic dot printer.</p>\n\n</div>\n", ["DOT", "GENERIC", "PRINTER"]);
add_ocaml_element("Mapper", "Std.Mapper", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.Mapper.html", "<div class=\"info\">\n<p>functorized version of <a href=\"Graphlib.Std.Graphlib.html#VALview\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Graphlib</span>.view</code></a> function.</p>\n\n</div>\n", ["FUNCTION", "FUNCTORIZED", "GRAPHLIB", "STD", "VERSION", "VIEW"]);
add_ocaml_element("Filtered", "Std.Filtered", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.Filtered.html", "<div class=\"info\">\n<p>functorized version of a <code class=\"code\">filter</code> function.</p>\n\n</div>\n", ["FILTER", "FUNCTION", "FUNCTORIZED", "VERSION"]);
add_ocaml_element("Of_ocamlgraph", "Std.Of_ocamlgraph", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.Of_ocamlgraph.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Of_ocamlgraph</span>(<span class=\"constructor\">O</span>)</code> creates an adapter module, that implements\n        <code class=\"code\"><span class=\"constructor\">Graphlib</span></code> interface on top of the module implementing\n        <code class=\"code\"><span class=\"constructor\">OCamlGraph</span></code> interface.</p>\n\n</div>\n", ["ADAPTER", "CREATES", "GRAPHLIB", "IMPLEMENTING", "IMPLEMENTS", "INTERFACE", "MODULE", "OCAMLGRAPH", "OF_OCAMLGRAPH", "THAT", "THE", "TOP"]);
add_ocaml_element("To_ocamlgraph", "Std.To_ocamlgraph", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.To_ocamlgraph.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">To_ocamlgraph</span>(<span class=\"constructor\">G</span>)</code> returns a module that implements\n        OCamlGraph interface for a persistent graph.</p>\n\n</div>\n", ["FOR", "GRAPH", "IMPLEMENTS", "INTERFACE", "MODULE", "OCAMLGRAPH", "PERSISTENT", "RETURNS", "THAT", "TO_OCAMLGRAPH"]);
add_ocaml_element("Labeled", "Std.Labeled", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.Labeled.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Labeled</span>(<span class=\"constructor\">Node</span>)(<span class=\"constructor\">Node_label</span>)(<span class=\"constructor\">Edge_label</span>)</code> creates a graph\n        structure with both nodes and edges labeled with abitrary\n        types.</p>\n\n</div>\n", ["ABITRARY", "ABSTRACT", "AND", "ANY", "ARE", "BOTH", "CAN", "CONTRARY", "CREATES", "DATA", "DIFFERENT", "EDGES", "EDGE_LABEL", "FUNCTIONAL", "FUNCTOR", "GRAPH", "INCLUDING", "LABEL", "LABELED", "MAKE", "MOREOVER", "NODE", "NODES", "NODE_LABEL", "PURE", "STRUCTURE", "THE", "THEY", "TYPE", "TYPES", "UNIFIED", "WHERE", "WITH"]);
add_ocaml_element("Edge", "Std.Graph.Edge", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graph.Edge.html", "<div class=\"info\">\n<p>Graph edges</p>\n\n</div>\n", ["EDGES", "GRAPH"]);
add_ocaml_element("Node", "Std.Graph.Node", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graph.Node.html", "<div class=\"info\">\n<p>Graph nodes.</p>\n\n</div>\n", ["GRAPH", "NODES"]);
add_ocaml_element("Make", "Std.Make", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Node</span>)(<span class=\"constructor\">Edge</span>)</code> creates a module that implements <code class=\"code\"><span class=\"constructor\">Graph</span></code>\n        interface and has unlabeled nodes of type <code class=\"code\"><span class=\"constructor\">Node</span>.t</code> and edges\n        labeled with <code class=\"code\"><span class=\"constructor\">Edge</span>.t</code></p>\n\n</div>\n", ["AND", "ANY", "ARE", "BASICALLY", "CAN", "COMPARE", "CORE_KERNEL", "CREATES", "DERIVED", "DIRECTLY", "DOESN", "EASILY", "EDGE", "EDGES", "FUNCTIONS", "GRAPH", "GRAPHLIB", "HAS", "HASH", "IMPLEMENTED", "IMPLEMENTS", "INT64", "INTERFACE", "LABELED", "MAKE", "MODULE", "NEW", "NODE", "NODES", "OPAQUE", "PROVIDED", "REASONABLE", "SATISFIES", "SATISFY", "STRUCTURE", "THAT", "THE", "THEN", "TYPE", "UNIT", "UNLABELED", "USED", "WITH"]);
add_ocaml_element("Graphlib", "Std.Graphlib", "module", "<i>(... module ...)</i>", "Graphlib.Std.Graphlib.html", "<div class=\"info\">\n<p>Generic Graph Library</p>\n\n</div>\n", ["GENERIC", "GRAPH", "LIBRARY"]);
add_ocaml_element("Solution", "Std.Solution", "module", "<i>(... module ...)</i>", "Graphlib.Std.Solution.html", "<div class=\"info\">\n<p>A solution to a system of fixed-point equations.</p>\n\n</div>\n", ["ALL", "AND", "ARE", "ASSOCIATES", "DEFAULT", "EQUATIONS", "FINITE", "FIXED", "ITS", "MAPPING", "NODE", "NOT", "PAIR", "POINT", "REPRESENT", "SOLUTION", "SYSTEM", "THAT", "THE", "VALUE", "VARIABLE", "VARIABLES", "WITH"]);
add_ocaml_element("Equiv", "Std.Equiv", "module", "<i>(... module ...)</i>", "Graphlib.Std.Equiv.html", "<div class=\"info\">\n<p>Ordinal for representing equivalence.</p>\n\n</div>\n", ["BASED", "ELEMENTS", "EQUIVALENCE", "FOR", "INDEXING", "ORDINAL", "REPRESENTING", "THEIR", "USEFUL"]);
add_ocaml_element("Group", "Std.Group", "module", "<i>(... module ...)</i>", "Graphlib.Std.Group.html", "<div class=\"info\">\n<p>Group is a non-empty set that is a result of partitioning of an\n      underlying set <code class=\"code\"><span class=\"constructor\">S</span></code> into a set of non-intersecting and non-empty\n      subsets that cover set <code class=\"code\"><span class=\"constructor\">S</span></code>.</p>\n\n</div>\n", ["AND", "COVER", "EMPTY", "FOR", "GRAPHLIB", "GROUP", "INFORMATION", "INTERSECTING", "INTO", "MORE", "NON", "PARTITION", "PARTITIONING", "RESULT", "SEE", "SET", "STD", "SUBSETS", "THAT", "UNDERLYING"]);
add_ocaml_element("Partition", "Std.Partition", "module", "<i>(... module ...)</i>", "Graphlib.Std.Partition.html", "<div class=\"info\">\n<p>Result of a set partitioning.</p>\n\n</div>\n", ["ABOUT", "ALL", "AND", "BELONGING", "CALLED", "CAN", "CLASS", "COMPONENTS", "CONNECTED", "DATA", "DEPENDING", "DIFFERENT", "EACH", "ELEMENT", "ELEMENT", "EMPTY", "EQUIV", "EQUIVALENCE", "EXAMPLE", "FOR", "FORMS", "GRAPH", "GRAPHLIB", "GROUP", "GROUPS", "HAVE", "INCLUDED", "INTO", "NATURE", "NODES", "NON", "NUMBER", "NUMBERS", "ONE", "ONLY", "ORDINAL", "ORDINARY", "OUR", "PARLANCE", "PARTICULAR", "PARTIONING", "PARTITION", "PARTITIONING", "PLAYS", "REPRESENT", "REPRESENTATION", "REPRESENTATIVE", "REPRESENTED", "REPRESENTS", "RESULT", "RESULTS", "ROLE", "SAME", "SEE", "SEMANTICS", "SET", "SIDE", "STD", "STRONGLY", "STRUCTURE", "SUBSET", "SUBSETS", "SUCH", "THAT", "THE", "THIS", "THOUGHT", "UNION", "USED"]);
add_ocaml_element("Path", "Std.Path", "module", "<i>(... module ...)</i>", "Graphlib.Std.Path.html", "<div class=\"info\">\n<p>Path between two nodes.</p>\n\n</div>\n", ["BETWEEN", "NODES", "PATH", "TWO"]);
add_ocaml_element("Frontier", "Std.Frontier", "module", "<i>(... module ...)</i>", "Graphlib.Std.Frontier.html", "<div class=\"info\">\n<p>Frontier maps each node into a possibly empty set of nodes.</p>\n\n</div>\n", ["AND", "DOMINANCE", "EACH", "EMPTY", "FOR", "FRONTIER", "FRONTIERS", "INTO", "MAPS", "NODE", "NODES", "POSSIBLY", "POST", "REPRESENTING", "SET", "THIS", "USED"]);
add_ocaml_element("Tree", "Std.Tree", "module", "<i>(... module ...)</i>", "Graphlib.Std.Tree.html", "<div class=\"info\">\n<p>Tree is a particular subtype of a graph for which\n      each node has only one predecessor, and there is only\n      one path between tree root and any other node.</p>\n\n</div>\n", ["AND", "ANY", "BETWEEN", "EACH", "EXAMPLE", "FOR", "GRAPH", "HAS", "HERE", "NODE", "ONE", "ONLY", "OTHER", "PARTICULAR", "PATH", "PREDECESSOR", "ROOT", "SUBTYPE", "THERE", "TREE", "WHICH"]);
add_ocaml_element("Std", "Std", "module", "<i>(... module ...)</i>", "Graphlib.Std.html", "<div class=\"info\">\n<p>Graph library</p>\n\n</div>\n", ["ACCEPT", "ACCEPTED", "ALGORITHM", "ALGORITHMS", "ALL", "ALONG", "ALSO", "AND", "ANY", "ARE", "ARGUMENT", "AUXILIARY", "BIND", "BOOL", "BUT", "CAN", "CHOICE", "CHOSEN", "CLASS", "COME", "CONTRARY", "CORE", "COURSE", "CREATE", "DATA", "DEBUG", "DIE", "DIFFERENT", "EACH", "EASIER", "EDGE", "EDGES", "EMPTY", "ENTRY", "ETC", "EXIT", "EXPLICIT", "EXTENDS", "FALSE", "FIRST", "FOR", "FUNCTION", "FUNCTOR", "FUNCTORS", "GENERIC", "GOOD", "GRAPH", "GRAPHLIB", "GRAPHLIBS", "GRAPHS", "HARDS", "HAS", "HASHTBLS", "HAVE", "HEAVILY", "IMPLEMENT", "IMPLEMENTATION", "IMPLEMENTATIONS", "IMPLEMENTS", "IMPLICITS", "INSERT", "INSTANCE", "INTERFACE", "INTERFACES", "ISOMORPHIC", "ISOMORPHISM", "ITS", "KEYWORD", "KNOWN", "LABELED", "LATER", "LET", "LIBRARY", "LIKE", "LOOP", "MAKE", "MAKES", "MAKING", "MANY", "MAPS", "MODULAR", "MODULE", "MORE", "MUCH", "NAME", "NAMED", "NEED", "NODE", "NODES", "NON", "NOT", "NOW", "OCAML", "OCAMLGRAPH", "OF_OCAMLGRAPH", "OMITTED", "ONE", "OPAQUE", "OPTIONAL", "OWN", "PARAMETER", "PARAMETERS", "PARTITION", "PARTITIONING", "PASS", "PATH", "PATHS", "PERSISTANT", "POSSIBLE", "PREINSTANTIATED", "PRELOADED", "PRINTABLE", "PROVIDED", "PROVIDES", "REACH", "RECOMMENDED", "REPRESENT", "REPRESENTING", "RICHER", "SET", "SETS", "SHORT", "SIGNATURE", "SIGS", "SOME", "SPANNINGS", "STD", "STILL", "STRING", "STRUCTURE", "STRUCTURES", "STYLE", "SUITE", "SYNTACTICALLY", "THANKS", "THAT", "THE", "THEM", "THERE", "THESE", "THEY", "THINK", "THIS", "THUS", "TO_OCAMLGRAPH", "TREE", "TRUE", "TWO", "TYPE", "USE", "USED", "USES", "USUALLY", "VALUES", "VERSE", "VICE", "WAY", "WELL", "WHEN", "WILL", "WITH", "WITNESS", "WORK", "WOULD", "WRITTEN", "YOU"]);
add_ocaml_element("Graphlib", "Graphlib", "module", "<i>(... module ...)</i>", "Graphlib.html", "", []);
add_ocaml_element("Signal", "Bap_future.Std.Signal", "module", "<i>(... module ...)</i>", "Bap_future.Std.Signal.html", "<div class=\"info\">\n<p>A handler to produce elements in streams.</p>\n\n</div>\n", ["ELEMENTS", "HANDLER", "PRODUCE", "STREAMS"]);
add_ocaml_element("Variadic", "Bap_future.Std.Stream.Variadic", "module", "<i>(... module ...)</i>", "Bap_future.Std.Stream.Variadic.html", "", []);
add_ocaml_element("Stream", "Bap_future.Std.Stream", "module", "<i>(... module ...)</i>", "Bap_future.Std.Stream.html", "<div class=\"info\">\n<p>A stream of elements.</p>\n\n</div>\n", ["AGGREGATE", "ALL", "ALLOWS", "ALSO", "AND", "ANY", "ARE", "ASK", "BUILT", "BUT", "CALLED", "CAN", "CANNOT", "COINDUCTIVELY", "COMBINED", "CONDITION", "CONSIDERED", "CONSISTS", "CONSUMER", "COOPERATION", "COOPERATIVE", "CORECURSIVELY", "DATA", "DEFINED", "DESIGNATES", "ELEMENTS", "END", "FEED", "FEEDER", "FOR", "FORM", "FROM", "FUNCTIONS", "FUTURES", "GENERAL", "GET", "HAS_SUBSCRIBERS", "HIS", "INDUCTIVE", "INFINITE", "INTERFACE", "INTERMEDIATE", "INTO", "LAZY", "LIMIT", "MADE", "MANDATORY", "MEANS", "MECHANISM", "MOMENT", "NORMAL", "NOT", "NOTION", "OBSERVED", "ONE", "ONLY", "ON_SUBSCRIBE", "ON_UNSUBSCRIBE", "ON_WAIT", "PAUSE", "PERFORMED", "POSSIBLE", "PROCESSED", "PRODUCER", "PROVIDE", "PUSHBACK", "RATE", "REACT", "REQUESTED", "REQUIRES", "SENSE", "SEQUENCE", "SHOULD", "SIMULATE", "SINCE", "SINK", "SNAPSHOT", "SOME", "STATE", "STILL", "STREAM", "STREAMS", "SUBSRIPTIONS", "THAT", "THE", "THEN", "THERE", "THIS", "TWO", "USE", "USEFUL", "USER", "USING", "WAIT", "WANTS", "WATCHING", "WHEN", "WORK"]);
add_ocaml_element("Promise", "Bap_future.Std.Promise", "module", "<i>(... module ...)</i>", "Bap_future.Std.Promise.html", "<div class=\"info\">\n<p>An promise to provide a value in a future.</p>\n\n</div>\n", ["FUTURE", "PROMISE", "PROVIDE", "VALUE"]);
add_ocaml_element("Args", "Bap_future.Std.Args", "module", "<i>(... module ...)</i>", "Bap_future.Std.Future.Args.html", "", []);
add_ocaml_element("Variadic", "Bap_future.Std.Variadic", "module", "<i>(... module ...)</i>", "Bap_future.Std.Future.Variadic.html", "", []);
add_ocaml_element("Future", "Bap_future.Std.Future", "module", "<i>(... module ...)</i>", "Bap_future.Std.Future.html", "<div class=\"info\">\n<p>Future is an object whose value will be decided somewhere in the\n      future, if that future has occurred.</p>\n\n</div>\n", ["ALSO", "AND", "ANY", "ARE", "ASYNC", "ASYNCHRONOUSLY", "BETWEEN", "CALLBACKS", "CAN", "CANNOT", "CELLS", "COMMON", "COMPUTATION", "DECIDABLE", "DECIDED", "DEFERRED", "DEFINED", "DENOMINATOR", "DIFFERENT", "DUE", "EITHER", "EMPTY", "ERROR", "EVENT", "FILLED", "FIRST_INSN", "FORMER", "FST", "FULFILLED", "FUN", "FUTURE", "FUTURES", "HAS", "HAVING", "INTERFACE", "JUST", "LATTER", "LET", "LIKE", "LWT", "MAY", "MEANS", "MEM", "MEMORY", "MODELS", "MONAD", "MONADIC", "NATIVE", "NONLINEAR", "NOT", "NOTE", "NTH", "OBJECT", "OCAML", "OCCUR", "OCCURRED", "ONCE", "ONE", "ONLY", "OR_ERROR", "OTHER", "PATH", "PATTERN", "PHYSICAL", "POINT", "POSSIBLE", "PREFERRED", "PROMISE", "RANGE", "REPRESENT", "RETURN", "SEEN", "SET", "SND", "SOFTWARE", "SOME", "SOMEWHERE", "STATES", "STREAM", "SUM", "THAT", "THE", "THINK", "THIS", "THREAD", "THREADS", "THUS", "TIME", "TOTAL", "TREE", "TUPLE", "TWO", "TYPE", "USE", "VALUE", "VARIANTS", "VIA", "WHOSE", "WILL", "WITH", "WORK", "WORLD"]);
add_ocaml_element("Make", "Bap_future.Std.Variadic.Make", "module", "<i>(... module ...)</i>", "Bap_future.Std.Variadic.Make.html", "", []);
add_ocaml_element("Variadic", "Bap_future.Std.Variadic", "module", "<i>(... module ...)</i>", "Bap_future.Std.Variadic.html", "<div class=\"info\">\n<p>Variadic arguments.</p>\n\n</div>\n", ["ABI", "ABLE", "ABOVE", "ABSTRACTS", "ACCORDING", "ACTUALLY", "ALIST", "ALL", "ALSO", "AMOUNT", "AND", "API", "APPLICABLE", "APPLICATIVE", "APPLIED", "APPLY", "ARBITRARY", "ARCH", "ARCHITECTURE", "ARE", "ARGS", "ARGUMENT", "ARGUMENTS", "ASSUME", "AVAILABLE", "BENEFIT", "BINARY", "BIND", "BINDINGS", "BOTH", "CAN", "CARTESIAN", "CARTESIAN_PRODUCT", "CASE", "CASES", "CMDLINER", "COINDUCTIVE", "COLLECT", "COLLECTED", "COLLECTION", "COLLECTIONS", "COMMAND", "COMMON", "CONCRETE", "CONSIDERED", "CONSTRUCTOR", "CORE", "CREATE", "DEFINED", "DEFINES", "DEFINITION", "DIFFERENT", "EACH", "EMPTY", "END", "ENVIRONMENT", "ERROR", "ETC", "EXAMPLE", "EXAMPLES", "FOLLOWING", "FOR", "FROM", "FUN", "FUNCTION", "FUNCTIONS", "FUNCTOR", "FUTURE", "GENERAL", "GENERALIZATION", "GENERALIZE", "GIVEN", "HAVE", "HERE", "HIGHLIGHTS", "HOWEVER", "IDIOM", "IMPLEMENT", "IMPLEMENTS", "INCLUDE", "INDUCTIVE", "INTERFACE", "LACK", "LANG", "LANGUAGE", "LATTER", "LESS", "LET", "LEVEL", "LIKE", "LINE", "LIST", "MAKE", "MAKES", "MAPPED", "MATCH", "MERGE", "MODULE", "MONAD", "MONADIC", "MORE", "MPARSER", "MUCH", "MULTIPLE", "NONE", "NOT", "NOTE", "NUMBER", "OBSERVED", "OCAML", "ONE", "ONLY", "OPERATIONS", "OPTION", "ORDER", "PAIR", "PARSERS", "PARTICULAR", "PASS", "PATTERN", "POSSIBLE", "POWERFUL", "PRINTF", "PRODUCED", "PRODUCT", "PROGRAM", "PROGRAMMING", "PROJECT", "PROPERTIES", "PROVIDE", "QUARTET", "RELIES", "REQUIRES", "RESTRICTED", "RESTRICTION", "RETURN", "RULES", "SAME", "SCANF", "SENSE", "SEQUENCES", "SETS", "SEVERAL", "SINCE", "SOLUTION", "SOME", "SPECIFICATION", "SPECIFIED", "SPECIFIES", "STANDARD", "STILL", "STREAM", "STRUCT", "STRUCTURE", "SUBSTITUTE", "SUCH", "SUPPOSE", "TAKING", "THAT", "THE", "THEM", "THEY", "THIS", "TIMES", "TRICK", "TYPE", "TYPECHECK", "TYPES", "TYPING", "USE", "USED", "USING", "VALUES", "VARAGS", "VARARGS", "VARIABLE", "VARIADIC", "WAITING", "WHEN", "WILL", "WITH", "WITHOUT", "WOULD", "WRITE", "ZERO"]);
add_ocaml_element("Applicable", "Bap_future.Std.Applicable", "module", "<i>(... module ...)</i>", "Bap_future.Std.Applicable.html", "", []);
add_ocaml_element("Std", "Bap_future.Std", "module", "<i>(... module ...)</i>", "Bap_future.Std.html", "<div class=\"info\">\n<p>Future library.</p>\n\n</div>\n", ["ABOUT", "ACTUAL", "AFTER", "AKIN", "ALL", "ALLOWS", "ALSO", "AND", "ANY", "ARE", "ASYNC", "BASED", "BASICALLY", "BEFORE", "BETWEEN", "BIND", "BOTH", "BROUGHT", "BUILT", "BUT", "CALLS", "CAN", "CANNOT", "CHANGED", "CHANGES", "CLOCK", "COINDUCTION", "COINDUCTIVE", "COMMON", "COMPLEX", "COMPUTATION", "COMPUTES", "CONCERNS", "CONSIDER", "CONTROL", "CORRESPONDING", "CREATE", "CREATED", "DEFERRED", "DEFINE", "DEFINED", "DEFINES", "DENOMINATOR", "DEPENDENCY", "DESCRIBE", "DIFFERENCE", "DIFFERENCES", "DIFFERENT", "DUAL", "DUE", "DYNAMIC", "DYNAMISM", "EFFECTIVE", "EMPTY", "ENGINEER", "ETC", "EVENT", "EVENTS", "EVERY", "EVERYTHING", "EXAMPLE", "FAIL", "FAILS", "FEW", "FINITE", "FIRST", "FIXED", "FOR", "FORTHCOMING", "FROM", "FULFILL", "FULFILLED", "FUNCTION", "FUTURE", "FUTURE_OF_THREAD", "GUARANTEED", "HANDLED", "HANDLES", "HAPPEN", "HARD", "HAS", "HIDDEN", "HOW", "HOWEVER", "IMPOSSIBLE", "INDUCTIVE", "INFINITE", "INTERNAL", "INTO", "ITS", "JUST", "KIND", "KNOW", "LET", "LIBRARIES", "LIBRARY", "LIFE", "LINE", "LIST", "LOOP", "LOOPS", "LWT", "MADE", "MAIN", "MATHEMATICAL", "MATHEMATICALLY", "MEANS", "MECHANISMS", "METHODS", "MIGHT", "MODEL", "MODELED", "MODELS", "MORE", "MULTICORE", "NEVER", "NOT", "NOTION", "OBJECT", "OBJECTS", "OBSERVABLE", "OBSERVED", "OCAML", "OCCURRED", "OCCURS", "ONCE", "ONLY", "ON_SUCCESS", "OPTION", "ORDER", "OTHER", "OVERVIEW", "OWN", "PARTICULAR", "PHASE", "PHASES", "PHYSICAL", "POSSIBLE", "PRACTICALLY", "PRECEDENCE", "PRECISELY", "PRIMITIVE", "PROGRAMMING", "PROMISE", "PROMISES", "PROVIDE", "PURELY", "PURPOSE", "PUTTING", "QUITE", "REASON", "REASONING", "REIFY", "REPLACED", "REPRESENT", "REPRESENTABLE", "REPRESENTATION", "REPRESENTED", "REQUIREMENT", "RESPONSIBLE", "REST", "RESULT", "SAME", "SAY", "SECOND", "SECONDS", "SEEN", "SEPARATE", "SEPARATED", "SEPARATION", "SEQUENCE", "SERIALIZED", "SHOULD", "SIGNAL", "SIGNALED", "SIGNALS", "SIMILAR", "SIMPLE", "SIMULTANEITY", "SIMULTANEOUS", "SINCE", "SLOT", "SOME", "SPECIAL", "START", "STATE", "STREAM", "SUCCEED", "SUCH", "SUM", "SYSTEM", "SYSTEMS", "THAN", "THAT", "THE", "THERE", "THEY", "THIS", "THREAD", "THREADS", "TIME", "TIMER", "TIMESCALE", "TOTALLY", "TRIES", "TRUE", "TWO", "TYPE", "TYPES", "UNDEFINED", "UNDER", "UNLIKE", "UPON", "USE", "USER", "USING", "USUALLY", "VALUE", "VALUES", "VARIES", "VIEWED", "WANTS", "WAY", "WELCOME", "WHAT", "WHEN", "WHOSE", "WINDOW", "WITH", "WITHOUT", "WORDS", "YET"]);
add_ocaml_element("Bap_future", "Bap_future", "module", "<i>(... module ...)</i>", "Bap_future.html", "", []);
add_ocaml_element("Make", "Ogre.Make", "module", "<i>(... module ...)</i>", "Ogre.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> returns an Ogre monad implementation wrapped in a monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["IMPLEMENTATION", "MAKE", "MONAD", "OGRE", "RETURNS", "WRAPPED"]);
add_ocaml_element("Doc", "Ogre.Doc", "module", "<i>(... module ...)</i>", "Ogre.Doc.html", "<div class=\"info\">\n<p>An Ogre document.</p>\n\n</div>\n", ["CONCRETE", "DATABASE", "DOCUMENT", "OGRE", "REPRESENTATION"]);
add_ocaml_element("String", "Ogre.Query.String", "module", "<i>(... module ...)</i>", "Ogre.Query.String.html", "<div class=\"info\">\n<p>Defines field subscripting syntax.</p>\n\n</div>\n", ["ALSO", "AND", "BOUND", "COLUMN", "DEFINES", "EXAMPLE", "FIELD", "FIRST", "FOR", "FROM", "JOIN", "NAME", "NUMBER", "ONE", "POSSIBLE", "QUERY", "REFERENCE", "SECOND", "SELECT", "SELECTION", "STUDENTS", "SUBSCRIPTING", "SYNTAX", "THE", "VARIABLE", "WHERE", "WILL"]);
add_ocaml_element("Array", "Ogre.Query.Array", "module", "<i>(... module ...)</i>", "Ogre.Query.Array.html", "<div class=\"info\">\n<p>Defines a subscripting syntax for creating field variables.</p>\n\n</div>\n", ["AND", "ARRAY", "ATTRIBUTE", "CREATING", "DEFINES", "DENOTES", "EXP", "EXPRESSION", "FIELD", "FOR", "GET", "MODULE", "OCAML", "OVER", "QUERY", "RANGES", "RETURNS", "SCOPE", "SUBSCRIPTING", "SUGAR", "SYNTACTIC", "SYNTAX", "TAKES", "THAT", "THE", "THUS", "VALUES", "VARIABLE", "VARIABLES"]);
add_ocaml_element("Query", "Ogre.Query", "module", "<i>(... module ...)</i>", "Ogre.Query.html", "<div class=\"info\">\n<p>Domain specific language for constructing queries.</p>\n\n</div>\n", ["AND", "ARITHMETIC", "BASE", "BOOL", "CONSTRUCTING", "CONSTRUCTION", "CURRENTLY", "DOMAIN", "EXPRESSION", "EXPRESSIONS", "FLOAT", "FOR", "INT", "LANGUAGE", "LOGICAL", "ONLY", "PERMITS", "QUERIES", "QUERY", "SELECT", "SPECIFIC", "STR", "SUPPORTED", "THE", "TYPES"]);
add_ocaml_element("Type", "Ogre.Type", "module", "<i>(... module ...)</i>", "Ogre.Type.html", "<div class=\"info\">\n<p>Ogre type system.</p>\n\n</div>\n", ["AND", "ARBITRARY", "ATTRIBUTE", "ATTRIBUTES", "BOOLEAN", "CLASS", "CONSTRUCT", "DECONSTRUCT", "DESCRIBES", "EXTREMLY", "FALSE", "FIELD", "FIELDS", "FIRST", "FLOAT", "FOUR", "FROM", "HAS", "HOW", "INT", "INT64", "INTEGRAL", "LOGICAL", "MAPS", "NAME", "NUMBER", "OBJECTS", "OCAML", "OGRE", "ONLY", "PAIR", "QUERIES", "REAL", "REFERENCE", "REPRESENTED", "SCHEME", "SIMPLE", "STR", "STRING", "SYSTEM", "THAT", "THEM", "TRUE", "TWO", "TYPE", "TYPES", "USED", "VALUE", "VALUES"]);
add_ocaml_element("Ogre", "Ogre", "module", "<i>(... module ...)</i>", "Ogre.html", "<div class=\"info\">\n<p>OGRE - Open Generic Representation.</p>\n\n</div>\n", ["ABOUT", "ABSTRACT", "ADDING", "ALL", "ALLOWED", "ALSO", "AND", "ANY", "ARE", "ASSIGNMENTS", "ATTRIBUTE", "ATTRIBUTES", "BACKING", "BEFORE", "BOOL", "BOOLEAN", "BREAK", "CALLED", "CAN", "CLASS", "CLOSE", "COLLEGE", "COLUMN", "CONSTRAINTS", "CONTAINS", "CONTENTS", "CORRESPONDINGLY", "CREATE", "DATA", "DATABASE", "DECLARATION", "DECLARE", "DECLARED", "DEFAULT", "DEFINES", "DEFINITION", "DEFINITIONS", "DENOTE", "DESCRIBED", "DESCRIBES", "DESCRIBING", "DOC", "DOCUMENT", "DOESN", "EACH", "ENGINE", "ENOUGH", "ENTITY", "EQUIVALENT", "EVEN", "EXAMPLE", "EXPRESSIONS", "EXTENSIBILITY", "FACT", "FACTS", "FIELD", "FIELDS", "FLOAT", "FOLLOWING", "FOR", "GENERIC", "GIVEN", "GPA", "HAS", "HAVING", "HUMAN", "IMPORTANTLY", "INT", "ITSELF", "JOE", "JOINS", "JSON", "JUST", "KNOWLEDGE", "LANGUAGE", "LIKE", "MAPS", "MAYBE", "MODEL", "MODIFY", "MORE", "MUST", "NAME", "NAMED", "NAMES", "NEW", "NOSQL", "NOTION", "OBJECT", "OGRE", "ONE", "ONLY", "OPEN", "ORDER", "OUR", "PARLANCE", "PERSITANCE", "PREDICATE", "PREVIOUS", "PROPOSITION", "PROPOSITIONS", "PROVIDES", "QUERY", "QUERYING", "RATE", "REFERRED", "RELATIONAL", "RELVAR", "REPRESENTATION", "RESTRICTED", "RICH", "SAFE", "SCALAR", "SEEN", "SELF", "SET", "SHOULD", "SOME", "SPECIFIED", "SQL", "STORAGE", "STORED", "STR", "STRUCTURE", "STUDENT", "SUBJECT", "SUBSET", "SUPPORTS", "SYNTAX", "TABLE", "TEACHER", "THAT", "THE", "THEY", "THUS", "TOOL", "TUPLE", "TYPE", "TYPED", "TYPES", "UNDER", "UNDERSTAND", "UNLIKE", "UPDATING", "USED", "USES", "USUALLY", "VALUE", "VALUES", "WAY", "WELL", "WHERE", "WHICH", "WITH", "WITHOUT", "WORD", "WRITTEN", "XML"]);
add_ocaml_element("Make2", "Std.Monad.Cont.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Cont.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> wrapes the monad <code class=\"code\"><span class=\"constructor\">M</span></code> into the continuation monad.</p>\n\n</div>\n", ["CONTINUATION", "INTO", "MAKE2", "MONAD", "THE", "WRAPES"]);
add_ocaml_element("Make", "Std.Monad.Cont.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Cont.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">T</span>)(<span class=\"constructor\">M</span>)</code> wraps the monad <code class=\"code\"><span class=\"constructor\">M</span></code> into the continuation monad\n          and fix the type of the whole computation to <code class=\"code\"><span class=\"constructor\">T</span>.t</code></p>\n\n</div>\n", ["AND", "COMPUTATION", "CONTINUATION", "FIX", "INTO", "MAKE", "MONAD", "THE", "TYPE", "WHOLE", "WRAPS"]);
add_ocaml_element("T2", "Std.Monad.Cont.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Cont.T2.html", "", []);
add_ocaml_element("T1", "Std.Monad.Cont.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Cont.T1.html", "", []);
add_ocaml_element("Cont", "Std.Monad.Cont", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Cont.html", "<div class=\"info\">\n<p>The continuation monad.</p>\n\n</div>\n", ["ALSO", "AND", "ANOTHER", "AVAILABLE", "BEHAVES", "CALL", "CALLS", "CAN", "CASE", "CLASS", "COMPOSED", "COMPUTATION", "COMPUTATIONS", "CONTEXT", "CONTINUATION", "CONTINUATON", "CONTROL", "COROUTINES", "CURRENT", "ENCAPSULATES", "EVALUATION", "EXCEPT", "EXCEPTIONS", "FINAL", "FIRST", "FIXED", "FUNCTION", "HOST", "IMPLEMENT", "INTERFACES", "LANGUAGE", "LATER", "LEVEL", "LIKE", "MAKING", "MAY", "MODULE", "MONAD", "OCAML", "ONE", "OPERATOR", "OUR", "PROVIDE", "PROVIDED", "PROVIDES", "REIFIES", "RESULT", "RESUMED", "SAME", "STATE", "STORED", "STRUCTURES", "THAT", "THE", "THEM", "THIS", "TWO", "TYPE", "USED", "USER", "VALUES", "VARIABLE", "VARIOUS", "WHERE", "WITH"]);
add_ocaml_element("Make2", "Std.Monad.Lazy.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Lazy.Make2.html", "", []);
add_ocaml_element("T2", "Std.Monad.Lazy.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Lazy.T2.html", "", []);
add_ocaml_element("Make", "Std.Monad.Lazy.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Lazy.Make.html", "", []);
add_ocaml_element("T1", "Std.Monad.Lazy.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Lazy.T1.html", "", []);
add_ocaml_element("Lazy", "Std.Monad.Lazy", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Lazy.html", "<div class=\"info\">\n<p>The Lazy monad.</p>\n\n</div>\n", ["BUILT", "CALL", "COMPUTATION", "COMPUTATIONS", "DELAYED", "EVALUATION", "IMPLEMENT", "IMPLEMENTS", "LAZY", "MEMOIZATION", "MONAD", "NEED", "OCAML", "RUN", "STRATEGY", "THE", "UNTIL", "USES"]);
add_ocaml_element("Make2", "Std.Monad.Fun.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Fun.Make2.html", "", []);
add_ocaml_element("T2", "Std.Monad.Fun.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Fun.T2.html", "", []);
add_ocaml_element("Make", "Std.Monad.Fun.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Fun.Make.html", "", []);
add_ocaml_element("T1", "Std.Monad.Fun.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Fun.T1.html", "", []);
add_ocaml_element("Fun", "Std.Monad.Fun", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Fun.html", "<div class=\"info\">\n<p>The Function Monad.</p>\n\n</div>\n", ["ACTUALLY", "ADDITIONAL", "ALL", "ALSO", "AND", "ARE", "BEHAVIOR", "BEHAVIORS", "BUT", "CAN", "COMPUTATION", "CONT", "DELAYED", "DELAYING", "DELAYS", "ENVIRONMENT", "FUNCTION", "HAS", "HAVE", "LAZY", "MEMOIZATION", "MONAD", "MONADS", "NOT", "ONLY", "OTHER", "READER", "RUN", "SEEN", "STATE", "SUCH", "THAT", "THE", "THEY", "THIS", "TOP", "UNIT", "UNTIL", "WITH", "WITHOUT"]);
add_ocaml_element("Make2", "Std.Monad.State.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Make2.html", "", []);
add_ocaml_element("Make", "Std.Monad.State.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Make.html", "", []);
add_ocaml_element("T2", "Std.Monad.State.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.T2.html", "", []);
add_ocaml_element("T1", "Std.Monad.State.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.T1.html", "", []);
add_ocaml_element("Id", "Std.Monad.State.Multi.S2.Id", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.S2.Id.html", "", []);
add_ocaml_element("Make2", "Std.Monad.State.Multi.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.Make2.html", "", []);
add_ocaml_element("Id", "Std.Monad.State.Multi.S.Id", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.S.Id.html", "", []);
add_ocaml_element("Make", "Std.Monad.State.Multi.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.Make.html", "", []);
add_ocaml_element("T2", "Std.Monad.State.Multi.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.T2.html", "", []);
add_ocaml_element("T1", "Std.Monad.State.Multi.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.T1.html", "", []);
add_ocaml_element("Id", "Std.Monad.State.Multi.Id", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.Id.html", "", []);
add_ocaml_element("Multi", "Std.Monad.State.Multi", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.Multi.html", "<div class=\"info\">\n<p>The Multi State monad.</p>\n\n</div>\n", ["ALL", "ANCESTOR", "AND", "AVAILABLE", "BEING", "BETWEEN", "CALLED", "CAN", "CHOOSES", "CLONES", "COMPUTATION", "COMPUTATIONS", "CONCURRENT", "CURRENT", "DENOTE", "DETERMINISTIC", "DIFFERENT", "EFFECTS", "ENVIRONMENT", "FORK", "FORKED", "FORM", "GENERALIZATION", "GLOBAL", "HAVE", "HIERARCHY", "INITIAL", "INTRODUCES", "MONAD", "MORE", "MULTI", "NEW", "NEWLY", "NON", "ONE", "OPERATOR", "OPERATORS", "PARENT", "REPLICATES", "SIMULTANEOUSLY", "STATE", "STATES", "SWITCH", "THAN", "THE", "TWO", "USED", "WHERE", "WHICH", "WITH"]);
add_ocaml_element("State", "Std.Monad.State", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.State.html", "<div class=\"info\">\n<p>The State Monad.</p>\n\n</div>\n", ["AND", "ARBITRARY", "ARE", "BOTH", "CAN", "CASES", "COMES", "COMPUTATION", "CONSTANT", "DENOTES", "DIFFERENCE", "DIFFERENT", "DURING", "EFFECTFUL", "FIXED", "FLAVORS", "GENERIC", "HOWEVER", "IMPLEMENTATION", "INTERFACES", "JUST", "LEFT", "LEVEL", "MODULE", "MONAD", "PERFORM", "READER", "REMAINS", "SAME", "STATE", "THE", "THERE", "THESE", "TRANSFORMATIONS", "TWO", "TYPE", "UNLIKE", "VARIABLE", "WITH", "WITHREADER", "WRITER"]);
add_ocaml_element("Make2", "Std.Monad.Reader.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Reader.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">Env</span>)(<span class=\"constructor\">M</span>)</code> composes the Reader monad with <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["COMPOSES", "ENV", "MAKE2", "MONAD", "READER", "THE", "WITH"]);
add_ocaml_element("Make", "Std.Monad.Reader.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Reader.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Env</span>)(<span class=\"constructor\">M</span>)</code> concretizes the environment type to <code class=\"code\"><span class=\"constructor\">Env</span>.t</code>\n          and composes the Reader monad with <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["AND", "COMPOSES", "CONCRETIZES", "ENV", "ENVIRONMENT", "MAKE", "MONAD", "READER", "THE", "TYPE", "WITH"]);
add_ocaml_element("T2", "Std.Monad.Reader.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Reader.T2.html", "", []);
add_ocaml_element("T1", "Std.Monad.Reader.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Reader.T1.html", "", []);
add_ocaml_element("Reader", "Std.Monad.Reader", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Reader.html", "<div class=\"info\">\n<p>The Reader monad.</p>\n\n</div>\n", ["ALLOWED", "ALSO", "AND", "ARGUMENTS", "BUT", "CAN", "CHANGE", "COEFFECT", "COMMAND", "COMMON", "COMPUTATION", "CONFIGURATION", "DENOTES", "DEPEND", "EFFECTFUL", "FACT", "FORM", "FUNCTIONS", "GLOBAL", "ITSELF", "KNOWN", "LIMITED", "LINE", "MAY", "MONAD", "NAMESPACE", "ONLY", "PARAMETER", "PASS", "POLLUTIONG", "PROGRAM", "READER", "SEEN", "SEVERAL", "SINCE", "SOME", "STATE", "THE", "THREADING", "USAGE", "USE", "VARIABLES", "VERY", "WAY", "WITH", "WITHOUT", "WORLD", "WOULD"]);
add_ocaml_element("Make", "Std.Monad.Writer.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Writer.Make.html", "<div class=\"info\">\n<p>Make(Sum)(M) constructs a reader that uses <code class=\"code\"><span class=\"constructor\">Sum</span>.t</code> type as a\n          state accumulator and composes the Writer with the monad\n          <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["ACCUMULATOR", "AND", "COMPOSES", "CONSTRUCTS", "MAKE", "MONAD", "READER", "STATE", "SUM", "THAT", "THE", "TYPE", "USES", "WITH", "WRITER"]);
add_ocaml_element("T1", "Std.Monad.Writer.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Writer.T1.html", "", []);
add_ocaml_element("Writer", "Std.Monad.Writer", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Writer.html", "<div class=\"info\">\n<p>The Writer monad.</p>\n\n</div>\n", ["ACCUMULATED", "ALSO", "ARE", "COMPUTATIONS", "DENOTES", "EFFECTFUL", "EFFECTS", "ENVIRONMENT", "FORM", "KNOWN", "LOGGER", "MONAD", "MONOID", "OPERATION", "PLUS", "REPRESENTED", "SHOULD", "SIMPLE", "SOME", "THAT", "THE", "TYPE", "USING", "WITH", "WRITER"]);
add_ocaml_element("Make2", "Std.Monad.Seq.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Seq.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> composes the Seq monad with <code class=\"code\"><span class=\"constructor\">M</span></code></p>\n\n</div>\n", ["COMPOSES", "MAKE2", "MONAD", "SEQ", "THE", "WITH"]);
add_ocaml_element("T2", "Std.Monad.Seq.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Seq.T2.html", "", []);
add_ocaml_element("Make", "Std.Monad.Seq.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Seq.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> composes the Seq monad with <code class=\"code\"><span class=\"constructor\">M</span></code></p>\n\n</div>\n", ["COMPOSES", "MAKE", "MONAD", "SEQ", "THE", "WITH"]);
add_ocaml_element("T1", "Std.Monad.Seq.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Seq.T1.html", "", []);
add_ocaml_element("Seq", "Std.Monad.Seq", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Seq.html", "<div class=\"info\">\n<p>The Sequence monad.</p>\n\n</div>\n", ["ARE", "EXCEPT", "LIST", "MONAD", "MULTIPLE", "REPRESENT", "RESULTS", "SAME", "SEQUENCE", "SEQUENCES", "THE", "USED"]);
add_ocaml_element("Make2", "Std.Monad.List.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.List.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> composes the List monad with <code class=\"code\"><span class=\"constructor\">M</span></code></p>\n\n</div>\n", ["COMPOSES", "LIST", "MAKE2", "MONAD", "THE", "WITH"]);
add_ocaml_element("T2", "Std.Monad.List.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.List.T2.html", "", []);
add_ocaml_element("Make", "Std.Monad.List.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.List.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> composes the List monad with <code class=\"code\"><span class=\"constructor\">M</span></code></p>\n\n</div>\n", ["COMPOSES", "LIST", "MAKE", "MONAD", "THE", "WITH"]);
add_ocaml_element("T1", "Std.Monad.List.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.List.T1.html", "", []);
add_ocaml_element("List", "Std.Monad.List", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.List.html", "<div class=\"info\">\n<p>The List monad.</p>\n\n</div>\n", ["ALL", "CAN", "COMPUTATION", "DENOTES", "DETERMINISTIC", "HAVE", "LIST", "MONAD", "MORE", "NON", "ONE", "RESULT", "RESULTS", "THAN", "THAT", "THE"]);
add_ocaml_element("Make", "Std.Monad.Result.Exception.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Exception.Make.html", "", []);
add_ocaml_element("T", "Std.Monad.Result.Exception.T", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Exception.T.html", "", []);
add_ocaml_element("Exception", "Std.Monad.Result.Exception", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Exception.html", "<div class=\"info\">\n<p>The Exception monad.</p>\n\n</div>\n", ["ASSOCIATED", "CONTROL", "EXCEPTION", "EXCEPTIONAL", "EXN", "FLOW", "MONAD", "RESULT", "THAT", "THE", "TYPE", "USES", "VALUES", "WITH"]);
add_ocaml_element("Make", "Std.Monad.Result.Error.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Error.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> wraps <code class=\"code\"><span class=\"constructor\">M</span></code> into the <code class=\"code\"><span class=\"constructor\">Error</span></code> monad.</p>\n\n</div>\n", ["ERROR", "INTO", "MAKE", "MONAD", "THE", "WRAPS"]);
add_ocaml_element("T", "Std.Monad.Result.Error.T", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Error.T.html", "", []);
add_ocaml_element("Error", "Std.Monad.Result.Error", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Error.html", "<div class=\"info\">\n<p>The Error monad.</p>\n\n</div>\n", ["AKA", "CONCRETIZATION", "ERROR", "FIXED", "MONAD", "OR_ERROR", "RESULT", "THE", "TYPE", "WITH"]);
add_ocaml_element("Make2", "Std.Monad.Result.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> composes the result monad with the monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["COMPOSES", "MAKE2", "MONAD", "RESULT", "THE", "WITH"]);
add_ocaml_element("Make", "Std.Monad.Result.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">E</span>)(<span class=\"constructor\">M</span>)</code> concretized the type of error to <code class=\"code\"><span class=\"constructor\">E</span>.t</code> and\n          composes the Result monad with the monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["AND", "COMPOSES", "CONCRETIZED", "ERROR", "MAKE", "MONAD", "RESULT", "THE", "TYPE", "WITH"]);
add_ocaml_element("T2", "Std.Monad.Result.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.T2.html", "", []);
add_ocaml_element("T1", "Std.Monad.Result.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.T1.html", "", []);
add_ocaml_element("Result", "Std.Monad.Result", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Result.html", "<div class=\"info\">\n<p>The Result Monad.</p>\n\n</div>\n", ["AND", "ANOTHER", "ARBITRARY", "BEAR", "BOTTOM", "CAN", "CHANGED", "COMPUTATION", "DURING", "ERROR", "EXCEPTION", "EXN", "FIXED", "FIXES", "GENERALIZATION", "MONAD", "NOT", "OPTION", "RESULT", "SPECIALIZATION", "THAT", "THE", "TYPE", "VALUE", "WHERE"]);
add_ocaml_element("Make2", "Std.Monad.Option.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Option.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> composes the option monad with the monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["COMPOSES", "MAKE2", "MONAD", "OPTION", "THE", "WITH"]);
add_ocaml_element("Make", "Std.Monad.Option.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Option.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> composes the option monad with the monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["COMPOSES", "MAKE", "MONAD", "OPTION", "THE", "WITH"]);
add_ocaml_element("T2", "Std.Monad.Option.T2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Option.T2.html", "", []);
add_ocaml_element("T1", "Std.Monad.Option.T1", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Option.T1.html", "", []);
add_ocaml_element("Option", "Std.Monad.Option", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Option.html", "<div class=\"info\">\n<p>The option aka Maybe monad.</p>\n\n</div>\n", ["ABSENCE", "AKA", "BOTTOM", "CAN", "COMPUTATIONS", "CONSIDERED", "DENOTE", "DETERMINISTIC", "FORM", "LIMITED", "MAYBE", "MONAD", "NON", "OPTION", "OUTCOME", "PARTIAL", "POSIBLE", "RESULT", "THE", "THIS", "USED", "VALUE", "WHERE"]);
add_ocaml_element("Ident", "Std.Monad.Ident", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Ident.html", "<div class=\"info\">\n<p>The identity monad.</p>\n\n</div>\n", ["ACTUALLY", "AND", "BUT", "CODE", "COMPUTATION", "DERIVED", "EFFICIENT", "FUNCTOR", "HAS", "HELP", "HOST", "IDENTITY", "IMPLEMENTATION", "INLINE", "LANGUAGE", "MANUALLY", "MONAD", "NOT", "OPTIMIZER", "PROVIDE", "PROVIDED", "RATHER", "REPRESENTS", "SAME", "SEMANTICS", "SOME", "THAT", "THE", "VIA", "WITHOUT", "WRITTEN"]);
add_ocaml_element("Minimal2", "Std.Monad.Minimal2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Minimal2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Minimal2</span>(<span class=\"constructor\">M</span>)</code> derives <a href=\"Monads.Std.Monad.S2.html\">Monad.S2</a> from the\n        <a href=\"Monads.Std.Monad.Minimal2.html\">Minimal</a> implementation</p>\n\n</div>\n", ["DERIVES", "FROM", "IMPLEMENTATION", "MINIMAL", "MINIMAL2", "MONAD", "THE"]);
add_ocaml_element("Minimal", "Std.Monad.Minimal", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Minimal.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Minimal</span>(<span class=\"constructor\">M</span>)</code> derives <a href=\"Monads.Std.Monad.S.html\">Monad.S</a> from the\n        <a href=\"Monads.Std.Monad.Minimal.html\">Minimal</a> implementation</p>\n\n</div>\n", ["DERIVES", "FROM", "IMPLEMENTATION", "MINIMAL", "MONAD", "THE"]);
add_ocaml_element("Core2", "Std.Monad.Core2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Core2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Core2</span>(<span class=\"constructor\">M</span>)</code> derives <a href=\"Monads.Std.Monad.S2.html\">Monad.S2</a> from the\n        <a href=\"Monads.Std.Monad.Core2.html\">Core</a> implementation</p>\n\n</div>\n", ["CORE", "CORE2", "DERIVES", "FROM", "IMPLEMENTATION", "MONAD", "THE"]);
add_ocaml_element("Core", "Std.Monad.Core", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Core.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Core</span>(<span class=\"constructor\">M</span>)</code> derives <a href=\"Monads.Std.Monad.S.html\">Monad.S</a> from the\n        <a href=\"Monads.Std.Monad.Core.html\">Core</a> implementation</p>\n\n</div>\n", ["CORE", "DERIVES", "FROM", "IMPLEMENTATION", "MONAD", "THE"]);
add_ocaml_element("Syntax", "Std.Monad.S2.Syntax", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Syntax.html", "<div class=\"info\">\n<p>Monadic operators, see\n          <a href=\"Monads.Std.Monad.Syntax.S2.html\">Monad.Syntax.S2</a> for more.</p>\n\n</div>\n", ["FOR", "MONAD", "MONADIC", "MORE", "OPERATORS", "SEE", "SYNTAX"]);
add_ocaml_element("Seq", "Std.Monad.S2.Seq", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Seq.html", "<div class=\"info\">\n<p>The <a href=\"Monads.Std.Monad.Collection.S2.html\">Monad.Collection.S2</a> interface\n            for sequences</p>\n\n</div>\n", ["COLLECTION", "FOR", "INTERFACE", "MONAD", "SEQUENCES", "THE"]);
add_ocaml_element("List", "Std.Monad.S2.List", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.List.html", "<div class=\"info\">\n<p>The <a href=\"Monads.Std.Monad.Collection.S2.html\">Monad.Collection.S2</a> interface\n            for lists</p>\n\n</div>\n", ["COLLECTION", "FOR", "INTERFACE", "LISTS", "MONAD", "THE"]);
add_ocaml_element("Delay", "Std.Monad.S2.Collection.Delay", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Collection.Delay.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Delay</span>(<span class=\"constructor\">C</span>)</code> derives\n            <a href=\"Monads.Std.Monad.Collection.S2.html\">Monad.Collection.S2</a> for container\n            <code class=\"code\"><span class=\"constructor\">C</span></code></p>\n\n</div>\n", ["COLLECTION", "CONTAINER", "DELAY", "DERIVES", "FOR", "MONAD"]);
add_ocaml_element("Eager", "Std.Monad.S2.Collection.Eager", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Collection.Eager.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Eager</span>(<span class=\"constructor\">C</span>)</code> derives\n            <a href=\"Monads.Std.Monad.Collection.S2.html\">Monad.Collection.S2</a> for container\n            <code class=\"code\"><span class=\"constructor\">C</span></code></p>\n\n</div>\n", ["COLLECTION", "CONTAINER", "DERIVES", "EAGER", "FOR", "MONAD"]);
add_ocaml_element("Collection", "Std.Monad.S2.Collection", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Collection.html", "<div class=\"info\">\n<p>Lifts collection interface into the monad.</p>\n\n</div>\n", ["AND", "BASIC", "COLLECTION", "FOR", "FUNCTORS", "INFORMATION", "INTERFACE", "INTO", "LIFTS", "MODULE", "MONAD", "MORE", "PROVIDE", "PROVIDES", "SEE", "TAKE", "THAT", "THE", "THIS", "TWO"]);
add_ocaml_element("Exn", "Std.Monad.S2.Exn", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Exn.html", "<div class=\"info\">\n<p>Interacting between monads and language exceptions</p>\n\n</div>\n", ["AND", "BETWEEN", "EXCEPTIONS", "INTERACTING", "LANGUAGE", "MONADS"]);
add_ocaml_element("Lift", "Std.Monad.S2.Lift", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Lift.html", "<div class=\"info\">\n<p>Lifts functions into the monad.</p>\n\n</div>\n", ["ARITIES", "CAN", "COMMON", "COMPUTATIONS", "FOR", "FUNCTION", "FUNCTIONS", "INTO", "LIFTES", "LIFTS", "MAPPED", "MONAD", "OPERATES", "PROVIDE", "SEVERAL", "THAT", "THE", "VALUES"]);
add_ocaml_element("Triple", "Std.Monad.S2.Triple", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Triple.html", "<div class=\"info\">\n<p>The triple interface lifted into a monad.</p>\n\n</div>\n", ["INTERFACE", "INTO", "LIFTED", "MONAD", "THE", "TRIPLE"]);
add_ocaml_element("Pair", "Std.Monad.S2.Pair", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Pair.html", "<div class=\"info\">\n<p>The pair interface lifted into the monad.</p>\n\n</div>\n", ["INTERFACE", "INTO", "LIFTED", "MONAD", "PAIR", "THE"]);
add_ocaml_element("Fn", "Std.Monad.S2.Fn", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S2.Fn.html", "<div class=\"info\">\n<p>Various function combinators lifted into the Kleisli category.</p>\n\n</div>\n", ["CATEGORY", "COMBINATORS", "FUNCTION", "INTO", "KLEISLI", "LIFTED", "THE", "VARIOUS"]);
add_ocaml_element("Make2", "Std.Monad.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> derives <a href=\"Monads.Std.Monad.S2.html\">Monad.S2</a> from the\n        <a href=\"Monads.Std.Monad.Basic2.html\">Basic</a> implementation</p>\n\n</div>\n", ["BASIC", "DERIVES", "FROM", "IMPLEMENTATION", "MAKE2", "MONAD", "THE"]);
add_ocaml_element("Syntax", "Std.Monad.S.Syntax", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Syntax.html", "<div class=\"info\">\n<p>Monadic operators, see\n          <a href=\"Monads.Std.Monad.Syntax.S.html\">Monad.Syntax.S</a> for more.</p>\n\n</div>\n", ["FOR", "MONAD", "MONADIC", "MORE", "OPERATORS", "SEE", "SYNTAX"]);
add_ocaml_element("Seq", "Std.Monad.S.Seq", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Seq.html", "<div class=\"info\">\n<p>The <a href=\"Monads.Std.Monad.Collection.S.html\">Monad.Collection.S</a> interface\n            for sequences</p>\n\n</div>\n", ["COLLECTION", "FOR", "INTERFACE", "MONAD", "SEQUENCES", "THE"]);
add_ocaml_element("List", "Std.Monad.S.List", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.List.html", "<div class=\"info\">\n<p>The <a href=\"Monads.Std.Monad.Collection.S.html\">Monad.Collection.S</a> interface\n            for lists</p>\n\n</div>\n", ["COLLECTION", "FOR", "INTERFACE", "LISTS", "MONAD", "THE"]);
add_ocaml_element("Delay", "Std.Monad.S.Collection.Delay", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Collection.Delay.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Delay</span>(<span class=\"constructor\">C</span>)</code> derives\n            <a href=\"Monads.Std.Monad.Collection.S.html\">Monad.Collection.S</a> for container\n            <code class=\"code\"><span class=\"constructor\">C</span></code></p>\n\n</div>\n", ["COLLECTION", "CONTAINER", "DELAY", "DERIVES", "FOR", "MONAD"]);
add_ocaml_element("Eager", "Std.Monad.S.Collection.Eager", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Collection.Eager.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Eager</span>(<span class=\"constructor\">C</span>)</code> derives\n            <a href=\"Monads.Std.Monad.Collection.S.html\">Monad.Collection.S</a> for container\n            <code class=\"code\"><span class=\"constructor\">C</span></code></p>\n\n</div>\n", ["COLLECTION", "CONTAINER", "DERIVES", "EAGER", "FOR", "MONAD"]);
add_ocaml_element("Collection", "Std.Monad.S.Collection", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Collection.html", "<div class=\"info\">\n<p>Lifts collection interface into the monad.</p>\n\n</div>\n", ["AND", "BASIC", "COLLECTION", "FOR", "FUNCTORS", "INFORMATION", "INTERFACE", "INTO", "LIFTS", "MODULE", "MONAD", "MORE", "PROVIDE", "PROVIDES", "SEE", "TAKE", "THAT", "THE", "THIS", "TWO"]);
add_ocaml_element("Exn", "Std.Monad.S.Exn", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Exn.html", "<div class=\"info\">\n<p>Interacting between monads and language exceptions</p>\n\n</div>\n", ["AND", "BETWEEN", "EXCEPTIONS", "INTERACTING", "LANGUAGE", "MONADS"]);
add_ocaml_element("Lift", "Std.Monad.S.Lift", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Lift.html", "<div class=\"info\">\n<p>Lifts functions into the monad.</p>\n\n</div>\n", ["ARITIES", "CAN", "COMMON", "COMPUTATIONS", "FOR", "FUNCTION", "FUNCTIONS", "INTO", "LIFTES", "LIFTS", "MAPPED", "MONAD", "OPERATES", "PROVIDE", "SEVERAL", "THAT", "THE", "VALUES"]);
add_ocaml_element("Triple", "Std.Monad.S.Triple", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Triple.html", "<div class=\"info\">\n<p>The triple interface lifted into a monad.</p>\n\n</div>\n", ["INTERFACE", "INTO", "LIFTED", "MONAD", "THE", "TRIPLE"]);
add_ocaml_element("Pair", "Std.Monad.S.Pair", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Pair.html", "<div class=\"info\">\n<p>The pair interface lifted into the monad.</p>\n\n</div>\n", ["INTERFACE", "INTO", "LIFTED", "MONAD", "PAIR", "THE"]);
add_ocaml_element("Fn", "Std.Monad.S.Fn", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.S.Fn.html", "<div class=\"info\">\n<p>Various function combinators lifted into the Kleisli category.</p>\n\n</div>\n", ["CATEGORY", "COMBINATORS", "FUNCTION", "INTO", "KLEISLI", "LIFTED", "THE", "VARIOUS"]);
add_ocaml_element("Make", "Std.Monad.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> derives <a href=\"Monads.Std.Monad.S.html\">Monad.S</a> from the\n        <a href=\"Monads.Std.Monad.Basic.html\">Basic</a> implementation</p>\n\n</div>\n", ["BASIC", "DERIVES", "FROM", "IMPLEMENTATION", "MAKE", "MONAD", "THE"]);
add_ocaml_element("Syntax", "Std.Monad.Syntax", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Syntax.html", "<div class=\"info\">\n<p>Describes monadic operators.</p>\n\n</div>\n", ["DESCRIBES", "MONADIC", "OPERATORS"]);
add_ocaml_element("Collection", "Std.Monad.Collection", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Collection.html", "<div class=\"info\">\n<p>Container interface in the Kleisli category.</p>\n\n</div>\n", ["ALL", "AND", "ANY", "ARE", "BASE", "BINARY", "CAN", "CASE", "CATEGORY", "CIRCUITED", "COLLECTION", "COLLECTIONS", "COMPUTATION", "COMPUTATIONS", "CONSTANT", "CONSULTING", "CONTAINER", "CONTAINTERS", "CONTINUATION", "CONTINUATIONS", "DELAY", "DELAYED", "DERIVED", "DETERMINED", "DIFFER", "EAGER", "ELEMENTS", "ESPECIALLY", "ETC", "EXISTS", "FIND", "FOLD", "FOR", "FUNCTION", "FUNCTIONS", "GENERAL", "GENERIC", "HAVE", "HOWEVER", "IMPLEMENTED", "IMPLEMENTS", "INFINITE", "INSTEAD", "INTERFACE", "INTERFACES", "ITERATORS", "KLEISLI", "MAY", "MAYBE", "MODULE", "MONAD", "MONADIC", "MORE", "NOT", "ONLY", "OUR", "PARAMETRIZED", "POSSIBLE", "PROBLEMATIC", "PROVIDE", "PROVIDED", "PROVIDES", "REGULAR", "RETURN", "SEQUENCES", "SHORT", "SHOULD", "SIZE", "STACK", "STILL", "THAT", "THE", "THEN", "THIS", "THROUGH", "TWO", "TYPE", "UNARY", "USE", "USING", "USUALL", "VALUES", "VARIANT", "VERSION", "VERSIONS", "WHERE", "WHILE", "WILL", "WITH", "WITHOUT"]);
add_ocaml_element("Trans", "Std.Monad.Trans", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Trans.html", "<div class=\"info\">\n<p>Monad Transformer Interface.</p>\n\n</div>\n", ["ACTUALLY", "ALL", "AND", "ARBITRARY", "BINARY", "BOTH", "BUT", "CAN", "COMPOSE", "COMPOSES", "COMPOSITION", "COMPUTATION", "COMPUTATIONS", "DEFINES", "DENOTED", "DIFFERENTLY", "DOLL", "EACH", "EVERY", "FUNCTION", "GENERIC", "HAS", "INNER", "INTERFACE", "INTERFACES", "ITS", "LIFT", "LIFTS", "MAKE", "MODULE", "MONAD", "MONADS", "NEW", "NOT", "NOTION", "OPERATOR", "OUTER", "OWN", "PROPERTIES", "PROVIDE", "PROVIDES", "RESULT", "RESULTINT", "RUN", "RUSSIAN", "SHOULD", "SINGLE", "TAKES", "THAT", "THE", "THEM", "THERE", "THIS", "THREE", "TRANS", "TRANSFOMER", "TRANSFOMERS", "TRANSFORMER", "TWO", "TYPE", "UNARY", "VALUE", "VISUALIZE", "WILL", "YOU"]);
add_ocaml_element("Make2", "Std.Monad.Choice.Make2", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Choice.Make2.html", "", []);
add_ocaml_element("Make", "Std.Monad.Choice.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Choice.Make.html", "", []);
add_ocaml_element("Choice", "Std.Monad.Choice", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Choice.html", "<div class=\"info\">\n<p>A choice monad interface.</p>\n\n</div>\n", ["ADDITIONAL", "AKIN", "ARE", "BASICALLY", "CHOICE", "COMPUTATION", "CONTROL", "ERROR", "EXAMPLE", "EXCEPT", "EXCEPTIONAL", "EXCHANGE", "FAIL", "FLOW", "FUN", "GUARD", "HAVE", "HOLD", "IMPLEMENTED", "INFORMATION", "INTERFACE", "LET", "LIST", "MAKE", "MAKE2", "MAY", "MONAD", "NOT", "ONE", "OPERATORS", "OPTION", "PROVIDED", "RESULT", "SEQ", "SEVERAL", "SQRT", "THAT", "THE", "WITH", "ZERO"]);
add_ocaml_element("Fail", "Std.Monad.Fail", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Fail.html", "<div class=\"info\">\n<p>A fail monad interface.</p>\n\n</div>\n", ["ABSTRACTION", "AND", "ARE", "BASE", "CATCH", "COMPUTATION", "DIFFERENT", "ERROR", "EXCEPTION", "FAIL", "FLAVORS", "FOR", "FUNCTIONS", "IMPLEMENTED", "INTERFACE", "KINDS", "MAKE", "MAKE2", "MODULE", "MONAD", "MONADS", "NAMELY", "PARTIAL", "PROVIDES", "REPRESENT", "RESULT", "SEVERAL", "THE", "THEM", "THERE", "THIS", "USED", "WITH"]);
add_ocaml_element("Plus", "Std.Monad.Plus", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.Plus.html", "<div class=\"info\">\n<p>A parametric <a href=\"Monads.Std.Monoid.html\">monoid</a></p>\n\n</div>\n", ["MONOID", "PARAMETRIC"]);
add_ocaml_element("Monad", "Std.Monad", "module", "<i>(... module ...)</i>", "Monads.Std.Monad.html", "<div class=\"info\">\n<p>The Monad module.</p>\n\n</div>\n", ["MODULE", "MONAD", "THE"]);
add_ocaml_element("Product", "Std.Monoid.Float.Product", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Float.Product.html", "<div class=\"info\">\n<p>A monoid over product</p>\n\n</div>\n", ["MONOID", "OVER", "PRODUCT"]);
add_ocaml_element("Sum", "Std.Monoid.Float.Sum", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Float.Sum.html", "<div class=\"info\">\n<p>A monoind over addition</p>\n\n</div>\n", ["ADDITION", "MONOIND", "OVER"]);
add_ocaml_element("Float", "Std.Monoid.Float", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Float.html", "<div class=\"info\">\n<p>Provides monoids in the R domain.</p>\n\n</div>\n", ["ADDITION", "DEFAULT", "DOMAIN", "MONOID", "MONOIDS", "PROVIDED", "PROVIDES", "THE"]);
add_ocaml_element("Product", "Std.Monoid.Int.Product", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Int.Product.html", "<div class=\"info\">\n<p>A monoid over product</p>\n\n</div>\n", ["MONOID", "OVER", "PRODUCT"]);
add_ocaml_element("Sum", "Std.Monoid.Int.Sum", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Int.Sum.html", "<div class=\"info\">\n<p>A monoind over addition</p>\n\n</div>\n", ["ADDITION", "MONOIND", "OVER"]);
add_ocaml_element("Int", "Std.Monoid.Int", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Int.html", "<div class=\"info\">\n<p>Provides monoids in the Z domain.</p>\n\n</div>\n", ["ADDITION", "DEFAULT", "DOMAIN", "MONOID", "MONOIDS", "PROVIDED", "PROVIDES", "THE"]);
add_ocaml_element("Make", "Std.Monoid.Set.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Set.Make.html", "<div class=\"info\">\n<p>Derives a set monoind from the set <code class=\"code\"><span class=\"constructor\">S</span></code>.</p>\n\n</div>\n", ["DERIVES", "FROM", "MONOIND", "SET", "THE"]);
add_ocaml_element("Set", "Std.Monoid.Set", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Set.html", "<div class=\"info\">\n<p>A set monoind.</p>\n\n</div>\n", ["MONOIND", "SET"]);
add_ocaml_element("String", "Std.Monoid.String", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.String.html", "<div class=\"info\">\n<p>A monoid on strings.</p>\n\n</div>\n", ["MONOID", "STRINGS"]);
add_ocaml_element("Make", "Std.Monoid.List.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.List.Make.html", "<div class=\"info\">\n<p>Make(T) constructs a monoid that accumulates elements of\n          type <code class=\"code\"><span class=\"constructor\">T</span>.t</code></p>\n\n</div>\n", ["ACCUMULATES", "CONSTRUCTS", "ELEMENTS", "MAKE", "MONOID", "THAT", "TYPE"]);
add_ocaml_element("List", "Std.Monoid.List", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.List.html", "<div class=\"info\">\n<p>A monoid that accumulates data in a list.</p>\n\n</div>\n", ["ACCUMULATES", "DATA", "LIST", "MONOID", "THAT"]);
add_ocaml_element("Make", "Std.Monoid.Stack.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Stack.Make.html", "<div class=\"info\">\n<p>Make(T) constructs a monoid that accumulates elements of\n          type <code class=\"code\"><span class=\"constructor\">T</span>.t</code></p>\n\n</div>\n", ["ACCUMULATES", "CONSTRUCTS", "ELEMENTS", "MAKE", "MONOID", "THAT", "TYPE"]);
add_ocaml_element("Stack", "Std.Monoid.Stack", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Stack.html", "<div class=\"info\">\n<p>A <a href=\"Monads.Std.Monoid.List.html\">list monoid</a> that accumulates data in a\n        reversed order.</p>\n\n</div>\n", ["ACCUMULATES", "DATA", "LIST", "MONOID", "ORDER", "REVERSED", "THAT"]);
add_ocaml_element("TList", "Std.Monoid.TList", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.TList.html", "<div class=\"info\">\n<p>Concretizes <code class=\"code\"><span class=\"keywordsign\">'</span>a&nbsp;list</code> to <code class=\"code\"><span class=\"constructor\">T</span>.t&nbsp;list</code></p>\n\n</div>\n", ["CONCRETIZES", "LIST"]);
add_ocaml_element("Unit", "Std.Monoid.Unit", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Unit.html", "<div class=\"info\">\n<p>a trivial monoid</p>\n\n</div>\n", ["MONOID", "TRIVIAL"]);
add_ocaml_element("Make", "Std.Monoid.Make", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.Make.html", "<div class=\"info\">\n<p>Make(Base) derives a monoid from its minimal definition</p>\n\n</div>\n", ["BASE", "DEFINITION", "DERIVES", "FROM", "ITS", "MAKE", "MINIMAL", "MONOID"]);
add_ocaml_element("Monoid", "Std.Monoid", "module", "<i>(... module ...)</i>", "Monads.Std.Monoid.html", "<div class=\"info\">\n<p>A monoid set.</p>\n\n</div>\n", ["ADDITION", "ALSO", "AND", "ARE", "ASSOCIATIVE", "BEING", "BINARY", "CLOSED", "CLOSURE", "CONTAINER", "CONTAINERS", "ELEMENT", "EMPTY", "EXAMPLES", "FLOAT", "FORM", "GOOD", "INT", "LIST", "MONOID", "MULTIPLICATION", "NEUTRAL", "NUMERIC", "ONE", "OPERATION", "PLUS", "PRODUCT", "SEE", "SET", "STACK", "STRING", "SUM", "THAT", "THE", "TYPES", "UNDER", "USUALLY", "WITH", "ZERO"]);
add_ocaml_element("Std", "Std", "module", "<i>(... module ...)</i>", "Monads.Std.html", "<div class=\"info\">\n<p>Monad Transformer Library.</p>\n\n</div>\n", ["ABSTRACT", "ABSTRACTION", "ABSTRACTIONS", "ACTUAL", "ACTUALLY", "ADD", "AFTER", "AKIN", "ALGORITHM", "ALGORITHMS", "ALIAS", "ALL", "ALSO", "ALTERNATIVELY", "AND", "ANOTHER", "ARBITRARY", "ARE", "ASSIGN", "ASSIGNMENT", "ASSOCIATIVE", "BASIC", "BASICALLY", "BECOME", "BECOMES", "BEHAVIOR", "BEING", "BEYOND", "BINARY", "BIND", "BOTTOM", "BOUND", "BRING", "BUT", "CALL", "CALLED", "CAN", "CASE", "CASES", "CATEGORIES", "CHANGE", "CHANGES", "CHOICE", "CODE", "COEFFECT", "COLLECTION", "COME", "COMFORTABLE", "COMMONLY", "COMPOSITION", "COMPUTATION", "COMPUTATIONS", "COMPUTE", "COMPUTED", "CONCEPT", "CONSEQUENT", "CONSTANT", "CONSTRUCTOR", "CONSTRUCTORS", "CONSTRUCTS", "CONT", "CONTAINER", "CONTENTS", "CONTEXT", "CONTINUATION", "CONTROL", "CONVENTIONAL", "CONVENTIONS", "CORE", "CORE2", "CORRESPONDINGLY", "CREATES", "DEFINED", "DEFINES", "DEFINING", "DENOTED", "DEPEND", "DEPENDING", "DESIGN", "DETERMINISTIC", "DEVELOP", "DIFFERENT", "DIVERGE", "DIVERGES", "EACH", "EASIER", "EFFECT", "EFFECTFUL", "EFFECTS", "END", "ENRICHES", "ENVIRONMENT", "ERROR", "ETC", "EVALUATION", "EVERY", "EXAMPLES", "EXCEPTION", "EXTRA", "FAIL", "FAILURE", "FEEL", "FEW", "FIRST", "FLOW", "FOLLOW", "FOLLOWING", "FOR", "FORM", "FROM", "FULL", "FUN", "FUNCTION", "FUNCTIONS", "FUNCTOR", "FUNCTORS", "GENERAL", "GENERALIZATION", "GENERATE", "GENERIC", "GIVEN", "GIVES", "GOES", "HABIT", "HAS", "HAVE", "HOLDS", "HOST", "HOW", "HOWEVER", "IDEA", "IDENT", "IMPLEMENTATION", "IMPLEMENTATIONS", "INFORMATION", "INTERFACE", "INTERFACES", "INTO", "INTRODUCE", "INTRODUCTION", "ITS", "ITSELF", "JUST", "KIND", "KNOWN", "LANGUAGE", "LANGUAGES", "LESS", "LET", "LIBRARY", "LIFT", "LIFTS", "LIKE", "LIST", "LONGER", "MAKE", "MAKE2", "MAKES", "MAY", "MEANS", "MECHANISMS", "MINIMAL", "MINIMAL2", "MODULE", "MODULES", "MONAD", "MONADIC", "MONADS", "MONOID", "MORE", "MUCH", "MULTI", "NAMED", "NEED", "NEXT", "NON", "NONDETERMINISM", "NONDETERMINISTIC", "NOT", "NOTATION", "NOTHING", "NOTION", "NOW", "OCAML", "OFTEN", "ONCE", "ONE", "ONLY", "OPEN", "OPERATES", "OPERATION", "OPERATOR", "OPERATORS", "OPPORTUNITY", "OPTION", "ORDER", "ORIGINAL", "OTHER", "OUR", "OVER", "OVERLOADED", "PAIR", "PARAMETER", "PARAMETERS", "PARAMETRIZATION", "PARAMETRIZE", "PARAMETRIZED", "PARTIAL", "PARTIALITY", "PARTICULAR", "PASSED", "PASSES", "PATTERN", "PERFORMED", "PLAY", "PLUS", "POSSIBLE", "PRECISE", "PREPROCESSORS", "PRODUCE", "PRODUCED", "PROGRAM", "PROGRAMMING", "PROPAGATED", "PROVIDE", "PROVIDES", "RATHER", "READABLE", "READER", "REGULAR", "REIFES", "REPRESENTATION", "REPRESENTATIONS", "REPRESENTED", "REQUIRE", "RESULT", "RETURN", "RUN", "SCALAR", "SCOPE", "SECOND", "SECTION", "SEE", "SEEN", "SEMANTICS", "SEMICOLON", "SEQ", "SEQUENCE", "SEQUENCED", "SEQUENCING", "SET", "SEVERAL", "SHOULD", "SHOW", "SIDE", "SIG", "SIGNATURE", "SIGNATURES", "SIMPLE", "SINCE", "SKIP", "SMALL", "SOME", "SOMETIMES", "STATE", "STD", "STRUCT", "SUBDIVIDE", "SYNTAX", "TABLE", "TAKES", "TERMS", "THAN", "THAT", "THE", "THEM", "THEN", "THERE", "THEY", "THIS", "THOUGH", "THUS", "TIMES", "TOTAL", "TRANS", "TRANSFORMATIONS", "TRANSFORMED", "TRANSFORMER", "TRANSFORMERS", "TRANSFORMS", "TRIVIAL", "TRY", "TWO", "TYPE", "TYPICALLY", "UNARY", "UNDERSTAND", "USE", "USED", "USING", "USUALLY", "VAL", "VALUE", "VALUES", "WAY", "WELL", "WHAT", "WHEN", "WHENEVER", "WHETHER", "WHICH", "WHOLE", "WILL", "WITH", "WORK", "WOULD", "WRITABLE", "WRITE", "WRITER", "WRITING", "YOU", "YOUR", "YOURSELF"]);
add_ocaml_element("Monads", "Monads", "module", "<i>(... module ...)</i>", "Monads.html", "", []);
add_ocaml_element("Unsafe", "Std.Bytes.Unsafe", "module", "<i>(... module ...)</i>", "Regular.Std.Bytes.Unsafe.html", "<div class=\"info\">\n<p>Unsafe conversions (for advanced users)</p>\n\n</div>\n", ["ADVANCED", "ALWAYS", "AND", "ARE", "AUTHORS", "AVAILABLE", "BETWEEN", "BREAK", "BUT", "BYTES", "CAN", "CONVERSION", "CONVERSIONS", "COPY", "CORRECT", "DATA", "DESCRIBES", "EXPERT", "FOR", "FUNCTIONS", "IMMUTABILITY", "IMPROPERLY", "INSTEAD", "INTERNAL", "INVARIANT", "LEVEL", "LIBRARY", "LOW", "MOST", "NOT", "OF_STRING", "OPTION", "PROVIDED", "PURPOSES", "REGULAR", "SAFE", "SECTION", "SHOULD", "STD", "STRING", "STRINGS", "THE", "THEY", "THIS", "TO_STRING", "UNSAFE", "USE", "USED", "USERS", "YOU"]);
add_ocaml_element("To_string", "Std.Bytes.To_string", "module", "<i>(... module ...)</i>", "Regular.Std.Bytes.To_string.html", "", []);
add_ocaml_element("From_string", "Std.Bytes.From_string", "module", "<i>(... module ...)</i>", "Regular.Std.Bytes.From_string.html", "", []);
add_ocaml_element("Bytes", "Std.Bytes", "module", "<i>(... module ...)</i>", "Regular.Std.Bytes.html", "<div class=\"info\">\n<p>Extension of the standard bytes module.</p>\n\n</div>\n", ["ANY", "ARE", "BIG", "BUT", "BYTES", "DATA", "ENHANCED", "EXCLUDING", "EXPECTED", "EXTENSION", "FOR", "FUNCTIONS", "HOWEVER", "INCLUDES", "INDEED", "INTERFACE", "ITSELF", "MODULE", "NEED", "NOT", "OCAML", "PRETTY", "REFERS", "REGULAR", "SERIALIZATION", "SET", "SPECIFIC", "STANDARD", "STD", "SUBSET", "SUPPORT", "THE", "WITH"]);
add_ocaml_element("Make", "Std.Opaque.Make", "module", "<i>(... module ...)</i>", "Regular.Std.Opaque.Make.html", "<div class=\"info\">\n<p>creates a module implementing <code class=\"code\"><span class=\"constructor\">Opaque</span></code> interface.</p>\n\n</div>\n", ["CREATES", "IMPLEMENTING", "INTERFACE", "MODULE", "OPAQUE"]);
add_ocaml_element("Opaque", "Std.Opaque", "module", "<i>(... module ...)</i>", "Regular.Std.Opaque.html", "<div class=\"info\">\n<p>Opaque type is like regular type, except that we can print or\n      examine it in any way.</p>\n\n</div>\n", ["ANY", "CAN", "CREATE", "EXAMINE", "EXCEPT", "INSTANCES", "LIKE", "MAKE", "OPAQUE", "PRETTY", "PRINT", "PRINTED", "REGULAR", "SERIALIZED", "STD", "SUCH", "THAT", "TYPE", "WAY"]);
add_ocaml_element("Make", "Std.Make", "module", "<i>(... module ...)</i>", "Regular.Std.Regular.Make.html", "<div class=\"info\">\n<p>In order to implement <code class=\"code\"><span class=\"constructor\">Regular</span></code> interface you need to provide a\n        minimum implementation <code class=\"code\"><span class=\"constructor\">M</span></code></p>\n\n</div>\n", ["IMPLEMENT", "IMPLEMENTATION", "INTERFACE", "MINIMUM", "NEED", "ORDER", "PROVIDE", "REGULAR", "YOU"]);
add_ocaml_element("Regular", "Std.Regular", "module", "<i>(... module ...)</i>", "Regular.Std.Regular.html", "<div class=\"info\">\n<p>Regular types models a general concept of value, i.e., something\n      that can be used in way similar to regular <code class=\"code\">int</code>, <code class=\"code\">string</code>,\n      <code class=\"code\">char</code> and other built in types.</p>\n\n</div>\n", ["ALSO", "AND", "ARE", "BUILT", "BUT", "CAN", "CHAR", "COMPARED", "COMPARISON", "CONCEPT", "CORE", "DERIVED", "DOESN", "EFFICIENTLY", "ELEGANTLY", "ETC", "FROM", "FUNCTION", "FUNCTIONS", "GENERAL", "HARDER", "HASHTABLES", "IDENTIFIABLE", "IMPLEMENT", "IMPLEMENTED", "INSTEAD", "INT", "MAPS", "MODELS", "MORE", "MUCH", "NOTE", "OF_STRING", "OTHER", "PLETHORA", "PPO", "PPS", "PRETTY", "PRINTER", "PRINTING", "REGULAR", "REQUIRE", "REQUIRES", "SETS", "SIGNATURE", "SIMILAR", "SOMETHING", "STR", "STRING", "THAT", "THE", "THIS", "TO_STRING", "TYPES", "USED", "USUALLY", "VALUE", "WAY", "WHOLE", "WITH"]);
add_ocaml_element("Service", "Std.Data.Cache.Service", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Cache.Service.html", "<div class=\"info\">\n<p>Service injection point.</p>\n\n</div>\n", ["ACTIVE", "ADD", "ALL", "ANY", "CACHE", "CACHING", "CAN", "CUSTOM", "DATA", "DEFAULT", "DOESN", "FOR", "FORGOTTEN", "FUNCTION", "FUNCTORS", "GIVEN", "IMPLEMENTING", "IMPLEMENTS", "INJECTION", "INTERFACE", "ITSELF", "JUST", "LIBRARY", "MAKE", "MODULE", "MOMENT", "NEED", "NOTE", "ONE", "ONLY", "OPAQUE", "ORDER", "PLUGINS", "POINT", "PREFERENCE", "PROVIDE", "PROVIDED", "REGISTER", "REGULAR", "SERVICE", "SERVICES", "STD", "STORED", "THE", "THEN", "THIS", "TYPE", "USE", "USING", "WHO", "WHOSE", "YOU", "YOUR"]);
add_ocaml_element("Digest", "Std.Data.Cache.Digest", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Cache.Digest.html", "<div class=\"info\">\n<p>Data digesting for caching.</p>\n\n</div>\n", ["CACHING", "DATA", "DIGESTING", "FOR"]);
add_ocaml_element("Cache", "Std.Data.Cache", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Cache.html", "<div class=\"info\">\n<p>Generic caching.</p>\n\n</div>\n", ["BUILD", "CACHE", "CACHING", "DATA", "DIGEST", "DIGESTS", "FOR", "GENERIC", "MODULE", "REGULAR", "STD", "THE", "TYPE", "USE", "VALUES", "WANT", "YOU"]);
add_ocaml_element("Write", "Std.Data.Write", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Write.html", "<div class=\"info\">\n<p>Write typeclass.</p>\n\n</div>\n", ["AND", "CLASS", "CONCERNING", "DATA", "DEFINES", "FOR", "INFORMATION", "MODULE", "MORE", "READ", "REGULAR", "SEE", "SERIALIZABLE", "STD", "THIS", "TYPECLASS", "USE", "VALUES", "WHEN", "WHY", "WRITE", "WRITEABLE"]);
add_ocaml_element("Read", "Std.Data.Read", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Read.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Read</span></code> typeclass.</p>\n\n</div>\n", ["ARE", "AVAILABLE", "CLASS", "DATA", "DIRECTLY", "FOR", "FUNCTIONS", "IMPLEMENTING", "INTERFACE", "LOOK", "LOOKING", "MODULE", "NEEDED", "NEW", "PROTOCOLS", "RARELY", "READ", "READABLE", "READERS", "REGULAR", "STD", "THE", "THEN", "THIS", "TYPE", "TYPECLASS", "USE", "USED", "VALUES", "YOU"]);
add_ocaml_element("Cache", "Std.Data.S.Cache", "module", "<i>(... module ...)</i>", "Regular.Std.Data.S.Cache.html", "<div class=\"info\">\n<p>Data cache.</p>\n\n</div>\n", ["ADDED", "AFFECT", "ALGORITHM", "ALLOWED", "AMOUNT", "AND", "ANY", "ARGUMENT", "ARGUMENTS", "AVAILABLE", "BECAUSE", "BENEFITS", "BUILD", "BUILDS", "BUILD_GRAPH", "BUT", "CACHE", "CACHED", "CACHING", "CAN", "CFG", "CODE", "COMPUTED", "COMPUTE_GRAPH", "CONTROL", "CORRESPONDINGLY", "COURSE", "CREATE", "DATA", "DEBUG", "DIGEST", "DISAPPEAR", "DOESN", "EVEN", "EXAMPLE", "EXTERNALLY", "FACILITIES", "FACT", "FALSE", "FLOW", "FOLLOWING", "FOR", "FORGET", "FROM", "FUNCTION", "GRAPH", "GRAPHS", "HAS", "HERE", "HOOD", "IMMEDIATELY", "INFRASTRUCTURE", "INT", "INTERFACE", "ITS", "ITSELF", "JUST", "KEY", "LET", "LIBRARY", "LOAD", "LOADING", "LONG", "LOOSE", "MATCH", "MD5", "NAMESPACE", "NONE", "NOT", "NOTE", "ONE", "ONLY", "OPTIONAL", "OUTLIVING", "PARAMETERS", "PERSISTANT", "PLUGIN", "PROGRAM", "PROVIDE", "PROVIDES", "REASONABLE", "REST", "RESULT", "RETRIEVE", "SAVE", "SEEN", "SERVICE", "SIGNIFICANT", "SINCE", "SOME", "STORAGE", "STORE", "STORED", "STORING", "STRING", "SUM", "SURVIVE", "TAKE", "THAT", "THE", "THERE", "THIS", "THREE", "TIME", "TRY", "TWO", "TYPE", "TYPES", "UNDERNEATH", "USE", "USED", "USING", "VALUE", "VIA", "WEAK", "WILL", "WITH", "WORK"]);
add_ocaml_element("Io", "Std.Data.S.Io", "module", "<i>(... module ...)</i>", "Regular.Std.Data.S.Io.html", "<div class=\"info\">\n<p>Input/Output functions for the given datum.</p>\n\n</div>\n", ["DATUM", "FOR", "FUNCTIONS", "GIVEN", "INPUT", "OUTPUT", "THE"]);
add_ocaml_element("Make", "Std.Data.Make", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Make.html", "<div class=\"info\">\n<p>Implements <code class=\"code\"><span class=\"constructor\">Data</span>.<span class=\"constructor\">S</span></code> interface from the provided minimal implementation.</p>\n\n</div>\n", ["DATA", "FROM", "IMPLEMENTATION", "IMPLEMENTS", "INTERFACE", "MINIMAL", "PROVIDED", "THE"]);
add_ocaml_element("Versioned", "Std.Data.Versioned", "module", "<i>(... module ...)</i>", "Regular.Std.Data.Versioned.html", "<div class=\"info\">\n<p>Versioned interfaces</p>\n\n</div>\n", ["INTERFACES", "VERSIONED"]);
add_ocaml_element("Data", "Std.Data", "module", "<i>(... module ...)</i>", "Regular.Std.Data.html", "<div class=\"info\">\n<p>Data types support module.</p>\n\n</div>\n", ["ALSO", "AND", "ANY", "BITS", "CACHE", "CACHING", "CAN", "COLLECTION", "DATA", "DEFINES", "DESCRIBES", "DOING", "EACH", "EXPECTED", "EXPLICIT", "FOR", "FUNCTIONS", "GENERIC", "HARD", "INSIST", "INTERFACE", "INTERFACES", "LOADED", "MEDIA", "MODULE", "OBTAIN", "OCAML", "OTHERWISE", "PROVIDES", "REGULAR", "REPRESENTATION", "SAFE", "SET", "SIDE", "SOME", "STD", "STORED", "SUITABLE", "SUPPORT", "THAT", "THE", "THIS", "TYPES", "USEFUL", "VALUE", "VERSIONING", "WAY"]);
add_ocaml_element("Seq", "Std.Seq", "module", "<i>(... module ...)</i>", "Regular.Std.Seq.html", "<div class=\"info\">\n<p>Lazy sequence.</p>\n\n</div>\n", ["CORE_KERNEL", "EXTENSION", "LAZY", "MODULE", "SEQUENCE", "THE", "THIS"]);
add_ocaml_element("Make", "Std.Printable.Make", "module", "<i>(... module ...)</i>", "Regular.Std.Printable.Make.html", "<div class=\"info\">\n<p>Implement <code class=\"code\"><span class=\"constructor\">Printable</span></code> interface from the minimum implementation.</p>\n\n</div>\n", ["AND", "FROM", "FUNCTION", "IMPLEMENT", "IMPLEMENTATION", "IMPLEMENTS", "INTERFACE", "MINIMUM", "MODULE", "MODULE_NAME", "PRINTABLE", "PRINTER", "PROVIDES", "REST", "TAKES", "THAT", "THE"]);
add_ocaml_element("Printable", "Std.Printable", "module", "<i>(... module ...)</i>", "Regular.Std.Printable.html", "<div class=\"info\">\n<p>Printable data structures.</p>\n\n</div>\n", ["DATA", "PRINTABLE", "STRUCTURES"]);
add_ocaml_element("Std", "Std", "module", "<i>(... module ...)</i>", "Regular.Std.html", "<div class=\"info\">\n<p>Interface that should support any regular data type.</p>\n\n</div>\n", ["ACTUALLY", "ALGEBRA", "ALGEBRAIC", "ALL", "ALLOWS", "ALSO", "ALWAYS", "AND", "ANY", "ARE", "BORDER", "BUT", "BYTES", "CALLED", "CAN", "CATCH", "CHARACTERS", "CLOSURE", "CLOSURES", "COLLECTIONS", "COMPARABLE", "COMPARISON", "CONCRETE", "CONTAINED", "CONTAINERS", "CONTRAST", "CREATING", "DATA", "DEFINES", "DERIVED", "DERIVES", "DESCRIBES", "DESCRIPTORS", "DIFFERENCE", "DIFFERENT", "DOESN", "EACH", "ENHANCED", "ETC", "EVERYTHING", "EXPECTED", "EXTENSION", "FACILITATES", "FEATURES", "FINALLY", "FIRST", "FOR", "FROM", "FULL", "FUNCTION", "FUNCTIONS", "FUNCTOR", "HAS", "HASHABLE", "HASHTABLES", "HAVE", "IMMUTABLE", "IMPLEMENT", "IMPLEMENTATION", "INCLUDES", "INCLUDING", "INDUCTIVE", "INSPECT", "INTEFACE", "INTERFACE", "LIBRARY", "LIKE", "LINE", "MAIN", "MAPS", "MINIMAL", "MODULE", "MUTABLE", "NON", "NOT", "NUMBERS", "OBSERVED", "OCAML", "ONE", "ONLY", "OPAQUE", "ORDER", "OVERVIEW", "PRETEND", "PRINTABLE", "PRINTING", "PROPER", "PROVIDE", "PROVIDED", "PROVIDES", "PROXIES", "READ", "REALLY", "REGULAR", "REPRESENT", "REPRESENTATION", "REPRESENTED", "REQUIRES", "REST", "SEE", "SELF", "SERIALIZATION", "SERIALIZE", "SET", "SETS", "SHOULD", "SOMETHING", "STANDARD", "STD", "STRINGS", "SUBSET", "SUCH", "SUPPORT", "TERM", "THAT", "THE", "THEIR", "THESE", "THIS", "TOTAL", "TRANSFER", "TREES", "TYPE", "TYPES", "USUALLY", "VALUES", "WHAT", "WHERE", "WHOLE", "WITH", "WOULD", "WRITE"]);
add_ocaml_element("Regular", "Regular", "module", "<i>(... module ...)</i>", "Regular.html", "<div class=\"info\">\n<p>Regular Library.</p>\n\n</div>\n", ["LIBRARY", "REGULAR"]);
add_ocaml_element("Plugins", "Bap_plugins.Std.Plugins", "module", "<i>(... module ...)</i>", "Bap_plugins.Std.Plugins.html", "<div class=\"info\">\n<p>Plugin loader.</p>\n\n</div>\n", ["ABOUT", "AND", "ARE", "BAP", "BAPBUNDLE", "BAP_PLUGINS", "BAP_PLUGIN_PATH", "CALLED", "COMMAND", "DEBUGGING", "DEFAULT", "DESCRIPTION", "DESTINATION", "DRIVEN", "DURING", "ENVIRONMENT", "EVENT", "EVENTS", "EXPLICITLY", "FIRE", "FOLLOWING", "FOR", "FUNCTION", "HANDLER", "HANDLES", "INFROMATION", "INSTALL", "INSTALLATION", "INTERCEPTED", "ISSUES", "LATTER", "LIB", "LIBRARY", "LOADER", "LOCATIONS", "LOGGER", "LOOKED", "MODULE", "ONCE", "PARAMETER", "PATH", "PATHS", "PLATFORM", "PLUGIN", "PLUGINS", "PREFIX", "REPOSITORY", "RUN", "SAME", "SEE", "SET", "SPECIFIED", "START", "STD", "SYNTAX", "SYSTEM", "THAT", "THE", "THEY", "THIS", "TYPE", "USED", "USEFUL", "USER", "VARIABLE", "VIA", "VISIBLE", "WHERE", "WILL", "WITH", "WRITE"]);
add_ocaml_element("Plugin", "Bap_plugins.Std.Plugin", "module", "<i>(... module ...)</i>", "Bap_plugins.Std.Plugin.html", "<div class=\"info\">\n<p>Plugin - a loadable self-contained piece of code.</p>\n\n</div>\n", ["AND", "BUNDLE", "CODE", "CONTAINED", "CONTAINS", "DATA", "INFORMATION", "LOADABLE", "META", "PIECE", "PLUGIN", "SELF", "THAT"]);
add_ocaml_element("Std", "Bap_plugins.Std", "module", "<i>(... module ...)</i>", "Bap_plugins.Std.html", "<div class=\"info\">\n<p>Interface to the plugin subsystem.</p>\n\n</div>\n", ["INTERFACE", "PLUGIN", "SUBSYSTEM", "THE"]);
add_ocaml_element("Bap_plugins", "Bap_plugins", "module", "<i>(... module ...)</i>", "Bap_plugins.html", "<div class=\"info\">\n<p>Bap Plugin Library.</p>\n\n</div>\n", ["BAP", "LIBRARY", "PLUGIN"]);
add_ocaml_element("Core_printers", "Core_printers", "module", "<i>(... module ...)</i>", "Core_printers.html", "", []);
add_ocaml_element("Bap_config", "Bap_config", "module", "<i>(... module ...)</i>", "Bap_config.html", "", []);
add_ocaml_element("Builder", "Bap_bundle.Std.Bundle.Builder", "module", "<i>(... module ...)</i>", "Bap_bundle.Std.Bundle.Builder.html", "<div class=\"info\">\n<p>Incremental bundle builder.</p>\n\n</div>\n", ["ADDED", "BUILD", "BUILDER", "BUNDLE", "CALLED", "COPIED", "DATA", "FLUSH", "INCREMENTAL", "INCREMENTALLY", "METHOD", "MODULE", "NOT", "POSSIBLE", "RECIPE", "THAT", "THE", "THIS", "UNTIL", "USING", "WAS", "WILL"]);
add_ocaml_element("Bundle", "Bap_bundle.Std.Bundle", "module", "<i>(... module ...)</i>", "Bap_bundle.Std.Bundle.html", "<div class=\"info\">\n<p>Program Bundle.</p>\n\n</div>\n", ["ACCESS", "ASSOCIATED", "BAP_BUNDLE", "BUNDLE", "COLLECTION", "DATA", "FUNCTION", "LET", "MAIN_BUNDLE", "OPEN", "PROGRAM", "STD", "THE", "USE", "WITH"]);
add_ocaml_element("Manifest", "Bap_bundle.Std.Manifest", "module", "<i>(... module ...)</i>", "Bap_bundle.Std.Manifest.html", "<div class=\"info\">\n<p>Program meta infromation.</p>\n\n</div>\n", ["INFROMATION", "META", "PROGRAM"]);
add_ocaml_element("Std", "Bap_bundle.Std", "module", "<i>(... module ...)</i>", "Bap_bundle.Std.html", "", []);
add_ocaml_element("Bap_bundle", "Bap_bundle", "module", "<i>(... module ...)</i>", "Bap_bundle.html", "", []);
add_ocaml_element("CPU", "Std.Target.CPU", "module", "<i>(... module ...)</i>", "Bap.Std.Target.CPU.html", "<div class=\"info\">\n<p>access to the CPU variables.</p>\n\n</div>\n", ["ACCESS", "CPU", "THE", "VARIABLES"]);
add_ocaml_element("Log", "Std.Log", "module", "<i>(... module ...)</i>", "Bap.Std.Log.html", "<div class=\"info\">\n<p>Default Logger.</p>\n\n</div>\n", ["ACCESSED", "AGE", "ALSO", "AND", "BAP", "BAP_BACKLOG", "BAP_LOG_DIR", "CALLS", "CAN", "CAPTURE", "DEFAULT", "DEFAULTS", "ENVIRONMENT", "EVEN", "EVENT", "EVENTS", "EVERY", "EXAMPLE", "FILE", "FOLDER", "FOR", "FUNCTION", "HAVE", "HOME", "INTO", "LOCAL", "LOCATED", "LOG", "LOGGER", "LOGS", "MAXIMUM", "NAME", "OLDEST", "PREVIOUS", "PRINT", "ROTATED", "SET", "START", "STARTED", "STAT", "STD", "SYSTEM", "TEMPORARY", "THAT", "THE", "THEM", "THEN", "THIS", "TIME", "UNDEFINED", "UNDER", "VARIABLE", "VIA", "WHERE", "WILL", "XDG_STATE_HOME"]);
add_ocaml_element("Config", "Std.Self.Config", "module", "<i>(... module ...)</i>", "Bap.Std.Self.Config.html", "<div class=\"info\">\n<p>This module allows plugins to access BAP configuration variables.</p>\n\n</div>\n", ["ACCESS", "ALLOWS", "ARGUMENTS", "BAP", "COMMAND", "CONFIG", "CONFIGURATION", "DEBUG", "DECREASING", "DEFAULT", "DOC", "DO_STUFF", "ENVIRONMENT", "EXAMPLE", "FALLBACK", "FILE", "FLAG", "FOR", "FUN", "GET", "INPUT", "LET", "LINE", "MAIN", "MODULE", "ORDER", "PARAM", "PATH", "PLUGINS", "PRECEDENCE", "READING", "STRING", "THE", "THIS", "TXT", "USAGE", "VALUE", "VALUES", "VARIABLES", "WHEN", "WHEN_READY"]);
add_ocaml_element("Self", "Std.Self", "module", "<i>(... module ...)</i>", "Bap.Std.Self.html", "<div class=\"info\">\n<p>A self reflection.</p>\n\n</div>\n", ["AND", "APPLICATION", "APPLICATIONS", "ARGV", "BRING", "BUNDLED", "BUT", "CAN", "DEBUGGING", "DEFINITIONS", "DESIGNED", "EXECUTABLE_NAME", "FIELD", "FOR", "FUNCTOR", "GENERATIVE", "INCLUDE", "INFORMATION", "INSIDE", "MODE", "MODULE", "NAME", "PLUGIN", "PLUGINS", "PROGRAM", "REFERS", "REFLECTION", "RUN", "RUNNING", "SCOPE", "SELF", "SET", "STANDALONE", "SYNTAX", "SYS", "THE", "THEM", "THEN", "THIS", "USE", "USED", "USEFULL", "WELL", "WITH", "WOULD"]);
add_ocaml_element("Pass", "Std.Project.Pass", "module", "<i>(... module ...)</i>", "Bap.Std.Project.Pass.html", "<div class=\"info\">\n<p>A program analysis pass.</p>\n\n</div>\n", ["ANALYSIS", "AND", "ASSOCIATED", "DATA", "DEPEND", "ESSENTIALLY", "FEW", "FUNCTION", "HAVE", "MAY", "MODIFIED", "NEW", "OTHER", "PASS", "PASSES", "POSSIBLY", "PROGRAM", "PROJECT", "PROPERTIES", "RETURNS", "STRUCTURES", "TAKES", "THAT", "THEM", "WITH"]);
add_ocaml_element("Input", "Std.Project.Input", "module", "<i>(... module ...)</i>", "Bap.Std.Project.Input.html", "<div class=\"info\">\n<p>Input information.</p>\n\n</div>\n", ["ABSTRACTS", "INFORMATION", "INPUT", "MODULE", "THIS", "TYPE"]);
add_ocaml_element("Info", "Std.Project.Info", "module", "<i>(... module ...)</i>", "Bap.Std.Project.Info.html", "<div class=\"info\">\n<p>Information obtained during project reconstruction.</p>\n\n</div>\n", ["ARE", "BAP", "CREATE", "DISCOVERED", "DURING", "FOR", "FUNCTION", "GUARANTEED", "INFORMATION", "MORE", "OBTAINED", "PIECES", "PROCESS", "PROJECT", "RECONSTRUCTION", "SEE", "STD", "THE", "THESE"]);
add_ocaml_element("Project", "Std.Project", "module", "<i>(... module ...)</i>", "Bap.Std.Project.html", "<div class=\"info\">\n<p>Disassembled program.</p>\n\n</div>\n", ["ABLE", "ACTUALLY", "ALLOWS", "ALSO", "AMOUNT", "ANALYSES", "ANALYSIS", "AND", "ARBITRARY", "ASSOCIATE", "ATTACH", "BAP", "BASE", "BETWEEN", "CAN", "COMMUNICATION", "CONTAINS", "DATA", "DEEPLY", "DELIVERING", "DIFFERENT", "DISASSEMBLED", "DISASSEMBLY", "DURING", "EVEN", "FACTS", "FROM", "GLOBALLY", "INFORMATION", "INTERCONNECTED", "ITSELF", "KNOWLEDGE", "MEDIA", "MEMORY", "OTHER", "PASSES", "PROGRAM", "PROJECT", "RECONSTRUCT", "REGIONS", "SEE", "SEEN", "SEMANTIC", "STD", "TERMS", "THAN", "THAT", "THE", "THEM", "USED", "WERE", "WITH"]);
add_ocaml_element("Log", "Std.Event.Log", "module", "<i>(... module ...)</i>", "Bap.Std.Event.Log.html", "<div class=\"info\">\n<p>Logging event.</p>\n\n</div>\n", ["EVENT", "LOGGING"]);
add_ocaml_element("Event", "Std.Event", "module", "<i>(... module ...)</i>", "Bap.Std.Event.html", "<div class=\"info\">\n<p>Event subsystem.</p>\n\n</div>\n", ["BAP", "BETWEEN", "COMMUNICATING", "DIFFERENT", "EVENT", "SUBSYSTEM", "SUBSYSTEMS", "THE", "WAY"]);
add_ocaml_element("Factory", "Std.Reconstructor.Factory", "module", "<i>(... module ...)</i>", "Bap.Std.Reconstructor.Factory.html", "<div class=\"info\">\n<p>a factory of reconstructors</p>\n\n</div>\n", ["FACTORY", "RECONSTRUCTORS"]);
add_ocaml_element("Reconstructor", "Std.Reconstructor", "module", "<i>(... module ...)</i>", "Bap.Std.Reconstructor.html", "<div class=\"info\">\n<p>Reconstructor is responsible for reconstructing symbol table\n      from a CFG.</p>\n\n</div>\n", ["ABOUT", "AND", "BAP", "CFG", "FOR", "FROM", "FUNCTIONS", "INFORMATION", "INTERSECTING", "INTO", "MODULE", "MORE", "PARTITION", "POSSIBLY", "RECONSTRUCTING", "RECONSTRUCTOR", "RESPONSIBLE", "SEE", "SET", "SHOULD", "STD", "SYMBOL", "SYMTAB", "TABLE"]);
add_ocaml_element("Factory", "Std.Brancher.Factory", "module", "<i>(... module ...)</i>", "Bap.Std.Brancher.Factory.html", "", []);
add_ocaml_element("Brancher", "Std.Brancher", "module", "<i>(... module ...)</i>", "Bap.Std.Brancher.html", "<div class=\"info\">\n<p>Brancher is responsible for resolving destinations of branch\n      instructions.</p>\n\n</div>\n", ["BRANCH", "BRANCHER", "DESTINATIONS", "FOR", "INSTRUCTIONS", "RESOLVING", "RESPONSIBLE"]);
add_ocaml_element("Factory", "Std.Rooter.Factory", "module", "<i>(... module ...)</i>", "Bap.Std.Rooter.Factory.html", "<div class=\"info\">\n<p>A factory of rooters.</p>\n\n</div>\n", ["CUSTOM", "FACTORY", "REGISTER", "ROOTERS", "USEFUL"]);
add_ocaml_element("Rooter", "Std.Rooter", "module", "<i>(... module ...)</i>", "Bap.Std.Rooter.html", "<div class=\"info\">\n<p>Rooter finds starts of functions in the binary.</p>\n\n</div>\n", ["BINARY", "FINDS", "FUNCTIONS", "ROOTER", "STARTS", "THE"]);
add_ocaml_element("Factory", "Std.Symbolizer.Factory", "module", "<i>(... module ...)</i>", "Bap.Std.Symbolizer.Factory.html", "<div class=\"info\">\n<p>A factory of symbolizers.</p>\n\n</div>\n", ["AND", "CREATE", "FACTORY", "REGISTER", "SYMBOLIZERS", "USE"]);
add_ocaml_element("Symbolizer", "Std.Symbolizer", "module", "<i>(... module ...)</i>", "Bap.Std.Symbolizer.html", "<div class=\"info\">\n<p>Symbolizer maps addresses to function names</p>\n\n</div>\n", ["ADDRESSES", "FUNCTION", "MAPS", "NAMES", "SYMBOLIZER"]);
add_ocaml_element("Map", "Std.Taint.Map", "module", "<i>(... module ...)</i>", "Bap.Std.Taint.Map.html", "", []);
add_ocaml_element("Expi", "Std.Taint.S.Expi", "module", "<i>(... module ...)</i>", "Bap.Std.Taint.S.Expi.html", "", []);
add_ocaml_element("Make", "Std.Taint.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Taint.Make.html", "", []);
add_ocaml_element("Taint", "Std.Taint", "module", "<i>(... module ...)</i>", "Bap.Std.Taint.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>Abstract taint.</p>\n\n</span></div>\n", ["ABSTRACT", "ASSOCIATED", "BAP", "DEFINES", "DEPRECATED", "DESIGNATE", "EACH", "FRAMEWORK", "GIVEN", "IDENTIFIER", "PRODUCED", "REPRESENT", "SET", "TAINT", "TAINTED", "TAINTS", "TERM", "THAT", "THE", "THIS", "USE", "USUALLY", "VARIABLE", "WAS", "WHICH", "WITH"]);
add_ocaml_element("Make", "Std.Source.Factory.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Source.Factory.Make.html", "", []);
add_ocaml_element("Factory", "Std.Source.Factory", "module", "<i>(... module ...)</i>", "Bap.Std.Source.Factory.html", "<div class=\"info\">\n<p>Factory of data processors.</p>\n\n</div>\n", ["DATA", "FACTORY", "INFORMATION", "PROCESSORS", "REGISTRY", "SOURCES"]);
add_ocaml_element("Source", "Std.Source", "module", "<i>(... module ...)</i>", "Bap.Std.Source.html", "<div class=\"info\">\n<p>Source of information.</p>\n\n</div>\n", ["INFORMATION", "SOURCE"]);
add_ocaml_element("Label", "Std.Label", "module", "<i>(... module ...)</i>", "Bap.Std.Label.html", "<div class=\"info\">\n<p>Target of a control flow transfer.</p>\n\n</div>\n", ["CONTROL", "FLOW", "TARGET", "TRANSFER"]);
add_ocaml_element("Call", "Std.Call", "module", "<i>(... module ...)</i>", "Bap.Std.Call.html", "<div class=\"info\">\n<p>A control transfer to another subroutine.</p>\n\n</div>\n", ["ANOTHER", "CONTROL", "SUBROUTINE", "TRANSFER"]);
add_ocaml_element("Arg", "Std.Arg", "module", "<i>(... module ...)</i>", "Bap.Std.Arg.html", "<div class=\"info\">\n<p>Subroutine argument.</p>\n\n</div>\n", ["ARGUMENT", "SUBROUTINE"]);
add_ocaml_element("Phi", "Std.Phi", "module", "<i>(... module ...)</i>", "Bap.Std.Phi.html", "<div class=\"info\">\n<p>PHI-node</p>\n\n</div>\n", ["NODE", "PHI"]);
add_ocaml_element("Jmp", "Std.Jmp", "module", "<i>(... module ...)</i>", "Bap.Std.Jmp.html", "<div class=\"info\">\n<p>A control transfer operation.</p>\n\n</div>\n", ["CONTROL", "OPERATION", "TRANSFER"]);
add_ocaml_element("Def", "Std.Def", "module", "<i>(... module ...)</i>", "Bap.Std.Def.html", "<div class=\"info\">\n<p>Definition.</p>\n\n</div>\n", ["DEFINITION"]);
add_ocaml_element("Builder", "Std.Blk.Builder", "module", "<i>(... module ...)</i>", "Bap.Std.Blk.Builder.html", "<div class=\"info\">\n<p>Builder interface.</p>\n\n</div>\n", ["BUILDER", "INTERFACE"]);
add_ocaml_element("Blk", "Std.Blk", "module", "<i>(... module ...)</i>", "Bap.Std.Blk.html", "<div class=\"info\">\n<p>Basic block.</p>\n\n</div>\n", ["AFTER", "AKA", "AND", "ANY", "ARE", "BASIC", "BLOCK", "CAN", "COLLOQUIAL", "COMING", "CONDITION", "CONSISTS", "C_1", "C_2", "C_N", "DEFINITIONS", "DESTINATION", "EACH", "EDGES", "ELEMENT", "ELSE", "ENDS", "ENTITIES", "EXAMPLE", "EXECUTE", "EXECUTION", "FOLLOWING", "FOR", "HAVE", "JMP_N", "JUMP", "JUMPS", "LATTER", "LOGICALLY", "NAMED", "NODES", "NOT", "OCAML", "ONLY", "ORDER", "OUT", "PER", "PHI", "PROGRAM", "SEMANTICS", "SEQUENCE", "SET", "SHOULD", "SIMULTANEOUSLY", "SPECIFIED", "STOP", "STORED", "TAKEN", "TERM", "THE", "THEN", "THEY", "THIS", "THREE", "T_1", "T_2", "T_N", "WAS", "WHERE", "WHICH", "WITH", "WOULD"]);
add_ocaml_element("Builder", "Std.Sub.Builder", "module", "<i>(... module ...)</i>", "Bap.Std.Sub.Builder.html", "<div class=\"info\">\n<p>Subroutine builder</p>\n\n</div>\n", ["BUILDER", "SUBROUTINE"]);
add_ocaml_element("Sub", "Std.Sub", "module", "<i>(... module ...)</i>", "Bap.Std.Sub.html", "<div class=\"info\">\n<p>Subroutine.</p>\n\n</div>\n", ["SUBROUTINE"]);
add_ocaml_element("Builder", "Std.Program.Builder", "module", "<i>(... module ...)</i>", "Bap.Std.Program.Builder.html", "<div class=\"info\">\n<p>Program builder.</p>\n\n</div>\n", ["BUILDER", "PROGRAM"]);
add_ocaml_element("Program", "Std.Program", "module", "<i>(... module ...)</i>", "Bap.Std.Program.html", "<div class=\"info\">\n<p>Program in Intermediate representation.</p>\n\n</div>\n", ["INTERMEDIATE", "PROGRAM", "REPRESENTATION"]);
add_ocaml_element("Term", "Std.Term", "module", "<i>(... module ...)</i>", "Bap.Std.Term.html", "<div class=\"info\">\n<p>IR language term.</p>\n\n</div>\n", ["00000001", "00000003", "AND", "APPEND", "ARE", "BINARY", "BLK", "BLOCK", "BUILDING", "CAN", "CHILD", "CLASS", "CLASSES", "CLS", "CREATE", "DEFINITION", "DEF_T", "DENOTED", "DIFFERENT", "D_1", "D_2", "EXAMPLE", "EXPLICIT", "FOR", "FUNCTIONS", "GIVE", "INSTANCE", "INTERMEDIATE", "LANGUAGE", "LET", "MODULE", "OVERLOADED", "PARENT", "PROGRAM", "PROVIDES", "REPRESENTATION", "STANDS", "TERM", "THAT", "THE", "THIS", "TRUE", "TYPE", "UPDATE", "VAL", "VALUE", "WHERE", "WITH"]);
add_ocaml_element("Tid", "Std.Tid", "module", "<i>(... module ...)</i>", "Bap.Std.Tid.html", "<div class=\"info\">\n<p>Term identifier</p>\n\n</div>\n", ["IDENTIFIER", "TERM"]);
add_ocaml_element("Symtab", "Std.Symtab", "module", "<i>(... module ...)</i>", "Bap.Std.Symtab.html", "<div class=\"info\">\n<p>Reconstructed symbol table.</p>\n\n</div>\n", ["RECONSTRUCTED", "SYMBOL", "TABLE"]);
add_ocaml_element("With_exn", "Std.Disasm.With_exn", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm.With_exn.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">With_exn</span>.f</code> is the same as <code class=\"code\">f</code> except that it throws an\n        exception instead of returning <code class=\"code\"><span class=\"constructor\">Error</span></code>.</p>\n\n</div>\n", ["ERROR", "EXCEPT", "EXCEPTION", "INSTEAD", "RETURNING", "SAME", "THAT", "THE", "THROWS", "WITH_EXN"]);
add_ocaml_element("Disasm", "Std.Disasm", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm.html", "<div class=\"info\">\n<p>Disassembled program.</p>\n\n</div>\n", ["DIASSEMBLING", "DISASSEMBLED", "FOR", "INTERFACE", "PROGRAM", "THINGS"]);
add_ocaml_element("Tid", "Std.Graphs.Tid", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.Tid.html", "<div class=\"info\">\n<p>Graph of Term identifiers.</p>\n\n</div>\n", ["ALL", "ALSO", "AND", "ARE", "BETWEEN", "DISTILLED", "GRAPH", "IDENTIFIERS", "INFORMATION", "LABELED", "RELATIONS", "TERM", "THAT", "THEM", "THIS", "WHERE", "WITH"]);
add_ocaml_element("Node", "Std.Graphs.Ir.Node", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.Ir.Node.html", "<div class=\"info\">\n<p>IR Graph node.</p>\n\n</div>\n", ["BLK", "GRAPH", "LABELED", "NODE", "TERM", "THE"]);
add_ocaml_element("Edge", "Std.Graphs.Ir.Edge", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.Ir.Edge.html", "<div class=\"info\">\n<p>since in IR the order of edges defines semantics, we provide\n          extra functions</p>\n\n</div>\n", ["DEFINES", "EDGES", "EXTRA", "FUNCTIONS", "ORDER", "PROVIDE", "SEMANTICS", "SINCE", "THE"]);
add_ocaml_element("Ir", "Std.Graphs.Ir", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.Ir.html", "<div class=\"info\">\n<p>Graph view over IR.</p>\n\n</div>\n", ["ABSENT", "ABSTRACT", "ACCURATELY", "ADDED", "AFFECT", "AFFECTS", "ALL", "ALREADY", "ALSO", "ALTHOUGH", "AND", "ANY", "APPLIED", "ARBITRARY", "ARE", "ASSUMING", "AUGMENTED", "AUXILIARY", "BAP", "BASIC", "BASICALLY", "BEFORE", "BEHAVIOR", "BETTER", "BETWEEN", "BLK", "BLOCK", "BLOCKS", "BUILD", "BUILDER", "BUT", "CAN", "CHANGES", "CLARIFY", "COMPUTING", "CONDITIONS", "CONTAIN", "CONTROL", "CORRECTLY", "CORRESPONDING", "CORRESPONDS", "CREATE", "CREATED", "CURRENT", "DATA", "DEPENDING", "DESCRIPTION", "DESTINATION", "DIFFERENT", "DOESN", "DUMMY", "EACH", "EDGE", "EDGES", "EVALUATED", "EXAMPLE", "EXISTING", "EXISTS", "FALSE", "FEW", "FIXED", "FLOW", "FOLLOWING", "FOR", "FROM", "FUNCTION", "GIVEN", "GRAPH", "GUARD", "HANDLE", "IGNORED", "IMPLEMENTS", "INCIDENT", "INSERT", "INSERTED", "INSERTING", "INSERTION", "INSTANCE", "INSTEAD", "INTERFACE", "INTERFACES", "INTERMEDIATE", "INTO", "ITSELF", "JMP", "JUMP", "JUMPS", "JUST", "LABEL", "LABELED", "LANGUAGE", "LEAD", "LEAST", "LEFT", "LIKE", "LOG", "LOOK", "MAPPED", "MATTERS", "MIDDLE", "MODIFICATION", "MODIFIED", "MODIFY", "MODULE", "MODULES", "MOMENT", "MORE", "MOST", "MUST", "NEEDED", "NEW", "NEXT", "NODE", "NODES", "NOT", "NUMBER", "OBTAINED", "OF_CFG", "ONLY", "OPERATION", "OPERATIONS", "ORDER", "OTHER", "OVER", "PERFORMANCE", "PERFORMS", "POINT", "POINTS", "POSITION", "POSSIBLY", "PRECAUTION", "PREPENDED", "PRESENT", "PRESERVED", "PROJECTION", "RATHER", "REACH", "READ", "REASONS", "RECOMMENDED", "REMOVE", "REMOVED", "REMOVES", "REMOVING", "REPRESENTATION", "REPRESENTED", "REPRESENTS", "RESULT", "SAME", "SAMENESS", "SECTIONS", "SEE", "SEMANTICS", "SEQUENCE", "SET", "SHOULD", "SLOT", "SOME", "SOURCE", "STATEMENT", "STD", "STRUCTURES", "SUB", "SUBROUTINE", "SUBSTITUTED", "SUCH", "SWITCH", "SYMMETRIC", "TAKE", "TAKEN", "TARGET", "TERM", "TERMS", "THAT", "THE", "THEN", "THERE", "THEY", "THIS", "THUS", "TIME", "TO_CFG", "TRANSFER", "UNDERLYING", "UNSPECIFIED", "UNTOUCHED", "UPDATE", "UPDATED", "UPDATING", "USE", "USING", "VERSION", "VIEW", "WANT", "WAS", "WERE", "WHEN", "WHETHER", "WILL", "WITH", "YET", "YOU", "YOUR", "ZERO"]);
add_ocaml_element("Callgraph", "Std.Graphs.Callgraph", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.Callgraph.html", "<div class=\"info\">\n<p>A call graph representation.</p>\n\n</div>\n", ["AND", "ARE", "CALL", "CALLS", "CALLSITE", "CALLSITES", "DENOTED", "EDGES", "GRAPH", "IDENTIFIERS", "JUMP", "LIST", "MARKED", "NODES", "REPRESENTATION", "REPRESENTATIONS", "REPRESENTING", "SUBROUTINE", "TERM", "TERMS", "THIS", "WHERE", "WITH"]);
add_ocaml_element("Cfg", "Std.Graphs.Cfg", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.Cfg.html", "<div class=\"info\">\n<p>Control Flow Graph with a machine basic block as a node.</p>\n\n</div>\n", ["BASIC", "BLOCK", "CONTROL", "FLOW", "GRAPH", "MACHINE", "NODE", "WITH"]);
add_ocaml_element("Graphs", "Std.Graphs", "module", "<i>(... module ...)</i>", "Bap.Std.Graphs.html", "<div class=\"info\">\n<p>BAP Common Graphs.</p>\n\n</div>\n", ["ACROSS", "AND", "ARE", "BAP", "BIND", "BLOCK", "CASE", "CFG", "CHOSEN", "CLASS", "COMMON", "CONCAT_MAP", "CONTAINS", "DIFFERENT", "FIRST", "FUNCTIONS", "GRAPH", "GRAPHLIB", "GRAPHS", "IDIOMATIC", "INSNS", "LET", "LIBRARY", "MAP", "MODULE", "NAME", "OF_LIST", "REVERSE_POSTORDER_TRAVERSE", "SEQ", "SEVERAL", "SHORTER", "STRUCTURES", "THAT", "THE", "THIS", "USE", "USED", "WITH"]);
add_ocaml_element("Block", "Std.Block", "module", "<i>(... module ...)</i>", "Bap.Std.Block.html", "<div class=\"info\">\n<p>Basic block.</p>\n\n</div>\n", ["ALSO", "AND", "ANY", "ARE", "BASIC", "BLOCK", "BLOCKS", "CAN", "CODE", "CONSISTS", "CONTAINER", "CONTROL", "EACH", "ENTRY", "EXIT", "FLOW", "FOLLOWING", "FOR", "GRAPHS", "HAS", "INSTRUCTION", "INSTRUCTIONS", "INVARIANTS", "JUMP", "KNOWN", "LEADER", "LEAST", "MUST", "NODES", "NOT", "ONE", "PIECE", "POINTS", "PRESERVED", "PROGRAM", "SEEN", "SINGLE", "SOME", "TERMINATOR", "THAT", "THE", "THERE"]);
add_ocaml_element("Normalized", "Std.Insn.Trie.Normalized", "module", "<i>(... module ...)</i>", "Bap.Std.Insn.Trie.Normalized.html", "", []);
add_ocaml_element("Trie", "Std.Insn.Trie", "module", "<i>(... module ...)</i>", "Bap.Std.Insn.Trie.html", "<div class=\"info\">\n<p>Prefix Tree\n        This module provides a trie data structure where a sequence of\n        instructions is used as a key (and an individual instruction\n        as a token).</p>\n\n</div>\n", ["AND", "ARE", "COMPARED", "COMPARISON", "CONCERETE", "DATA", "DIFFERENT", "EXCESS", "EXCLUDED", "FROM", "HAVE", "IGNORED", "IMMEDIATE", "IMPLEMENTATIONS", "INDIVIDUAL", "INSNS", "INSTRUCTION", "INSTRUCTIONS", "KEY", "MODULE", "NORMALIZED", "NUMBER", "ONLY", "OPERANDS", "PREFIX", "PROVIDED", "PROVIDES", "REGULAR", "SEQUENCE", "STRUCTURE", "THE", "THEN", "THIS", "TOKEN", "TREE", "TRIE", "TWO", "USED", "USING", "VALUES", "WHERE"]);
add_ocaml_element("Insn", "Std.Insn", "module", "<i>(... module ...)</i>", "Bap.Std.Insn.html", "<div class=\"info\">\n<p>Assembly instruction.</p>\n\n</div>\n", ["ABOUT", "ADD", "ALSO", "ANALYZED", "AND", "ARE", "ASSEMBLY", "ATTACHED", "BAP", "BIL", "BLOCK", "BORN", "CODE", "CREATE", "CREATED", "DESCRIBES", "DISASM", "EACH", "EXAMPLE", "FIELD", "FLAGS", "FOR", "FROM", "FURTHER", "HIGH", "INFORMATION", "INSN", "INSNS", "INSTRUCTION", "INSTRUCTIONS", "LATER", "LEVEL", "LOW", "MACHINERY", "MANUALLY", "MAY", "NEED", "NON", "ONE", "OPCODE", "OPERANDS", "PAIR", "SEE", "SEMANTIC", "SEMANTICS", "SEQUENCE", "STAGES", "STD", "STORES", "SYNTHETIC", "TAGS", "TERM", "THAT", "THE", "THERE", "USUALLY", "WAS", "WHICH", "WITH"]);
add_ocaml_element("Recursive", "Std.Disasm_expert.Recursive", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Recursive.html", "<div class=\"info\">\n<p>Recursive Descent Disassembler.</p>\n\n</div>\n", ["ALGORITHM", "AND", "BASIC", "BUILT", "CFG", "DESCENT", "DISASM", "DISASSEMBLER", "DISASSEMBLY", "EXPERT", "HIGH", "IMPLEMENT", "INTERFACE", "LEVEL", "LIST", "MODULE", "ONTOP", "PROGRAM", "RECONSTRUCTS", "RECURSIVE", "SUGGESTED", "THAT", "THE", "THIS", "TOP", "USE", "USES", "WHOLE", "WORK"]);
add_ocaml_element("With_exn", "Std.Disasm_expert.Linear.With_exn", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Linear.With_exn.html", "", []);
add_ocaml_element("Linear", "Std.Disasm_expert.Linear", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Linear.html", "<div class=\"info\">\n<p>A simple linear sweep disassembler.</p>\n\n</div>\n", ["DISASSEMBLER", "LINEAR", "SIMPLE", "SWEEP"]);
add_ocaml_element("Normalized", "Std.Disasm_expert.Basic.Trie.Normalized", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Basic.Trie.Normalized.html", "", []);
add_ocaml_element("Trie", "Std.Disasm_expert.Basic.Trie", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Basic.Trie.html", "<div class=\"info\">\n<p>Trie maps over instructions</p>\n\n</div>\n", ["INSTRUCTIONS", "MAPS", "OVER", "TRIE"]);
add_ocaml_element("Insn", "Std.Disasm_expert.Basic.Insn", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Basic.Insn.html", "<div class=\"info\">\n<p>Basic instruction.</p>\n\n</div>\n", ["BACKEND", "BASIC", "INSTRUCTION", "INTO", "OPAQUE", "PHANTOM", "POINTER", "PROTECTED", "THIS", "THUS", "TYPES", "WITH"]);
add_ocaml_element("Basic", "Std.Disasm_expert.Basic", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.Basic.html", "<div class=\"info\">\n<p>Basic disassembler.</p>\n\n</div>\n", ["AGNOSTIC", "BASIC", "DISASSEMBLER", "LEVEL", "LOW", "TARGET", "THIS"]);
add_ocaml_element("Disasm_expert", "Std.Disasm_expert", "module", "<i>(... module ...)</i>", "Bap.Std.Disasm_expert.html", "<div class=\"info\">\n<p>Expert interface to disassembler.</p>\n\n</div>\n", ["AND", "AROUND", "BASIC", "BLOCKS", "BUILT", "COMPLICATED", "CONTINUATION", "CONTROL", "DISASSEMBLER", "DRIVEN", "EFFICIENT", "EXPERT", "FLOW", "GRAPH", "IMPLEMENTATIONS", "INTERFACE", "LATTER", "LAZY", "LINEAR", "PASSING", "PROVIDES", "RATHER", "RECONSTRUCTS", "RECURSIVE", "REPRESENTS", "STYLE", "SWEEP", "TABLE", "THAT", "THE", "THIS", "TOP", "TWO", "VERY"]);
add_ocaml_element("Normalized", "Std.Op.Normalized", "module", "<i>(... module ...)</i>", "Bap.Std.Op.Normalized.html", "<div class=\"info\">\n<p>Normalized comparison.</p>\n\n</div>\n", ["COMPARISON", "NORMALIZED"]);
add_ocaml_element("Op", "Std.Op", "module", "<i>(... module ...)</i>", "Bap.Std.Op.html", "<div class=\"info\">\n<p>Operand</p>\n\n</div>\n", ["OPERAND"]);
add_ocaml_element("Fmm", "Std.Fmm", "module", "<i>(... module ...)</i>", "Bap.Std.Fmm.html", "<div class=\"info\">\n<p>Floating point immediate operand</p>\n\n</div>\n", ["FLOATING", "IMMEDIATE", "OPERAND", "POINT"]);
add_ocaml_element("Imm", "Std.Imm", "module", "<i>(... module ...)</i>", "Bap.Std.Imm.html", "<div class=\"info\">\n<p>Integer immediate operand</p>\n\n</div>\n", ["IMMEDIATE", "INTEGER", "OPERAND"]);
add_ocaml_element("Reg", "Std.Reg", "module", "<i>(... module ...)</i>", "Bap.Std.Reg.html", "<div class=\"info\">\n<p>Register.</p>\n\n</div>\n", ["REGISTER"]);
add_ocaml_element("Kind", "Std.Kind", "module", "<i>(... module ...)</i>", "Bap.Std.Kind.html", "<div class=\"info\">\n<p>Kinds of instructions</p>\n\n</div>\n", ["INSTRUCTIONS", "KINDS"]);
add_ocaml_element("Memmap", "Std.Memmap", "module", "<i>(... module ...)</i>", "Bap.Std.Memmap.html", "<div class=\"info\">\n<p>Memory maps.</p>\n\n</div>\n", ["ALSO", "ARBITRARY", "ASSOSIATIVE", "CAN", "DATA", "INSTANCE", "INTERSECT", "INTERVAL", "INTERVAL_TREE", "KNOWN", "MAP", "MAPS", "MEMMAP", "MEMORY", "REGIONS", "SERVING", "STRUCTURE", "TABLE", "THAT", "THE", "THIS", "TREE", "UNLIKE", "VALUES", "WAYS", "WITH"]);
add_ocaml_element("Scheme", "Std.Image.Scheme", "module", "<i>(... module ...)</i>", "Bap.Std.Image.Scheme.html", "<div class=\"info\">\n<p>A scheme of image specification.</p>\n\n</div>\n", ["ABOUT", "ACTUAL", "ADDR", "AND", "ATTRIBUTE", "COMMENTS", "DATABASE", "EACH", "FACTS", "FIELD", "FIELDS", "FOR", "FUNCTION", "HAS", "IMAGE", "INFERRED", "INFORMATION", "LIBRARY", "LOGICAL", "MEANS", "MORE", "NAMES", "NOTE", "OGRE", "PROGRAM", "PROPOSITION", "SCHEME", "SECTION", "SEE", "SINCE", "SIZE", "SOME", "SPECIFICATION", "STATEMENT", "SYNOPSIS", "THAT", "THE", "THUS", "TRUE", "TWO", "USE"]);
add_ocaml_element("Symbol", "Std.Image.Symbol", "module", "<i>(... module ...)</i>", "Bap.Std.Image.Symbol.html", "<div class=\"info\">\n<p>Symbol.</p>\n\n</div>\n", ["SYMBOL"]);
add_ocaml_element("Segment", "Std.Image.Segment", "module", "<i>(... module ...)</i>", "Bap.Std.Image.Segment.html", "<div class=\"info\">\n<p>Image Segments.</p>\n\n</div>\n", ["CONTIGUOUS", "ELF", "HAS", "IMAGE", "MEMORY", "PERMISSIONS", "REGION", "SAME", "SEGMENT", "SEGMENTS", "THAT", "THE"]);
add_ocaml_element("Image", "Std.Image", "module", "<i>(... module ...)</i>", "Bap.Std.Image.html", "<div class=\"info\">\n<p>Binary Image.</p>\n\n</div>\n", ["BINARY", "IMAGE"]);
add_ocaml_element("Img", "Std.Backend.Img", "module", "<i>(... module ...)</i>", "Bap.Std.Backend.Img.html", "<div class=\"info\">\n<p>A Img from a backend perspective.</p>\n\n</div>\n", ["BACKEND", "FROM", "IMG", "PERSPECTIVE"]);
add_ocaml_element("Section", "Std.Backend.Section", "module", "<i>(... module ...)</i>", "Bap.Std.Backend.Section.html", "<div class=\"info\">\n<p>Just a named region of memory.</p>\n\n</div>\n", ["JUST", "MEMORY", "NAMED", "REGION"]);
add_ocaml_element("Symbol", "Std.Backend.Symbol", "module", "<i>(... module ...)</i>", "Bap.Std.Backend.Symbol.html", "<div class=\"info\">\n<p>Symbol definition, that can span several non-contiguous parts of\n        memory</p>\n\n</div>\n", ["CAN", "CONTIGUOUS", "DEFINITION", "MEMORY", "NON", "PARTS", "SEVERAL", "SPAN", "SYMBOL", "THAT"]);
add_ocaml_element("Segment", "Std.Backend.Segment", "module", "<i>(... module ...)</i>", "Bap.Std.Backend.Segment.html", "<div class=\"info\">\n<p>A named contiguous part of file with permissions.</p>\n\n</div>\n", ["ALSO", "CONTIGUOUS", "ELF", "FILE", "KNOWN", "NAMED", "PART", "PERMISSIONS", "SEGMENT", "WITH"]);
add_ocaml_element("Backend", "Std.Backend", "module", "<i>(... module ...)</i>", "Bap.Std.Backend.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>A backend interface.</p>\n\n</span></div>\n", ["ACCESSIBLE", "AND", "BACKEND", "DEPRECATED", "FOR", "FUNCTION", "IMAGE", "IMAGES", "IMPLEMENTED", "INTERFACE", "LOADER", "LOADING", "MUST", "NEW", "OGRE", "ORDER", "PLUGIN", "POWERED", "REGISTER", "REGISTERED", "THIS", "USE", "WITH"]);
add_ocaml_element("Location", "Std.Location", "module", "<i>(... module ...)</i>", "Bap.Std.Location.html", "<div class=\"info\">\n<p>A locations of a chunk of memory</p>\n\n</div>\n", ["CHUNK", "LOCATIONS", "MEMORY"]);
add_ocaml_element("Table", "Std.Table", "module", "<i>(... module ...)</i>", "Bap.Std.Table.html", "<div class=\"info\">\n<p>Table.</p>\n\n</div>\n", ["ALL", "ALSO", "ALTHOUGH", "AND", "ANOTHER", "APPLICATIVE", "ARBITRARY", "ARE", "AREA", "AREAS", "ASSOSIATED", "BETTER", "BOUND", "BUILD", "CACHING", "CAN", "CREATE", "DETAILS", "DIFFERENT", "EACH", "EFFECTS", "EMPLOY", "EXAMPLE", "FOR", "FROM", "FUNCTION", "HAVE", "HOOD", "INTERSECTING", "INTO", "KIND", "LINK", "LINKED", "MANY", "MAPPING", "MEMORY", "MODE", "NON", "OBSERVABLE", "ONCE", "ONE", "OPERATIONS", "OVER", "PARTITION", "PERFORM", "PURELY", "REGION", "SAME", "SEE", "SET", "SETS", "SIDE", "SOME", "TABLE", "TABLES", "THAT", "THE", "THERE", "THEY", "TIMES", "TWO", "TYPE", "UNDERNEATH", "USED", "VALUE", "VALUES", "WITH", "YOU"]);
add_ocaml_element("R64", "Std.Memory.Trie.R64", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.R64.html", "", []);
add_ocaml_element("R32", "Std.Memory.Trie.R32", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.R32.html", "", []);
add_ocaml_element("R16", "Std.Memory.Trie.R16", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.R16.html", "", []);
add_ocaml_element("R8", "Std.Memory.Trie.R8", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.R8.html", "", []);
add_ocaml_element("R64", "Std.Memory.Trie.Stable.V2.R64", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V2.R64.html", "", []);
add_ocaml_element("R32", "Std.Memory.Trie.Stable.V2.R32", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V2.R32.html", "", []);
add_ocaml_element("R16", "Std.Memory.Trie.Stable.V2.R16", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V2.R16.html", "", []);
add_ocaml_element("R8", "Std.Memory.Trie.Stable.V2.R8", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V2.R8.html", "", []);
add_ocaml_element("V2", "Std.Memory.Trie.Stable.V2", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V2.html", "", []);
add_ocaml_element("R64", "Std.Memory.Trie.Stable.V1.R64", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V1.R64.html", "", []);
add_ocaml_element("R32", "Std.Memory.Trie.Stable.V1.R32", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V1.R32.html", "", []);
add_ocaml_element("R16", "Std.Memory.Trie.Stable.V1.R16", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V1.R16.html", "", []);
add_ocaml_element("R8", "Std.Memory.Trie.Stable.V1.R8", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V1.R8.html", "", []);
add_ocaml_element("V1", "Std.Memory.Trie.Stable.V1", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.V1.html", "", []);
add_ocaml_element("Stable", "Std.Memory.Trie.Stable", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.Stable.html", "", []);
add_ocaml_element("Trie", "Std.Memory.Trie", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Trie.html", "<div class=\"info\">\n<p>Tries over memory</p>\n\n</div>\n", ["MEMORY", "OVER", "TRIES"]);
add_ocaml_element("Make_iterators", "Std.Memory.Make_iterators", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Make_iterators.html", "<div class=\"info\">\n<p>lifts iterators to monad <code class=\"code\"><span class=\"constructor\">M</span></code></p>\n\n</div>\n", ["ITERATORS", "LIFTS", "MONAD"]);
add_ocaml_element("With_error", "Std.Memory.With_error", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.With_error.html", "<div class=\"info\">\n<p>iterators lifter to the Or_error monad</p>\n\n</div>\n", ["ITERATORS", "LIFTER", "MONAD", "OR_ERROR", "THE"]);
add_ocaml_element("Input", "Std.Memory.Input", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.Input.html", "<div class=\"info\">\n<p>A set of low level input operations.</p>\n\n</div>\n", ["ABOVE", "ACCESS", "CHECK", "EFFECTIVE", "EVERY", "HEAD", "INPUT", "INSTEAD", "INTERFACE", "ITERATORS", "LEVEL", "LOW", "MEMORY", "MORE", "NEED", "NOT", "NOTE", "OPERATIONS", "SET", "SINCE", "THIS", "USE"]);
add_ocaml_element("Memory", "Std.Memory", "module", "<i>(... module ...)</i>", "Bap.Std.Memory.html", "<div class=\"info\">\n<p>Memory region</p>\n\n</div>\n", ["MEMORY", "REGION"]);
add_ocaml_element("Expi", "Std.Biri.S.Expi", "module", "<i>(... module ...)</i>", "Bap.Std.Biri.S.Expi.html", "", []);
add_ocaml_element("Make", "Std.Biri.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Biri.Make.html", "", []);
add_ocaml_element("Biri", "Std.Biri", "module", "<i>(... module ...)</i>", "Bap.Std.Biri.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>BIR Interpreter</p>\n\n</span></div>\n", ["BIR", "DEPRECATED", "FRAMEWORK", "INTERPRETER", "PRIMUS", "THE", "USE"]);
add_ocaml_element("Vector", "Std.Vector", "module", "<i>(... module ...)</i>", "Bap.Std.Vector.html", "<div class=\"info\">\n<p>Resizable Array.</p>\n\n</div>\n", ["ARRAY", "ARRAYS", "DEFAULT", "DEFAULTCONSTRUCTIBLE", "LOGARITHMIC", "NEED", "PROVIDE", "PUSH_BACK", "REQUIREMENT", "RESIZABLE", "STYLE", "THE", "USER", "VALUE", "VERSION", "WITH"]);
add_ocaml_element("Dict", "Std.Dict", "module", "<i>(... module ...)</i>", "Bap.Std.Dict.html", "<div class=\"info\">\n<p>Universal Heterogeneous Map.</p>\n\n</div>\n", ["HETEROGENEOUS", "MAP", "UNIVERSAL"]);
add_ocaml_element("Typeid", "Std.Value.Typeid", "module", "<i>(... module ...)</i>", "Bap.Std.Value.Typeid.html", "<div class=\"info\">\n<p>Persistent type identifiers.</p>\n\n</div>\n", ["IDENTIFIERS", "PERSISTENT", "TYPE"]);
add_ocaml_element("Match", "Std.Value.Match", "module", "<i>(... module ...)</i>", "Bap.Std.Value.Match.html", "<div class=\"info\">\n<p>Runtime parallel match.</p>\n\n</div>\n", ["MATCH", "PARALLEL", "RUNTIME"]);
add_ocaml_element("Tag", "Std.Value.Tag", "module", "<i>(... module ...)</i>", "Bap.Std.Value.Tag.html", "<div class=\"info\">\n<p>Variants of values.</p>\n\n</div>\n", ["VALUES", "VARIANTS"]);
add_ocaml_element("Value", "Std.Value", "module", "<i>(... module ...)</i>", "Bap.Std.Value.html", "<div class=\"info\">\n<p>Universal Values.</p>\n\n</div>\n", ["08CA", "2175C28C", "3A01E1C6AB6F", "400E190E", "4052", "488D", "8385", "87B1", "ABOVE", "ABUSE", "ACROSS", "ACTUALLY", "ADD", "ADDING", "AKA", "ALLOCATION", "ALSO", "ALTHOUGH", "AND", "ANY", "ARBITRARY", "ARE", "ARGC", "ARGV", "AVAILABLE", "BAP", "BASICALLY", "BEAR", "BEHAVIOR", "BETWEEN", "BINARY", "BIN_IO", "BOTH", "BRANCH", "BUILDS", "BUT", "C101709621A8", "CALL", "CALLED", "CAN", "CASE", "CE21", "CHAR", "CIPHER", "CLASS", "CODE", "COL", "COMPARE", "COMPARISON", "COMPILE", "COMPILER", "CONFORM", "CONST", "CONSTRUCTED", "CONSTRUCTOR", "CONTAINER", "CONTEXT", "CORE", "CREATE", "CREATED", "CREATES", "CRITICAL", "DATA", "DECONSTRUCT", "DIFFERENCE", "DIFFERENT", "DOESN", "DRIVEN", "DYNAMICALLY", "EASILY", "EFFICIENT", "END", "EQUAL", "EQUIVALENT", "EVEN", "EXAMPLE", "EXISTING", "EXPRESSION", "EXTENDED", "EXTENDING", "EXTENSIBLE", "EXTENSIONS", "EXTRA", "EXTRACT", "FACT", "FILE", "FIRST", "FOLLOWING", "FOR", "FORMAT", "FORMATTER", "FPRINTF", "FROM", "FUNCTION", "FUNCTION_SIGNATURE", "GENERAL", "GET", "GET_EXN", "GOOD", "GUARANTEE", "GUARANTEES", "HAND", "HAS", "HOOD", "IGNORE", "IMPLEMENT", "IMPLEMENTATION", "INCLUDING", "INFORMATION", "INITIALIZATION", "INITIALIZED", "INT", "INTENTIONALLY", "INTO", "INTRODUCED", "ISSUE", "ITSELF", "JUST", "KEY", "KNOWN", "LATER", "LEAST", "LET", "LINE", "LINUX", "LIST", "LITERAL", "LOC", "MAC", "MADE", "MAIN", "MAIN_POS", "MAIN_T", "MATTERS", "MAY", "MEANING", "MEANS", "MERELY", "METHOD", "MODULE", "MODULES", "MORE", "MOST", "MULTI", "MUST", "NAME", "NEAT", "NEED", "NEVER", "NEW", "NEWS", "NOT", "OCAML", "ONE", "ONLY", "OPTION", "ORDER", "ORDERING", "ORIGINAL", "OTHER", "PACKAGE", "PAIR", "PARAMETER", "PERFORMANCE", "PLACE", "PLUGIN", "POLYMORPHIC", "PPF", "PRESERVED", "PRETTY", "PREVENT", "PRINTING", "PRINTS", "PROGRAM", "PROGRAMS", "PROPERTIES", "PROVIDED", "PUT", "REALLY", "REGISTER", "REGISTERED", "REPRESENTATION", "REQUIRE", "REQUIREMENTS", "REQUIRES", "RESEMBLES", "RETURNED", "RTTI", "RULES", "RUNTIME", "SAFE", "SAFETY", "SAME", "SEE", "SEMANTIC", "SERIALIZABLE", "SERIALIZATION", "SEXP", "SHOULD", "SHOULDN", "SIG", "SIGNATURE", "SINGLE", "SOME", "SPACE", "SPECIAL", "STILL", "STRING", "STRINGS", "STRUCT", "SUCH", "SUM", "SYNTAX", "SYSTEM", "TAG", "TEST", "THAT", "THE", "THEM", "THEN", "THINK", "THIS", "THREAD", "TIME", "TUPLE", "TWO", "TYPE", "TYPES", "UNACCEPTABLE", "UNDERNEATH", "UNIFORMLY", "UNION", "UNIQUE", "UNIT", "UNIVERSAL", "UNIVERSE", "UNKNOWN", "UNPACK", "UNSAFE", "USE", "USED", "USING", "USUALLY", "UUID", "UUIDGEN", "VAL", "VALUE", "VALUES", "VARIANT", "VERSIONS", "VERY", "VOID", "WAS", "WASN", "WHAT", "WHERE", "WILL", "WITH", "WORDS", "YOU", "YOUR", "YOURSELF"]);
add_ocaml_element("Arch", "Std.Arch", "module", "<i>(... module ...)</i>", "Bap.Std.Arch.html", "<div class=\"info\">\n<p>Architecture</p>\n\n</div>\n", ["ARCHITECTURE"]);
add_ocaml_element("Stmt", "Std.Stmt", "module", "<i>(... module ...)</i>", "Bap.Std.Stmt.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Regular</span></code> interface for BIL statements</p>\n\n</div>\n", ["BIL", "FOR", "INTERFACE", "REGULAR", "STATEMENTS"]);
add_ocaml_element("Exp", "Std.Exp", "module", "<i>(... module ...)</i>", "Bap.Std.Exp.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Regular</span></code> interface for BIL expressions</p>\n\n</div>\n", ["BIL", "EXPRESSIONS", "FOR", "INTERFACE", "REGULAR"]);
add_ocaml_element("Eff", "Std.Eff", "module", "<i>(... module ...)</i>", "Bap.Std.Eff.html", "<div class=\"info\">\n<p>Effect analysis.</p>\n\n</div>\n", ["ACCESSES", "ACCESSING", "ANALYSIS", "AND", "ARBITRARY", "BETWEEN", "BOTH", "CAN", "CHANGE", "COEFFECTS", "COMPUTATION", "CPU", "DEPENDS", "DESCRIBES", "DISTINGUISH", "DIVISION", "DOESN", "EFFECT", "EFFECTS", "EITHER", "EXAMPLES", "EXCEPTION", "EXPRESSION", "FAR", "FOLLOWING", "FURTHER", "GENERATIVE", "HAS", "HAVE", "HIDDEN", "HOW", "IDEMPOTENT", "INCLUDING", "INTERACTS", "LOAD", "MAY", "MEMORY", "MODIFIES", "MOVED", "ONLY", "OUTSIDE", "PAGEFAULT", "RAISE", "RAISING", "READ", "READS", "REGISTER", "REMOVED", "REPRODUCED", "SEMANTICS", "SIGNIFICANT", "SINCE", "SORTS", "STATE", "STORING", "SUBDIVIDED", "SUBSTITUTED", "THAT", "THE", "TREE", "UNDERSTAND", "VALUE", "VIA", "WHEN", "WHOLE", "WITH", "WITHOUT", "WORLD", "ZERO"]);
add_ocaml_element("Expi", "Std.Bili.S.Expi", "module", "<i>(... module ...)</i>", "Bap.Std.Bili.S.Expi.html", "", []);
add_ocaml_element("Make", "Std.Bili.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Bili.Make.html", "", []);
add_ocaml_element("Bili", "Std.Bili", "module", "<i>(... module ...)</i>", "Bap.Std.Bili.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>BIL Interpreter.</p>\n\n</span></div>\n", ["0X1", "ALLOWING", "ALSO", "AST", "BAP", "BEHAVIOR", "BIL", "BILI", "BINDINGS", "BIRI", "BOOL_T", "CHANGE", "CONTEXT", "CREATE", "CTXT", "DEFAULT", "DEPRECATED", "DON", "EASIER", "EVAL", "EVALUATING", "EVALUATION", "EXAMPLE", "EXPI", "EXPOSES", "EXTENDS", "FALSE", "FOR", "FRAMEWORK", "INT", "INTERFACE", "INTERMEDIATE", "INTERPRET", "INTERPRETER", "LET", "LIST", "MAY", "METHODS", "NEED", "NEW", "OBJ", "ONE", "PRIMUS", "REPRESENTATION", "RESULT", "SEQ", "STATEMENTS", "STD", "STMT", "THAT", "THE", "THEN", "THUS", "TO_LIST", "USE", "VAL", "VAR", "WITH", "WORD", "YOU"]);
add_ocaml_element("Eval", "Std.Expi.S.Eval", "module", "<i>(... module ...)</i>", "Bap.Std.Expi.S.Eval.html", "<div class=\"info\">\n</div>\n", ["SINCE"]);
add_ocaml_element("M", "Std.Expi.S.M", "module", "<i>(... module ...)</i>", "Bap.Std.Expi.S.M.html", "", []);
add_ocaml_element("Make", "Std.Expi.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Expi.Make.html", "", []);
add_ocaml_element("Expi", "Std.Expi", "module", "<i>(... module ...)</i>", "Bap.Std.Expi.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>Expression Language Interpreter.</p>\n\n</span></div>\n", ["DEPRECATED", "EXPRESSION", "FRAMEWORK", "INTERPRETER", "LANGUAGE", "PRIMUS", "THE", "USE"]);
add_ocaml_element("M", "Std.Eval.S.M", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.S.M.html", "", []);
add_ocaml_element("Make", "Std.Eval.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">M</span>)</code> provides an implementation of the <code class=\"code\"><span class=\"constructor\">S2</span></code> interface\n        lifted into the monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["IMPLEMENTATION", "INTERFACE", "INTO", "LIFTED", "MAKE", "MONAD", "PROVIDES", "THE"]);
add_ocaml_element("M", "Std.Eval.S2.M", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.S2.M.html", "", []);
add_ocaml_element("Make2", "Std.Eval.Make2", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.Make2.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make2</span>(<span class=\"constructor\">M</span>)</code> provides an implementation of the <code class=\"code\"><span class=\"constructor\">S2</span></code> interface\n        lifted into the monad <code class=\"code\"><span class=\"constructor\">M</span></code>.</p>\n\n</div>\n", ["IMPLEMENTATION", "INTERFACE", "INTO", "LIFTED", "MAKE2", "MONAD", "PROVIDES", "THE"]);
add_ocaml_element("T2", "Std.Eval.T2", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.T2.html", "<div class=\"info\">\n<p>An evaluator parametrized by a <code class=\"code\"><span class=\"constructor\">T2</span></code> monad.</p>\n\n</div>\n", ["EVALUATOR", "MONAD", "PARAMETRIZED"]);
add_ocaml_element("T1", "Std.Eval.T1", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.T1.html", "<div class=\"info\">\n<p>An evaluator interface parametrized by a <code class=\"code\"><span class=\"constructor\">T1</span></code> monad.</p>\n\n</div>\n", ["EVALUATOR", "INTERFACE", "MONAD", "PARAMETRIZED"]);
add_ocaml_element("Eval", "Std.Eval", "module", "<i>(... module ...)</i>", "Bap.Std.Eval.html", "<div class=\"info\">\n<p>Basic and generic expression evaluator.</p>\n\n</div>\n", ["ALREADY", "AND", "BASE", "BASIC", "BIL", "BILI", "BIRI", "BUILD", "CAN", "CHANGING", "CLASS", "CLASSES", "CONSIDER", "DERIVE", "DRASTICALLY", "EVALUATOR", "EVALUATORS", "EXISTING", "EXPI", "EXPRESSION", "FOR", "FRAMEWORK", "FUNCTORS", "GENERIC", "INTERFACE", "INTERPETERS", "INTERPRETER", "LEVEL", "LOW", "MODULE", "NOTE", "OWN", "PRIMUS", "PROVIDES", "SEMANTICS", "SINCE", "THAT", "THE", "THIS", "TYPES", "USE", "USED", "USING", "WANT", "WITHOUT", "YOU", "YOUR"]);
add_ocaml_element("Type_error", "Std.Type_error", "module", "<i>(... module ...)</i>", "Bap.Std.Type_error.html", "", []);
add_ocaml_element("Context", "Std.Context", "module", "<i>(... module ...)</i>", "Bap.Std.Context.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>Base class for evaluation contexts.</p>\n\n</span></div>\n", ["ALL", "AND", "ANY", "BASE", "CLASS", "CONTEXT", "CONTEXTS", "DEPRECATED", "EVALUATE", "EVALUATION", "FOR", "FRAMEWORK", "FROM", "GIVEN", "HAS", "IMPLEMENTATION", "INTERFACE", "INTERPRETER", "INTERPRETERS", "INTO", "JUST", "LOGARITHMIC", "LOOKUP", "MAPPING", "MATCHING", "METHODS", "MODULE", "MONAD", "MUST", "NOT", "OTHER", "PARTICULAR", "PRIMUS", "PROVIDES", "REQUIRED", "SHOULD", "SINCE", "STATE", "STRUCTURAL", "SUBTYPE", "SUBTYPES", "TERMS", "THAN", "THAT", "THE", "THIS", "TYPE", "TYPES", "UNDER", "UPDATE", "USE", "USED", "VALUES", "VARIABLES", "WILL", "WORK", "WRAPPED"]);
add_ocaml_element("Var", "Std.Var", "module", "<i>(... module ...)</i>", "Bap.Std.Var.html", "<div class=\"info\">\n<p>BIL variable.</p>\n\n</div>\n", ["ACCOUNT", "ALL", "AND", "ARE", "BASE", "BIL", "BUT", "CAN", "COMPARE", "COMPARISON", "CONTROL", "CORRESPOND", "DEFAULT", "DESIGNATE", "DIFFERENT", "DOESN", "DURING", "EVALUATION", "FLOW", "FOR", "FORM", "FUNCTION", "HAVE", "INDEX", "INDICES", "INTO", "LOCATION", "MAY", "NAME", "NEVER", "ORDER", "OVER", "PARTICULARY", "PATH", "PHYSICAL", "PRETTY", "PRINT", "PRINTER", "PRINTING", "PRINTS", "PROGRAM", "RANGES", "REGARDLESS", "REGISTER", "REGULAR", "REPRESENT", "REPRESENTING", "SAME", "SENSE", "SET", "SOME", "SPACE", "SSA", "SYMBOLIC", "TAKES", "THAT", "THE", "THEIR", "THIS", "TIME", "TWO", "TYPES", "USE", "USED", "USEFUL", "USUALLY", "VALUES", "VARIABLE", "VARIABLES", "VIRTUAL", "WHICH", "WITH", "ZERO"]);
add_ocaml_element("Error", "Std.Type.Error", "module", "<i>(... module ...)</i>", "Bap.Std.Type.Error.html", "<div class=\"info\">\n<p>BIL type errors.</p>\n\n</div>\n", ["ADDRESS", "ALL", "APPLIED", "APPLY", "ARGUMENTS", "BAD_CAST", "BAD_IMM", "BAD_MEM", "BAD_TYPE", "BETWEEN", "BIL", "BITVECTOR", "CALLED", "CAST", "CORRECT", "DEFINED", "DIAGNOSIS", "DIFFERENT", "DISTINGUISH", "DOESN", "DURING", "ERROR", "ERRORS", "EVALUATE", "EVALUATED", "EVALUATION", "EXAMPLE", "EXP", "EXPECTED", "EXPRESSION", "EXPRESSIONS", "FINALLY", "FOR", "FORMED", "FROM", "FURTHER", "GOT", "HAVE", "HELP", "ILL", "IMPROPER", "INDEX", "INTEGER", "LOAD", "MAKE", "MAY", "MEMORY", "NOT", "OPERATION", "REGULAR", "SEMANTICS", "SENSE", "SINCE", "SIZE", "STORAGE", "STORE", "SYNTACTICALLY", "THAT", "THE", "TYPE", "TYPED", "TYPES", "VALUE", "WELL", "WHEN", "WHERE"]);
add_ocaml_element("Type", "Std.Type", "module", "<i>(... module ...)</i>", "Bap.Std.Type.html", "<div class=\"info\">\n<p>The type of a BIL expression.</p>\n\n</div>\n", ["ARE", "BIL", "BOOL_T", "BROUGHT", "CHUNK", "CONSTRUCTORS", "EACH", "EITHER", "EXPRESSION", "FOLLOWING", "GIVE", "GIVEN", "IMMEDIATE", "MEM32_T", "MEM64_T", "MEMORY", "PREDEFINED", "REG128_T", "REG16_T", "REG256_T", "REG32_T", "REG64_T", "REG8_T", "SCOPE", "SIZE", "THE", "TYPE", "VALUE", "WIDTH"]);
add_ocaml_element("Pass", "Std.Bil.Pass", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Pass.html", "<div class=\"info\">\n<p>A BIL analysis pass</p>\n\n</div>\n", ["ANALYSIS", "BIL", "PASS", "SINCE"]);
add_ocaml_element("Normalized", "Std.Bil.Trie.Normalized", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Trie.Normalized.html", "", []);
add_ocaml_element("Trie", "Std.Bil.Trie", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Trie.html", "<div class=\"info\">\n<p>Tries on BIL.</p>\n\n</div>\n", ["ADDRESSED", "ALL", "AND", "ARE", "BIL", "COMPARE", "COMPARISON", "COMPILATION", "CONTEXT", "DEFAULT", "DEPENDING", "DIFFERENT", "DISK", "EXAMPLE", "FILE", "FIND", "FOR", "FROM", "HARD", "HAVE", "IMMEDIATE", "ISSUES", "LIFTERS", "LITERALLY", "MAY", "MEANS", "MET", "MOREOVER", "NAMES", "NORMALIZED", "NOT", "OBTAINED", "ONE", "OTHER", "PERSISTANT", "PREFIX", "PROVIDES", "REGISTERS", "SAME", "SENSITIVE", "SOME", "STATEMENTS", "STORAGE", "THAT", "THE", "THEM", "THIS", "THROUGH", "TREES", "TRIE", "TRIES", "TWO", "VALUES", "VARIABLE", "VARIABLES", "WAS", "WILL", "YOUR"]);
add_ocaml_element("Value", "Std.Bil.Result.Value", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Result.Value.html", "", []);
add_ocaml_element("Id", "Std.Bil.Result.Id", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Result.Id.html", "<div class=\"info\">\n<p>Result identifier.</p>\n\n</div>\n", ["IDENTIFIER", "ORDERED", "REGULAR", "RESULT", "TOTALLY", "VALUE"]);
add_ocaml_element("Result", "Std.Bil.Result", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Result.html", "", []);
add_ocaml_element("Storage", "Std.Bil.Storage", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Storage.html", "<div class=\"info\">\n<span class=\"deprecated\"><p>Predefined storage classes</p>\n\n</span></div>\n", ["CLASSES", "DEPRECATED", "FRAMEWORK", "PREDEFINED", "PRIMUS", "STORAGE", "THE", "USE"]);
add_ocaml_element("Apply", "Std.Bil.Apply", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Apply.html", "<div class=\"info\">\n<p>Maps BIL operators to bitvectors.</p>\n\n</div>\n", ["BIL", "BITVECTORS", "MAPS", "OPERATORS", "SINCE"]);
add_ocaml_element("Infix", "Std.Bil.Infix", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Infix.html", "<div class=\"info\">\n<p>Infix operators</p>\n\n</div>\n", ["INFIX", "OPERATORS"]);
add_ocaml_element("Types", "Std.Bil.Types", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.Types.html", "", []);
add_ocaml_element("Bil", "Std.Bil", "module", "<i>(... module ...)</i>", "Bap.Std.Bil.html", "<div class=\"info\">\n<p>Main BIL module.</p>\n\n</div>\n", ["ALGEBRAIC", "ALLOWS", "AND", "ARE", "BIL", "BINARY", "CONSTRUCTOR", "DEFINE", "DEFINED", "DSL", "DST", "EACH", "EMBEDDED", "EXP", "EXPRESSIONS", "FOR", "I32", "INSTRUCTION", "INSTRUCTIONS", "INT", "INTO", "LAND", "LANGUAGE", "LET", "LOR", "LSL", "LSR", "MAIN", "MODULE", "NAME", "OCAML", "OF_INT", "SAME", "SEMANTICS", "SMART", "SOME", "SPECIFIES", "SRC", "SYNTAX", "THE", "THIS", "TYPE", "TYPES", "USE", "USING", "VAR", "VARIABLES", "WHERE", "WHILE_", "WIDTH", "WITH", "WORD"]);
add_ocaml_element("Addr", "Std.Addr", "module", "<i>(... module ...)</i>", "Bap.Std.Addr.html", "<div class=\"info\">\n<p>Shortcut for bitvectors that represent addresses</p>\n\n</div>\n", ["ADDRESSES", "BITVECTORS", "FOR", "REPRESENT", "SHORTCUT", "THAT"]);
add_ocaml_element("Word", "Std.Word", "module", "<i>(... module ...)</i>", "Bap.Std.Word.html", "<div class=\"info\">\n<p>Shortcut for bitvectors that represent words</p>\n\n</div>\n", ["BITVECTORS", "FOR", "REPRESENT", "SHORTCUT", "THAT", "WORDS"]);
add_ocaml_element("Bytes", "Std.Bitvector.Trie.Little.Bytes", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.Little.Bytes.html", "", []);
add_ocaml_element("Bits", "Std.Bitvector.Trie.Little.Bits", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.Little.Bits.html", "", []);
add_ocaml_element("Little", "Std.Bitvector.Trie.Little", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.Little.html", "", []);
add_ocaml_element("Bytes", "Std.Bitvector.Trie.Big.Bytes", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.Big.Bytes.html", "", []);
add_ocaml_element("Bits", "Std.Bitvector.Trie.Big.Bits", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.Big.Bits.html", "", []);
add_ocaml_element("Big", "Std.Bitvector.Trie.Big", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.Big.html", "", []);
add_ocaml_element("Trie", "Std.Bitvector.Trie", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Trie.html", "<div class=\"info\">\n<p>Prefix trees for bitvectors.</p>\n\n</div>\n", ["AND", "BIG", "BIT", "BITS", "BITVECTOR", "BITVECTORS", "BYTE", "COMES", "EACH", "ENDIAN", "FOR", "FROM", "LESS", "LITTLE", "LSB", "MOST", "MSB", "PREDEFINED", "PREFIX", "SIGNIFICANT", "TOKEN", "TOKENIZED", "TREE", "TREES", "TRIE", "WHERE", "WITH"]);
add_ocaml_element("V2", "Std.Bitvector.Stable.V2", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Stable.V2.html", "", []);
add_ocaml_element("V1", "Std.Bitvector.Stable.V1", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Stable.V1.html", "", []);
add_ocaml_element("Stable", "Std.Bitvector.Stable", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Stable.html", "<div class=\"info\">\n<p>Stable marshaling interface.</p>\n\n</div>\n", ["INTERFACE", "MARSHALING", "STABLE"]);
add_ocaml_element("Unsafe", "Std.Bitvector.Unsafe", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Unsafe.html", "<div class=\"info\">\n<p>Arithmentic operations that doesn't check the widths.</p>\n\n</div>\n", ["ARITHMENTIC", "CHECK", "DOESN", "OPERATIONS", "THAT", "THE", "WIDTHS"]);
add_ocaml_element("Int_exn", "Std.Bitvector.Int_exn", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Int_exn.html", "<div class=\"info\">\n<p>Arithmetic that raises exceptions.</p>\n\n</div>\n", ["ARITHMETIC", "BUT", "COMMON", "EXCEPTION", "EXCEPTIONS", "EXPOSES", "INTEGER", "INTERFACE", "INTO", "LIFTED", "MISMATCH", "MODULE", "MONAD", "NOT", "OPERANDS", "OPERATIONS", "OR_ERROR", "RAISES", "RAISING", "SIZES", "THAT", "THIS", "WIDTH", "WITH"]);
add_ocaml_element("Int_err", "Std.Bitvector.Int_err", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Int_err.html", "<div class=\"info\">\n<p>Arithmetic raised into <code class=\"code\"><span class=\"constructor\">Or_error</span></code> monad</p>\n\n</div>\n", ["ALL", "ARE", "ARITHMETIC", "BINARY", "BUT", "DEFINED", "EQUAL", "EXAMPLE", "EXCEPTIONS", "I16", "INT", "INTEGER", "INTO", "JUST", "MODULE", "MONAD", "NOT", "ONLY", "OPERANDS", "OPERATIONS", "OR_ERROR", "PROVIDES", "RAISE", "RAISED", "RETURN", "SET", "SIZES", "THAT", "VALUES", "WELL", "WITH"]);
add_ocaml_element("Mono", "Std.Bitvector.Mono", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.Mono.html", "<div class=\"info\">\n<p>A comparable interface with size-monomorphic comparison.</p>\n\n</div>\n", ["COMPARABLE", "COMPARISON", "INTERFACE", "MONOMORPHIC", "SIZE", "WITH"]);
add_ocaml_element("Bitvector", "Std.Bitvector", "module", "<i>(... module ...)</i>", "Bap.Std.Bitvector.html", "<div class=\"info\">\n<p>Bitvector -- an integer with modular arithmentics.</p>\n\n</div>\n", ["0B0101", "0X0", "0X1", "0X5D", "0XD", "0XDEADBEEF", "16U", "250", "32S", "ADDRESSES", "ALL", "ALLOW", "ALWAYS", "AND", "ANY", "APPLY", "ARE", "ARITHMENTICS", "ARITHMETIC", "ASCENDING", "ASSUMED", "ATTRIBUTED", "BASE", "BINARY", "BITVECTOR", "BITWIDTH", "CAN", "CANNOT", "CAST", "CASTS", "CLARIFICATION", "COMPARE", "COMPARISON", "COMPARISONS", "COMPLEMENT", "CONSIDERED", "CREATED", "DEC", "DECIMAL", "DEFAULT", "DEFINED", "DIFFERENT", "DIGIT", "DOESN", "DONE", "EACH", "EBNF", "EITHER", "EMPHASIZE", "EQUAL", "ERROR", "EXAMPLE", "EXAMPLES", "EXCEPTION", "EXISTS", "EXPECTING", "EXPLICIT", "EXPOSED", "EXPRESSION", "FACILITIES", "FALSE", "FAMILY", "FOLLOWING", "FOR", "FORMAT", "FROM", "FULL", "FUNCTIONS", "GOOD", "GREATER", "GUARANTEE", "HASH", "HAVE", "HEX", "HEXADECIMAL", "HOWEVER", "HUMAN", "IDENTIFIABLE", "IMPLEMENTATIONS", "INCLUDES", "INTEGER", "INTERFACE", "INTERFACED", "INT_EXN", "JUST", "KEYS", "KIND", "KNOW", "LET", "LEXICAL", "LIFTED", "MAP", "MODULAR", "MODULE", "MODULES", "MODULO", "MONAD", "MONO", "MONOMORPHIC", "MORPHISM", "NEED", "NEW", "NOT", "NOTE", "NUMBER", "NUMBERS", "NUMERIC", "OCT", "OCTAL", "OFFSETS", "OF_INT", "OF_STRING", "OMITTED", "OMMITED", "ONE", "OPERAND", "OPERANDS", "OPERATION", "OPERATIONS", "OPERATOR", "OPPOSED", "ORDER", "ORDERING", "OR_ERROR", "OTHER", "OUTPUT", "OVER", "OVERVIEW", "PAIR", "PART", "PERFORM", "POLYMORPHIC", "PREFIX", "PROPAGATE", "PROPERTY", "PROVIDE", "PROVIDES", "RAISE", "READABLE", "REALLY", "RELATION", "REMEMBER", "REPR", "REPRESENTATION", "REPRESENTED", "REPRESENTING", "RESTORE", "RESULT", "RETURN", "SAFE", "SEQUENCE", "SIGN", "SIGNED", "SIGNEDNESS", "SIGNS", "SINCE", "SIZE", "SIZES", "SPECIFIED", "STANDS", "STORE", "STRING", "SUBMODULE", "SUGGESTED", "TABLE", "TEMPORARY", "THAN", "THAT", "THE", "THEIR", "THEM", "THEN", "THERE", "THINK", "THIS", "TO_INT", "TO_STRING", "TRUE", "TUPLE", "TWO", "TYPE", "UNDERSTAND", "UNSIGNED", "UPCASTED", "USE", "USED", "USIGNED", "VALUE", "VALUES", "VERSION", "WANT", "WHAT", "WHENEVER", "WHERE", "WIDTH", "WIDTHS", "WILL", "WITH", "WON", "WORD", "WORDS", "WOULD", "YOU", "YOUR", "ZERO"]);
add_ocaml_element("Size", "Std.Size", "module", "<i>(... module ...)</i>", "Bap.Std.Size.html", "<div class=\"info\">\n<p>Type safe operand and register sizes.</p>\n\n</div>\n", ["AND", "OPERAND", "REGISTER", "SAFE", "SIZES", "TYPE"]);
add_ocaml_element("Make_binable", "Std.Interval_tree.Make_binable", "module", "<i>(... module ...)</i>", "Bap.Std.Interval_tree.Make_binable.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make_binable</span>(<span class=\"constructor\">Interval</span>)</code> create an abstract interval tree data type\n        that uses abstract <code class=\"code\"><span class=\"constructor\">Interval</span></code> and can be serialized via the Binable\n        interface.</p>\n\n</div>\n", ["ABSTRACT", "AND", "BINABLE", "CAN", "CREATE", "DATA", "INTERFACE", "INTERVAL", "MAKE_BINABLE", "SERIALIZED", "THAT", "THE", "TREE", "TYPE", "USES", "VIA"]);
add_ocaml_element("Make", "Std.Interval_tree.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Interval_tree.Make.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Make</span>(<span class=\"constructor\">Interval</span>)</code> create an abstract interval tree data type\n        that uses abstract <code class=\"code\"><span class=\"constructor\">Interval</span></code>.</p>\n\n</div>\n", ["ABSTRACT", "CREATE", "DATA", "INTERVAL", "MAKE", "THAT", "TREE", "TYPE", "USES"]);
add_ocaml_element("Interval_tree", "Std.Interval_tree", "module", "<i>(... module ...)</i>", "Bap.Std.Interval_tree.html", "<div class=\"info\">\n<p>Balanced Interval Tree.</p>\n\n</div>\n", ["ALLOWS", "AND", "ARBITRARY", "ARE", "AVL", "BALANCED", "BUILD", "CONTAIN", "DATA", "EFFICIENT", "ELEMENTS", "FROM", "IMPLEMENTED", "INSERTING", "INTERVAL", "INTERVALS", "MAPPINGS", "MAY", "OVERLAPPING", "REMOVING", "SINCE", "THE", "TREE", "TREES", "USED", "USING"]);
add_ocaml_element("Suffix", "Std.Trie.String.Suffix", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.String.Suffix.html", "", []);
add_ocaml_element("Prefix", "Std.Trie.String.Prefix", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.String.Prefix.html", "", []);
add_ocaml_element("String", "Std.Trie.String", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.String.html", "<div class=\"info\">\n<p>Predefined prefix and suffix string tries.</p>\n\n</div>\n", ["AND", "PREDEFINED", "PREFIX", "STRING", "SUFFIX", "TRIES"]);
add_ocaml_element("Suffix", "Std.Trie.Array.Suffix", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.Array.Suffix.html", "", []);
add_ocaml_element("Prefix", "Std.Trie.Array.Prefix", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.Array.Prefix.html", "", []);
add_ocaml_element("Array", "Std.Trie.Array", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.Array.html", "<div class=\"info\">\n<p>Prefix and suffix tries for specified token types.</p>\n\n</div>\n", ["AND", "FOR", "PREFIX", "SPECIFIED", "SUFFIX", "TOKEN", "TRIES", "TYPES"]);
add_ocaml_element("Make", "Std.Trie.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.Make.html", "<div class=\"info\">\n<p>Create a trie for a given <code class=\"code\"><span class=\"constructor\">Key</span></code></p>\n\n</div>\n", ["CREATE", "FOR", "GIVEN", "KEY", "TRIE"]);
add_ocaml_element("Trie", "Std.Trie", "module", "<i>(... module ...)</i>", "Bap.Std.Trie.html", "<div class=\"info\">\n<p>Constructs a trie</p>\n\n</div>\n", ["CONSTRUCTS", "TRIE"]);
add_ocaml_element("Seq", "Std.Seq", "module", "<i>(... module ...)</i>", "Bap.Std.Seq.html", "<div class=\"info\">\n<p>Lazy sequence</p>\n\n</div>\n", ["ABBREVIATION", "FOR", "LAZY", "SEQUENCE", "TYPE"]);
add_ocaml_element("Make", "Std.Integer.Make", "module", "<i>(... module ...)</i>", "Bap.Std.Integer.Make.html", "<div class=\"info\">\n<p>Derive <a href=\"Bap.Std.Integer.S.html\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Integer</span>.<span class=\"constructor\">S</span></code></a> from the minimal implementation.</p>\n\n</div>\n", ["BAP", "DERIVE", "FROM", "IMPLEMENTATION", "INTEGER", "MINIMAL", "STD", "THE"]);
add_ocaml_element("Integer", "Std.Integer", "module", "<i>(... module ...)</i>", "Bap.Std.Integer.html", "<div class=\"info\">\n<p>Abstract integral type.</p>\n\n</div>\n", ["ABSTRACT", "ARITHMETIC", "BASE", "DERIVES", "DESCRIBES", "FROM", "FUNCTOR", "IMPLEMENTS", "INTEGRAL", "INTERFACE", "MAKE", "MINIMAL", "MODULE", "PROVIDES", "THAT", "THE", "THIS", "TYPE", "WELL"]);
add_ocaml_element("Std", "Std", "module", "<i>(... module ...)</i>", "Bap.Std.html", "", []);
add_ocaml_element("Bap", "Bap", "module", "<i>(... module ...)</i>", "Bap.html", "<div class=\"info\">\n<p>BAP Standard Library</p>\n\n</div>\n", ["BAP", "LIBRARY", "STANDARD"]);
add_ocaml_element("Alphabet", "Bap_strings_unscrambler.Alphabet", "module type", "<i>(... module type ...)</i>", "Bap_strings_unscrambler.Alphabet.html", "<div class=\"info\">\n<p>symbol encoding</p>\n\n</div>\n", ["ENCODING", "SYMBOL"]);
add_ocaml_element("Key", "Bap_strings_index.Key", "module type", "<i>(... module type ...)</i>", "Bap_strings_index.Key.html", "", []);
add_ocaml_element("S", "Bap_strings_index.Persistent.S", "module type", "<i>(... module type ...)</i>", "Bap_strings_index.Persistent.S.html", "", []);
add_ocaml_element("P", "Bap_traces.Std.Trace.P", "module type", "<i>(... module type ...)</i>", "Bap_traces.Std.Trace.P.html", "", []);
add_ocaml_element("S", "Bap_traces.Std.Trace.S", "module type", "<i>(... module type ...)</i>", "Bap_traces.Std.Trace.S.html", "", []);
add_ocaml_element("S", "Bap_byteweight.S", "module type", "<i>(... module type ...)</i>", "Bap_byteweight.S.html", "<div class=\"info\">\n<p>Byteweight algorithm interface.</p>\n\n</div>\n", ["ALGORITHM", "BASED", "BOOLEAN", "BYTEWEIGHT", "CAN", "DOMAIN", "EACH", "EXAMPLE", "FALSE", "FINDING", "FOR", "FUNCTION", "GIVEN", "INFER", "INFERRED", "INPUT", "INTERFACE", "INTO", "LABEL", "LABELED", "LEARNING", "MACHINE", "MAP", "START", "STARTS", "STRING", "SUBSTRING", "SUBSTRINGS", "SUPERVISED", "TEACHES", "THAT", "THE", "TRUE", "WHERE", "WHETHER"]);
add_ocaml_element("Corpus", "Bap_byteweight.Corpus", "module type", "<i>(... module type ...)</i>", "Bap_byteweight.Corpus.html", "<div class=\"info\">\n<p>Data interface.</p>\n\n</div>\n", ["DATA", "INTERFACE", "REPRESENT", "THAT", "THE", "THIS", "TYPE", "USED"]);
add_ocaml_element("Ops", "Bap_bml.Ops", "module type", "<i>(... module type ...)</i>", "Bap_bml.Ops.html", "", []);
add_ocaml_element("Registry", "Bap_bml.Registry", "module type", "<i>(... module type ...)</i>", "Bap_bml.Registry.html", "<div class=\"info\">\n<p>Interface to a registry.</p>\n\n</div>\n", ["INTERFACE", "KEY", "REGISTRY", "STORAGE", "VALUE"]);
add_ocaml_element("S", "Bap_c_type_mapper_intf.S", "module type", "<i>(... module type ...)</i>", "Bap_c_type_mapper_intf.S.html", "<div class=\"info\">\n<p>Type mapper, visitor, iterator, finder all in one.</p>\n\n</div>\n", ["ABITRARY", "ABOVE", "AFRAID", "ALL", "ALLOWS", "ALSO", "AND", "ANY", "APPLICATION", "APPLIES", "ARE", "BASE", "BIND", "BINDING", "BOUND", "CALLS", "CALM", "CAN", "CHOOSING", "CLASS", "COMBINATION", "COMPUTATION", "CONTINUE", "CORRESPONDINGLY", "DEEP", "DEGRADE", "DEPENDING", "DIFFERENT", "DOWN", "EACH", "ELEMENT", "END", "ENTER_T", "EXECUTION", "FINALLY", "FINDER", "FIRST", "FOLD", "FOR", "FORMER", "FOUND", "HAVE", "IDENTITY", "IMPLEMENT", "IMPLEMENTING", "INHERIT", "INSTANTIATED", "INTERFACE", "INTO", "ITERATOR", "ITERATORS", "LATTER", "LEAVE_T", "MAKES", "MAPPER", "MAPPING", "MAP_T", "METHOD", "METHODS", "MONAD", "MONADIC", "MONADS", "MORPHED", "MORPHISMS", "MY_MAPPER", "MY_TRANSFORMATION", "NEEDED", "NORMAL", "NULL", "OBJECT", "ONE", "OPERATIONS", "OTHER", "OVER", "OVERRIDE", "OVERRIDEN", "PARAMETRIZE", "PATTERN", "PERFORM", "POSSIBLE", "PRIVATE", "PROPER", "READING", "REGULAR", "REPRESENTED", "RETURNS", "REVERSE", "SEARCH", "SEARCHING", "SELF", "SHORTCUT", "SHOULD", "SHOULDN", "SOON", "STATE", "STRATEGIES", "STRATEGY", "STRUCTURE", "SUCH", "SUPER", "SYNTACTICAL", "SYSTEM", "TARGET", "TERMINATED", "THAT", "THE", "THEN", "THERE", "THESE", "THIS", "THREE", "TWO", "TYPE", "USE", "USEFUL", "USUAL", "VALUE", "VISITING", "VISITOR", "WAY", "WHEN", "WHERE", "WHOLE", "WILL", "WITH", "WITHOUT", "WOULD", "WRAPPED", "YOU"]);
add_ocaml_element("S", "Bap_api.S", "module type", "<i>(... module type ...)</i>", "Bap_api.S.html", "<div class=\"info\">\n<p>Language processor interface.</p>\n\n</div>\n", ["INTERFACE", "LANGUAGE", "PROCESSOR"]);
add_ocaml_element("ModeVars", "X86_env.ModeVars", "module type", "<i>(... module type ...)</i>", "X86_env.ModeVars.html", "<div class=\"info\">\n<p>CPU BIL variables.</p>\n\n</div>\n", ["AND", "BIL", "BIT", "BOTH", "CONTRARY", "CPU", "EXAMPLE", "FOR", "FORMER", "HAS", "HOWEVER", "LATTER", "MODE", "NAME", "NAMES", "PROCESSORS", "RAX", "REGISTER", "REGISTERS", "SAME", "SIMPLICITY", "THE", "USING", "VARIABLES"]);
add_ocaml_element("Primitives", "Std.Primus.Lisp.Primitives", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Lisp.Primitives.html", "", []);
add_ocaml_element("Closure", "Std.Primus.Lisp.Closure", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Lisp.Closure.html", "<div class=\"info\">\n<p>Machine independent closure.</p>\n\n</div>\n", ["ANONYMOUS", "ARBITRARY", "ARE", "CLOSURE", "CLOSURES", "COMPUTATION", "EXTEND", "FUNCTION", "IMPLEMENTED", "INDEPENDENT", "LISP", "MACHINE", "MONAD", "OCAML", "OPERATIONS", "PERFORMS", "PRIMITIVE", "SOME", "THAT", "THE", "USED", "WITH"]);
add_ocaml_element("Element", "Std.Primus.Lisp.Doc.Element", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Lisp.Doc.Element.html", "<div class=\"info\">\n<p>Abstract Element of a document.</p>\n\n</div>\n", ["ABSTRACT", "CAN", "DOCUMENT", "DOCUMENTATION", "ELEMENT", "EXTEND", "FUTURE", "KEEP", "PLAN", "PRINTED", "SOMETHING", "THAT", "THE"]);
add_ocaml_element("Infinite", "Std.Primus.Iterator.Infinite", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Iterator.Infinite.html", "<div class=\"info\">\n<p>Inifinite iterators produces infinite sequences.</p>\n\n</div>\n", ["INFINITE", "INIFINITE", "ITERATORS", "PRODUCES", "SEQUENCES"]);
add_ocaml_element("Finite", "Std.Primus.Iterator.Finite", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Iterator.Finite.html", "<div class=\"info\">\n<p>Finite iterators produce finite sequences of values.</p>\n\n</div>\n", ["FINITE", "ITERATORS", "PRODUCE", "SEQUENCES", "VALUES"]);
add_ocaml_element("Base", "Std.Primus.Iterator.Base", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Iterator.Base.html", "<div class=\"info\">\n<p>Base interface of all iterators.</p>\n\n</div>\n", ["ALL", "BASE", "INTERFACE", "ITERATORS"]);
add_ocaml_element("Code", "Std.Primus.Linker.Code", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Linker.Code.html", "<div class=\"info\">\n<p>Code representation.</p>\n\n</div>\n", ["ABSTRACT", "AND", "CODE", "COMPUTATION", "FUNCTION", "HIDES", "HOW", "ITSELF", "JUST", "MACHINE", "PERFORMS", "REPRESENTATION", "REPRESENTED", "TAKES", "THAT", "THE", "THIS", "USING"]);
add_ocaml_element("Component", "Std.Primus.Machine.Component", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Machine.Component.html", "<div class=\"info\">\n<p>Machine component interface.</p>\n\n</div>\n", ["ALL", "ANY", "APPLIED", "ARE", "BUT", "CALLED", "CAN", "COMPONENT", "COMPONENTS", "COMPUTATION", "DOESN", "EVENT", "EVERY", "FUNCTION", "FUNCTOR", "INIT", "INITIALIZED", "INSTANTIATED", "INTERFACE", "MACHINE", "MATTER", "MONAD", "NOT", "OBSERVATIONS", "ORDER", "PERFORM", "REGISTERS", "SINCE", "SPECIFIED", "STARTED", "STATE", "STORE", "THAT", "THE", "THEIR", "TIME", "USUALLY", "WHEN", "WHICH"]);
add_ocaml_element("S", "Std.Primus.Machine.S", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Machine.S.html", "<div class=\"info\">\n<p>The Machine interface.</p>\n\n</div>\n", ["INTERFACE", "MACHINE", "THE"]);
add_ocaml_element("State", "Std.Primus.Machine.State", "module type", "<i>(... module type ...)</i>", "Bap_primus.Std.Primus.Machine.State.html", "<div class=\"info\">\n<p>An interface to the state.</p>\n\n</div>\n", ["ACCESS", "AND", "GIVES", "INTERFACE", "MACHINE", "MODIFY", "OPERATIONS", "QUERY", "STATE", "THAT", "THE"]);
add_ocaml_element("Value", "Bap_taint.Std.Value", "module type", "<i>(... module type ...)</i>", "Bap_taint.Std.Value.html", "<div class=\"info\">\n<p>Abstract value.</p>\n\n</div>\n", ["ABSTRACT", "ANYTHING", "COULD", "DEFINE", "EASILY", "EMBEDDED", "ISOMORPHIC", "ISOMORPHISM", "MACHINE", "MODULO", "MONAD", "POSSIBLE", "PRIMUS", "REPRESENTATION", "RUNTIME", "SINCE", "THAT", "THE", "TYPES", "VALUE"]);
add_ocaml_element("Isomorphism", "Std.Isomorphism", "module type", "<i>(... module type ...)</i>", "Graphlib.Std.Isomorphism.html", "<div class=\"info\">\n<p><code class=\"code\"><span class=\"constructor\">Isomorphism</span></code> is a bijection between type <code class=\"code\">s</code> and <code class=\"code\">t</code>.</p>\n\n</div>\n", ["AND", "BETWEEN", "BIJECTION", "CREATING", "FOR", "GRAPH", "GRAPHLIB", "GRAPHS", "ISOMORPHISM", "MAPPER", "MAPPING", "SEE", "STD", "TYPE", "USEFULL", "VIEW", "VIEWS"]);
add_ocaml_element("Predicate", "Std.Predicate", "module type", "<i>(... module type ...)</i>", "Graphlib.Std.Predicate.html", "<div class=\"info\">\n<p>A type of modules for filtering graphs.</p>\n\n</div>\n", ["FILTERED", "FILTERING", "FOR", "GRAPHLIB", "GRAPHS", "MODULES", "SEE", "STD", "TYPE"]);
add_ocaml_element("Graph", "Std.Graph", "module type", "<i>(... module type ...)</i>", "Graphlib.Std.Graph.html", "<div class=\"info\">\n<p>Graph signature.</p>\n\n</div>\n", ["GRAPH", "SIGNATURE"]);
add_ocaml_element("Edge", "Std.Edge", "module type", "<i>(... module type ...)</i>", "Graphlib.Std.Edge.html", "<div class=\"info\">\n<p>Interface that every Graph edge should provide</p>\n\n</div>\n", ["EDGE", "EVERY", "GRAPH", "INTERFACE", "PROVIDE", "SHOULD", "THAT"]);
add_ocaml_element("Node", "Std.Node", "module type", "<i>(... module type ...)</i>", "Graphlib.Std.Node.html", "<div class=\"info\">\n<p><a href=\"Graphlib.Std.Graph.html\"><code class=\"code\"><span class=\"constructor\">Std</span>.<span class=\"constructor\">Graph</span></code></a> nodes.</p>\n\n</div>\n", ["GRAPH", "GRAPHLIB", "NODES", "STD"]);
add_ocaml_element("S", "Bap_future.Std.Variadic.S", "module type", "<i>(... module type ...)</i>", "Bap_future.Std.Variadic.S.html", "<div class=\"info\">\n<p>Variadic argument list.</p>\n\n</div>\n", ["ARGUMENT", "LIST", "VARIADIC"]);
add_ocaml_element("S", "Bap_future.Std.Applicable.S", "module type", "<i>(... module type ...)</i>", "Bap_future.Std.Applicable.S.html", "<div class=\"info\">\n<p>Applicable is an abstraction lying between Arrow, Monad and\n        Applicative.</p>\n\n</div>\n", ["ABSTRACTION", "AND", "APPLICABLE", "APPLICATIVE", "ARROW", "AVAILABLE", "BETWEEN", "CAN", "CANNOT", "FOR", "FORM", "FUNCTOR", "GENERAL", "INDUCTIVE", "LACKS", "LYING", "MONAD", "MORE", "NOT", "OPERATION", "PURE", "RETURN", "SEEN", "SINCE", "STREAMS", "THAT", "THE", "TYPE", "USE"]);
add_ocaml_element("S", "Ogre.S", "module type", "<i>(... module type ...)</i>", "Ogre.S.html", "<div class=\"info\">\n<p>Monadic interface to the document.</p>\n\n</div>\n", ["ABSTRACT", "ABUSED", "ACCESSORS", "ACTUAL", "ALL", "ALONG", "AND", "ANY", "APPLY", "ARBITRARY", "ARE", "AROUND", "ASKS", "ATTRIBUTE", "BASED", "BUILT", "CASES", "CATCH", "COLLECTION", "CONCERNED", "DATA", "DEPENDS", "DERIVIATION", "DERIVIATIONS", "DESCRIBE", "DOCUMENT", "DON", "ENTITY", "ERROR", "EXAMPLE", "EXPOSE", "EXPOSES", "FACILITATES", "FACT", "FACTS", "FINALLY", "FOR", "FOREACH", "FROM", "FUNCTION", "FUNCTIONS", "FUNCTOR", "GETTERS", "GIVEN", "HOLDS", "HOOD", "HOW", "INSERTING", "INTERFACE", "INTO", "LEGITIMATE", "MAKE", "MAKING", "MANDATES", "MAY", "MIGHT", "MODALITY", "MODEL", "MONAD", "MONADIC", "MORE", "MUCH", "MUTATOR", "NEED", "NEEDED", "NOT", "OGRE", "ONE", "ONLY", "OPTIONAL", "OTHER", "OUR", "PARTICULAR", "PASS", "PERCEIVE", "PRESENT", "PROPAGATION", "PROVIDED", "QUERY", "QUERYING", "REQUEST", "REQUIRE", "REQUIRED", "REQUIREMENT", "REQUIRES", "SEE", "SET", "SETTERS", "SHOULD", "SOME", "STANDARD", "STATE", "STORE", "TERMS", "THAT", "THE", "THERE", "THIS", "TRANSFORMER", "UNDERNEATH", "USAGE", "USE", "USED", "USER", "VALUE", "VALUES", "WELL", "WILL", "WRAPPED", "WRAPS", "ZERO"]);
add_ocaml_element("Monad2", "Std.Monad.Monad2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Monad2.html", "", []);
add_ocaml_element("Monad", "Std.Monad.Monad", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Monad.html", "", []);
add_ocaml_element("Minimal2", "Std.Monad.Minimal2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Minimal2.html", "<div class=\"info\">\n<p>The Minimal monad interface.</p>\n\n</div>\n", ["INTERFACE", "MINIMAL", "MONAD", "THE"]);
add_ocaml_element("Minimal", "Std.Monad.Minimal", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Minimal.html", "<div class=\"info\">\n<p>The Minimal monad interface.</p>\n\n</div>\n", ["INTERFACE", "MINIMAL", "MONAD", "THE"]);
add_ocaml_element("Core2", "Std.Monad.Core2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Core2.html", "<div class=\"info\">\n<p>Reexports Core's <code class=\"code\"><span class=\"constructor\">Monad</span>.<span class=\"constructor\">S2</span></code> as <code class=\"code\"><span class=\"constructor\">Monads</span>.<span class=\"constructor\">Core2</span></code></p>\n\n</div>\n", ["CORE", "CORE2", "MONAD", "MONADS", "REEXPORTS"]);
add_ocaml_element("Core", "Std.Monad.Core", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Core.html", "<div class=\"info\">\n<p>Reexports Core's <code class=\"code\"><span class=\"constructor\">Monad</span>.<span class=\"constructor\">S</span></code> as <code class=\"code\"><span class=\"constructor\">Monads</span>.<span class=\"constructor\">Core</span></code></p>\n\n</div>\n", ["CORE", "MONAD", "MONADS", "REEXPORTS"]);
add_ocaml_element("S2", "Std.Monad.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.S.html", "<div class=\"info\">\n<p>An unary monad interface.</p>\n\n</div>\n", ["INTERFACE", "MONAD", "UNARY"]);
add_ocaml_element("Basic2", "Std.Monad.Basic2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Basic2.html", "<div class=\"info\">\n<p>Basic binary monad interface.</p>\n\n</div>\n", ["BASIC", "BINARY", "INTERFACE", "MONAD"]);
add_ocaml_element("Basic", "Std.Monad.Basic", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Basic.html", "<div class=\"info\">\n<p>Basic monad interface.</p>\n\n</div>\n", ["BASIC", "INTERFACE", "MONAD"]);
add_ocaml_element("S2", "Std.Monad.Cont.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Cont.S2.html", "<div class=\"info\">\n<p>The binary monad interface.</p>\n\n</div>\n", ["BINARY", "INTERFACE", "MONAD", "THE"]);
add_ocaml_element("S", "Std.Monad.Cont.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Cont.S.html", "<div class=\"info\">\n<p>The unary monad interface</p>\n\n</div>\n", ["INTERFACE", "MONAD", "THE", "UNARY"]);
add_ocaml_element("S2", "Std.Monad.Lazy.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Lazy.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.Lazy.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Lazy.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.Fun.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Fun.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.Fun.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Fun.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.State.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.State.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.State.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.State.S.html", "<div class=\"info\">\n<p>The State Monad interface with a fixed environment.</p>\n\n</div>\n", ["ENVIRONMENT", "FIXED", "INTERFACE", "MONAD", "STATE", "THE", "WITH"]);
add_ocaml_element("S2", "Std.Monad.State.Multi.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.State.Multi.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.State.Multi.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.State.Multi.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.Reader.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Reader.S2.html", "<div class=\"info\">\n<p>The reader monad interface with the environemnt type left\n          variable.</p>\n\n</div>\n", ["ALTHOUGH", "CANNOT", "CHANGED", "COMPUTATION", "DURING", "ENVIRONEMNT", "ENVIRONMENT", "INTERFACE", "LEFT", "MONAD", "NOTE", "READER", "STILL", "THE", "TYPE", "VARIABLE", "WITH"]);
add_ocaml_element("S", "Std.Monad.Reader.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Reader.S.html", "<div class=\"info\">\n<p>The reader monad interface with the environment type fixed\n          on the module level.</p>\n\n</div>\n", ["ENVIRONMENT", "FIXED", "INTERFACE", "LEVEL", "MODULE", "MONAD", "READER", "THE", "TYPE", "WITH"]);
add_ocaml_element("S", "Std.Monad.Writer.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Writer.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.Seq.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Seq.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.Seq.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Seq.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.List.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.List.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.List.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.List.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.Result.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Result.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.Result.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Result.S.html", "", []);
add_ocaml_element("S", "Std.Monad.Result.Error.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Result.Error.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.Option.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Option.S2.html", "<div class=\"info\">\n<p>The binary option monad</p>\n\n</div>\n", ["BINARY", "MONAD", "OPTION", "THE"]);
add_ocaml_element("S", "Std.Monad.Option.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Option.S.html", "<div class=\"info\">\n<p>The unary option monad.</p>\n\n</div>\n", ["MONAD", "OPTION", "THE", "UNARY"]);
add_ocaml_element("S", "Std.Monad.S2.Collection.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.S2.Collection.S.html", "", []);
add_ocaml_element("S", "Std.Monad.S.Collection.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.S.Collection.S.html", "", []);
add_ocaml_element("S2", "Std.Monad.Syntax.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Syntax.S2.html", "", []);
add_ocaml_element("S", "Std.Monad.Syntax.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Syntax.S.html", "<div class=\"info\">\n<p>Operators for an unary monad.</p>\n\n</div>\n", ["FOR", "MONAD", "OPERATORS", "UNARY"]);
add_ocaml_element("S", "Std.Monad.Collection.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Collection.S.html", "<div class=\"info\">\n<p>A container interface for an unary monad</p>\n\n</div>\n", ["CONTAINER", "FOR", "INTERFACE", "MONAD", "UNARY"]);
add_ocaml_element("S2", "Std.Monad.Collection.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Collection.S2.html", "<div class=\"info\">\n<p>A container interface for a binary monad.</p>\n\n</div>\n", ["BINARY", "CONTAINER", "FOR", "INTERFACE", "MONAD"]);
add_ocaml_element("Delay", "Std.Monad.Collection.Delay", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Collection.Delay.html", "<div class=\"info\">\n<p>A container with a generic fold</p>\n\n</div>\n", ["CONTAINER", "FOLD", "GENERIC", "WITH"]);
add_ocaml_element("Eager", "Std.Monad.Collection.Eager", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Collection.Eager.html", "<div class=\"info\">\n<p>A container with an eager (regular) fold.</p>\n\n</div>\n", ["CONTAINER", "EAGER", "FOLD", "REGULAR", "WITH"]);
add_ocaml_element("Basic", "Std.Monad.Collection.Basic", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Collection.Basic.html", "<div class=\"info\">\n<p>Base signature for collections</p>\n\n</div>\n", ["BASE", "COLLECTIONS", "FOR", "SIGNATURE"]);
add_ocaml_element("S2", "Std.Monad.Trans.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Trans.S2.html", "<div class=\"info\">\n<p>Binary to binary monad transfomer</p>\n\n</div>\n", ["BINARY", "MONAD", "TRANSFOMER"]);
add_ocaml_element("S1", "Std.Monad.Trans.S1", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Trans.S1.html", "<div class=\"info\">\n<p>Unary to binary monad transfomer.</p>\n\n</div>\n", ["BINARY", "MONAD", "TRANSFOMER", "UNARY"]);
add_ocaml_element("S", "Std.Monad.Trans.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Trans.S.html", "<div class=\"info\">\n<p>Unary monad transformer.</p>\n\n</div>\n", ["MONAD", "TRANSFORMER", "UNARY"]);
add_ocaml_element("S2", "Std.Monad.Choice.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Choice.S2.html", "<div class=\"info\">\n<p>The binary choice monad interface</p>\n\n</div>\n", ["BINARY", "CHOICE", "INTERFACE", "MONAD", "THE"]);
add_ocaml_element("Basic2", "Std.Monad.Choice.Basic2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Choice.Basic2.html", "<div class=\"info\">\n<p>The minimal choice interface for binary monad.</p>\n\n</div>\n", ["BINARY", "CHOICE", "FOR", "INTERFACE", "MINIMAL", "MONAD", "THE"]);
add_ocaml_element("S", "Std.Monad.Choice.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Choice.S.html", "<div class=\"info\">\n<p>The unary choice monad interface</p>\n\n</div>\n", ["CHOICE", "INTERFACE", "MONAD", "THE", "UNARY"]);
add_ocaml_element("Basic", "Std.Monad.Choice.Basic", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Choice.Basic.html", "<div class=\"info\">\n<p>The minimal choice interface for unary monad.</p>\n\n</div>\n", ["CHOICE", "FOR", "INTERFACE", "MINIMAL", "MONAD", "THE", "UNARY"]);
add_ocaml_element("S2", "Std.Monad.Fail.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Fail.S2.html", "<div class=\"info\">\n<p>The binary fail monad interface.</p>\n\n</div>\n", ["BINARY", "FAIL", "IMPLEMENTED", "INTERFACE", "MAKE2", "MONAD", "RESULT", "THE"]);
add_ocaml_element("S", "Std.Monad.Fail.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Fail.S.html", "<div class=\"info\">\n<p>The unary fail monad interface.</p>\n\n</div>\n", ["ERROR", "EXCEPTION", "FAIL", "IMPLEMENTED", "INTERFACE", "MAKE", "MONAD", "RESULT", "THE", "UNARY"]);
add_ocaml_element("S2", "Std.Monad.Plus.S2", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Plus.S2.html", "<div class=\"info\">\n<p>a monoid over a binary polymorphic type.</p>\n\n</div>\n", ["BINARY", "MONOID", "OVER", "POLYMORPHIC", "TYPE"]);
add_ocaml_element("S", "Std.Monad.Plus.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monad.Plus.S.html", "<div class=\"info\">\n<p>a monoid over an unary polymorphic type.</p>\n\n</div>\n", ["MONOID", "OVER", "POLYMORPHIC", "TYPE", "UNARY"]);
add_ocaml_element("S", "Std.Monoid.S", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monoid.S.html", "<div class=\"info\">\n<p>The monoid interface</p>\n\n</div>\n", ["INTERFACE", "MONOID", "THE"]);
add_ocaml_element("Base", "Std.Monoid.Base", "module type", "<i>(... module type ...)</i>", "Monads.Std.Monoid.Base.html", "<div class=\"info\">\n<p>The minimal monoid interface</p>\n\n</div>\n", ["INTERFACE", "MINIMAL", "MONOID", "THE"]);
add_ocaml_element("S", "Std.Opaque.S", "module type", "<i>(... module type ...)</i>", "Regular.Std.Opaque.S.html", "<div class=\"info\">\n<p>Opaque type is like regular type, except that we can print or\n      examine it in any way.</p>\n\n</div>\n", ["ANY", "CAN", "EXAMINE", "EXCEPT", "LIKE", "OPAQUE", "PRETTY", "PRINT", "PRINTED", "REGULAR", "SERIALIZED", "THAT", "TYPE", "WAY"]);
add_ocaml_element("Minimal", "Std.Minimal", "module type", "<i>(... module type ...)</i>", "Regular.Std.Regular.Minimal.html", "", []);
add_ocaml_element("S", "Std.S", "module type", "<i>(... module type ...)</i>", "Regular.Std.Regular.S.html", "<div class=\"info\">\n<p>Regular interface.</p>\n\n</div>\n", ["INTERFACE", "REGULAR"]);
add_ocaml_element("S", "Std.Data.S", "module type", "<i>(... module type ...)</i>", "Regular.Std.Data.S.html", "<div class=\"info\">\n<p>Data type interface.</p>\n\n</div>\n", ["ADDITION", "ALL", "ALLOWS", "AND", "BIL", "BIN_IO", "CAN", "CHANGES", "CONCRETE", "DATA", "DEFAULT", "DESERIALIZED", "EVERY", "EXAMPLE", "FILENAME", "FORMAT", "FORMATS", "GIVEN", "HAVE", "IMPLEMENT", "IMPLEMENTS", "INCLUDE", "INCREMENTED", "INTERFACE", "LET", "MARSHAL", "MAY", "MODULE", "MODULES", "MORE", "NUMBER", "OCAML", "ONE", "ONLY", "POSSIBLE", "PROG", "PROVIDE", "READ", "REGULAR", "REPRESENTATION", "REPRESENTS", "REQUIREMENT", "SAME", "SERIALIZED", "SEVERAL", "SEXP", "SHOULD", "SIMPLE", "THAN", "THAT", "THE", "THEY", "THIS", "TIME", "TYPE", "TYPES", "USED", "VALUE", "VERSION", "VERSIONS"]);
add_ocaml_element("S", "Std.Data.Versioned.S", "module type", "<i>(... module type ...)</i>", "Regular.Std.Data.Versioned.S.html", "<div class=\"info\">\n<p>a data type with a version</p>\n\n</div>\n", ["DATA", "TYPE", "VERSION", "WITH"]);
add_ocaml_element("S", "Std.Printable.S", "module type", "<i>(... module type ...)</i>", "Regular.Std.Printable.S.html", "<div class=\"info\">\n<p>Interface for printing data.</p>\n\n</div>\n", ["AMOUNT", "BAP", "BIL", "CODE", "COMMON", "DATA", "FAMILY", "FOLLOWING", "FOR", "FORMAT", "FUNCTIONS", "IDIOMATIC", "IMPLEMENTED", "INTERFACE", "MOST", "OPEN", "PRINTABLE", "PRINTF", "PRINTING", "PROG", "SIGNIFICANT", "SPECIFIER", "THE", "TYPES", "USE", "USING", "WAY"]);
add_ocaml_element("Target", "Std.Target", "module type", "<i>(... module type ...)</i>", "Bap.Std.Target.html", "<div class=\"info\">\n<p>Abstract interface for all targets.</p>\n\n</div>\n", ["ABSTRACT", "ACCESS", "AGNOSTIC", "ALL", "AMD64", "ARM", "BAP", "CODE", "CORRESPONDING", "CROSS", "DIRECTLY", "EACH", "FOR", "FUNCTION", "GET", "IA32", "IMPLEMENTATION", "IMPLEMENTS", "INTERFACE", "LIBRARIES", "PLATFORM", "SPECIFIC", "SUPPORTED", "TARGET", "TARGETS", "TARGET_OF_ARCH", "THE", "THEN", "THIS", "USE", "USING", "WANT", "WRITE", "WRITTEN", "YOU"]);
add_ocaml_element("CPU", "Std.CPU", "module type", "<i>(... module type ...)</i>", "Bap.Std.CPU.html", "<div class=\"info\">\n<p>A BIL model of CPU</p>\n\n</div>\n", ["ALL", "ALU", "AND", "ARCHITECTURE", "ARE", "BIL", "CPU", "DEFINITIONS", "GENERAL", "GENERIC", "INVOLVING", "MEMORY", "MODEL", "MODULE", "PRESENT", "PROCESSING", "PROCESSOR", "PROCESSORS", "REGISTERS", "THAT", "THE", "THEY", "THIS", "UNIT"]);
add_ocaml_element("Memory_iterators", "Std.Memory_iterators", "module type", "<i>(... module type ...)</i>", "Bap.Std.Memory_iterators.html", "<div class=\"info\">\n<p>Iterators lifted into monad</p>\n\n</div>\n", ["INTO", "ITERATORS", "LIFTED", "MONAD"]);
add_ocaml_element("S", "Std.Taint.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Taint.S.html", "", []);
add_ocaml_element("S", "Std.Source.Factory.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Source.Factory.S.html", "<div class=\"info\">\n<p>Factory interface</p>\n\n</div>\n", ["FACTORY", "INTERFACE"]);
add_ocaml_element("Loader", "Std.Image.Loader", "module type", "<i>(... module type ...)</i>", "Bap.Std.Image.Loader.html", "<div class=\"info\">\n<p>An interface that a backend shall implement.</p>\n\n</div>\n", ["ABLE", "ACCORDING", "AND", "ARE", "BACKEND", "CORRUPTED", "DOC", "DOCUMENT", "DOESN", "ERR", "ERROR", "FILE", "FILES", "FOLLOWING", "FROM", "FUNCTIONS", "HANDLE", "HOW", "IMPLEMENT", "INFORMATION", "INPUT", "INTERFACE", "INTERPRETATION", "INTO", "KNOW", "LOADER", "MONADS", "NONE", "OBTAIN", "OGRE", "OPTION", "OUTCOMES", "POSSIBLE", "PROVIDED", "RETURN", "SHALL", "SOME", "THAT", "THE", "THIS", "THREE", "THUS", "TYPE", "WAS", "WITH", "WRAPPED"]);
add_ocaml_element("S", "Std.Biri.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Biri.S.html", "", []);
add_ocaml_element("S", "Std.Value.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Value.S.html", "<div class=\"info\">\n<p>A required interface for the type to be lifted to value.</p>\n\n</div>\n", ["FOR", "INTERFACE", "LIFTED", "REQUIRED", "THE", "TYPE", "VALUE"]);
add_ocaml_element("S", "Std.Bili.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Bili.S.html", "", []);
add_ocaml_element("S", "Std.Expi.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Expi.S.html", "", []);
add_ocaml_element("S2", "Std.Eval.S2", "module type", "<i>(... module type ...)</i>", "Bap.Std.Eval.S2.html", "<div class=\"info\">\n<p>An interface of a basic evaluator in a <code class=\"code\"><span class=\"constructor\">T1</span></code> monad</p>\n\n</div>\n", ["BASIC", "EVALUATOR", "INTERFACE", "MONAD"]);
add_ocaml_element("S", "Std.Eval.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Eval.S.html", "<div class=\"info\">\n<p>An interface of a basic evaluator in a <code class=\"code\"><span class=\"constructor\">T1</span></code> monad</p>\n\n</div>\n", ["BASIC", "EVALUATOR", "INTERFACE", "MONAD"]);
add_ocaml_element("S_binable", "Std.Interval_tree.S_binable", "module type", "<i>(... module type ...)</i>", "Bap.Std.Interval_tree.S_binable.html", "<div class=\"info\">\n<p>Binable Interval Tree.</p>\n\n</div>\n", ["BINABLE", "EXTENSION", "INTERFACE", "INTERVAL", "SIGNATURE", "THE", "TREE", "WITH"]);
add_ocaml_element("Interval_binable", "Std.Interval_tree.Interval_binable", "module type", "<i>(... module type ...)</i>", "Bap.Std.Interval_tree.Interval_binable.html", "<div class=\"info\">\n<p>Binable Abstract Interval.</p>\n\n</div>\n", ["ABSTRACT", "BINABLE", "EXTENSION", "INTERFACE", "INTERVAL", "SIGNATURE", "THE", "WITH"]);
add_ocaml_element("S", "Std.Interval_tree.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Interval_tree.S.html", "<div class=\"info\">\n<p>The Interval Tree Interface.</p>\n\n</div>\n", ["ALL", "ALLOWED", "AND", "ARBITRARY", "ARE", "ASSOCIATED", "ASSOCIATION", "BELONG", "DOMINATE", "DOMINATION", "EITHER", "EXTRACT", "FROM", "INTERFACE", "INTERSECT", "INTERSECTION", "INTERSECTS", "INTERVAL", "INTERVALS", "KEY", "MAP", "MAPPING", "MAY", "MORE", "MULTIMAP", "NOTIONS", "ONE", "POINT", "PROVIDED", "REGULAR", "SENSE", "SETS", "SINGLE", "SUPER", "THAN", "THAT", "THE", "THUS", "TREE", "UNLIKE", "USES", "USING", "VALUE", "VALUES", "WHEN", "WITH"]);
add_ocaml_element("Interval", "Std.Interval_tree.Interval", "module type", "<i>(... module type ...)</i>", "Bap.Std.Interval_tree.Interval.html", "", []);
add_ocaml_element("Token", "Std.Trie.Token", "module type", "<i>(... module type ...)</i>", "Bap.Std.Trie.Token.html", "<div class=\"info\">\n<p>Minimum required interface for a token data type</p>\n\n</div>\n", ["DATA", "FOR", "INTERFACE", "MINIMUM", "REQUIRED", "TOKEN", "TYPE"]);
add_ocaml_element("S", "Std.Trie.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Trie.S.html", "<div class=\"info\">\n<p>Prefix trie interface.</p>\n\n</div>\n", ["ALSO", "BELOW", "BIL", "BITVECTOR", "CAN", "CREATE", "DATA", "ETC", "FORM", "FUNCTOR", "HASH", "IMPLEMENT", "IMPLEMENTATION", "INSN", "INTERFACE", "KEYS", "MAKE", "MODULE", "MODULES", "MUTABLE", "NAME", "PREFIX", "PROVIDE", "SEE", "SEEN", "SIGNATURE", "SOME", "SPECIALIZED", "STRING", "STRUCTURE", "TABLE", "THAT", "THE", "THIS", "TRIE", "UNDER", "USE", "WITH"]);
add_ocaml_element("Key", "Std.Trie.Key", "module type", "<i>(... module type ...)</i>", "Bap.Std.Trie.Key.html", "<div class=\"info\">\n<p>Key requirements.</p>\n\n</div>\n", ["ARRAYS", "BETTER", "BITSTRINGS", "CAN", "CONTIGUOUS", "DATA", "DON", "END", "ETC", "IMPLEMENTATION", "KEY", "KEYS", "LENGTH", "LIKE", "LISTS", "OTHERWISE", "REQUIREMENTS", "SEQUENCE", "SEQUENCES", "SLOW", "SPECIFIED", "STRINGS", "STRUCTURES", "THE", "TOKENS", "USE", "WITH", "YOU"]);
add_ocaml_element("S", "Std.Integer.S", "module type", "<i>(... module type ...)</i>", "Bap.Std.Integer.S.html", "<div class=\"info\">\n<p>The integer signature.</p>\n\n</div>\n", ["INTEGER", "SIGNATURE", "THE"]);
add_ocaml_element("Base", "Std.Integer.Base", "module type", "<i>(... module type ...)</i>", "Bap.Std.Integer.Base.html", "<div class=\"info\">\n<p>The minimal interface of an integer.</p>\n\n</div>\n", ["INTEGER", "INTERFACE", "MINIMAL", "THE"]);
