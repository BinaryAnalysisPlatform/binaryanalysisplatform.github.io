<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap.Std.Program.html">
<link rel="next" href="Bap.Std.Blk.html">
<link rel="Up" href="Bap.Std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_elf" rel="Chapter" href="Bap_elf.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Microx" rel="Chapter" href="Microx.html">
<link title="Microx_conqueror" rel="Chapter" href="Microx_conqueror.html">
<link title="Microx_concretizer" rel="Chapter" href="Microx_concretizer.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Bap.Std.Sub</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap.Std.Program.html" title="Bap.Std.Program">Previous</a>
&nbsp;<a class="up" href="Bap.Std.html" title="Bap.Std">Up</a>
&nbsp;<a class="post" href="Bap.Std.Blk.html" title="Bap.Std.Blk">Next</a>
</div>
<h1>Module <a href="type_Bap.Std.Sub.html">Bap.Std.Sub</a></h1>

<pre><span class="keyword">module</span> Sub: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Sub.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Subroutine.<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> <a href="Bap.Std.html#TYPEterm">term</a></code> </pre>
<div class="info ">
Subroutine is a set of blocks.  The first block of a function is
        considered an entry block.<br>
</div>


<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?tid:<a href="Bap.Std.html#TYPEtid">tid</a> -> ?name:string -> unit -> <a href="Bap.Std.Sub.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">create ?name ()</code> creates an empty subroutine with an optional
        name.<br>
</div>

<pre><span id="VALlift"><span class="keyword">val</span> lift</span> : <code class="type"><a href="Bap.Std.html#TYPEblock">block</a> -> <a href="Bap.Std.html#TYPEcfg">cfg</a> -> <a href="Bap.Std.html#TYPEsub">sub</a> <a href="Bap.Std.html#TYPEterm">term</a></code></pre><div class="info ">
<code class="code">lift entry</code> takes an basic block of assembler instructions,
        as an entry and lifts it to the subroutine term.<br>
</div>

<pre><span id="VALname"><span class="keyword">val</span> name</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<code class="code">name sub</code> returns a subroutine name<br>
</div>

<pre><span id="VALwith_name"><span class="keyword">val</span> with_name</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> string -> <a href="Bap.Std.Sub.html#TYPEt">t</a></code></pre><div class="info ">
updates subroutine name<br>
</div>

<pre><span id="VALssa"><span class="keyword">val</span> ssa</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> <a href="Bap.Std.Sub.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">ssa sub</code> returns <code class="code">sub</code> in SSA form. If program is already in
        SSA, then do nothing (see also <a href="Bap.Std.Sub.html#VALis_ssa"><code class="code"><span class="constructor">Sub</span>.is_ssa</code></a>). The underlying
        algorithm produces a semi-pruned SSA form. To represent
        different versions of the same variable we use <a href="Bap.Std.Var.html">variable
        versions</a>. Any definition of a variable increases its version
        number. So, the zero version is reserved for variables that
        weren't defined before the first use.<br>
</div>

<pre><span id="VALis_ssa"><span class="keyword">val</span> is_ssa</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_ssa sub</code> is <code class="code"><span class="keyword">true</span></code> if <code class="code">sub</code> was transformed into an SSA
        form. This is O(1) predicate that doesn't really check, that
        a subroutine is in an SSA form, so it is a responsibility of
        a user to preserve the SSA form on any transformation.<br>
</div>

<pre><span id="VALfree_vars"><span class="keyword">val</span> free_vars</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> Var.Set.t</code></pre><div class="info ">
<code class="code">free_vars sub</code> computes a set of variables that are free in
        a given subroutine <code class="code">sub</code>. The variable is considered free if it
        is used before defined or is not locally bound.  If <code class="code">sub</code> is in
        an SSA form, then the set is computed trivially, thanks to a
        naming scheme. If program is not in an SSA form, then a BFS on a
        dominators tree is used.<br>
</div>

<pre><span id="VALto_graph"><span class="keyword">val</span> to_graph</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> Graphs.Tid.t</code></pre><div class="info ">
<code class="code">to_graph sub</code> builds a graph of subroutine <code class="code">sub</code>. Graph nodes
        are block term identifiers, and edges are labeled with term
        identifiers of the jmp terms, that corresponds to the edge.
        This representation is useful, if you need to compute some
        graph relation on a subroutine, that will be later used to
        perform its incremental transformation.<br>
</div>

<pre><span id="VALto_cfg"><span class="keyword">val</span> to_cfg</span> : <code class="type"><a href="Bap.Std.Sub.html#TYPEt">t</a> -> <a href="Bap.Std.Graphs.Ir.html#TYPEt">Graphs.Ir.t</a></code></pre><div class="info ">
<code class="code">to_cfg sub</code> builds a graph representation of a subroutine
        <code class="code">sub</code>. All graph operations are mapped to corresponding
        <code class="code"><span class="constructor">Term</span></code> operations. See <code class="code"><span class="constructor">Graphlib</span>.<span class="constructor">Ir</span></code> for more information.<br>
</div>

<pre><span id="VALof_cfg"><span class="keyword">val</span> of_cfg</span> : <code class="type"><a href="Bap.Std.Graphs.Ir.html#TYPEt">Graphs.Ir.t</a> -> <a href="Bap.Std.Sub.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_cfg cfg</code> extracts a <code class="code">sub term</code> from a given graph <code class="code">cfg</code>.
        Since <code class="code"><span class="constructor">Graphlib</span>.<span class="constructor">Ir</span></code> module builds term incrementally this
        operation is just a projection, i.e., it has O(0) complexity.<br>
</div>

<pre><span id="VALaliases"><span class="keyword">val</span> aliases</span> : <code class="type">string list <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
other names for the given subroutine.<br>
</div>

<pre><span id="VALconst"><span class="keyword">val</span> const</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine doesn't examine any values except its arguments,
        and have no effects except the return value. Basically this is
        just slightly more strict class than the pure attribute below,
        since function is not allowed to read global memory.  Note that a
        function that has pointer arguments and examines the data
        pointed to is not const. Likewise, a function that
        calls a non-const function usually is not be const. It does not
        make sense for a const function to return void<br>
</div>

<pre><span id="VALpure"><span class="keyword">val</span> pure</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine have no effects except the return value and their
        return value depends only on the parameters and/or global
        variables.<br>
</div>

<pre><span id="VALstub"><span class="keyword">val</span> stub</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine is a stub<br>
</div>

<pre><span id="VALextern"><span class="keyword">val</span> extern</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine is visible outside of the compilation unit<br>
</div>

<pre><span id="VALleaf"><span class="keyword">val</span> leaf</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
a subroutine doesn't contain any calls in any disguise, i.e.,
        no longjmps, indirect calls, exceptions, etc.<br>
</div>

<pre><span id="VALmalloc"><span class="keyword">val</span> malloc</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine is malloc-like, i.e., the pointer P returned
        by the subroutine cannot alias any other pointer valid when the
        function returns, and moreover no pointers to valid objects occur
        in any storage addressed by P.<br>
</div>

<pre><span id="VALnoreturn"><span class="keyword">val</span> noreturn</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine will not return (either loop infinitely or abort
        a program)<br>
</div>

<pre><span id="VALreturns_twice"><span class="keyword">val</span> returns_twice</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine may return more than one time. Examples of such
        functions are setjmp and vfork<br>
</div>

<pre><span id="VALnothrow"><span class="keyword">val</span> nothrow</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A subroutine doesn't throw exceptions<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Sub.Builder.html">Builder</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Sub.Builder.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine builder
</div>

<pre><span class="keyword">include</span> Regular.S</pre>
</body></html>