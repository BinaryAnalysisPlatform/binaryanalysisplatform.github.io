<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Bap.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html"><link title="Bap core types" rel="Section" href="#types">
<link title="Memory model" rel="Section" href="#image">
<link title="Disassembler" rel="Section" href="#disasm">
<link title="Targets" rel="Section" href="#targets">
<link title="Project" rel="Section" href="#project">
<link title="Auxiliary libraries" rel="Section" href="#1_Auxiliarylibraries">
<link title="Basic signatures" rel="Subsection" href="#tc">
<link title="Functors" rel="Subsection" href="#functors">
<link title="Main types" rel="Subsection" href="#basic_types">
<link title="Size of operand" rel="Subsection" href="#size">
<link title="BIL" rel="Subsection" href="#bil">
<link title="A type to represent target architecture" rel="Subsection" href="#arch">
<link title="Extensible variants" rel="Subsection" href="#tag">
<link title="Access to memory regions" rel="Subsection" href="#memory">
<link title="Architecture specific libraries" rel="Subsection" href="#2_Architecturespecificlibraries">
<link title="Convenient interface to the disassembler." rel="Subsection" href="#2_Convenientinterfacetothedisassembler">
<link title="High-level interface" rel="Subsection" href="#2_Highlevelinterface">
<link title="Lifted targets" rel="Subsection" href="#2_Liftedtargets">
<title>Bap.Std</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Bap.html" title="Bap">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Bap.Std.html">Bap.Std</a></h1>

<pre><span class="keyword">module</span> Std: <code class="code">sig</code> <a href="Bap.Std.html">..</a> <code class="code">end</code></pre><div class="info module top">
<h1 id="1_BAPAPI">BAP API</h1><br>
</div>
<hr width="100%">
<br>
<h1 id="types">Bap core types</h1>
<p>

      Library provides 7 core types, namely:
<p>
<ul>
<li><code class="code">arch</code> - computer architecture</li>
<li><code class="code">size</code> - word or addresses size</li>
<li><code class="code">var</code>  - a typed variable</li>
<li><code class="code">typ</code> - types of expressions</li>
<li><code class="code">exp</code>  - bil expression</li>
<li><code class="code">stmt</code> - bil statement</li>
<li><code class="code">addr</code>, <code class="code">word</code> - represents imidiate data,
            this types are indeed synonyms to <code class="code">Bitvector.t</code>.</li>
</ul>

      Every type implements <code class="code">Regular</code> interface. This interface is
      very similiar to core's <code class="code">Identifiable</code>, and is supposed to
      represent a type that is as common as built-in type. One should
      expect to find any function that is implemented for such types as
      <code class="code">int</code>, <code class="code">string</code>, <code class="code">char</code>, etc. To name a few, this interface
      includes:
<p>
<ul>
<li>comparison functions: (<code class="code">&lt;, &gt;, &lt;= , &gt;= , compare, between, ...</code>);</li>
<li>each type defines a polymorphic <code class="code">Map</code> with keys of type <code class="code">t</code>;</li>
<li>each type provides a <code class="code">Set</code> with values of type <code class="code">t</code>;</li>
<li>hashtable is exposed via <code class="code">Table</code> module;</li>
<li>hashset is available under <code class="code">Hash_set</code> name</li>
<li>sexpable and binable interface;</li>
<li><code class="code">to_string</code>, <code class="code">str</code>, <code class="code">pp</code>, <code class="code">ppo</code>, <code class="code">pps</code> functions
      for pretty-printing.</li>
</ul>

      And most types usually provides much more.
<p>

      For each exported type, there is a module with the same name
      (module capitalization), that implements its interface. For
      example, type <code class="code">exp</code> is indeed a type abbreviation for <code class="code">Exp.t</code>,
      and module <code class="code">Exp</code> contains all functions and types related to type
      <code class="code">exp</code>. For example, to create a hashtable of statements, just
      type:
<p>

      <code class="code">let table = Stmt.Table.create ()</code>
<p>

      If a type is a variant type, and most types in <code class="code">bap-types</code>
      library, are variant, then for each contructor named <code class="code">Name</code>, you
      will find a corresponding function named <code class="code">name</code> that will accept
      the same number of arguments as the arity of the constructor. For
      example, type <code class="code">exp</code> has a contructor <code class="code">Extract int * int * t)</code>, and
      there is a corresponding function named <code class="code">extract</code>, that has type
      <code class="code">int -&gt; int -&gt; t -&gt; t</code>. See <code class="code">variantslib</code> for more information about,
      variants interface.<br>

<pre><span id="TYPEprinter"><span class="keyword">type</span> <code class="type">'a</code> printer</span> = <code class="type">Format.formatter -> 'a -> unit</code> </pre>
<div class="info ">
<code class="code">'a printer</code> defines a type for pretty-printers for a value of
      type <code class="code">'a</code>. This is the type, that is required by <code class="code">%a</code> specifier,
      for <code class="code">Format.printf</code>-family of functions. Also, this is the type,
      that can be installed into OCaml toplevel or debugger.
<p>

      Note: `bap.top` library automatically installs all printers.<br>
</div>

<br>
<h2 id="tc">Basic signatures</h2><br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Printable.html">Printable</a> = <code class="code">sig</code> <a href="Bap.Std.Printable.html">..</a> <code class="code">end</code></pre><div class="info">
Printable interface is implemented by a significant amount of
      BAP types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Regular.html">Regular</a> = <code class="code">sig</code> <a href="Bap.Std.Regular.html">..</a> <code class="code">end</code></pre><div class="info">
Regular types models a general concept of value, i.e., something
      that can be used in way similiar to regular <code class="code">int</code>, <code class="code">string</code>,
      <code class="code">char</code> and other built in types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Integer.html">Integer</a> = <code class="code">sig</code> <a href="Bap.Std.Integer.html">..</a> <code class="code">end</code></pre><div class="info">
Signature for integral type.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Trie.html">Trie</a> = <code class="code">sig</code> <a href="Bap.Std.Trie.html">..</a> <code class="code">end</code></pre><div class="info">
Prefix tries.
</div>
<br>
<h2 id="functors">Functors</h2><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Regular.html">Regular</a>: <code class="code">sig</code> <a href="Bap.Std.Regular.html">..</a> <code class="code">end</code></pre><div class="info">
In order to implement <code class="code">Regular</code> interface you need to provide a
      minimum implementation <code class="code">M</code>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Trie.html">Trie</a>: <code class="code">sig</code> <a href="Bap.Std.Trie.html">..</a> <code class="code">end</code></pre><div class="info">
Constructs a trie
</div>
<br>
<h2 id="basic_types">Main types</h2><br>

<pre><span id="TYPEword"><span class="keyword">type</span> <code class="type"></code>word</span> </pre>
<div class="info ">
Type to represent machine word<br>
</div>


<pre><span id="TYPEaddr"><span class="keyword">type</span> <code class="type"></code>addr</span> = <code class="type"><a href="Bap.Std.html#TYPEword">word</a></code> </pre>
<div class="info ">
A synonym for <code class="code">word</code>, that should be used for words
      that are addresses<br>
</div>

<br>
<h2 id="size">Size of operand</h2><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Size.html">Size</a>: <code class="code">sig</code> <a href="Bap.Std.Size.html">..</a> <code class="code">end</code></pre><div class="info">
Type safe operand and register sizes.
</div>

<pre><span id="TYPEsize"><span class="keyword">type</span> <code class="type"></code>size</span> = <code class="type"><a href="Bap.Std.Size.html#TYPEt">Size.t</a></code> </pre>
<div class="info ">
size of operand<br>
</div>


<pre><span id="TYPEaddr_size"><span class="keyword">type</span> <code class="type"></code>addr_size</span> = <code class="type">[ `r32 | `r64 ] <a href="Bap.Std.Size.html#TYPEp">Size.p</a></code> </pre>
<div class="info ">
size of address<br>
</div>


<pre><span id="TYPEnat1"><span class="keyword">type</span> <code class="type"></code>nat1</span> = <code class="type">int</code> </pre>
<div class="info ">
just a fancy type abbreviation<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.html">Bitvector</a>: <code class="code">sig</code> <a href="Bap.Std.Bitvector.html">..</a> <code class="code">end</code></pre><div class="info">
Bitvector
</div>

<pre><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = <code class="type"><a href="Bap.Std.Bitvector.html#TYPEendian">Bitvector.endian</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>

</tr></table>

<div class="info ">
Expose <code class="code">endian</code> constructors to <code class="code">Bap.Std</code> namespace<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Word.html">Word</a>: <code class="type">module type of Bitvector</code><code class="type">  with type t = word</code></pre><div class="info">
Shortcut for bitvectors that represents words
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Addr.html">Addr</a>: <code class="code">sig</code> <a href="Bap.Std.Addr.html">..</a> <code class="code">end</code></pre><div class="info">
Shortcut for bitvectors that represents addresses
</div>
<br>
<h2 id="bil">BIL</h2><br>
<br>
<h3 id="bil_type">BIL type system</h3><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Type.html">Type</a>: <code class="code">sig</code> <a href="Bap.Std.Type.html">..</a> <code class="code">end</code></pre><div class="info">
The type of a BIL expression.
</div>

<pre><span id="TYPEtyp"><span class="keyword">type</span> <code class="type"></code>typ</span> = <code class="type"><a href="Bap.Std.Type.html#TYPEt">Type.t</a></code> </pre>
<div class="info ">
short abbreviation for a type<br>
</div>


<pre><span id="VALbool_t"><span class="keyword">val</span> bool_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<h3 id="type_cons">Predefined type constructors</h3><br>
</div>

<pre><span id="VALreg8_t"><span class="keyword">val</span> reg8_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALreg16_t"><span class="keyword">val</span> reg16_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALreg32_t"><span class="keyword">val</span> reg32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALreg64_t"><span class="keyword">val</span> reg64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALreg128_t"><span class="keyword">val</span> reg128_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALreg256_t"><span class="keyword">val</span> reg256_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALmem32_t"><span class="keyword">val</span> mem32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALmem64_t"><span class="keyword">val</span> mem64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><br>
<h3 id="bil_var">BIL variables</h3>
<p>

      BIL variables are regular values. Every call to <code class="code">create</code> will
      create a fresh variable.<br>

<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> </pre>
<div class="info ">
bil variable<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Var.html">Var</a>: <code class="code">sig</code> <a href="Bap.Std.Var.html">..</a> <code class="code">end</code></pre><div class="info">
BIL variable
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.html">Bil</a>: <code class="code">sig</code> <a href="Bap.Std.Bil.html">..</a> <code class="code">end</code></pre><div class="info">
Main BIL module
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Exp.html">Exp</a>: <code class="code">sig</code> <a href="Bap.Std.Exp.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Regular</code> interface for BIL expressions
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Stmt.html">Stmt</a>: <code class="code">sig</code> <a href="Bap.Std.Stmt.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Regular</code> interface for BIL statements
</div>
<br>
<h2 id="arch">A type to represent target architecture</h2><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arch.html">Arch</a>: <code class="code">sig</code> <a href="Bap.Std.Arch.html">..</a> <code class="code">end</code></pre><div class="info">
Architecture
</div>

<pre><span id="TYPEarch"><span class="keyword">type</span> <code class="type"></code>arch</span> = <code class="type"><a href="Bap.Std.Arch.html#TYPEt">Arch.t</a></code> </pre>
<div class="info ">
architecture<br>
</div>

<br>
<h2 id="tag">Extensible variants</h2>
<p>

      This module creates an extensible variant type, that resembles
      extensible variant types, introduced in 4.02, but even more safe.
<p>

      To extend variant type with a new constructor, use
<p>

      <code class="code">Tag.register constructor_name sexp_of_constructor</code>, where
<p>

      constructor name can be any name, and can even clash with previous
      definitions it is guaranteed, that you will receive a new
      representation of the constructor, every time you're calling this
      function even if parameters are the same. The returned value is
      supposed to be exposed in a module, for later use in other
      modules, c.f., <code class="code">Image</code> module defines three constructors:<ul>
<li><code class="code">Image.symbol</code> for Image symbols, that basically can be seen as
      <code class="code">Image.Symbol of sym</code></li>
<li><code class="code">Image.section</code> for image sections;</li>
<li><code class="code">Image.region</code> for other named image memory regions.</li>
</ul>
<br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Tag.html">Tag</a>: <code class="code">sig</code> <a href="Bap.Std.Tag.html">..</a> <code class="code">end</code></pre><div class="info">
Tag module
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Seq.html">Seq</a>: <code class="code">sig</code> <a href="Bap.Std.Seq.html">..</a> <code class="code">end</code></pre><div class="info">
Lazy sequence
</div>

<pre><span id="TYPEseq"><span class="keyword">type</span> <code class="type">'a</code> seq</span> = <code class="type">'a <a href="Bap.Std.Seq.html#TYPEt">Seq.t</a></code> </pre>
<div class="info ">
type abbreviation for <code class="code">'a Sequence.t</code><br>
</div>


<pre><span id="VAL(^::)"><span class="keyword">val</span> (^::)</span> : <code class="type">'a -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> 'a <a href="Bap.Std.html#TYPEseq">seq</a></code></pre><div class="info ">
<code class="code">x ^:: xs</code> is a consing operator for sequences<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Config.html">Config</a>: <code class="code">sig</code> <a href="Bap.Std.Config.html">..</a> <code class="code">end</code></pre><div class="info">
Access to BAP configuration variables
</div>

<pre><span id="TYPEbil"><span class="keyword">type</span> <code class="type"></code>bil</span> = <code class="type"><a href="Bap.Std.Bil.html#TYPEt">Bil.t</a></code> </pre>
<div class="info ">
<h1 id="type_abbr">Type abbreviations</h1><br>
</div>


<pre><span id="TYPEbinop"><span class="keyword">type</span> <code class="type"></code>binop</span> = <code class="type">Bil.binop</code> </pre>


<pre><span id="TYPEcast"><span class="keyword">type</span> <code class="type"></code>cast</span> = <code class="type">Bil.cast</code> </pre>


<pre><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> = <code class="type"><a href="Bap.Std.Exp.html#TYPEt">Exp.t</a></code> </pre>


<pre><span id="TYPEstmt"><span class="keyword">type</span> <code class="type"></code>stmt</span> = <code class="type"><a href="Bap.Std.Stmt.html#TYPEt">Stmt.t</a></code> </pre>


<pre><span id="TYPEunop"><span class="keyword">type</span> <code class="type"></code>unop</span> = <code class="type">Bil.unop</code> </pre>


<pre><span id="TYPEvalue"><span class="keyword">type</span> <code class="type"></code>value</span> = <code class="type"><a href="Bap.Std.Tag.html#TYPEvalue">Tag.value</a></code> </pre>


<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type">'a</code> tag</span> = <code class="type">'a <a href="Bap.Std.Tag.html#TYPEt">Tag.t</a></code> </pre>

<br>
<h1 id="image">Memory model</h1>
<p>

      This library provides types that represents program as a memory
      object. This includes:
<p>
<ul>
<li><code class="code">mem</code> - a contiguous array of bytes, indexed with absolute
       addresses.</li>
<li><code class="code">table</code> - a mapping from a memory region to arbitrary entities.</li>
<li><code class="code">image</code> - a program loaded to memory, as it is viewed by
       system loader and OS.</li>
<li><code class="code">symbol</code> - some named (not strictly contiguous) part of the
       image</li>
<li><code class="code">section</code> - some contiguous part of the <code class="code">image</code> that has
       specific access flags.</li>
</ul>
<br>

<pre><span id="TYPEimage"><span class="keyword">type</span> <code class="type"></code>image</span> </pre>
<div class="info ">
an image loaded into memory<br>
</div>


<pre><span id="TYPEmem"><span class="keyword">type</span> <code class="type"></code>mem</span> </pre>
<div class="info ">
opaque memory<br>
</div>


<pre><span id="TYPEtable"><span class="keyword">type</span> <code class="type">'a</code> table</span> </pre>
<div class="info ">
a table from memory to <code class="code">'a</code><br>
</div>


<pre><span id="TYPEmemmap"><span class="keyword">type</span> <code class="type">'a</code> memmap</span> </pre>
<div class="info ">
interval trees from memory regions to <code class="code">'a</code><br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Memory_iterators.html">Memory_iterators</a> = <code class="code">sig</code> <a href="Bap.Std.Memory_iterators.html">..</a> <code class="code">end</code></pre><div class="info">
Iterators lifted into monad
</div>
<br>
<h2 id="memory">Access to memory regions</h2><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.html">Memory</a>: <code class="code">sig</code> <a href="Bap.Std.Memory.html">..</a> <code class="code">end</code></pre><div class="info">
Interface to <code class="code">mem</code> type
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Table.html">Table</a>: <code class="code">sig</code> <a href="Bap.Std.Table.html">..</a> <code class="code">end</code></pre><div class="info">
Table.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Location.html">Location</a>: <code class="code">sig</code> <a href="Bap.Std.Location.html">..</a> <code class="code">end</code></pre><div class="info">
A locations of a chunk of memory
</div>

<pre><span id="TYPElocation"><span class="keyword">type</span> <code class="type"></code>location</span> = <code class="type"><a href="Bap.Std.Location.html#TYPEt">Location.t</a></code> </pre>
<div class="info ">
memory location<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Backend.html">Backend</a>: <code class="code">sig</code> <a href="Bap.Std.Backend.html">..</a> <code class="code">end</code></pre><div class="info">
A backend interface.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Image.html">Image</a>: <code class="code">sig</code> <a href="Bap.Std.Image.html">..</a> <code class="code">end</code></pre><div class="info">
Binary Image.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memmap.html">Memmap</a>: <code class="code">sig</code> <a href="Bap.Std.Memmap.html">..</a> <code class="code">end</code></pre><div class="info">
Memory maps.
</div>
<br>
<h1 id="disasm">Disassembler</h1>
<p>

      Disassembler library has two interfaces. An expert interface,
      that provides access to a low-level representation. And a normal
      one, that hides all the complexities of the expert interface,
      but is less efficient and less flexible. If unsure, use the latter.
<p>

      <h2 id="2_Architecturespecificlibraries">Architecture specific libraries</h2>
<p>

      Also, this library provide architecture specific libraries, that
      tries to represent structurally each particular
      architecture. Currently only <code class="code">ARM</code> module, has first class
      assembler, i.e., constructors for opcodes, operands, etc.
      platform-specific stuff.<br>
<br>
<h2 id="2_Convenientinterfacetothedisassembler">Convenient interface to the disassembler.</h2><br>

<pre><span id="TYPEdisasm"><span class="keyword">type</span> <code class="type"></code>disasm</span> </pre>
<div class="info ">
value of type <code class="code">disasm</code> is a result of the disassembling of a
      memory region. To create values of this type use <code class="code">disassemble</code>
      function<br>
</div>


<pre><span id="TYPEinsn"><span class="keyword">type</span> <code class="type"></code>insn</span> </pre>
<div class="info ">
values of type <code class="code">insn</code> represents machine instructions decoded
      from the given piece of memory<br>
</div>


<pre><span id="TYPEblock"><span class="keyword">type</span> <code class="type"></code>block</span> </pre>
<div class="info ">
<code class="code">block</code> is a region of memory that is believed to be a basic block
      of control flow graph to the best of our knowledge.<br>
</div>


<pre><span id="VALdisassemble"><span class="keyword">val</span> disassemble</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble ?roots arch mem</code> disassemble provided memory region
      <code class="code">mem</code> using best available algorithm and backend for the specified
      <code class="code">arch</code>. Roots, if provided, should point to memory regions, that
      are believed to contain code. At best, this should be a list of
      function starts. If no roots are provided, then the starting
      address of the provided memory <code class="code">mem</code> will be used as a root.
<p>

      The returned value will contain all memory reachable from the
      given set of roots, at our best knowledge.<br>
</div>

<pre><span id="VALdisassemble_image"><span class="keyword">val</span> disassemble_image</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEimage">image</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_image image</code> disassemble given image.
      Will take executable sections of the image and disassemble it,
      applying <code class="code">disassemble</code> function. If no roots are specified, then
      symbol table will be used as a source of roots. If file doesn't
      contain one, then entry point will be used.<br>
</div>

<pre><span id="VALdisassemble_file"><span class="keyword">val</span> disassemble_file</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -><br>       string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a> Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALdisassemble_file_exn"><span class="keyword">val</span> disassemble_file_exn</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALlinear_sweep"><span class="keyword">val</span> linear_sweep</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -><br>       <a href="Bap.Std.html#TYPEmem">mem</a> -><br>       (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">linear_sweep arch mem</code> will perform a linear sweep disassembly on
      the specified memory <code class="code">mem</code><br>
</div>

<pre><span id="VALlinear_sweep_exn"><span class="keyword">val</span> linear_sweep_exn</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list</code></pre><div class="info ">
<code class="code">linear_sweep_exn</code> same as <code class="code">linear_sweep</code>, but raises an
      exception, instead of returning <code class="code">Or_error</code> monad<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm.html">Disasm</a>: <code class="code">sig</code> <a href="Bap.Std.Disasm.html">..</a> <code class="code">end</code></pre><div class="info">
Disassembled program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Kind.html">Kind</a>: <code class="code">sig</code> <a href="Bap.Std.Kind.html">..</a> <code class="code">end</code></pre><div class="info">
Kinds of instructions
</div>

<pre><span id="TYPEreg"><span class="keyword">type</span> <code class="type"></code>reg</span> </pre>
<div class="info ">
abstract and opaque register<br>
</div>


<pre><span id="TYPEimm"><span class="keyword">type</span> <code class="type"></code>imm</span> </pre>
<div class="info ">
opaque immediate value<br>
</div>


<pre><span id="TYPEfmm"><span class="keyword">type</span> <code class="type"></code>fmm</span> </pre>
<div class="info ">
floating point value<br>
</div>


<pre><span id="TYPEkind"><span class="keyword">type</span> <code class="type"></code>kind</span> = <code class="type"><a href="Bap.Std.Kind.html#TYPEt">Kind.t</a></code> </pre>
<div class="info ">
kind of instruction<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Reg.html">Reg</a>: <code class="code">sig</code> <a href="Bap.Std.Reg.html">..</a> <code class="code">end</code></pre><div class="info">
Register.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Imm.html">Imm</a>: <code class="code">sig</code> <a href="Bap.Std.Imm.html">..</a> <code class="code">end</code></pre><div class="info">
Integer immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Fmm.html">Fmm</a>: <code class="code">sig</code> <a href="Bap.Std.Fmm.html">..</a> <code class="code">end</code></pre><div class="info">
Floating point immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Op.html">Op</a>: <code class="code">sig</code> <a href="Bap.Std.Op.html">..</a> <code class="code">end</code></pre><div class="info">
Operand
</div>

<pre><span id="TYPEop"><span class="keyword">type</span> <code class="type"></code>op</span> = <code class="type"><a href="Bap.Std.Op.html#TYPEt">Op.t</a></code> </pre>

<br>
<h3 id="3_ApplicationBinaryInterface">Application Binary Interface</h3>
<p>

      Under this name, we're gathering several different concepts, like:
<p>
<ul>
<li>calling convention</li>
<li>stack frame organization</li>
<li>data representation</li>
<li>special functions</li>
</ul>

      Later we may extend the ABI class to handle system calls, type
      inference and other stuff.
<p>

      Each ABI object is constructed specifically to a particular
      symbol using the following functional constructor, of the
      following type:
<p>

      <code class="code">?image:image -&gt; ?sym:string -&gt; mem -&gt; block -&gt; abi option</code>
<p>

      ABI constructors are registered in the target specific lifter,
      and constructed for each symbol. Afterwards a set of most
      (and equally) applicable ABIs is provided to a calling part,
      to which it is left the final decision on how to disambiguate
      them.<br>

<pre><span id="TYPEabi"><span class="keyword">class type</span> <a href="Bap.Std.abi-c.html">abi</a></span> = <code class="code">object</code> <a href="Bap.Std.abi-c.html">..</a> <code class="code">end</code></pre><div class="info">
ABI interface.
</div>

<pre><span id="TYPEabi_constructor"><span class="keyword">type</span> <code class="type"></code>abi_constructor</span> = <code class="type">?image:<a href="Bap.Std.html#TYPEimage">image</a> -><br>       ?sym:string -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEblock">block</a> -> <a href="Bap.Std.abi-c.html">abi</a></code> </pre>
<div class="info ">
symbol name may be provided if known. Also an access
      to the whole binary image is provided if there is one.<br>
</div>

<br>
<h3 id="3_ABILmodelofCPU">A BIL model of CPU</h3>
<p>

      In general this is a model of a processor architecture, involving
      ALU, processing unit, registers and memory.<br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.CPU.html">CPU</a> = <code class="code">sig</code> <a href="Bap.Std.CPU.html">..</a> <code class="code">end</code></pre><div class="info">
Abstract interface to CPU
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.ABI.html">ABI</a> = <code class="code">sig</code> <a href="Bap.Std.ABI.html">..</a> <code class="code">end</code></pre><div class="info">
Abstract interface for ABI.
</div>
<br>
<h3 id="3_NavigatingthroughCFG">Navigating through CFG</h3>
<p>

      On a disassembly level CFG is represented as a linked set of
      basic blocks. Each basic block has a sequence of successors
      and predecessors. To get a set of block use <code class="code">Disasm.blocks</code>
      function. To navigate through use any combinations of the
      following methods:
<p>
<ul>
<li>recurse through successors and predecessors, taking care
      of possible loops;</li>
<li>use <code class="code">Block.dfs</code> to search in depth-first execution order;</li>
<li>use <code class="code">ocamlgraph</code> library and <code class="code">to_graph</code> helper functions.</li>
</ul>
<br>

<pre><span id="TYPEjump"><span class="keyword">type</span> <code class="type"></code>jump</span> = <code class="type">[ `Cond | `Jump ]</code> </pre>
<div class="info ">
a jump kind.
      A jump to another block can be conditional or unconditional.
<p>
This type defines a relation between two basic blocks.<br>
</div>


<pre><span id="TYPEedge"><span class="keyword">type</span> <code class="type"></code>edge</span> = <code class="type">[ `Cond | `Fall | `Jump ]</code> </pre>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_accessors.html">Block_accessors</a> = <code class="code">sig</code> <a href="Bap.Std.Block_accessors.html">..</a> <code class="code">end</code></pre><div class="info">
Access to block attributes.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_traverse.html">Block_traverse</a> = <code class="code">sig</code> <a href="Bap.Std.Block_traverse.html">..</a> <code class="code">end</code></pre><div class="info">
Navigate to neighborhood blocks.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm_expert.html">Disasm_expert</a>: <code class="code">sig</code> <a href="Bap.Std.Disasm_expert.html">..</a> <code class="code">end</code></pre><div class="info">
Expert interface to disassembler.
</div>
<br>
<h2 id="2_Highlevelinterface">High-level interface</h2><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Insn.html">Insn</a>: <code class="code">sig</code> <a href="Bap.Std.Insn.html">..</a> <code class="code">end</code></pre><div class="info">
Assembly instruction.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Block.html">Block</a>: <code class="code">sig</code> <a href="Bap.Std.Block.html">..</a> <code class="code">end</code></pre><div class="info">
Basic block of assembly instructions.
</div>
<br>
<h1 id="targets">Targets</h1><br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Target.html">Target</a> = <code class="code">sig</code> <a href="Bap.Std.Target.html">..</a> <code class="code">end</code></pre><div class="info">
Abstract interface for all targets.
</div>

<pre><span id="VALtarget_of_arch"><span class="keyword">val</span> target_of_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> (module Bap.Std.Target)</code></pre><div class="info ">
<code class="code">target_of_arch arch</code> creates a module for the given <code class="code">arch</code>, if
      <code class="code">arch</code> is not lifted, the stub module is returned.<br>
</div>
<br>
<h2 id="2_Liftedtargets">Lifted targets</h2>
      All targets implement at least <code class="code">Target</code> interface.<br>

<pre><span class="keyword">module</span> <a href="Bap.Std.ARM.html">ARM</a>: <code class="code">sig</code> <a href="Bap.Std.ARM.html">..</a> <code class="code">end</code></pre><div class="info">
ARM architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.IA32.html">IA32</a>: <code class="code">sig</code> <a href="Bap.Std.IA32.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">x86</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.AMD64.html">AMD64</a>: <code class="code">sig</code> <a href="Bap.Std.AMD64.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">x86-64</code> architecture
</div>
<br>
<h3 id="3_Sematicanalysis">Sematic analysis</h3><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Symtab.html">Symtab</a>: <code class="code">sig</code> <a href="Bap.Std.Symtab.html">..</a> <code class="code">end</code></pre><div class="info">
<span class="deprecated"></span></div>
<br>
<h1 id="project">Project</h1>
      A big view on a dissassembled binary<br>
<br>
Interface for the BAP project.
<p>

      Project represents the results of analysis applied to a certain
      binary object. It is slightly more abstract, then binary image,
      thus allowing to apply analysis on arbitrary binary blobs.
<p>

      Project is also a common ground, where different plugins can meet,
      talk and exchange with information. Each plugin is barely a
      function of type <code class="code">t -&gt; t</code>, i.e., it can functionally update
      project, e.g., add annotations, discover new symbols, remove
      incorrect and, even, change architecture and redisassemble
      everything.
<p>

      <h3 id="3_Exchanginginformation">Exchanging information</h3>
<p>

      For exchanging information in type safe manner we use universal
      values. Values can be attached to a particular memory region, or to
      a key of type <code class="code">string</code>. For the first case we use `memmap` data
      structure that is an interval tree containing all the memory
      regions that were used during analysis. For the latter a simple
      <code class="code">String.Map</code> is used.
<p>

      <h4 id="4_Annotatingmemory">Annotating memory</h4>
<p>

      Depending on the analysis performed and input parameters, one can
      expect that memory may be annotated with the following tags:
<p>
<ul>
<li><code class="code">Image.region</code> -- for regions of memory, that had some
      particular name in the original binary. For example, in ELF
      sections have names, that will be used to annotate corresponding
      memory regions.</li>
</ul>
<ul>
<li><code class="code">Image.section</code> -- if the binary data was loaded from a binary
      format that contains sections (aka segments), then corresponding
      memory regions would be marked. Sections gives you access to
      permission information.</li>
</ul>
<ul>
<li><code class="code">Image.symbol</code> -- with this tag we annotate each memory regions
      that belongs to a particular symbol. Currently, the type of tag
      is just a string.</li>
</ul>
<br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Project.html">Project</a>: <code class="code">sig</code> <a href="Bap.Std.Project.html">..</a> <code class="code">end</code></pre><br>
<h1 id="1_Auxiliarylibraries">Auxiliary libraries</h1><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Dwarf.html">Dwarf</a>: <code class="code">sig</code> <a href="Bap.Std.Dwarf.html">..</a> <code class="code">end</code></pre><div class="info">
Dwarf library
      This library gives an access to debugging information stored
      in a binary program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Signatures.html">Signatures</a>: <code class="code">sig</code> <a href="Bap.Std.Signatures.html">..</a> <code class="code">end</code></pre><div class="info">
Binary Signatures Storage
</div>
<br>
<h4 id="4_ByteweightAlgorithmimplementation">Byteweight Algorithm implementation</h4><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Byteweight.html">Byteweight</a>: <code class="code">sig</code> <a href="Bap.Std.Byteweight.html">..</a> <code class="code">end</code></pre></body></html>