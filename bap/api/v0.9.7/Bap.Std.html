<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Bap.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html"><link title="BAP API" rel="Section" href="#api">
<link title="Overview" rel="Subsection" href="#2_Overview">
<link title="Foundation Library" rel="Subsection" href="#bfl">
<link title="Memory model" rel="Subsection" href="#image">
<link title="Disassembler" rel="Subsection" href="#disasm">
<link title="Semantic Analysis" rel="Subsection" href="#sema">
<link title="Writing Program Analysis Plugins" rel="Subsection" href="#project">
<link title="Auxiliary libraries" rel="Subsection" href="#aux">
<title>Bap.Std</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Bap.html" title="Bap">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Bap.Std.html">Bap.Std</a></h1>

<pre><span class="keyword">module</span> Std: <code class="code">sig</code> <a href="Bap.Std.html">..</a> <code class="code">end</code></pre><div class="info module top">
<h1 id="1_BinaryAnalysisPlatformLibrary">Binary Analysis Platform Library</h1><br>
</div>
<hr width="100%">
<br>
<h2 id="2_Overview">Overview</h2>
<p>

      BAP has a layered architecture currently consisting of four
      layers:
<p>

      <pre class="codepre"><code class="code">        +-----------------------------------------+
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |       Foundation Library          |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        |                                         |
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |          Memory Model             |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        |                                         |
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |           Disassembling           |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        |                                         |
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |        Semantic Analysis          |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        +-----------------------------------------+
      </code></pre>
<p>

      <a href="Bap.Std.html#bfl">Foundation library</a> defines core types, that are used
      throughout the whole BAP library and is useful in binary
      analysis. <a href="Bap.Std.html#image">Memory model</a> layer is responsible
      for loading and parsing binary objects and representing them in
      memory. It also defines few useful data structures, that are
      used extensively by later layers. The next layer performs
      <a href="Bap.Std.html#disasm">disassembling</a> and lifting to BIL. And,
      finally, the <a href="Bap.Std.html#sema">semantic analysis</a> layer,
      transforms binary into IR representation and provides a set of
      handful analysis tools.
<p>

      From another point of view BAP has a plugin architecture, like
      GIMP or Frama-C. BAP plugins plays different role in our
      infrastructure.  In fact even LLVM disassembler is just a
      plugin. Currently we have three different extension points in
      BAP:
<p>
<ul>
<li><a href="Bap.Std.Backend.html">loaders</a> - to add new binary object loaders;</li>
<li>disassemblers - to add new disassemblers;</li>
<li><a href="Bap.Std.Project.html">program analysis</a> - to analyze programs.</li>
</ul>

      The latter category of plugins is most widely used, so that
      usually when we speak about plugin, we think in particular
      program analysis plugin. The following figure provides an
      overview of the BAP system.
<p>

      <pre class="codepre"><code class="code">        +---------------------------------------------+
        |  +----------------+    +-----------------+  |
        |  |    Loader      |    |  Disassembler   |  |
        |  |    Plugins     |    |    Plugins      |  |
        |  +-------+--------+    +--------+--------+  |
        |          |                      |           |
        |  +-------+----------------------+--------+  |
        |  |                                       |  |
        |  |             BAP Library               |  |
        |  |                                       |  |
        |  +-------+-------------------------------+  |
        |          ^                      ^           |
        |          |                      |           |
        |  +-------+--------+    +--------+--------+  |
        |  |                |    |                 |  |
        |  |  BAP toolkit   |&lt;--&gt;|   BAP Plugins   |  |
        |  |                |    |                 |  |
        |  +----------------+    +-----------------+  |
        +---------------------------------------------+
      </code></pre>
<p>

      All plugins has full access to the library, so that they can and
      should open <code class="code">Bap.Std</code>. BAP library uses loader and disassembler
      plugins as a backends, to provide its services. Program analysis
      plugins are loaded by BAP toolkit utilities, to extend their
      functionality and to provide an access to the state of the
      target of analysis or, in our parlance, to the
      <a href="Bap.Std.html#TYPEproject">project</a>. (See <a href="Bap.Std.html#project"><i>Writing Program Analysis Plugins</i></a>).
<p>

      Other then library itself, and BAP toolkit, there are two more
      libraries, that are bundled with BAP:
<p>
<ul>
<li><code class="code">bap.plugins</code> to dynamically load code into BAP;</li>
<li><code class="code">bap.serialization</code> to serialize BAP data structures in
        different formats.</li>
</ul>
<br>
<br>
<h2 id="bfl">Foundation Library</h2>
<p>

      At this layer we define our core types that are tightly
      integrated with Binary Intermediate Language (<a href="Bap.Std.Bil.html">BIL</a>). The
      core types are:
<p>
<ul>
<li><a href="Bap.Std.Arch.html">arch</a> - to denote computer architecture;</li>
<li><a href="Bap.Std.Size.html">size</a> - to specify sizes of wors or addresses;</li>
<li><a href="Bap.Std.Var.html">var</a>  - BIL variable;</li>
<li><a href="Bap.Std.Type.html">typ</a> - OCaml type for BIL type;</li>
<li><a href="Bap.Std.Exp.html">exp</a>  - BIL expression;</li>
<li><a href="Bap.Std.Stmt.html">stmt</a> - BIL statement;</li>
<li><a href="Bap.Std.Bitvector.html">word,addr</a> - a bitvector data structure
        to represent immediate data;</li>
<li><a href="Bap.Std.Tag.html">'a tag</a> and <a href="Bap.Std.Tag.html">value</a> - an extensible variant type,
        aka existential, aka type <code class="code">any</code>;</li>
<li><a href="Bap.Std.Seq.html">'a seq</a> - slightly extended Core <code class="code">Sequence</code>, aka lazy
        list.</li>
</ul>

      Every type implements <a href="Bap.Std.Regular.html">Regular</a> interface. This
      interface is very similar to Core's <code class="code">Identifiable</code>, and is
      supposed to represent a type that is as common as built-in
      type. One should expect to find any function that is implemented
      for such types as <code class="code">int</code>, <code class="code">string</code>, <code class="code">char</code>, etc. To name a few,
      this interface includes:
<p>
<ul>
<li>comparison functions: (<code class="code">&lt;, &gt;, &lt;= , &gt;= , compare, between, ...</code>);</li>
<li>each type defines a polymorphic <code class="code">Map</code> with keys of type <code class="code">t</code>;</li>
<li>each type provides a <code class="code">Set</code> with values of type <code class="code">t</code>;</li>
<li>hashtable is exposed via <code class="code">Table</code> module;</li>
<li>hashset is available under <code class="code">Hash_set</code> name</li>
<li>sexpable and binable interface;</li>
<li><code class="code">to_string</code>, <code class="code">str</code>, <code class="code">pp</code>, <code class="code">ppo</code>, <code class="code">pps</code> functions
      for pretty-printing.</li>
</ul>

      And most types usually provide much more.
<p>

      For each type, there is a module with the same name, that
      implements its interface. For example, type <code class="code">exp</code> is indeed a
      type abbreviation for <code class="code">Exp.t</code>, and module <code class="code">Exp</code> contains all
      functions and types related to type <code class="code">exp</code>. For example, to create
      a hashtable of statements, just type:
<p>

      <code class="code">let table = Stmt.Table.create ()</code>
<p>

      If a type is a variant type (i.e., defines constructors) then for
      each contructor named <code class="code">Name</code>, you will find a corresponding
      function named <code class="code">name</code> that will accept the same number of
      arguments as the arity of the constructor. For example, <code class="code">Bil.Int</code>
      can be constructed with <code class="code">Bil.int</code> function, that has type <code class="code">word -&gt;
      exp</code>. If constructor has several arguments of the same type we
      usually disambiguate them with keywords, e.g., <code class="code">Bil.Load of
      (exp,exp,endian,size)</code> has function <a href="Bap.Std.Bil.html#VALload">Bil.load</a> with
      type: <code class="code">mem:exp -&gt; addr:exp -&gt; endian -&gt; size -&gt; exp</code>
<p>

      <h3 id="tries">Tries</h3>
<p>

      Foundation library also defines a prefix tree data structure,
      that proved to be useful in binary analysis applications.
      <a href="Bap.Std.Trie.html">Trie</a>s in BAP is a functor, that will derive for
      a given <a href="Bap.Std.Trie.Key.html">Key</a> a polymorphic trie data structure.
<p>

      For the convenience we provide instantiated tries for most of
      our data structures. For example, <a href="Bap.Std.Bitvector.html">Word</a> has several
      <a href="Bap.Std.Bitvector.Trie.html">tries</a> inside.
<p>

      For the common strings, we provide <a href="Bap.Std.Trie.String.html"><code class="code">Bap.Std.Trie.String</code></a>.<br>
<br>
<h2 id="image">Memory model</h2>
<p>

      This layer provides everything you need to work with binary
      objects:s
<p>
<ul>
<li><a href="Bap.Std.Memory.html">mem</a> - a contiguous array of bytes, indexed with
       absolute addresses.</li>
</ul>
<ul>
<li><a href="Bap.Std.Table.html"> 'a table</a> - a mapping from a memory regions to
       arbitrary data (no duplicates or intersections).</li>
</ul>
<ul>
<li><a href="Bap.Std.Memmap.html">a memmap</a> - a mapping from memory region to
        arbitrary data with duplicates and intersections allowed, aka
        segment tree or interval map;</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html">image</a> - represents a binary object with all its
       symbols, sections and other meta information.</li>
</ul>

      <code class="code">Image</code> module uses plugin system to load binary objects. In
      order to add new loader, one should implement
      <a href="Bap.Std.Backend.html">Backend.t</a> loader function and register it using
      <a href="Bap.Std.Image.html#VALregister_backend">Image.register_backend</a> function<br>
<br>
<h2 id="disasm">Disassembler</h2>
<p>

      This layer consists of disassemblers and lifters. They are
      tightly integrated, but in general we can disassemble all
      supported <a href="Bap.Std.Arch.html#TYPEt">architectures</a>, but lift only arm, x86 and
      x86_64.
<p>

      There're two interfaces to disassemblers:
<p>
<ul>
<li><a href="Bap.Std.Disasm.html">Disasm</a> - a regular interface, that hides all
       complexities, but sometimes not very flexible.</li>
<li><a href="Bap.Std.Disasm_expert.html">Disasm_expert</a> - an expert interface that
      provides access to a low-level representation, and is very
      flexible and fast, but is hard to use.</li>
</ul>

      To disassemble file or data with regular interface use one of the
      following functions:
<p>
<ul>
<li><a href="Bap.Std.html#VALdisassemble">disassemble</a> - to disassemble a region of
        memory;</li>
<li><a href="Bap.Std.html#VALdisassemble_image">disassemble_image</a> - to disassembled
        loaded binary object;</li>
<li><a href="Bap.Std.html#VALdisassemble_file">disassemble_file</a> or
        <a href="Bap.Std.html#VALdisassemble_file_exn">disassemble_file</a> - to disassemble
        file.</li>
</ul>

      All this functions perform recursive descent disassembly,
      reconstruct the control flow graph and perform lifting. The
      result of disassembling is represented by abstract value of
      type <a href="Bap.Std.Disasm.html">disasm</a>. Two main data structures that are used
      to represent disassembled program are:
<p>
<ul>
<li><a href="Bap.Std.Insn.html">insn</a> - machine instruction;</li>
<li><a href="Bap.Std.Block.html">block</a> - a basic block, i.e. a linear sequence of
        instructions.</li>
</ul>

      The following figure shows the relationship between basic data
      structures of the disassembled program.
<p>

      <pre class="codepre"><code class="code">        +-----------------+
        | +-------------+ |
        | |   disasm    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |    block    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     insn    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     stmt    | |
        | +-------------+ |
        +-----------------+
      </code></pre>
<p>

      A disassembled program is represented as a set of interconnected
      <a href="Bap.Std.Block.html">basic blocks</a>. You can navigate between blocks using
      <a href="Bap.Std.Block_traverse.html#VALsuccs">Block.succs</a> and
      <a href="Bap.Std.Block_traverse.html#VALpreds">Block.preds</a> functions, or you can
      transform a set of blocks into a real <a href="Bap.Std.Block.Cfg.html">graph</a>, using
      <a href="Bap.Std.Block.html#VALto_graph">Block.to_graph</a> function. Sometimes it maybe
      enough to traverse program using <a href="Bap.Std.Block.html#VALdfs">depth-first
      search</a>.
<p>

      Each block is a container to a sequence of machine
      instructions. It is guaranteed, that there is at least one
      instruction in the block, thus
      <a href="Bap.Std.Block_accessors.html#VALleader">Block.leader</a> and
      <a href="Bap.Std.Block_accessors.html#VALterminator">Block.terminator</a> functions are
      total.
<p>

      Each <a href="Bap.Std.Insn.html">machine instruction</a> is represented by its
      <code class="code">opcode</code>, <code class="code">name</code> and <code class="code">array</code> of operands, that are machine and
      disassembler specific; a set of predicates, that describes
      instruction semantics on a very high level; and by a sequence of
      <a href="Bap.Std.Bil.html">BIL</a> statements, that defines precisely the semantics of
      this instruction.
<p>

      Modules of type <a href="Bap.Std.CPU.html">CPU</a> provide a high level abstraction of
      CPU and allow one to reason about instruction semantics
      independently from the target platform. Modules of type
      <a href="Bap.Std.ABI.html">ABI</a> provide even more information, e.g., maps registers
      to formals. Module type <a href="Bap.Std.Target.html">Target</a> brings <code class="code">CPU</code> and <code class="code">ABI</code>
      together. To get an instance of this module, you can use
      function <a href="Bap.Std.html#VALtarget_of_arch">target_of_arch</a>. To get access to
      full information about target platform, use the following
      modules, that reveals low-level and platform-specific details:
<p>
<ul>
<li><a href="Bap.Std.ARM.html">ARM</a>;</li>
<li><a href="Bap.Std.IA32.html">IA32</a>;</li>
<li><a href="Bap.Std.AMD64.html">AMD64</a>.</li>
</ul>

      If you do not need the cfg reconstruction, then you can use
      <a href="Bap.Std.html#VALlinear_sweep">linear_sweep</a> function to disassemble given
      memory region. If you need more granularity, then you can use
      expert interface, that has two modules inside:
<p>
<ul>
<li><a href="Bap.Std.Disasm_expert.Basic.html">Basic</a> - provides access to a low-level
        disassembler on top of which all other disassemblers are
        built;</li>
<li><a href="Bap.Std.Disasm_expert.Recursive.html">Recursive</a> - an interface to a
        recursive descent algorithm.</li>
</ul>
<br>
<br>
<h2 id="sema">Semantic Analysis</h2>
      This part of the library are currently under heavy
      construction. We will provide information later.<br>
<br>
<h2 id="project">Writing Program Analysis Plugins</h2>
<p>

      To write a program analysis plugin you need to implement a
      function of one of the following interfaces:
<p>
<ul>
<li><code class="code">project -&gt; project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_plugin">register_plugin</a>;</li>
<li><code class="code">project -&gt; unit</code> and register it with
         <a href="Bap.Std.Project.html#VALregister_plugin'">register_plugin'</a>;</li>
<li><code class="code">string array -&gt; project -&gt; project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_plugin_with_args">register_plugin_with_args</a></li>
<li><code class="code">string array -&gt; project -&gt; unit</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_plugin_with_args'">register_plugin_with_args'</a>.</li>
</ul>

      Once loaded from the <code class="code">bap</code> utility (see <code class="code">man bap</code>) this function
      will be invoked with a value of type <a href="Bap.Std.Project.html#TYPEt">project</a>, that
      provides an access to all information that was gathered over the
      binary so far. If registered function returns non <code class="code">unit</code> type,
      then it can functionally update the project state, e.g., add
      annotations, discover new symbols, remove incorrect and, even,
      change architecture and redisassemble everything.
<p>

      <h3 id="3_Exchanginginformation">Exchanging information</h3>
<p>

      For exchanging information in type safe manner we use
      <a href="Bap.Std.Tag.html">universal values</a>. Values can be attached to a particular
      memory region, or to a key of type <code class="code">string</code>. For the first case
      we use <a href="Bap.Std.Memmap.html">memmap</a> data structure that is an interval tree
      containing all the memory regions that were used during
      analysis. For the latter a regular <code class="code">String.Map</code> is used.
<p>

      <h3 id="3_Annotatingmemory">Annotating memory</h3>
<p>

      Depending on the analysis performed and input parameters, one can
      expect that memory may be annotated with the following tags:
<p>
<ul>
<li><code class="code">Image.region</code> -- for regions of memory, that had some
      particular name in the original binary. For example, in ELF
      sections have names, that will be used to annotate corresponding
      memory regions.</li>
</ul>
<ul>
<li><code class="code">Image.section</code> -- if the binary data was loaded from a binary
      format that contains sections (aka segments), then corresponding
      memory regions would be marked. Sections gives you access to
      permission information.</li>
</ul>
<ul>
<li><code class="code">Image.symbol</code> -- with this tag we annotate each memory regions
      that belongs to a particular symbol. Currently, the type of tag
      is just a string.</li>
</ul>
<br>
<br>
<h2 id="aux">Auxiliary libraries</h2>
<p>

      <h3 id="dwarf">DWARF library</h3>
<p>

      Dwarf library provides an access to DWARF debugging
      information. It implements parsing of some subset of DWARF
      features, and a high-level interface <a href="Bap.Std.Dwarf.Fbi.html">Fbi</a> that
      will extract function symbols from the given DWARF data.
<p>

      <h3 id="sigs">Byteweight</h3>
<p>

      This <a href="Bap.Std.Byteweight.html">library</a> implements a byteweight algorithm,
      that can identify functions in stripped binaries, as well as to
      train itself on provided training corpus.<br>
<br>
<h1 id="api">BAP API</h1><br>

<pre><span id="TYPEprinter"><span class="keyword">type</span> <code class="type">'a</code> printer</span> = <code class="type">Format.formatter -> 'a -> unit</code> </pre>
<div class="info ">
<code class="code">'a printer</code> defines a type for pretty-printers for a value of
      type <code class="code">'a</code>. This is the type, that is required by <code class="code">%a</code> specifier,
      for <code class="code">Format.printf</code>-family of functions. Also, this is the type,
      that can be installed into OCaml toplevel or debugger.
<p>

      Note: `bap.top` library automatically installs all printers.<br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Printable.html">Printable</a> = <code class="code">sig</code> <a href="Bap.Std.Printable.html">..</a> <code class="code">end</code></pre><div class="info">
Printable interface is implemented by a significant amount of
      BAP types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Regular.html">Regular</a> = <code class="code">sig</code> <a href="Bap.Std.Regular.html">..</a> <code class="code">end</code></pre><div class="info">
Regular types models a general concept of value, i.e., something
      that can be used in way similiar to regular <code class="code">int</code>, <code class="code">string</code>,
      <code class="code">char</code> and other built in types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Integer.html">Integer</a> = <code class="code">sig</code> <a href="Bap.Std.Integer.html">..</a> <code class="code">end</code></pre><div class="info">
Signature for integral type.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Regular.html">Regular</a>: <code class="code">sig</code> <a href="Bap.Std.Regular.html">..</a> <code class="code">end</code></pre><div class="info">
In order to implement <code class="code">Regular</code> interface you need to provide a
      minimum implementation <code class="code">M</code>
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Trie.html">Trie</a> = <code class="code">sig</code> <a href="Bap.Std.Trie.html">..</a> <code class="code">end</code></pre><div class="info">
Prefix tries.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Trie.html">Trie</a>: <code class="code">sig</code> <a href="Bap.Std.Trie.html">..</a> <code class="code">end</code></pre><div class="info">
Constructs a trie
</div>

<pre><span id="TYPEword"><span class="keyword">type</span> <code class="type"></code>word</span> </pre>
<div class="info ">
Type to represent machine word<br>
</div>


<pre><span id="TYPEaddr"><span class="keyword">type</span> <code class="type"></code>addr</span> = <code class="type"><a href="Bap.Std.html#TYPEword">word</a></code> </pre>
<div class="info ">
A synonym for <code class="code">word</code>, that should be used for words
      that are addresses<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Size.html">Size</a>: <code class="code">sig</code> <a href="Bap.Std.Size.html">..</a> <code class="code">end</code></pre><div class="info">
Type safe operand and register sizes.
</div>

<pre><span id="TYPEsize"><span class="keyword">type</span> <code class="type"></code>size</span> = <code class="type"><a href="Bap.Std.Size.html#TYPEt">Size.t</a></code> </pre>
<div class="info ">
size of operand<br>
</div>


<pre><span id="TYPEaddr_size"><span class="keyword">type</span> <code class="type"></code>addr_size</span> = <code class="type">[ `r32 | `r64 ] <a href="Bap.Std.Size.html#TYPEp">Size.p</a></code> </pre>
<div class="info ">
size of address<br>
</div>


<pre><span id="TYPEnat1"><span class="keyword">type</span> <code class="type"></code>nat1</span> = <code class="type">int</code> </pre>
<div class="info ">
just a fancy type abbreviation<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.html">Bitvector</a>: <code class="code">sig</code> <a href="Bap.Std.Bitvector.html">..</a> <code class="code">end</code></pre><div class="info">
Bitvector -- a type for representing binary values.
</div>

<pre><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = <code class="type"><a href="Bap.Std.Bitvector.html#TYPEendian">Bitvector.endian</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>

</tr></table>

<div class="info ">
Expose <code class="code">endian</code> constructors to <code class="code">Bap.Std</code> namespace<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Word.html">Word</a>: <code class="type">module type of Bitvector</code><code class="type"> 
    with type t = word
     and type endian = endian
     and type comparator_witness = Bitvector.comparator_witness</code></pre><div class="info">
Shortcut for bitvectors that represent words
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Addr.html">Addr</a>: <code class="code">sig</code> <a href="Bap.Std.Addr.html">..</a> <code class="code">end</code></pre><div class="info">
Shortcut for bitvectors that represent addresses
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Type.html">Type</a>: <code class="code">sig</code> <a href="Bap.Std.Type.html">..</a> <code class="code">end</code></pre><div class="info">
The type of a BIL expression.
</div>

<pre><span id="TYPEtyp"><span class="keyword">type</span> <code class="type"></code>typ</span> = <code class="type"><a href="Bap.Std.Type.html#TYPEt">Type.t</a></code> </pre>
<div class="info ">
short abbreviation for a type<br>
</div>


<pre><span id="VALbool_t"><span class="keyword">val</span> bool_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
one bit<br>
</div>

<pre><span id="VALreg8_t"><span class="keyword">val</span> reg8_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
8-bit width value<br>
</div>

<pre><span id="VALreg16_t"><span class="keyword">val</span> reg16_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
16-bit width value<br>
</div>

<pre><span id="VALreg32_t"><span class="keyword">val</span> reg32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
32-bit width value<br>
</div>

<pre><span id="VALreg64_t"><span class="keyword">val</span> reg64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
64-bit width value<br>
</div>

<pre><span id="VALreg128_t"><span class="keyword">val</span> reg128_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
128-bit width value<br>
</div>

<pre><span id="VALreg256_t"><span class="keyword">val</span> reg256_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
256-bit width value<br>
</div>

<pre><span id="VALmem32_t"><span class="keyword">val</span> mem32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem32_t size</code> 32-bit chunk of memory of a given <code class="code">size</code><br>
</div>

<pre><span id="VALmem64_t"><span class="keyword">val</span> mem64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem64_t size</code>  32-bit chunk of memory of a given <code class="code">size</code><br>
</div>

<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> </pre>
<div class="info ">
bil variable<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Var.html">Var</a>: <code class="code">sig</code> <a href="Bap.Std.Var.html">..</a> <code class="code">end</code></pre><div class="info">
BIL variable.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.html">Bil</a>: <code class="code">sig</code> <a href="Bap.Std.Bil.html">..</a> <code class="code">end</code></pre><div class="info">
Main BIL module
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Exp.html">Exp</a>: <code class="code">sig</code> <a href="Bap.Std.Exp.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Regular</code> interface for BIL expressions
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Stmt.html">Stmt</a>: <code class="code">sig</code> <a href="Bap.Std.Stmt.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">Regular</code> interface for BIL statements
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arch.html">Arch</a>: <code class="code">sig</code> <a href="Bap.Std.Arch.html">..</a> <code class="code">end</code></pre><div class="info">
Architecture
</div>

<pre><span id="TYPEarch"><span class="keyword">type</span> <code class="type"></code>arch</span> = <code class="type"><a href="Bap.Std.Arch.html#TYPEt">Arch.t</a></code> </pre>
<div class="info ">
architecture<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Tag.html">Tag</a>: <code class="code">sig</code> <a href="Bap.Std.Tag.html">..</a> <code class="code">end</code></pre><div class="info">
Extensible variants
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Seq.html">Seq</a>: <code class="code">sig</code> <a href="Bap.Std.Seq.html">..</a> <code class="code">end</code></pre><div class="info">
Lazy sequence
</div>

<pre><span id="TYPEseq"><span class="keyword">type</span> <code class="type">'a</code> seq</span> = <code class="type">'a <a href="Bap.Std.Seq.html#TYPEt">Seq.t</a></code> </pre>
<div class="info ">
type abbreviation for <code class="code">'a Sequence.t</code><br>
</div>


<pre><span id="VAL(^::)"><span class="keyword">val</span> (^::)</span> : <code class="type">'a -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> 'a <a href="Bap.Std.html#TYPEseq">seq</a></code></pre><div class="info ">
<code class="code">x ^:: xs</code> is a consing operator for sequences<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Config.html">Config</a>: <code class="code">sig</code> <a href="Bap.Std.Config.html">..</a> <code class="code">end</code></pre><div class="info">
Access to BAP configuration variables
</div>

<pre><span id="TYPEbil"><span class="keyword">type</span> <code class="type"></code>bil</span> = <code class="type"><a href="Bap.Std.Bil.html#TYPEt">Bil.t</a></code> </pre>


<pre><span id="TYPEbinop"><span class="keyword">type</span> <code class="type"></code>binop</span> = <code class="type">Bil.binop</code> </pre>


<pre><span id="TYPEcast"><span class="keyword">type</span> <code class="type"></code>cast</span> = <code class="type">Bil.cast</code> </pre>


<pre><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> = <code class="type"><a href="Bap.Std.Exp.html#TYPEt">Exp.t</a></code> </pre>


<pre><span id="TYPEstmt"><span class="keyword">type</span> <code class="type"></code>stmt</span> = <code class="type"><a href="Bap.Std.Stmt.html#TYPEt">Stmt.t</a></code> </pre>


<pre><span id="TYPEunop"><span class="keyword">type</span> <code class="type"></code>unop</span> = <code class="type">Bil.unop</code> </pre>


<pre><span id="TYPEvalue"><span class="keyword">type</span> <code class="type"></code>value</span> = <code class="type"><a href="Bap.Std.Tag.html#TYPEvalue">Tag.value</a></code> </pre>


<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type">'a</code> tag</span> = <code class="type">'a <a href="Bap.Std.Tag.html#TYPEt">Tag.t</a></code> </pre>


<pre><span id="TYPEimage"><span class="keyword">type</span> <code class="type"></code>image</span> </pre>
<div class="info ">
an image loaded into memory<br>
</div>


<pre><span id="TYPEmem"><span class="keyword">type</span> <code class="type"></code>mem</span> </pre>
<div class="info ">
opaque memory<br>
</div>


<pre><span id="TYPEtable"><span class="keyword">type</span> <code class="type">'a</code> table</span> </pre>
<div class="info ">
a table from memory to <code class="code">'a</code><br>
</div>


<pre><span id="TYPEmemmap"><span class="keyword">type</span> <code class="type">'a</code> memmap</span> </pre>
<div class="info ">
interval trees from memory regions to <code class="code">'a</code><br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Memory_iterators.html">Memory_iterators</a> = <code class="code">sig</code> <a href="Bap.Std.Memory_iterators.html">..</a> <code class="code">end</code></pre><div class="info">
Iterators lifted into monad
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.html">Memory</a>: <code class="code">sig</code> <a href="Bap.Std.Memory.html">..</a> <code class="code">end</code></pre><div class="info">
Memory region
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Table.html">Table</a>: <code class="code">sig</code> <a href="Bap.Std.Table.html">..</a> <code class="code">end</code></pre><div class="info">
Table.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Location.html">Location</a>: <code class="code">sig</code> <a href="Bap.Std.Location.html">..</a> <code class="code">end</code></pre><div class="info">
A locations of a chunk of memory
</div>

<pre><span id="TYPElocation"><span class="keyword">type</span> <code class="type"></code>location</span> = <code class="type"><a href="Bap.Std.Location.html#TYPEt">Location.t</a></code> </pre>
<div class="info ">
memory location<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Backend.html">Backend</a>: <code class="code">sig</code> <a href="Bap.Std.Backend.html">..</a> <code class="code">end</code></pre><div class="info">
A backend interface.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Image.html">Image</a>: <code class="code">sig</code> <a href="Bap.Std.Image.html">..</a> <code class="code">end</code></pre><div class="info">
Binary Image.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memmap.html">Memmap</a>: <code class="code">sig</code> <a href="Bap.Std.Memmap.html">..</a> <code class="code">end</code></pre><div class="info">
Memory maps.
</div>

<pre><span id="TYPEdisasm"><span class="keyword">type</span> <code class="type"></code>disasm</span> </pre>
<div class="info ">
value of type <code class="code">disasm</code> is a result of the disassembling of a
      memory region. To create values of this type use <code class="code">disassemble</code>
      function<br>
</div>


<pre><span id="TYPEinsn"><span class="keyword">type</span> <code class="type"></code>insn</span> </pre>
<div class="info ">
values of type <code class="code">insn</code> represents machine instructions decoded
      from the given piece of memory<br>
</div>


<pre><span id="TYPEblock"><span class="keyword">type</span> <code class="type"></code>block</span> </pre>
<div class="info ">
<code class="code">block</code> is a region of memory that is believed to be a basic block
      of control flow graph to the best of our knowledge.<br>
</div>


<pre><span id="VALdisassemble"><span class="keyword">val</span> disassemble</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble ?roots arch mem</code> disassemble provided memory region
      <code class="code">mem</code> using best available algorithm and backend for the specified
      <code class="code">arch</code>. Roots, if provided, should point to memory regions, that
      are believed to contain code. At best, this should be a list of
      function starts. If no roots are provided, then the starting
      address of the provided memory <code class="code">mem</code> will be used as a root.
<p>

      The returned value will contain all memory reachable from the
      given set of roots, at our best knowledge.<br>
</div>

<pre><span id="VALdisassemble_image"><span class="keyword">val</span> disassemble_image</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEimage">image</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_image image</code> disassemble given image.
      Will take executable sections of the image and disassemble it,
      applying <code class="code">disassemble</code> function. If no roots are specified, then
      symbol table will be used as a source of roots. If file doesn't
      contain one, then entry point will be used.<br>
</div>

<pre><span id="VALdisassemble_file"><span class="keyword">val</span> disassemble_file</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -><br>       string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a> Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALdisassemble_file_exn"><span class="keyword">val</span> disassemble_file_exn</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALlinear_sweep"><span class="keyword">val</span> linear_sweep</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -><br>       <a href="Bap.Std.html#TYPEmem">mem</a> -><br>       (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">linear_sweep arch mem</code> will perform a linear sweep disassembly on
      the specified memory <code class="code">mem</code><br>
</div>

<pre><span id="VALlinear_sweep_exn"><span class="keyword">val</span> linear_sweep_exn</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list</code></pre><div class="info ">
<code class="code">linear_sweep_exn</code> same as <code class="code">linear_sweep</code>, but raises an
      exception, instead of returning <code class="code">Or_error</code> monad<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm.html">Disasm</a>: <code class="code">sig</code> <a href="Bap.Std.Disasm.html">..</a> <code class="code">end</code></pre><div class="info">
Disassembled program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Kind.html">Kind</a>: <code class="code">sig</code> <a href="Bap.Std.Kind.html">..</a> <code class="code">end</code></pre><div class="info">
Kinds of instructions
</div>

<pre><span id="TYPEreg"><span class="keyword">type</span> <code class="type"></code>reg</span> </pre>
<div class="info ">
abstract and opaque register<br>
</div>


<pre><span id="TYPEimm"><span class="keyword">type</span> <code class="type"></code>imm</span> </pre>
<div class="info ">
opaque immediate value<br>
</div>


<pre><span id="TYPEfmm"><span class="keyword">type</span> <code class="type"></code>fmm</span> </pre>
<div class="info ">
floating point value<br>
</div>


<pre><span id="TYPEkind"><span class="keyword">type</span> <code class="type"></code>kind</span> = <code class="type"><a href="Bap.Std.Kind.html#TYPEt">Kind.t</a></code> </pre>
<div class="info ">
kind of instruction<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Reg.html">Reg</a>: <code class="code">sig</code> <a href="Bap.Std.Reg.html">..</a> <code class="code">end</code></pre><div class="info">
Register.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Imm.html">Imm</a>: <code class="code">sig</code> <a href="Bap.Std.Imm.html">..</a> <code class="code">end</code></pre><div class="info">
Integer immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Fmm.html">Fmm</a>: <code class="code">sig</code> <a href="Bap.Std.Fmm.html">..</a> <code class="code">end</code></pre><div class="info">
Floating point immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Op.html">Op</a>: <code class="code">sig</code> <a href="Bap.Std.Op.html">..</a> <code class="code">end</code></pre><div class="info">
Operand
</div>

<pre><span id="TYPEop"><span class="keyword">type</span> <code class="type"></code>op</span> = <code class="type"><a href="Bap.Std.Op.html#TYPEt">Op.t</a></code> </pre>


<pre><span id="TYPEabi"><span class="keyword">class type</span> <a href="Bap.Std.abi-c.html">abi</a></span> = <code class="code">object</code> <a href="Bap.Std.abi-c.html">..</a> <code class="code">end</code></pre><div class="info">
ABI interface.
</div>

<pre><span id="TYPEabi_constructor"><span class="keyword">type</span> <code class="type"></code>abi_constructor</span> = <code class="type">?image:<a href="Bap.Std.html#TYPEimage">image</a> -><br>       ?sym:string -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEblock">block</a> -> <a href="Bap.Std.abi-c.html">abi</a></code> </pre>
<div class="info ">
symbol name may be provided if known. Also an access
      to the whole binary image is provided if there is one.<br>
</div>

<br>
A BIL model of CPU
<p>

      In general this is a model of a processor architecture, involving
      ALU, processing unit, registers and memory.<br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.CPU.html">CPU</a> = <code class="code">sig</code> <a href="Bap.Std.CPU.html">..</a> <code class="code">end</code></pre><div class="info">
Abstract interface to CPU
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.ABI.html">ABI</a> = <code class="code">sig</code> <a href="Bap.Std.ABI.html">..</a> <code class="code">end</code></pre><div class="info">
Application Binary Interface
</div>

<pre><span id="TYPEjump"><span class="keyword">type</span> <code class="type"></code>jump</span> = <code class="type">[ `Cond | `Jump ]</code> </pre>
<div class="info ">
a jump kind.
      A jump to another block can be conditional or unconditional.
<p>
This type defines a relation between two basic blocks.<br>
</div>


<pre><span id="TYPEedge"><span class="keyword">type</span> <code class="type"></code>edge</span> = <code class="type">[ `Cond | `Fall | `Jump ]</code> </pre>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_accessors.html">Block_accessors</a> = <code class="code">sig</code> <a href="Bap.Std.Block_accessors.html">..</a> <code class="code">end</code></pre><div class="info">
Access to block attributes.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_traverse.html">Block_traverse</a> = <code class="code">sig</code> <a href="Bap.Std.Block_traverse.html">..</a> <code class="code">end</code></pre><div class="info">
Navigate to neighborhood blocks.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm_expert.html">Disasm_expert</a>: <code class="code">sig</code> <a href="Bap.Std.Disasm_expert.html">..</a> <code class="code">end</code></pre><div class="info">
Expert interface to disassembler.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Insn.html">Insn</a>: <code class="code">sig</code> <a href="Bap.Std.Insn.html">..</a> <code class="code">end</code></pre><div class="info">
Assembly instruction.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Block.html">Block</a>: <code class="code">sig</code> <a href="Bap.Std.Block.html">..</a> <code class="code">end</code></pre><div class="info">
Basic block of machine instructions.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Target.html">Target</a> = <code class="code">sig</code> <a href="Bap.Std.Target.html">..</a> <code class="code">end</code></pre><div class="info">
Abstract interface for all targets.
</div>

<pre><span id="VALtarget_of_arch"><span class="keyword">val</span> target_of_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> (module Bap.Std.Target)</code></pre><div class="info ">
<code class="code">target_of_arch arch</code> creates a module for the given <code class="code">arch</code>, if
      <code class="code">arch</code> is not lifted, the stub module is returned.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.ARM.html">ARM</a>: <code class="code">sig</code> <a href="Bap.Std.ARM.html">..</a> <code class="code">end</code></pre><div class="info">
ARM architecture.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.IA32.html">IA32</a>: <code class="code">sig</code> <a href="Bap.Std.IA32.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">x86</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.AMD64.html">AMD64</a>: <code class="code">sig</code> <a href="Bap.Std.AMD64.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">x86-64</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Symtab.html">Symtab</a>: <code class="code">sig</code> <a href="Bap.Std.Symtab.html">..</a> <code class="code">end</code></pre><div class="info">
<span class="deprecated"></span></div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Project.html">Project</a>: <code class="code">sig</code> <a href="Bap.Std.Project.html">..</a> <code class="code">end</code></pre><div class="info">
Target of analysis.
</div>

<pre><span id="TYPEproject"><span class="keyword">type</span> <code class="type"></code>project</span> = <code class="type"><a href="Bap.Std.Project.html#TYPEt">Project.t</a></code> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Dwarf.html">Dwarf</a>: <code class="code">sig</code> <a href="Bap.Std.Dwarf.html">..</a> <code class="code">end</code></pre><div class="info">
Dwarf library
      This library gives an access to debugging information stored
      in a binary program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Signatures.html">Signatures</a>: <code class="code">sig</code> <a href="Bap.Std.Signatures.html">..</a> <code class="code">end</code></pre><div class="info">
Binary signatures storage
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Byteweight.html">Byteweight</a>: <code class="code">sig</code> <a href="Bap.Std.Byteweight.html">..</a> <code class="code">end</code></pre><div class="info">
Byteweight Algorithm implementation
</div>
</body></html>