<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Ogre.Type.html">
<link rel="next" href="Ogre.Doc.html">
<link rel="Up" href="Ogre.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Ogre.Query</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Ogre.Type.html" title="Ogre.Type">Previous</a>
&nbsp;<a class="up" href="Ogre.html" title="Ogre">Up</a>
&nbsp;<a class="post" href="Ogre.Doc.html" title="Ogre.Doc">Next</a>
</div>
<h1>Module <a href="type_Ogre.Query.html">Ogre.Query</a></h1>

<pre><span class="keyword">module</span> Query: <code class="code"><span class="keyword">sig</span></code> <a href="Ogre.Query.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Domain specific language for constructing queries.
<p>

    Currently only a select query is supported.
<p>

    Currently, the expression language permits construction arithmetic
    and logical expressions on the base types (int, float, str and
    bool).<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">'a <a href="Ogre.html#TYPEquery">Ogre.query</a></code> </pre>


<pre><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> </pre>
<div class="info ">
logical expression language, defined as
      <pre class="verbatim">      exp ::= str `string`
            | int `int64`
            | float `float`
            | bool `bool`
            | `'a attribute`.(`'b field`)
            | `'b field`.[`int`]
            | exp &lt;bop&gt; exp
            | &lt;uop&gt; exp

      bop ::=  &lt;aop&gt; | &lt;lop&gt; | &lt;cop&gt;
      uop ::=  not
      aop ::= + | -
      lop ::= || | &amp;&amp; | ==&gt;
      cop ::= &lt; | &gt; | = | &lt;&gt; | &lt;= | &gt;=
     </pre>
<p>

      In the grammar above, the names delimited with backticks represent
      types of OCaml values, that should be passed at these syntactic
      locations (sort of an unquoting), for example, <code class="code">str&nbsp;<span class="string">"hello"</span></code> is
      an expression, as well as <code class="code">student.(gpa)</code> assuming that
      <code class="code">student</code> is a value of type <code class="code"><span class="keywordsign">'</span>a&nbsp;attribute</code> and <code class="code">gpa</code> is a field
      of type <code class="code"><span class="keywordsign">'</span>b&nbsp;field</code>.
<p>

      Not all expressions are well-formed, as they also must obey to
      the typing rules. The typing rules are simple (informally):
<p>

      0. <code class="code">x&nbsp;&lt;bop&gt;&nbsp;y</code> is wff if <code class="code">x</code> and <code class="code">y</code> are of the same type;
      1. <code class="code">x.(y)</code> is wff if <code class="code">y</code> is a field of attribute <code class="code">x</code>;
      2. <code class="code">x&nbsp;&lt;aop&gt;&nbsp;y</code> is wff if <code class="code">x</code> and <code class="code">y</code> are float or int;
      3. <code class="code">not&nbsp;x</code> is wff if <code class="code">x</code> is bool
      4. <code class="code">x&nbsp;&lt;lop&gt;&nbsp;y</code> is wff if <code class="code">x</code> and <code class="code">y</code> are bool
      5. <code class="code">x&nbsp;&lt;cop&gt;&nbsp;y</code> has type bool.<br>
</div>


<pre><span id="TYPEjoin"><span class="keyword">type</span> <code class="type"></code>join</span> </pre>
<div class="info ">
join statement.
<p>

      The <code class="code">join</code> statement is a list of equality classes. Each
      equality class defines a query constraint, requiring all
      elements of the class to be equal. The elements of the class are
      field variables, constructed with the <code class="code">field</code> function. There
      are two kinds of the field variables:
<p>
<ul>
<li>A fully qualified field variable, defined with the expression
        <code class="code">field&nbsp;y&nbsp;~from:x</code>.</li>
</ul>
<ul>
<li>An unqualified field variable, defined as <code class="code">field&nbsp;y</code>.</li>
</ul>

      A fully qualified variable matches only with the corresponding
      field expression, e.g., an equality class
<p>

      <code class="code">[field&nbsp;teacher&nbsp;~from:student;&nbsp;field&nbsp;id&nbsp;~from:teacher]</code>
<p>

      emposes a constraint <code class="code">student.(teacher)&nbsp;=&nbsp;teacher.(id)</code>, and is
      roughly equivalent to the SQL's
<p>

      <code class="code"><span class="constructor">INNER</span>&nbsp;<span class="constructor">JOIN</span>&nbsp;teacher&nbsp;<span class="constructor">ON</span>&nbsp;student.id&nbsp;=&nbsp;teacher.id</code>
<p>

      Note:  it is OK to use <code class="code">where</code> clause instead of the <code class="code">join</code>
      clause to join attributes, if it makes the query more
      readable. There is no performance penalty.
<p>

      The unqualified variable matches with the same fields ignoring
      the attribute name, for example, an equality class <code class="code">field<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classid</code>, will impose an equality constraint on values from all
      <code class="code">classid</code> fields of the selected attributes. Given a concrete
      select query:
<p>

      <pre class="codepre"><code class="code">select (from student $teacher) ~join:[[field classid]]</code></pre>
<p>

      a constraint <code class="code">student.(classid)&nbsp;=&nbsp;teacher.(classid)</code> is
      constructed. Another way to construct the same selection is:
<p>

      <pre class="codepre"><code class="code">select (from student $teacher)
          ~where:student.(classid) = teacher.(classid)
      </code></pre><br>
</div>


<pre><span id="TYPEtables"><span class="keyword">type</span> <code class="type">'a</code> tables</span> </pre>
<div class="info ">
a selection of attributes.
<p>

      The tables clause can be constructed using the following grammar:
<p>

      <pre class="verbatim">tables ::= from attr | &lt;tables&gt; $ attr</pre>
<p>

      In other words, there are two constructors, a prefix <code class="code">from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr</code>, and an infix <code class="code">attr1&nbsp;$&nbsp;attr2</code>, e.g.,
<p>

      <code class="code">from&nbsp;students&nbsp;$&nbsp;teachers&nbsp;$&nbsp;classes</code><br>
</div>


<pre><span id="VALselect"><span class="keyword">val</span> select</span> : <code class="type">?where:<a href="Ogre.Query.html#TYPEexp">exp</a> -><br>       ?join:<a href="Ogre.Query.html#TYPEjoin">join</a> list list -> 'a <a href="Ogre.Query.html#TYPEtables">tables</a> -> 'a <a href="Ogre.Query.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">select&nbsp;~where&nbsp;~join&nbsp;(from&nbsp;t1&nbsp;t2&nbsp;...&nbsp;tm)</code> selects attributes
      <code class="code">t1</code>, <code class="code">t2</code>, ..., <code class="code">tm</code>, join them by the fields specified in the
      <code class="code">join</code> clause, and filters those that satisfy the condition
      defined with the <code class="code">where</code> clause.
<p>

      Examples:
<p>

      Select all students that has the GPA rate greater than 3.8.
      <pre class="codepre"><code class="code">        select
          ~where:(student.(gpa) &gt; float 3.8)
          (from students)
      </code></pre>
<p>

      Select all students and their corresponding teachers, that have
      a GPA greater than 3.8 (assuming that teacher is a foreign key
      to the table of teachers).
      <pre class="codepre"><code class="code">        select
          ~where:(student.(gpa) &gt; float 3.8)
          ~join:[[field teacher ~from:student; field id ~from:teacher]]
          (from students)
      </code></pre>
<p>

      You may notice, that the <code class="code">select</code> query lacks the SQL's <code class="code"><span class="constructor">WHAT</span></code>
      clause, i.e., it is not possible or needed to specify columns. The
      reason for this, is that the query used as a value that is
      passed to some command constructor, (e.g.,<code class="code">foreach</code>), that can
      work with fields individually, e.g., the following is a complete
      correspondance of the SQL's:
<p>

      <pre class="verbatim">SELECT name FROM students WHERE gpa &gt; 3.5</pre>
<p>

      <pre class="codepre"><code class="code">        foreach <span class="constructor">Query</span>.(select
                         ~where:(student.(gpa) &gt; float 3.8)
                         (from students))
          ~f:(<span class="keyword">fun</span> s <span class="keywordsign">-&gt;</span> return (<span class="constructor">Student</span>.name s))
      </code></pre>
<p>

      It is nearly three times as long, but in return it is type-safe,
      and composable.<br>
</div>

<pre><span id="VALfrom"><span class="keyword">val</span> from</span> : <code class="type">('a, 'b -> 'c) <a href="Ogre.html#TYPEattribute">Ogre.attribute</a> -> (('a -> 'r) -> 'r) <a href="Ogre.Query.html#TYPEtables">tables</a></code></pre><div class="info ">
<code class="code">from&nbsp;attr</code> adds an attribute <code class="code">attr</code> to the query. An attribute
      can be referenced in the query if it occurs in the from
      clause. Otherwise the query is not well-formed.<br>
</div>

<pre><span id="VAL($)"><span class="keyword">val</span> ($)</span> : <code class="type">('a -> 'b -> 'r) <a href="Ogre.Query.html#TYPEtables">tables</a> -><br>       ('b, 'c -> 'd) <a href="Ogre.html#TYPEattribute">Ogre.attribute</a> -> ('a -> 'r) <a href="Ogre.Query.html#TYPEtables">tables</a></code></pre><div class="info ">
<code class="code">attrs&nbsp;$&nbsp;attr</code> appends an attribute <code class="code">attr</code> to the sequence of
      chosen attributes <code class="code">attrs</code>.<br>
</div>

<pre><span id="VALfield"><span class="keyword">val</span> field</span> : <code class="type">?from:('a, 'b -> 'c) <a href="Ogre.html#TYPEattribute">Ogre.attribute</a> -> 'd <a href="Ogre.html#TYPEfield">Ogre.field</a> -> <a href="Ogre.Query.html#TYPEjoin">join</a></code></pre><div class="info ">
<code class="code">field&nbsp;name</code> creates an unqualified join variable.
      <code class="code">field&nbsp;name&nbsp;~from:attr</code> creates a qualified join variable.
<p>

      See the <a href="Ogre.Query.html#TYPEjoin"><code class="code"><span class="constructor">Ogre</span>.<span class="constructor">Query</span>.join</code></a> type description, for the explanation of the
      <code class="code">join</code> expressions and joining.<br>
</div>

<pre><span class="keyword">module</span> <a href="Ogre.Query.Array.html">Array</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Ogre.Query.Array.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Defines a subscripting syntax for creating field variables.
</div>

<pre><span class="keyword">module</span> <a href="Ogre.Query.String.html">String</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Ogre.Query.String.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Defines field subscripting syntax.
</div>

<pre><span id="VALstr"><span class="keyword">val</span> str</span> : <code class="type">string -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">str&nbsp;x</code> creates a string constant.<br>
</div>

<pre><span id="VALint"><span class="keyword">val</span> int</span> : <code class="type">int64 -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">int&nbsp;x</code> creates an integer constant<br>
</div>

<pre><span id="VALbool"><span class="keyword">val</span> bool</span> : <code class="type">bool -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">bool&nbsp;x</code> creates a logic constant<br>
</div>

<pre><span id="VALfloat"><span class="keyword">val</span> float</span> : <code class="type">float -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">float&nbsp;x</code> creates a real number constant.<br>
</div>

<pre><span id="VAL(&&)"><span class="keyword">val</span> (&amp;&amp;)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;y</code> conjunction<br>
</div>

<pre><span id="VAL(||)"><span class="keyword">val</span> (||)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;<span class="keywordsign">||</span>&nbsp;y</code> disjunction<br>
</div>

<pre><span id="VAL(==>)"><span class="keyword">val</span> (==&gt;)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;==&gt;&nbsp;y</code> implication.
<p>

      Be aware that the precedence of OCaml operator ==&gt; is higher than
      a common precedence of the implication operator in mathematics.
<p>

      That means, that an expression <code class="code">x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;y&nbsp;==&gt;&nbsp;x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;z</code> is parsed as
      <code class="code">x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;(y&nbsp;==&gt;&nbsp;x)&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;z</code>.
<p>

      The rule of the thumb is to always put parenthesis in an
      expression, that has an implication, as even if you're aware of
      the precedence issue, it is not known to a reader of your code,
      whether you were aware, or wrote this code by a mistake.<br>
</div>

<pre><span id="VALnot"><span class="keyword">val</span> not</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">not&nbsp;x</code> logical negation.<br>
</div>

<pre><span id="VAL(<)"><span class="keyword">val</span> (&lt;)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;&lt;&nbsp;y</code> less than<br>
</div>

<pre><span id="VAL(>)"><span class="keyword">val</span> (&gt;)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;&gt;&nbsp;y</code> greater than<br>
</div>

<pre><span id="VAL(=)"><span class="keyword">val</span> (=)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;=&nbsp;y</code> equality<br>
</div>

<pre><span id="VAL(<>)"><span class="keyword">val</span> (&lt;&gt;)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;&lt;&gt;&nbsp;y</code> nonequality<br>
</div>

<pre><span id="VAL(<=)"><span class="keyword">val</span> (&lt;=)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;&lt;=&nbsp;y</code> less than or equal<br>
</div>

<pre><span id="VAL(>=)"><span class="keyword">val</span> (&gt;=)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;&gt;=&nbsp;y</code> greater or equal<br>
</div>

<pre><span id="VAL(+)"><span class="keyword">val</span> (+)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;+&nbsp;y</code> summation<br>
</div>

<pre><span id="VAL(-)"><span class="keyword">val</span> (-)</span> : <code class="type"><a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a> -> <a href="Ogre.Query.html#TYPEexp">exp</a></code></pre><div class="info ">
<code class="code">x&nbsp;-&nbsp;y</code> subtracting<br>
</div>
</body></html>