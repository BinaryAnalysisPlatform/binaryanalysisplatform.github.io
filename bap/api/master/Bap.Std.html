<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Bap.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html"><link title="Binary Analysis Platform Library" rel="Section" href="#1_BinaryAnalysisPlatformLibrary">
<link title="BAP API" rel="Section" href="#api">
<link title="Overview" rel="Subsection" href="#2_Overview">
<link title="Foundation Library" rel="Subsection" href="#bfl">
<link title="Memory model" rel="Subsection" href="#image">
<link title="Disassembler" rel="Subsection" href="#disasm">
<link title="Semantic Analysis" rel="Subsection" href="#sema">
<link title="Writing Program Analysis Plugins" rel="Subsection" href="#project">
<link title="Auxiliary libraries" rel="Subsection" href="#aux">
<title>Bap.Std</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Bap.html" title="Bap">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Bap.Std.html">Bap.Std</a></h1>

<pre><span class="keyword">module</span> Std: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><hr width="100%">
<br>
<h1 id="1_BinaryAnalysisPlatformLibrary">Binary Analysis Platform Library</h1><br>
<br>
<h2 id="2_Overview">Overview</h2>
<p>

      BAP has a layered architecture currently consisting of four
      layers:
<p>

      <pre class="verbatim">        +-----------------------------------------+
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |       Foundation Library          |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        |                                         |
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |          Memory Model             |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        |                                         |
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |           Disassembly             |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        |                                         |
        |  +-----------------------------------+  |
        |  |                                   |  |
        |  |        Semantic Analysis          |  |
        |  |                                   |  |
        |  +-----------------------------------+  |
        +-----------------------------------------+
     </pre>
<p>

      The <a href="Bap.Std.html#bfl">Foundation library</a> defines core types that are used
      throughout the BAP library for binary analysis. The
      <a href="Bap.Std.html#image">Memory model</a> layer is responsible for loading
      and parsing binary objects and representing them in memory. It
      also defines a few useful data structures that are used
      extensively by later layers. The next layer performs
      <a href="Bap.Std.html#disasm">disassembly</a> and lifting to BIL. Finally,
      the <a href="Bap.Std.html#sema">semantic analysis</a> layer transforms a
      binary into an IR representation, and further provides a set of
      handful analysis tools.
<p>

      Another important point of view is the BAP plugin architecture,
      similar to that of GIMP or Frama-C. BAP features a pluggable
      architecture with a number of extension points. For example,
      even the LLVM disassembler is considered a type of plugin.
      Currently we support three such extension points in BAP:
<p>
<ul>
<li><a href="Bap.Std.Backend.html">loaders</a> - to add new binary object loaders;</li>
<li>disassemblers - to add new disassemblers;</li>
<li><a href="Bap.Std.Project.html">program analysis</a> - to analyze programs.</li>
</ul>

      The latter category of plugins is most widely used. Therefore,
      when we use the term "plugin" without making a distinction, we
      refer to a program analysis plugin. The following figure
      provides an overview of the BAP system.
<p>

      <pre class="verbatim">        +---------------------------------------------+
        |  +----------------+    +-----------------+  |
        |  |    Loader      |    |  Disassembler   |  |
        |  |    Plugins     |    |    Plugins      |  |
        |  +-------+--------+    +--------+--------+  |
        |          |                      |           |
        |  +-------+----------------------+--------+  |
        |  |                                       |  |
        |  |             BAP Library               |  |
        |  |                                       |  |
        |  +-------+-------------------------------+  |
        |          ^                      ^           |
        |          |                      |           |
        |  +-------+--------+    +--------+--------+  |
        |  |                |    |                 |  |
        |  |  BAP toolkit   |&lt;--&gt;|   BAP Plugins   |  |
        |  |                |    |                 |  |
        |  +----------------+    +-----------------+  |
        +---------------------------------------------+
     </pre>
<p>

      All plugins have full access to the library; an important
      consequence is that they can and should open <code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span></code>. The BAP
      library uses backend loader and disassembler plugins to provide
      its services. Program analysis plugins are loaded by BAP
      toolkit utilities. These utilities extend plugin functionality
      by providing access to the state of the target of analysis or,
      in our parlance, to the <a href="Bap.Std.html#TYPEproject">project</a>. (See
      <a href="Bap.Std.html#project"><i>Writing Program Analysis Plugins</i></a>).
<p>

      Other than library itself, and the BAP toolkit, there are two
      additional libraries that are bundled with BAP:
<p>
<ul>
<li><code class="code">bap.plugins</code> to dynamically load code into BAP;</li>
<li><code class="code">bap.serialization</code> to serialize BAP data structures in
        different formats.</li>
</ul>
<br>
<br>
<h2 id="bfl">Foundation Library</h2>
<p>

      At this layer we define the core types that are tightly
      integrated with Binary Intermediate Language (<a href="Bap.Std.Bil.html">BIL</a>). The
      core types are:
<p>
<ul>
<li><a href="Bap.Std.Arch.html">arch</a> - to denote computer architecture;</li>
<li><a href="Bap.Std.Size.html">size</a> - to specify sizes of wors or addresses;</li>
<li><a href="Bap.Std.Var.html">var</a>  - BIL variable;</li>
<li><a href="Bap.Std.Type.html">typ</a> - OCaml type for BIL type;</li>
<li><a href="Bap.Std.Exp.html">exp</a>  - BIL expression;</li>
<li><a href="Bap.Std.Stmt.html">stmt</a> - BIL statement;</li>
<li><a href="Bap.Std.Bitvector.html">word,addr</a> - a bitvector data structure
        to represent immediate data;</li>
<li><a href="Bap.Std.Value.html">'a tag</a> and <a href="Bap.Std.Value.html">value</a> - an extensible variant type,
        aka existential, aka type <code class="code">any</code>;</li>
<li><a href="Bap.Std.Seq.html">'a seq</a> - slightly extended Core <code class="code"><span class="constructor">Sequence</span></code>, aka lazy
        list.</li>
</ul>

      Every type implements the <a href="Bap.Std.Regular.html">Regular</a> interface. This
      interface is very similar to Core's <code class="code"><span class="constructor">Identifiable</span></code>, and is
      supposed to represent a type that is as common as a built-in
      type. One should expect to find any function that is
      implemented for such types as <code class="code">int</code>, <code class="code">string</code>, <code class="code">char</code>, etc.
      Namely, this interface includes:
<p>
<ul>
<li>comparison functions: (<code class="code">&lt;, &gt;, &lt;= , &gt;= , compare, between, ...</code>);</li>
<li>each type defines a polymorphic <code class="code"><span class="constructor">Map</span></code> with keys of type <code class="code">t</code>;</li>
<li>each type provides a <code class="code"><span class="constructor">Set</span></code> with values of type <code class="code">t</code>;</li>
<li>hashtable is exposed via <code class="code"><span class="constructor">Table</span></code> module;</li>
<li>hashset is available under <code class="code"><span class="constructor">Hash_set</span></code> name</li>
<li>sexpable and binable interface;</li>
<li><code class="code">to_string</code>, <code class="code">str</code>, <code class="code">pp</code>, <code class="code">ppo</code>, <code class="code">pps</code> functions
      for pretty-printing.</li>
</ul>

      Most types usually provide much more. For each type, there is a
      module with the same name that implements its interface. For
      example, type <code class="code">exp</code> is indeed a type abbreviation for <code class="code"><span class="constructor">Exp</span>.t</code>,
      and module <code class="code"><span class="constructor">Exp</span></code> contains all functions and types related to
      type <code class="code">exp</code>. For example, to create a hashtable of statements,
      just type:
<p>

      <code class="code"><span class="keyword">let</span> table = <span class="constructor">Stmt</span>.<span class="constructor">Table</span>.create ()</code>
<p>

      If a type is a variant type (i.e., defines constructors) then for
      each constructor named <code class="code"><span class="constructor">Name</span></code>, there exists a corresponding
      function named <code class="code">name</code> that will accept the same number of
      arguments as the arity of the constructor. For example, a
      <code class="code"><span class="constructor">Bil</span>.<span class="constructor">Int</span></code> can be constructed with the <code class="code"><span class="constructor">Bil</span>.int</code> function that
      has type <code class="code">word <span class="keywordsign">-&gt;</span> exp</code>. If a constructor has several arguments
      of the same type we usually disambiguate them with keywords,
      e.g., <code class="code"><span class="constructor">Bil</span>.<span class="constructor">Load</span> <span class="keyword">of</span> (exp,exp,endian,size)</code> has function
      <a href="Bap.Std.Bil.html#VALload">Bil.load</a> with type:
      <code class="code">mem:exp <span class="keywordsign">-&gt;</span> addr:exp <span class="keywordsign">-&gt;</span> endian <span class="keywordsign">-&gt;</span> size <span class="keywordsign">-&gt;</span> exp</code>
<p>

      <h3 id="tries">Tries</h3>
<p>

      The Foundation library also defines a prefix tree data
      structure that proves useful for binary analysis applications.
      <a href="Bap.Std.Trie.html">Trie</a>s in BAP is a functor that derives a
      polymorphic trie data structure for a given
      <a href="Bap.Std.Trie.Key.html">Key</a>.
<p>

      For convenience we support instantiating tries for most of
      our data structures. For example, <a href="Bap.Std.Bitvector.html">Word</a> has several
      <a href="Bap.Std.Bitvector.Trie.html">tries</a> inside.
<p>

      For common strings, there's <a href="Bap.Std.Trie.String.html"><code class="code"><span class="constructor">Trie</span>.<span class="constructor">String</span></code></a>.<br>
<br>
<h2 id="image">Memory model</h2>
<p>

      This layer provides everything you need to work with binary
      objects:
<p>
<ul>
<li><a href="Bap.Std.Memory.html">mem</a> - a contiguous array of bytes, indexed with
       absolute addresses;</li>
</ul>
<ul>
<li><a href="Bap.Std.Table.html"> 'a table</a> - a mapping from a memory regions to
       arbitrary data (no duplicates or intersections);</li>
</ul>
<ul>
<li><a href="Bap.Std.Memmap.html">a memmap</a> - a mapping from memory region to
        arbitrary data with duplicates and intersections allowed, aka
        segment tree or interval map;</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html">image</a> - represents a binary object with all its
       symbols, sections and other meta information.</li>
</ul>

      The <code class="code"><span class="constructor">Image</span></code> module uses the plugin system to load binary
      objects. In order to add new loader, one should implement the
      <a href="Bap.Std.Backend.html">Backend.t</a> loader function and register it with the
      <a href="Bap.Std.Image.html#VALregister_backend">Image.register_backend</a> function.<br>
<br>
<h2 id="disasm">Disassembler</h2>
<p>

      This layer consists of disassemblers and lifters. They are
      tightly integrated, but in general we can disassemble all
      supported <a href="Bap.Std.Arch.html#TYPEt">architectures</a>. Currently we lift only arm,
      x86 and x86_64.
<p>

      There are two interfaces to disassemblers:
<p>
<ul>
<li><a href="Bap.Std.Disasm.html">Disasm</a> - a regular interface that hides all
       complexities, but may not always be very flexible.</li>
<li><a href="Bap.Std.Disasm_expert.html">Disasm_expert</a> - an expert interface that
      provides access to a low-level representation. It is very
      flexible and fast, but harder to use.</li>
</ul>

      To disassemble files or data with the regular interface, use
      one of the following functions:
<p>
<ul>
<li><a href="Bap.Std.html#VALdisassemble">disassemble</a> - to disassemble a region of
        memory;</li>
<li><a href="Bap.Std.html#VALdisassemble_image">disassemble_image</a> - to disassemble a
        loaded binary object;</li>
<li><a href="Bap.Std.html#VALdisassemble_file">disassemble_file</a> or
        <a href="Bap.Std.html#VALdisassemble_file_exn">disassemble_file</a> - to disassemble
        file.</li>
</ul>

      All these functions perform disassembly by recursive descent,
      reconstruct the control flow graph, and perform lifting. The
      result of disassembly is represented by the abstract value of
      type <a href="Bap.Std.Disasm.html">disasm</a>. Two main data structures that are used
      to represent disassembled program are:
<p>
<ul>
<li><a href="Bap.Std.Insn.html">insn</a> - a machine instruction;</li>
<li><a href="Bap.Std.Block.html">block</a> - a basic block, i.e., a linear sequence of
        instructions.</li>
</ul>

      The following figure shows the relationship between basic data
      structures of the disassembled program.
<p>

      <pre class="verbatim">        +-----------------+
        | +-------------+ |
        | |   disasm    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |    block    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     insn    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     stmt    | |
        | +-------------+ |
        +-----------------+
     </pre>
<p>

      A disassembled program is represented as a set of
      interconnected <a href="Bap.Std.Block.html">basic blocks</a>. You can navigate between
      blocks using <a href="Bap.Std.Block_traverse.html#VALsuccs">Block.succs</a> and
      <a href="Bap.Std.Block_traverse.html#VALpreds">Block.preds</a> functions, or you can
      transform a set of blocks into a real <a href="Bap.Std.Block.Cfg.html">graph</a> using
      the <a href="Bap.Std.Block.html#VALto_graph">Block.to_graph</a> function. Sometimes it
      is enough to traverse program using
      <a href="Bap.Std.Block.html#VALdfs">depth-first search</a>.
<p>

      Each block is a container to a sequence of machine
      instructions. It is guaranteed that there's at least one
      instruction in the block, thus the
      <a href="Bap.Std.Block_accessors.html#VALleader">Block.leader</a> and
      <a href="Bap.Std.Block_accessors.html#VALterminator">Block.terminator</a> functions are
      total.
<p>

      Each <a href="Bap.Std.Insn.html">machine instruction</a> is represented by its
      <code class="code">opcode</code>, <code class="code">name</code> and <code class="code">array</code> of operands (these are machine and
      disassembler specific), a set of predicates (describing
      instruction semantics on a very high level), and a sequence of
      <a href="Bap.Std.Bil.html">BIL</a> statements that precisely define the semantics of
      the instruction.
<p>

      Modules of type <a href="Bap.Std.CPU.html">CPU</a> provide a high level abstraction of
      the CPU and allow one to reason about instruction semantics
      independently from the target platform. Modules of type
      <a href="Bap.Std.ABI.html">ABI</a> provide even more information, e.g., it maps
      registers to formals. The module type <a href="Bap.Std.Target.html">Target</a> brings
      <code class="code"><span class="constructor">CPU</span></code> and <code class="code"><span class="constructor">ABI</span></code> together. To get an instance of this module,
      you can use the <a href="Bap.Std.html#VALtarget_of_arch">target_of_arch</a> function. For
      accessing all information about target platform, use the
      following modules that expose low-level and platform-specific
      details:
<p>
<ul>
<li><a href="Bap.Std.ARM.html">ARM</a></li>
<li><a href="Bap.Std.IA32.html">IA32</a></li>
<li><a href="Bap.Std.AMD64.html">AMD64</a></li>
</ul>

      If you do not need cfg reconstruction, you can use
      <a href="Bap.Std.html#VALlinear_sweep">linear_sweep</a> function to disassemble a given
      memory region. If you need more granularity, then you can use
      the expert interface accordingly:
<p>
<ul>
<li><a href="Bap.Std.Disasm_expert.Basic.html">Basic</a> - provides access to a low-level
        disassembler on top of which all other disassemblers are
        built;</li>
<li><a href="Bap.Std.Disasm_expert.Recursive.html">Recursive</a> - an interface to a
        recursive descent algorithm.</li>
</ul>
<br>
<br>
<h2 id="sema">Semantic Analysis</h2>
<p>

      On semantic level the disassembled program is lifted into the
      intermediate representation (IR) suitable for writing analysis.
<p>

      IR is closely related to BIL. In fact it even reuses expression
      sub-language of BIL. But unlike BIL, IR is flat, (i.e., it
      doesn't contain recursive statements), and unstructured (no
      <code class="code"><span class="keyword">while</span></code>, <code class="code"><span class="keyword">if</span></code>, only jumps). Thus IR is much more low-level, so
      it is harder to read, but easier to analyze programmatically.
<p>

      The program in IR is build of terms. In fact the program itself
      is also a term. There're only 7 kinds of terms:
<p>
<ul>
<li><a href="Bap.Std.Program.html">program</a> - the program in whole;</li>
<li><a href="Bap.Std.Sub.html">sub</a> - subroutine;</li>
<li><a href="Bap.Std.Arg.html">arg</a> - subroutine argument;</li>
<li><a href="Bap.Std.Blk.html">blk</a> - basic block;</li>
<li><a href="Bap.Std.Def.html">def</a> - definition of a variable;</li>
<li><a href="Bap.Std.Phi.html">phi</a> - phi-node in the SSA form;</li>
<li><a href="Bap.Std.Jmp.html">jmp</a> - a transfer of control.</li>
</ul>

      Unlike expressions and statements in BIL, IR's terms are
      <em>concrete entities</em>.  Concrete entity is such entity that can
      change in time and space, as well as come in and out of
      existence.  Contrary, <em>abstract entity</em> is eternal and
      unchangeable.  <em>Identity</em> denotes the sameness of a concrete
      entity as it changes in time.  Abstract entities don't have an
      identity since they are immutable.  Program is built of concrete
      entities called terms.  Terms have <em>attributes</em> that can change in
      time, without affecting the identity of a term.  Attributes are
      abstract entities.  In each particular point of space and time a
      term is represented by a snapshot of all its attributes,
      colloquially called <em>value</em>.  Functions that change the value of a
      term in fact returns a new value with different set of
      attributes.  For example, <code class="code">def</code> term has two attributes: left
      hand side (lhs), that associates definition with abstract
      variable, and right hand side (rhs) that associates <code class="code">def</code> with
      an abstract expression. Suppose, that the definition was:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="keyword">let</span>&nbsp;d_1&nbsp;=&nbsp;<span class="constructor">Def</span>.create&nbsp;x&nbsp;<span class="constructor">Bil</span>.(var&nbsp;y&nbsp;+&nbsp;var&nbsp;z);;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;d_1&nbsp;:&nbsp;<span class="constructor">Def</span>.t&nbsp;=&nbsp;00000001:&nbsp;x&nbsp;:=&nbsp;y&nbsp;+&nbsp;z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      To change the right hand side of a definition we use
      <code class="code"><span class="constructor">Def</span>.with_rhs</code> that returns the <em>same</em> definition but with
      <em>different</em> value:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="keyword">let</span>&nbsp;d_2&nbsp;=&nbsp;<span class="constructor">Def</span>.with_rhs&nbsp;d_1&nbsp;<span class="constructor">Bil</span>.(int&nbsp;<span class="constructor">Word</span>.b1);;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;d_2&nbsp;:&nbsp;<span class="constructor">Def</span>.t&nbsp;=&nbsp;00000001:&nbsp;x&nbsp;:=&nbsp;<span class="keyword">true</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      <code class="code">d_1</code> and <code class="code">d_2</code> is different values
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="constructor">Def</span>.equal&nbsp;d_1&nbsp;d_2;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:&nbsp;bool&nbsp;=&nbsp;<span class="keyword">false</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>  of the same term <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="constructor">Term</span>.same&nbsp;d_1&nbsp;d_2;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:&nbsp;bool&nbsp;=&nbsp;<span class="keyword">true</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      The identity of this terms is denoted by the term identifier
      (<code class="code">tid</code>). In the textual representation term identifiers are
      printed as ordinal numbers.
<p>

      Terms, can contain other terms. But unlike BIL expressions or
      statements, this relation is not truly recursive, since the
      structure of program term is fixed: <code class="code">arg</code>, <code class="code">phi</code>, <code class="code">def</code>, <code class="code">jmp</code>
      are leaf terms; <code class="code">sub</code> can only contain <code class="code">arg</code>'s or <code class="code">blk</code>'s; <code class="code">blk</code>
      consists of <code class="code">phi</code>, <code class="code">def</code> and <code class="code">jmp</code> sequences of terms, as
      pictured in the figure below.  Although, the term structure is
      closed to changes, you still can extend particular term with
      attributes, using <code class="code">set_attr</code> and <code class="code">get_attr</code> functions of the
      <a href="Bap.Std.Term.html">Term</a> module. This functions are using <a href="Bap.Std.Value.html">extensible
      variant</a> type to encode attributes.
<p>

      <pre class="verbatim">        +--------------------------------------------------------+
        |                +-------------------+                   |
        |                |      program      |                   |
        |                +---------+---------+                   |
        |                          |*                            |
        |                +---------+---------+                   |
        |                |        sub        |                   |
        |                +---------+---------+                   |
        |                          |                             |
        |        +-----------------+---------------+             |
        |        |*                                |*            |
        |  +-----+-------+                 +-------+-------+     |
        |  |    arg      |                 |      blk      |     |
        |  +-------------+                 +-------+-------+     |
        |                                          |             |
        |           +---------------+--------------+             |
        |           |*              |*             | *           |
        |     +-----+-----+   +-----+-----+   +----+-----+       |
        |     |    phi    |   |    def    |   |   jmp    |       |
        |     +-----------+   +-----------+   +----------+       |
        +--------------------------------------------------------+
     </pre><br>
<br>
<h2 id="project">Writing Program Analysis Plugins</h2>
<p>

      To write a program analysis plugin you need to implement a
      function with one of the following interfaces:
<p>
<ul>
<li><code class="code">project <span class="keywordsign">-&gt;</span> project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_plugin">register_plugin</a>;</li>
<li><code class="code">project <span class="keywordsign">-&gt;</span> unit</code> and register it with
         <a href="Bap.Std.Project.html#VALregister_plugin'">register_plugin'</a>;</li>
<li><code class="code">string array <span class="keywordsign">-&gt;</span> project <span class="keywordsign">-&gt;</span> project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_plugin_with_args">register_plugin_with_args</a>;</li>
<li><code class="code">string array <span class="keywordsign">-&gt;</span> project <span class="keywordsign">-&gt;</span> unit</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_plugin_with_args'">register_plugin_with_args'</a>.</li>
</ul>

      Once loaded from the <code class="code">bap</code> utility (see <code class="code">man bap</code>) this function
      will be invoked with a value of type <a href="Bap.Std.Project.html#TYPEt">project</a> that
      provides access to all information gathered over the binary so
      far. If the registered function returns a non <code class="code">unit</code> type, then it
      can functionally update the project state, e.g., add
      annotations, discover new symbols, make corrections, and even
      change the architecture and re-disassemble everything.
<p>

      <h3 id="3_Exchanginginformation">Exchanging information</h3>
<p>

      For exchanging information in a type safe manner, we use
      <a href="Bap.Std.Value.html">universal values</a>. Values can be attached to a
      particular memory region, or put into the <code class="code">storage</code>
      dictionary. For the first case we use the <a href="Bap.Std.Memmap.html">memmap</a> data
      structure.  It is an interval tree containing all the memory
      regions that are used during analysis. For the <code class="code">storage</code> we use
      <code class="code"><span class="constructor">Dict</span></code> data structure. One can also annotate program by
      attaching attributes to IR terms.
<p>

      <h3 id="3_Predefinedtags">Predefined tags</h3>
<p>

      Depending on the analysis performed and input parameters there
      would be different values in memory maps and storage.
      Here are summary
<p>
<ul>
<li><a href="Bap.Std.Image.html#VALregion">region</a> -- for regions of memory that had a
      particular name in the original binary. For example, in ELF,
      sections have names that annotate a corresponding memory
      region. Of course, this will be available only if the project
      was loaded from some binary container.</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html#VALsection">section</a> -- if the binary data was loaded
      from a binary format that contains sections (aka segments), then
      the corresponding memory regions are be marked. Sections provide
      access to permission information.</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html#VALsymbol">symbol</a> -- for annotating with symbol names.</li>
</ul>
<br>
<br>
<h2 id="aux">Auxiliary libraries</h2>
<p>

      <h3 id="dwarf">DWARF library</h3>
<p>

      The Dwarf library provides an access to DWARF debugging
      information. It implements parsing of some subset of DWARF
      features, and a high-level interface <a href="Bap.Std.Dwarf.Fbi.html">Fbi</a> that
      extracts function symbols from the given DWARF data.
<p>

      <h3 id="sigs">Byteweight</h3>
<p>

      This <a href="Bap.Std.Byteweight.html">library</a> implements a byteweight algorithm
      that identifies functions in stripped binaries, as well as
      being able to train itself on a provided training corpus.<br>
<br>
<h1 id="api">BAP API</h1><br>

<pre><span id="TYPEprinter"><span class="keyword">type</span> <code class="type">'a</code> printer</span> = <code class="type">Format.formatter -> 'a -> unit</code> </pre>
<div class="info ">
<code class="code"><span class="keywordsign">'</span>a printer</code> defines a type for pretty-printers for a value of
      type <code class="code"><span class="keywordsign">'</span>a</code>. This is the type, that is required by <code class="code">%a</code> specifier,
      for <code class="code"><span class="constructor">Format</span>.printf</code>-family of functions. Also, this is the type,
      that can be installed into OCaml toplevel or debugger.
<p>

      Note: `bap.top` library automatically installs all printers.<br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Printable.html">Printable</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Printable.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Printable interface is implemented by a significant amount of
      BAP types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Regular.html">Regular</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Regular.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Regular types models a general concept of value, i.e., something
      that can be used in way similar to regular <code class="code">int</code>, <code class="code">string</code>,
      <code class="code">char</code> and other built in types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Integer.html">Integer</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Integer.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Signature for integral type.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Regular.html">Regular</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Regular.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
In order to implement <code class="code"><span class="constructor">Regular</span></code> interface you need to provide a
      minimum implementation <code class="code"><span class="constructor">M</span></code>
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Trie.html">Trie</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Prefix tries.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Trie.html">Trie</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Constructs a trie
</div>

<pre><span id="TYPEword"><span class="keyword">type</span> <code class="type"></code>word</span> </pre>
<div class="info ">
Type to represent machine word<br>
</div>


<pre><span id="TYPEaddr"><span class="keyword">type</span> <code class="type"></code>addr</span> = <code class="type"><a href="Bap.Std.html#TYPEword">word</a></code> </pre>
<div class="info ">
A synonym for <code class="code">word</code>, that should be used for words
      that are addresses<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Size.html">Size</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Size.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Type safe operand and register sizes.
</div>

<pre><span id="TYPEsize"><span class="keyword">type</span> <code class="type"></code>size</span> = <code class="type"><a href="Bap.Std.Size.html#TYPEt">Size.t</a></code> </pre>
<div class="info ">
size of operand<br>
</div>


<pre><span id="TYPEaddr_size"><span class="keyword">type</span> <code class="type"></code>addr_size</span> = <code class="type">[ `r32 | `r64 ] <a href="Bap.Std.Size.html#TYPEp">Size.p</a></code> </pre>
<div class="info ">
size of address<br>
</div>


<pre><span id="TYPEnat1"><span class="keyword">type</span> <code class="type"></code>nat1</span> = <code class="type">int</code> </pre>
<div class="info ">
just a fancy type abbreviation<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.html">Bitvector</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Bitvector -- a type for representing binary values.
</div>

<pre><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = <code class="type"><a href="Bap.Std.Bitvector.html#TYPEendian">Bitvector.endian</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>

</tr></table>

<div class="info ">
Expose <code class="code">endian</code> constructors to <code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span></code> namespace<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Word.html">Word</a>: <code class="type">module type of Bitvector</code><code class="type"> 
    with type t = word
     and type endian = endian
     and type comparator_witness = Bitvector.comparator_witness</code></pre><div class="info">
Shortcut for bitvectors that represent words
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Addr.html">Addr</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Addr.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Shortcut for bitvectors that represent addresses
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Type.html">Type</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Type.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The type of a BIL expression.
</div>

<pre><span id="TYPEtyp"><span class="keyword">type</span> <code class="type"></code>typ</span> = <code class="type"><a href="Bap.Std.Type.html#TYPEt">Type.t</a></code> </pre>
<div class="info ">
short abbreviation for a type<br>
</div>


<pre><span id="VALbool_t"><span class="keyword">val</span> bool_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
one bit<br>
</div>

<pre><span id="VALreg8_t"><span class="keyword">val</span> reg8_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
8-bit width value<br>
</div>

<pre><span id="VALreg16_t"><span class="keyword">val</span> reg16_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
16-bit width value<br>
</div>

<pre><span id="VALreg32_t"><span class="keyword">val</span> reg32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
32-bit width value<br>
</div>

<pre><span id="VALreg64_t"><span class="keyword">val</span> reg64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
64-bit width value<br>
</div>

<pre><span id="VALreg128_t"><span class="keyword">val</span> reg128_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
128-bit width value<br>
</div>

<pre><span id="VALreg256_t"><span class="keyword">val</span> reg256_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
256-bit width value<br>
</div>

<pre><span id="VALmem32_t"><span class="keyword">val</span> mem32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem32_t size</code> creates a type for memory with <code class="code">32</code>-bit addresses
      and elements of size <code class="code">size</code>.<br>
</div>

<pre><span id="VALmem64_t"><span class="keyword">val</span> mem64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem64_t size</code> creates a type for memory with <code class="code">64</code>-bit addresses
      and elements of size <code class="code">size</code>.<br>
</div>

<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> </pre>
<div class="info ">
bil variable<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Var.html">Var</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Var.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
BIL variable.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.html">Bil</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Main BIL module
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Exp.html">Exp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Exp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Regular</span></code> interface for BIL expressions
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Stmt.html">Stmt</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Stmt.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Regular</span></code> interface for BIL statements
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arch.html">Arch</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Arch.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Architecture
</div>

<pre><span id="TYPEarch"><span class="keyword">type</span> <code class="type"></code>arch</span> = <code class="type"><a href="Bap.Std.Arch.html#TYPEt">Arch.t</a></code> </pre>
<div class="info ">
architecture<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Value.html">Value</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Universal Values.
</div>

<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type">'a</code> tag</span> = <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">Value.tag</a></code> </pre>

<br>
<h3 id="3_Somepredefinedtags">Some predefined tags</h3><br>

<pre><span id="TYPEcolor"><span class="keyword">type</span> <code class="type"></code>color</span> = <code class="type">[ `black | `blue | `cyan | `green | `magenta | `red | `white | `yellow ]</code> </pre>


<pre><span id="VALcolor"><span class="keyword">val</span> color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre>
<pre><span id="VALcomment"><span class="keyword">val</span> comment</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A human readable comment<br>
</div>

<pre><span id="VALpython"><span class="keyword">val</span> python</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A command in python language<br>
</div>

<pre><span id="VALshell"><span class="keyword">val</span> shell</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A command in shell language<br>
</div>

<pre><span id="VALmark"><span class="keyword">val</span> mark</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Mark something as marked<br>
</div>

<pre><span id="VALweight"><span class="keyword">val</span> weight</span> : <code class="type">float <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Give a weight<br>
</div>

<pre><span id="VALtarget_addr"><span class="keyword">val</span> target_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
The real virtual address of a target<br>
</div>

<pre><span id="VALtarget_name"><span class="keyword">val</span> target_name</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Symbolic name of a target<br>
</div>

<pre><span id="VALsubroutine_name"><span class="keyword">val</span> subroutine_name</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Name of a subroutine<br>
</div>

<pre><span id="VALsubroutine_addr"><span class="keyword">val</span> subroutine_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Address of a subroutine entry point<br>
</div>

<pre><span id="VALfilename"><span class="keyword">val</span> filename</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A name of a file<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Dict.html">Dict</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Dict.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Universal Heterogeneous Map.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Seq.html">Seq</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Seq.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Lazy sequence
</div>

<pre><span id="TYPEseq"><span class="keyword">type</span> <code class="type">'a</code> seq</span> = <code class="type">'a <a href="Bap.Std.Seq.html#TYPEt">Seq.t</a></code> </pre>
<div class="info ">
type abbreviation for <code class="code"><span class="keywordsign">'</span>a <span class="constructor">Sequence</span>.t</code><br>
</div>


<pre><span id="VAL(^::)"><span class="keyword">val</span> (^::)</span> : <code class="type">'a -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> 'a <a href="Bap.Std.html#TYPEseq">seq</a></code></pre><div class="info ">
<code class="code">x ^:: xs</code> is a consing operator for sequences<br>
</div>

<pre><span id="TYPEvector"><span class="keyword">type</span> <code class="type">'a</code> vector</span> </pre>
<div class="info ">
<a href="Bap.Std.Vector.html">Resizable array</a><br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Vector.html">Vector</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Vector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Resizable Array.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Config.html">Config</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Config.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Access to BAP configuration variables
</div>

<pre><span id="TYPEbil"><span class="keyword">type</span> <code class="type"></code>bil</span> = <code class="type"><a href="Bap.Std.Bil.html#TYPEt">Bil.t</a></code> </pre>


<pre><span id="TYPEbinop"><span class="keyword">type</span> <code class="type"></code>binop</span> = <code class="type">Bil.binop</code> </pre>


<pre><span id="TYPEcast"><span class="keyword">type</span> <code class="type"></code>cast</span> = <code class="type">Bil.cast</code> </pre>


<pre><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> = <code class="type"><a href="Bap.Std.Exp.html#TYPEt">Exp.t</a></code> </pre>


<pre><span id="TYPEstmt"><span class="keyword">type</span> <code class="type"></code>stmt</span> = <code class="type"><a href="Bap.Std.Stmt.html#TYPEt">Stmt.t</a></code> </pre>


<pre><span id="TYPEunop"><span class="keyword">type</span> <code class="type"></code>unop</span> = <code class="type">Bil.unop</code> </pre>


<pre><span id="TYPEvalue"><span class="keyword">type</span> <code class="type"></code>value</span> = <code class="type"><a href="Bap.Std.Value.html#TYPEt">Value.t</a></code> </pre>


<pre><span id="TYPEdict"><span class="keyword">type</span> <code class="type"></code>dict</span> = <code class="type"><a href="Bap.Std.Dict.html#TYPEt">Dict.t</a></code> </pre>


<pre><span id="TYPEimage"><span class="keyword">type</span> <code class="type"></code>image</span> </pre>
<div class="info ">
an image loaded into memory<br>
</div>


<pre><span id="TYPEmem"><span class="keyword">type</span> <code class="type"></code>mem</span> </pre>
<div class="info ">
opaque memory<br>
</div>


<pre><span id="TYPEtable"><span class="keyword">type</span> <code class="type">'a</code> table</span> </pre>
<div class="info ">
a table from memory to <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="TYPEmemmap"><span class="keyword">type</span> <code class="type">'a</code> memmap</span> </pre>
<div class="info ">
interval trees from memory regions to <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Memory_iterators.html">Memory_iterators</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory_iterators.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Iterators lifted into monad
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.html">Memory</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Memory region
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Table.html">Table</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Table.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Table.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Location.html">Location</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Location.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A locations of a chunk of memory
</div>

<pre><span id="TYPElocation"><span class="keyword">type</span> <code class="type"></code>location</span> = <code class="type"><a href="Bap.Std.Location.html#TYPEt">Location.t</a></code> </pre>
<div class="info ">
memory location<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Backend.html">Backend</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Backend.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A backend interface.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Image.html">Image</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Image.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Binary Image.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memmap.html">Memmap</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memmap.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Memory maps.
</div>

<pre><span id="TYPEdisasm"><span class="keyword">type</span> <code class="type"></code>disasm</span> </pre>
<div class="info ">
value of type <code class="code">disasm</code> is a result of the disassembling of a
      memory region. To create values of this type use <code class="code">disassemble</code>
      function<br>
</div>


<pre><span id="TYPEinsn"><span class="keyword">type</span> <code class="type"></code>insn</span> </pre>
<div class="info ">
values of type <code class="code">insn</code> represents machine instructions decoded
      from the given piece of memory<br>
</div>


<pre><span id="TYPEblock"><span class="keyword">type</span> <code class="type"></code>block</span> </pre>
<div class="info ">
<code class="code">block</code> is a region of memory that is believed to be a basic block
      of control flow graph to the best of our knowledge.<br>
</div>


<pre><span id="VALdisassemble"><span class="keyword">val</span> disassemble</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble ?roots arch mem</code> disassemble provided memory region
      <code class="code">mem</code> using best available algorithm and backend for the specified
      <code class="code">arch</code>. Roots, if provided, should point to memory regions, that
      are believed to contain code. At best, this should be a list of
      function starts. If no roots are provided, then the starting
      address of the provided memory <code class="code">mem</code> will be used as a root.
<p>

      The returned value will contain all memory reachable from the
      given set of roots, at our best knowledge.<br>
</div>

<pre><span id="VALdisassemble_image"><span class="keyword">val</span> disassemble_image</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEimage">image</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_image image</code> disassemble given image.
      Will take executable sections of the image and disassemble it,
      applying <code class="code">disassemble</code> function. If no roots are specified, then
      symbol table will be used as a source of roots. If file doesn't
      contain one, then entry point will be used.<br>
</div>

<pre><span id="VALdisassemble_file"><span class="keyword">val</span> disassemble_file</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -><br>       string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a> Or_error.t</code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALdisassemble_file_exn"><span class="keyword">val</span> disassemble_file_exn</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALlinear_sweep"><span class="keyword">val</span> linear_sweep</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -><br>       <a href="Bap.Std.html#TYPEmem">mem</a> -><br>       (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list Or_error.t</code></pre><div class="info ">
<code class="code">linear_sweep arch mem</code> will perform a linear sweep disassembly on
      the specified memory <code class="code">mem</code><br>
</div>

<pre><span id="VALlinear_sweep_exn"><span class="keyword">val</span> linear_sweep_exn</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list</code></pre><div class="info ">
<code class="code">linear_sweep_exn</code> same as <code class="code">linear_sweep</code>, but raises an
      exception, instead of returning <code class="code"><span class="constructor">Or_error</span></code> monad<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm.html">Disasm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Disasm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Disassembled program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Kind.html">Kind</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Kind.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Kinds of instructions
</div>

<pre><span id="TYPEreg"><span class="keyword">type</span> <code class="type"></code>reg</span> </pre>
<div class="info ">
abstract and opaque register<br>
</div>


<pre><span id="TYPEimm"><span class="keyword">type</span> <code class="type"></code>imm</span> </pre>
<div class="info ">
opaque immediate value<br>
</div>


<pre><span id="TYPEfmm"><span class="keyword">type</span> <code class="type"></code>fmm</span> </pre>
<div class="info ">
floating point value<br>
</div>


<pre><span id="TYPEkind"><span class="keyword">type</span> <code class="type"></code>kind</span> = <code class="type"><a href="Bap.Std.Kind.html#TYPEt">Kind.t</a></code> </pre>
<div class="info ">
kind of instruction<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Reg.html">Reg</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Reg.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Register.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Imm.html">Imm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Imm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Integer immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Fmm.html">Fmm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Fmm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Floating point immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Op.html">Op</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Op.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Operand
</div>

<pre><span id="TYPEop"><span class="keyword">type</span> <code class="type"></code>op</span> = <code class="type"><a href="Bap.Std.Op.html#TYPEt">Op.t</a></code> </pre>


<pre><span id="TYPEabi"><span class="keyword">class type</span> <a href="Bap.Std.abi-c.html">abi</a></span> = <code class="code"><span class="keyword">object</span></code> <a href="Bap.Std.abi-c.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
ABI interface.
</div>

<pre><span id="TYPEabi_constructor"><span class="keyword">type</span> <code class="type"></code>abi_constructor</span> = <code class="type">?image:<a href="Bap.Std.html#TYPEimage">image</a> -><br>       ?sym:string -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEblock">block</a> -> <a href="Bap.Std.abi-c.html">abi</a></code> </pre>
<div class="info ">
symbol name may be provided if known. Also an access
      to the whole binary image is provided if there is one.<br>
</div>

<br>
A BIL model of CPU
<p>

      In general this is a model of a processor architecture, involving
      ALU, processing unit, registers and memory.<br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.CPU.html">CPU</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.CPU.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract interface to CPU
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.ABI.html">ABI</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.ABI.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Application Binary Interface
</div>

<pre><span id="TYPEjump"><span class="keyword">type</span> <code class="type"></code>jump</span> = <code class="type">[ `Cond | `Jump ]</code> </pre>
<div class="info ">
a jump kind.
      A jump to another block can be conditional or unconditional.
<p>
This type defines a relation between two basic blocks.<br>
</div>


<pre><span id="TYPEedge"><span class="keyword">type</span> <code class="type"></code>edge</span> = <code class="type">[ `Cond | `Fall | `Jump ]</code> </pre>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_accessors.html">Block_accessors</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block_accessors.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Access to block attributes.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_traverse.html">Block_traverse</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block_traverse.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Navigate to neighborhood blocks.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm_expert.html">Disasm_expert</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Disasm_expert.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Expert interface to disassembler.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Insn.html">Insn</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Insn.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Assembly instruction.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Block.html">Block</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Basic block of machine instructions.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Target.html">Target</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Target.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract interface for all targets.
</div>

<pre><span id="VALtarget_of_arch"><span class="keyword">val</span> target_of_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> (module Bap.Std.Target)</code></pre><div class="info ">
<code class="code">target_of_arch arch</code> creates a module for the given <code class="code">arch</code>, if
      <code class="code">arch</code> is not lifted, the stub module is returned.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.ARM.html">ARM</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.ARM.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
ARM architecture.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.IA32.html">IA32</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.IA32.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code">x86</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.AMD64.html">AMD64</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.AMD64.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code">x86-64</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Symtab.html">Symtab</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Symtab.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<span class="deprecated"></span></div>

<pre><span id="TYPEterm"><span class="keyword">type</span> <code class="type">'a</code> term</span> </pre>
<div class="info ">
BAP IR.
<p>

      Program is a tree of terms.<br>
</div>


<pre><span id="TYPEprogram"><span class="keyword">type</span> <code class="type"></code>program</span> </pre>


<pre><span id="TYPEsub"><span class="keyword">type</span> <code class="type"></code>sub</span> </pre>


<pre><span id="TYPEarg"><span class="keyword">type</span> <code class="type"></code>arg</span> </pre>


<pre><span id="TYPEblk"><span class="keyword">type</span> <code class="type"></code>blk</span> </pre>


<pre><span id="TYPEphi"><span class="keyword">type</span> <code class="type"></code>phi</span> </pre>


<pre><span id="TYPEdef"><span class="keyword">type</span> <code class="type"></code>def</span> </pre>


<pre><span id="TYPEjmp"><span class="keyword">type</span> <code class="type"></code>jmp</span> </pre>


<pre><span id="TYPEtid"><span class="keyword">type</span> <code class="type"></code>tid</span> </pre>


<pre><span id="TYPEcall"><span class="keyword">type</span> <code class="type"></code>call</span> </pre>


<pre><code><span id="TYPElabel"><span class="keyword">type</span> <code class="type"></code>label</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Direct"><span class="constructor">Direct</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
direct jump<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Indirect"><span class="constructor">Indirect</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
indirect jump<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
target of control transfer<br>
</div>


<pre><code><span id="TYPEjmp_kind"><span class="keyword">type</span> <code class="type"></code>jmp_kind</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Call"><span class="constructor">Call</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEcall">call</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
call to subroutine<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Goto"><span class="constructor">Goto</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPElabel">label</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
jump inside subroutine<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Ret"><span class="constructor">Ret</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPElabel">label</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
return from call to label<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Int"><span class="constructor">Int</span></span> <span class="keyword">of</span> <code class="type">int * <a href="Bap.Std.html#TYPEtid">tid</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
interrupt and return to tid<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
control transfer variants<br>
</div>


<pre><code><span id="TYPEintent"><span class="keyword">type</span> <code class="type"></code>intent</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.In"><span class="constructor">In</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
input argument<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.Out"><span class="constructor">Out</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
output argument<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.Both"><span class="constructor">Both</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
input/output<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
argument intention<br>
</div>


<pre><span id="TYPEcls"><span class="keyword">type</span> <code class="type">('a, 'b)</code> cls</span> </pre>

<br>
<h4 id="4_Termtypeclasses">Term type classes</h4><br>

<pre><span id="VALsub_t"><span class="keyword">val</span> sub_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEprogram">program</a>, <a href="Bap.Std.html#TYPEsub">sub</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
sub<br>
</div>

<pre><span id="VALarg_t"><span class="keyword">val</span> arg_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEsub">sub</a>, <a href="Bap.Std.html#TYPEarg">arg</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
arg<br>
</div>

<pre><span id="VALblk_t"><span class="keyword">val</span> blk_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEsub">sub</a>, <a href="Bap.Std.html#TYPEblk">blk</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
blk<br>
</div>

<pre><span id="VALphi_t"><span class="keyword">val</span> phi_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEphi">phi</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
phi<br>
</div>

<pre><span id="VALdef_t"><span class="keyword">val</span> def_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEdef">def</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
def<br>
</div>

<pre><span id="VALjmp_t"><span class="keyword">val</span> jmp_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEjmp">jmp</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
jmp<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Tid.html">Tid</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Tid.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Term identifier
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Term.html">Term</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Term.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
IR language term.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Program.html">Program</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Program.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Sub.html">Sub</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Sub.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Blk.html">Blk</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Blk.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Block.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Def.html">Def</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Def.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Definition.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Jmp.html">Jmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Jmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A control transfer operation.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Phi.html">Phi</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Phi.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
PHI-node
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arg.html">Arg</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Arg.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine argument.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Call.html">Call</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Call.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A control transfer to another subroutine.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Label.html">Label</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Label.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Target of a control flow transfer.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Project.html">Project</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Target of analysis.
</div>

<pre><span id="TYPEproject"><span class="keyword">type</span> <code class="type"></code>project</span> = <code class="type"><a href="Bap.Std.Project.html#TYPEt">Project.t</a></code> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Dwarf.html">Dwarf</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Dwarf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Dwarf library
      This library gives an access to debugging information stored
      in a binary program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Signatures.html">Signatures</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Signatures.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Binary signatures storage
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Byteweight.html">Byteweight</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Byteweight.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Byteweight Algorithm implementation
</div>
</body></html>