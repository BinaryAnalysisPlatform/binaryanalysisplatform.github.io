<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Bap.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Microx" rel="Chapter" href="Microx.html">
<link title="Microx_conqueror" rel="Chapter" href="Microx_conqueror.html">
<link title="Microx_concretizer" rel="Chapter" href="Microx_concretizer.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html"><link title="Binary Analysis Platform Library" rel="Section" href="#1_BinaryAnalysisPlatformLibrary">
<link title="BAP API" rel="Section" href="#api">
<link title="Overview" rel="Subsection" href="#2_Overview">
<link title="Foundation Library" rel="Subsection" href="#bfl">
<link title="Memory model" rel="Subsection" href="#image">
<link title="Disassembler" rel="Subsection" href="#disasm">
<link title="Semantic Analysis" rel="Subsection" href="#sema">
<link title="Working with project" rel="Subsection" href="#project">
<title>BAR: BAP Annotated Reference : Bap.Std</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Bap.html" title="Bap">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Bap.Std.html">Bap.Std</a></h1>

<pre><span class="keyword">module</span> Std: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><hr width="100%">
<br>
<h1 id="1_BinaryAnalysisPlatformLibrary">Binary Analysis Platform Library</h1><br>
<br>
<h2 id="2_Overview">Overview</h2>
<p>

      BAP has a layered architecture consisting of four
      layers. Although the layers are not really observable from outside
      of the library, they make it easier to learn the library, as
      they introduce new concepts sequentially. On top of this layers,
      the <a href="Bap.Std.html#project">Project</a> module is defined, that
      consolidates all information about target of an
      analysis. <code class="code"><span class="constructor">Project</span></code> module may be viewed as an entry point to
      the library.
<p>

      <pre class="verbatim">        +-----------------------------------------------------+
        | +--------+   +-----------------------------------+  |
        | |        |   |                                   |  |
        | |        |   |       Foundation Library          |  |
        | |        |   |                                   |  |
        | |        |   +-----------------------------------+  |
        | |   P    |                                          |
        | |        |   +-----------------------------------+  |
        | |   R    |   |                                   |  |
        | |        |   |          Memory Model             |  |
        | |   O    |   |                                   |  |
        | |        |   +-----------------------------------+  |
        | |   J    |                                          |
        | |        |   +-----------------------------------+  |
        | |   E    |   |                                   |  |
        | |        |   |           Disassembly             |  |
        | |   C    |   |                                   |  |
        | |        |   +-----------------------------------+  |
        | |   T    |                                          |
        | |        |   +-----------------------------------+  |
        | |        |   |                                   |  |
        | |        |   |        Semantic Analysis          |  |
        | |        |   |                                   |  |
        | +--------+   +-----------------------------------+  |
        +-----------------------------------------------------+
     </pre>
<p>

      The <a href="Bap.Std.html#bfl">Foundation library</a> defines <a href="Bap.Std.Bil.html">BAP Instruction
      language</a> data types, as well as other useful data structures,
      like <a href="Bap.Std.Value.html"><code class="code"><span class="constructor">Value</span></code></a>, <a href="Bap.Std.Trie.html"><code class="code"><span class="constructor">Trie</span></code></a>, <a href="Bap.Std.Vector.html"><code class="code"><span class="constructor">Vector</span></code></a>, <code class="code"><span class="constructor">Graph</span></code>, etc. The
      <a href="Bap.Std.html#image">Memory model</a> layer is responsible for loading
      and parsing binary objects and representing them in computer
      memory. It also defines a few useful data structures that are
      used extensively by later layers, like <a href="Bap.Std.Table.html"><code class="code"><span class="constructor">Table</span></code></a> and
      <a href="Bap.Std.Memmap.html"><code class="code"><span class="constructor">Memmap</span></code></a>. The next layer performs
      <a href="Bap.Std.html#disasm">disassembly</a> and lifting to BIL. Finally, the
      <a href="Bap.Std.html#sema">semantic analysis</a> layer transforms a binary
      into an IR representation, that is suitable for writing analysis.
<p>

      Another important point of view is the BAP plugin architecture.
      Similar to GIMP or Frama-C, BAP features a pluggable architecture
      with a number of extension points. For example, even the LLVM
      disassembler is considered a type of plugin.  Currently we
      support three such extension points in BAP:
<p>
<ul>
<li><a href="Bap.Std.Backend.html">loaders</a> - to add new binary object loaders;</li>
<li>disassemblers - to add new disassemblers;</li>
<li><a href="Bap.Std.html#project">program analysis</a> - to write analysis.</li>
</ul>

      The latter category of plugins is most widely used. Therefore,
      when we use the term "plugin" without making a distinction, we
      refer to a program analysis plugin. The following figure
      provides an overview of the BAP system.
<p>

      <pre class="verbatim">        +---------------------------------------------+
        |  +----------------+    +-----------------+  |
        |  |    Loader      |    |  Disassembler   |  |
        |  |    Plugins     |    |    Plugins      |  |
        |  +-------+--------+    +--------+--------+  |
        |          |                      |           |
        |  +-------+----------------------+--------+  |
        |  |                                       |  |
        |  |             BAP Library               |  |
        |  |                                       |  |
        |  +-------+-------------------------------+  |
        |          ^                      ^           |
        |          |                      |           |
        |  +-------+--------+    +--------+--------+  |
        |  |                |    |                 |  |
        |  |  BAP toolkit   |&lt;--&gt;|   BAP Plugins   |  |
        |  |                |    |                 |  |
        |  +----------------+    +-----------------+  |
        +---------------------------------------------+
     </pre>
<p>

      All plugins have full access to the library; an important
      consequence is that they can and should open <code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span></code>. The BAP
      library uses backend loader and disassembler plugins to provide
      its services. Program analysis plugins are loaded by BAP
      toolkit utilities. These utilities extend plugin functionality
      by providing access to the state of the target of analysis or,
      in our parlance, to the <a href="Bap.Std.html#TYPEproject">project</a>. (See
      <a href="Bap.Std.html#project"><i>Working with project</i></a>).
<p>

      Other than library itself, and the BAP toolkit, there are two
      additional libraries that are bundled with BAP:
<p>
<ul>
<li><code class="code">bap.plugins</code> to dynamically load code into BAP;</li>
<li><code class="code">bap.serialization</code> to serialize BAP data structures in
        different formats.</li>
</ul>
<br>
<br>
<h2 id="bfl">Foundation Library</h2>
<p>

      At this layer we define (<a href="Bap.Std.Bil.html">Binary Instruction language</a>)
      and few other useful data structures:
<p>
<ul>
<li><a href="Bap.Std.Arch.html">arch</a> - describes computer architecture;</li>
<li><a href="Bap.Std.Size.html">size</a> - word and register sizes;</li>
<li><a href="Bap.Std.Var.html">var</a>  - <a href="Bap.Std.Bil.html">BIL</a> variable;</li>
<li><a href="Bap.Std.Type.html">typ</a> - <a href="Bap.Std.Bil.html">BIL</a> type system;</li>
<li><a href="Bap.Std.Exp.html">exp</a>  - <a href="Bap.Std.Bil.html">BIL</a> expression sub-language;</li>
<li><a href="Bap.Std.Stmt.html">stmt</a> - <a href="Bap.Std.Bil.html">BIL</a> statements;</li>
<li><a href="Bap.Std.Bitvector.html">bitvector</a> - a bitvector data structure
        to represent immediate data, used usually by their aliases</li>
<li><a href="Bap.Std.html#TYPEword"><code class="code">word</code></a> and <a href="Bap.Std.html#TYPEaddr"><code class="code">addr</code></a>;</li>
<li><a href="Bap.Std.Value.html">value</a> - an extensible variant type;</li>
<li><a href="Bap.Std.Dict.html">dict</a> - an extensible record;</li>
<li><a href="Bap.Std.Vector.html">vector</a> - array that can grow;</li>
<li><a href="Bap.Std.Seq.html">'a seq</a> - slightly extended Core <code class="code"><span class="constructor">Sequence</span></code>, aka lazy
        list;</li>
<li><a href="Bap.Std.Trie.html">Trie</a> - prefix trees;</li>
<li>Graph - graph implementations and library.</li>
</ul>

      Most of the types implement the <a href="Regular.html">Regular</a>
      interface. This interface is very similar to Core's
      <code class="code"><span class="constructor">Identifiable</span></code>, and is supposed to represent a type that is as
      common as a built-in type. One should expect to find any
      function that is implemented for such types as <code class="code">int</code>, <code class="code">string</code>,
      <code class="code">char</code>, etc.  Namely, this interface includes:
<p>
<ul>
<li>comparison functions: (<code class="code">&lt;, &gt;, &lt;= , &gt;= , compare, between, ...</code>);</li>
<li>each type defines a polymorphic <code class="code"><span class="constructor">Map</span></code> with keys of type <code class="code">t</code>;</li>
<li>each type provides a <code class="code"><span class="constructor">Set</span></code> with values of type <code class="code">t</code>;</li>
<li>hashtable is exposed via <code class="code"><span class="constructor">Table</span></code> module;</li>
<li>hashset is available under <code class="code"><span class="constructor">Hash_set</span></code> name</li>
<li>sexpable and binable interface;</li>
<li><code class="code">to_string</code>, <code class="code">str</code>, <code class="code">pp</code>, <code class="code">ppo</code>, <code class="code">pps</code> functions
      for pretty-printing.</li>
</ul>

      Most types usually provide much more. For each type, there is a
      module with the same name that implements its interface. For
      example, type <code class="code">exp</code> is indeed a type abbreviation for <code class="code"><span class="constructor">Exp</span>.t</code>,
      and module <code class="code"><span class="constructor">Exp</span></code> contains all functions and types related to
      type <code class="code">exp</code>. For example, to create a hashtable of statements,
      just type:
<p>

      <code class="code"><span class="keyword">let</span> table = <span class="constructor">Stmt</span>.<span class="constructor">Table</span>.create ()</code>
<p>

      If a type is a variant type (i.e., defines constructors) then for
      each constructor named <code class="code"><span class="constructor">Name</span></code>, there exists a corresponding
      function named <code class="code">name</code> that will accept the same number of
      arguments as the arity of the constructor. For example, a
      <code class="code"><span class="constructor">Bil</span>.<span class="constructor">Int</span></code> can be constructed with the <code class="code"><span class="constructor">Bil</span>.int</code> function that
      has type <code class="code">word <span class="keywordsign">-&gt;</span> exp</code>. If a constructor has several arguments
      of the same type we usually disambiguate them with keywords,
      e.g., <code class="code"><span class="constructor">Bil</span>.<span class="constructor">Load</span> <span class="keyword">of</span> (exp,exp,endian,size)</code> has function
      <a href="Bap.Std.Bil.html#VALload">Bil.load</a> with type:
      <code class="code">mem:exp <span class="keywordsign">-&gt;</span> addr:exp <span class="keywordsign">-&gt;</span> endian <span class="keywordsign">-&gt;</span> size <span class="keywordsign">-&gt;</span> exp</code>
<p>

      <h3 id="value">Value</h3>
<p>

      <a href="Bap.Std.Value.html">Universal values</a> can be viewed as extensible variants on
      steroids. Not only they maybe extended, but they also can be
      serialized, compared with user-defined comparison function and
      even pretty printed.
<p>

      <h3 id="dict">Dict</h3>
<p>

      Like <a href="Bap.Std.Value.html">value</a> is an extensible sum type, <a href="Bap.Std.Dict.html">dict</a>
      can be viewed as extensible product type. Dict is a sequence of
      values of type <a href="Bap.Std.html#TYPEvalue"><code class="code">value</code></a>, with <a href="Bap.Std.Value.Tag.html">tags</a> used as field
      names. Of course, fields are unique.
<p>

      <h3 id="vector">Vector</h3>
<p>

      Vector is an implementation of C++ STL like vectors with
      logarithmic push back.
<p>

      <h3 id="tries">Tries</h3>
<p>

      The Foundation library also defines a prefix tree data structure
      that proves to be useful for binary analysis applications.
      <a href="Bap.Std.Trie.html">Trie</a>s in BAP is a functor that derives a
      polymorphic trie data structure for a given
      <a href="Bap.Std.Trie.Key.html">Key</a>.
<p>

      For convenience we support instantiating tries for most of
      our data structures. For example, <a href="Bap.Std.Bitvector.html">Word</a> has several
      <a href="Bap.Std.Bitvector.Trie.html">tries</a> inside.
<p>

      For common strings, there's <a href="Bap.Std.Trie.String.html"><code class="code"><span class="constructor">Trie</span>.<span class="constructor">String</span></code></a>.<br>
<br>
<h2 id="image">Memory model</h2>
<p>

      This layer provides everything you need to work with binary
      objects:
<p>
<ul>
<li><a href="Bap.Std.Memory.html">mem</a> - a contiguous array of bytes, indexed with
       absolute addresses;</li>
</ul>
<ul>
<li><a href="Bap.Std.Table.html"> 'a table</a> - a mapping from a memory regions to
       arbitrary data (no duplicates or intersections);</li>
</ul>
<ul>
<li><a href="Bap.Std.Memmap.html">a memmap</a> - a mapping from memory region to
        arbitrary data with duplicates and intersections allowed, aka
        segment tree or interval map;</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html">image</a> - represents a binary object with all its
       symbols, segments, sections and other meta information.</li>
</ul>

      The <code class="code"><span class="constructor">Image</span></code> module uses the plugin system to load binary
      objects. In order to add new loader, one should implement the
      <a href="Bap.Std.Backend.html">Backend.t</a> loader function and register it with the
      <a href="Bap.Std.Image.html#VALregister_backend">Image.register_backend</a> function.<br>
<br>
<h2 id="disasm">Disassembler</h2>
<p>

      This layer consists of disassemblers and lifters. They are
      tightly integrated, but in general we can disassemble all
      supported <a href="Bap.Std.Arch.html#TYPEt">architectures</a>. Currently we lift only arm,
      x86 and x86_64.
<p>

      There are two interfaces to disassemblers:
<p>
<ul>
<li><a href="Bap.Std.Disasm.html">Disasm</a> - a regular interface that hides all
       complexities, but may not always be very flexible.</li>
<li><a href="Bap.Std.Disasm_expert.html">Disasm_expert</a> - an expert interface that
      provides access to a low-level representation. It is very
      flexible and fast, but harder to use.</li>
</ul>

      To disassemble files or data with the regular interface, use
      one of the following functions:
<p>
<ul>
<li>disassemble - to disassemble a region of
        memory;</li>
<li>disassemble_image - to disassemble a
        loaded binary object;</li>
<li>disassemble_file or
        disassemble_file - to disassemble
        file.</li>
</ul>

      All these functions perform disassembly by recursive descent,
      reconstruct the control flow graph, and perform lifting. The
      result of disassembly is represented by the abstract value of
      type <a href="Bap.Std.Disasm.html">disasm</a>. Two main data structures that are used
      to represent disassembled program are:
<p>
<ul>
<li><a href="Bap.Std.Insn.html">insn</a> - a machine instruction;</li>
<li><a href="Bap.Std.Block.html">block</a> - a basic block, i.e., a linear sequence of
        instructions.</li>
</ul>

      The following figure shows the relationship between basic data
      structures of the disassembled program.
<p>

      <pre class="verbatim">        +-----------------+
        | +-------------+ |
        | |   disasm    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |    block    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     insn    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     stmt    | |
        | +-------------+ |
        +-----------------+
     </pre>
<p>

      A disassembled program is represented as a set of
      interconnected <a href="Bap.Std.Block.html">basic blocks</a>. You can navigate between
      blocks using Block.succs and
      Block.preds functions, or you can
      transform a set of blocks into a real graph using
      the Block.to_graph function. Sometimes it
      is enough to traverse program using
      depth-first search.
<p>

      Each block is a container to a sequence of machine
      instructions. It is guaranteed that there's at least one
      instruction in the block, thus the
      Block.leader and
      Block.terminator functions are
      total.
<p>

      Each <a href="Bap.Std.Insn.html">machine instruction</a> is represented by its
      <code class="code">opcode</code>, <code class="code">name</code> and <code class="code">array</code> of operands (these are machine and
      disassembler specific), a set of predicates (describing
      instruction semantics on a very high level), and a sequence of
      <a href="Bap.Std.Bil.html">BIL</a> statements that precisely define the semantics of
      the instruction.
<p>

      Modules of type <a href="Bap.Std.CPU.html">CPU</a> provide a high level abstraction of
      the CPU and allow one to reason about instruction semantics
      independently from the target platform. The module type
      <a href="Bap.Std.Target.html">Target</a> brings <code class="code"><span class="constructor">CPU</span></code> and <code class="code"><span class="constructor">ABI</span></code> together. To get an
      instance of this module, you can use the
      <a href="Bap.Std.html#VALtarget_of_arch">target_of_arch</a> function. For accessing all
      information about target platform, use the following modules
      that expose low-level and platform-specific details:
<p>
<ul>
<li><a href="ARM.html">ARM</a></li>
<li>IA32</li>
<li>AMD64</li>
</ul>

      If you do not need cfg reconstruction, you can use
      linear_sweep function to disassemble a given
      memory region. If you need more granularity, then you can use
      the expert interface accordingly:
<p>
<ul>
<li><a href="Bap.Std.Disasm_expert.Basic.html">Basic</a> - provides access to a low-level
        disassembler on top of which all other disassemblers are
        built;</li>
<li><a href="Bap.Std.Disasm_expert.Recursive.html">Recursive</a> - an interface to a
        recursive descent algorithm.</li>
</ul>
<br>
<br>
<h2 id="sema">Semantic Analysis</h2>
<p>

      On semantic level the disassembled program is lifted into the
      intermediate representation (IR) suitable for writing analysis.
<p>

      IR is closely related to BIL. In fact it even reuses expression
      sub-language of BIL. But unlike BIL, IR is flat, (i.e., it
      doesn't contain recursive statements), and unstructured (no
      <code class="code"><span class="keyword">while</span></code>, <code class="code"><span class="keyword">if</span></code>, only jumps). Thus IR is much more low-level, so
      it is harder to read, but easier to analyze programmatically.
<p>

      The program in IR is build of terms. In fact the program itself
      is also a term. There're only 7 kinds of terms:
<p>
<ul>
<li><a href="Bap.Std.Program.html">program</a> - the program in whole;</li>
<li><a href="Bap.Std.Sub.html">sub</a> - subroutine;</li>
<li><a href="Bap.Std.Arg.html">arg</a> - subroutine argument;</li>
<li><a href="Bap.Std.Blk.html">blk</a> - basic block;</li>
<li><a href="Bap.Std.Def.html">def</a> - definition of a variable;</li>
<li><a href="Bap.Std.Phi.html">phi</a> - phi-node in the SSA form;</li>
<li><a href="Bap.Std.Jmp.html">jmp</a> - a transfer of control.</li>
</ul>

      Unlike expressions and statements in BIL, IR's terms are
      <em>concrete entities</em>.  Concrete entity is such entity that can
      change in time and space, as well as come in and out of
      existence.  Contrary, <em>abstract entity</em> is eternal and
      unchangeable.  <em>Identity</em> denotes the sameness of a concrete
      entity as it changes in time.  Abstract entities don't have an
      identity since they are immutable.  Program is built of concrete
      entities called terms.  Terms have <em>attributes</em> that can change in
      time, without affecting the identity of a term.  Attributes are
      abstract entities.  In each particular point of space and time a
      term is represented by a snapshot of all its attributes,
      colloquially called <em>value</em>.  Functions that change the value of a
      term in fact returns a new value with different set of
      attributes.  For example, <code class="code">def</code> term has two attributes: left
      hand side (lhs), that associates definition with abstract
      variable, and right hand side (rhs) that associates <code class="code">def</code> with
      an abstract expression. Suppose, that the definition was:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="keyword">let</span>&nbsp;d_1&nbsp;=&nbsp;<span class="constructor">Def</span>.create&nbsp;x&nbsp;<span class="constructor">Bil</span>.(var&nbsp;y&nbsp;+&nbsp;var&nbsp;z);;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;d_1&nbsp;:&nbsp;<span class="constructor">Def</span>.t&nbsp;=&nbsp;00000001:&nbsp;x&nbsp;:=&nbsp;y&nbsp;+&nbsp;z
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      To change the right hand side of a definition we use
      <code class="code"><span class="constructor">Def</span>.with_rhs</code> that returns the <em>same</em> definition but with
      <em>different</em> value:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="keyword">let</span>&nbsp;d_2&nbsp;=&nbsp;<span class="constructor">Def</span>.with_rhs&nbsp;d_1&nbsp;<span class="constructor">Bil</span>.(int&nbsp;<span class="constructor">Word</span>.b1);;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;d_2&nbsp;:&nbsp;<span class="constructor">Def</span>.t&nbsp;=&nbsp;00000001:&nbsp;x&nbsp;:=&nbsp;<span class="keyword">true</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      <code class="code">d_1</code> and <code class="code">d_2</code> is different values
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="constructor">Def</span>.equal&nbsp;d_1&nbsp;d_2;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:&nbsp;bool&nbsp;=&nbsp;<span class="keyword">false</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>  of the same term <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="constructor">Term</span>.same&nbsp;d_1&nbsp;d_2;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:&nbsp;bool&nbsp;=&nbsp;<span class="keyword">true</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      The identity of this terms is denoted by the term identifier
      (<code class="code">tid</code>). In the textual representation term identifiers are
      printed as ordinal numbers.
<p>

      Terms, can contain other terms. But unlike BIL expressions or
      statements, this relation is not truly recursive, since the
      structure of program term is fixed: <code class="code">arg</code>, <code class="code">phi</code>, <code class="code">def</code>, <code class="code">jmp</code>
      are leaf terms; <code class="code">sub</code> can only contain <code class="code">arg</code>'s or <code class="code">blk</code>'s; <code class="code">blk</code>
      consists of <code class="code">phi</code>, <code class="code">def</code> and <code class="code">jmp</code> sequences of terms, as
      pictured in the figure below.  Although, the term structure is
      closed to changes, you still can extend particular term with
      attributes, using <code class="code">set_attr</code> and <code class="code">get_attr</code> functions of the
      <a href="Bap.Std.Term.html">Term</a> module. This functions are using <a href="Bap.Std.Value.html">extensible
      variant</a> type to encode attributes.
<p>

      <pre class="verbatim">        +--------------------------------------------------------+
        |                +-------------------+                   |
        |                |      program      |                   |
        |                +---------+---------+                   |
        |                          |*                            |
        |                +---------+---------+                   |
        |                |        sub        |                   |
        |                +---------+---------+                   |
        |                          |                             |
        |        +-----------------+---------------+             |
        |        |*                                |*            |
        |  +-----+-------+                 +-------+-------+     |
        |  |    arg      |                 |      blk      |     |
        |  +-------------+                 +-------+-------+     |
        |                                          |             |
        |           +---------------+--------------+             |
        |           |*              |*             | *           |
        |     +-----+-----+   +-----+-----+   +----+-----+       |
        |     |    phi    |   |    def    |   |   jmp    |       |
        |     +-----------+   +-----------+   +----------+       |
        +--------------------------------------------------------+
     </pre><br>
<br>
<h2 id="project">Working with project</h2>
<p>

      There're two general approaches to obtain a value of type
      <a href="Bap.Std.Project.html">project</a>:<ul>
<li>create it manually using one of the <code class="code"><span class="constructor">Project</span>.from_*</code> function;</li>
<li>to write a plugin to a <code class="code">bap</code> utility</li>
</ul>

      Although the first approach is simplistic and gives you a full
      control, we still recommend to use the latter, as <code class="code">bap</code> utility
      will provide you integration with different tools, like IDA, as
      well as interaction with a user and other plugins.
<p>

      To write a program analysis plugin (or pass in short) you need to
      implement a function with one of the following interfaces:
<p>
<ul>
<li><code class="code">project <span class="keywordsign">-&gt;</span> project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_pass">register_pass</a>;</li>
<li><code class="code">project <span class="keywordsign">-&gt;</span> unit</code> and register it with
         <a href="Bap.Std.Project.html#VALregister_pass'">register_pass'</a>;</li>
<li><code class="code">string array <span class="keywordsign">-&gt;</span> project <span class="keywordsign">-&gt;</span> project</code> and register it with
        register_pass_with_args;</li>
<li><code class="code">string array <span class="keywordsign">-&gt;</span> project <span class="keywordsign">-&gt;</span> unit</code> and register it with
        register_pass_with_args'.</li>
</ul>

      Once loaded from the <code class="code">bap</code> utility (see <code class="code">man bap</code>) this function
      will be invoked with a value of type <a href="Bap.Std.Project.html#TYPEt">project</a> that
      provides access to all information gathered over the binary so
      far. If the registered function returns a non <code class="code">unit</code> type, then it
      can functionally update the project state, e.g., add
      annotations, discover new symbols, make corrections, and even
      change the architecture and re-disassemble everything.
<p>

      <h3 id="3_Example">Example</h3>
<p>

      The following plugin prints all sections in a file:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Core_kernel</span>.<span class="constructor">Std</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Bap</span>.<span class="constructor">Std</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Format</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;print_sections&nbsp;p&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Project</span>.memory&nbsp;p&nbsp;|&gt;&nbsp;<span class="constructor">Memmap</span>.to_sequence&nbsp;|&gt;&nbsp;<span class="constructor">Seq</span>.iter&nbsp;~f:(<span class="keyword">fun</span>&nbsp;(mem,x)&nbsp;<span class="keywordsign">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Option</span>.iter&nbsp;(<span class="constructor">Value</span>.get&nbsp;<span class="constructor">Image</span>.section&nbsp;x)&nbsp;~f:(<span class="keyword">fun</span>&nbsp;name&nbsp;<span class="keywordsign">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;<span class="string">"Section:&nbsp;%s@.%a@."</span>&nbsp;name&nbsp;<span class="constructor">Memory</span>.pp&nbsp;mem))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;()&nbsp;=&nbsp;<span class="constructor">Project</span>.register_pass'&nbsp;<span class="string">"print-sections"</span>&nbsp;print_sections
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      <h3 id="3_Exchanginginformation">Exchanging information</h3>
<p>

      For exchanging information in a type safe manner, we use
      <a href="Bap.Std.Value.html">universal values</a>. Values can be attached to a
      particular memory region, IR terms, or put into the <code class="code">storage</code>
      dictionary. For the first case we use the <a href="Bap.Std.Memmap.html">memmap</a> data
      structure.  It is an interval tree containing all the memory
      regions that are used during analysis. For the <code class="code">storage</code> we use
      <code class="code"><span class="constructor">Dict</span></code> data structure.
<p>

      <h3 id="3_Memorymarks">Memory marks</h3>
<p>

      By default the memory is marked with the following marks:
<p>
<ul>
<li><a href="Bap.Std.Image.html#VALsection">section</a> -- for regions of memory that had a
      particular name in the original binary. For example, in ELF,
      sections have names that annotate a corresponding memory
      region. If project was created from memory object, then the
      overall memory will be marked as a <code class="code"><span class="string">"bap.user"</span></code> section.</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html#VALsegment">segment</a> -- if the binary data was loaded
      from a binary format that contains segments, then the
      corresponding memory regions are be marked. Segments provide
      access to permission information.</li>
</ul>
<br>

<pre><span id="TYPEprinter"><span class="keyword">type</span> <code class="type">'a</code> printer</span> = <code class="type">Format.formatter -> 'a -> unit</code> </pre>
<div class="info ">
Converts an 'a to a string<br>
</div>

<br>
<h1 id="api">BAP API</h1><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Self.html">Self</a> <code class="code">(</code><code class="code">*</code><code class="code"> : </code><code class="code"><span class="keyword">sig</span></code><div class="sig_block"></div><code class="code"><span class="keyword">end</span></code><code class="code">) </code>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Self.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
This module refers to an information bundled with an application.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Integer.html">Integer</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Integer.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Signature for integral type.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Monad.html">Monad</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Monad.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Monad is an interface, that is pervasives through many data
      types.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Seq.html">Seq</a>: <code class="type">module type of Seq</code><code class="type"> 
    with type 'a t = 'a Sequence.t</code></pre><div class="info">
Lazy sequence
</div>

<pre><span id="TYPEseq"><span class="keyword">type</span> <code class="type">'a</code> seq</span> = <code class="type">'a Seq.t</code> </pre>


<pre><span id="VALbin_seq"><span class="keyword">val</span> bin_seq</span> : <code class="type">'a Bin_prot.Type_class.t -><br>       'a <a href="Bap.Std.html#TYPEseq">seq</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_seq"><span class="keyword">val</span> bin_read_seq</span> : <code class="type">'a Bin_prot.Read.reader -><br>       'a <a href="Bap.Std.html#TYPEseq">seq</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_seq__"><span class="keyword">val</span> __bin_read_seq__</span> : <code class="type">'a Bin_prot.Read.reader -><br>       (int -> 'a <a href="Bap.Std.html#TYPEseq">seq</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_seq"><span class="keyword">val</span> bin_reader_seq</span> : <code class="type">'a Bin_prot.Type_class.reader -><br>       'a <a href="Bap.Std.html#TYPEseq">seq</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_seq"><span class="keyword">val</span> bin_size_seq</span> : <code class="type">'a Bin_prot.Size.sizer -><br>       'a <a href="Bap.Std.html#TYPEseq">seq</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_seq"><span class="keyword">val</span> bin_write_seq</span> : <code class="type">'a Bin_prot.Write.writer -><br>       'a <a href="Bap.Std.html#TYPEseq">seq</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_seq"><span class="keyword">val</span> bin_writer_seq</span> : <code class="type">'a Bin_prot.Type_class.writer -><br>       'a <a href="Bap.Std.html#TYPEseq">seq</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_seq"><span class="keyword">val</span> compare_seq</span> : <code class="type">('a -> 'a -> int) -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> int</code></pre>
<pre><span id="VALseq_of_sexp"><span class="keyword">val</span> seq_of_sexp</span> : <code class="type">(Sexplib.Sexp.t -> 'a) -> Sexplib.Sexp.t -> 'a <a href="Bap.Std.html#TYPEseq">seq</a></code></pre>
<pre><span id="VALsexp_of_seq"><span class="keyword">val</span> sexp_of_seq</span> : <code class="type">('a -> Sexplib.Sexp.t) -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module type</span> <a href="Bap.Std.Trie.html">Trie</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Prefix tries.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Trie.html">Trie</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Constructs a trie
</div>

<pre><span id="TYPEword"><span class="keyword">type</span> <code class="type"></code>word</span> </pre>
<div class="info ">
Type to represent machine word<br>
</div>


<pre><span id="VALbin_word"><span class="keyword">val</span> bin_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_word"><span class="keyword">val</span> bin_read_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_word__"><span class="keyword">val</span> __bin_read_word__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEword">word</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_word"><span class="keyword">val</span> bin_reader_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_word"><span class="keyword">val</span> bin_size_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_word"><span class="keyword">val</span> bin_write_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_word"><span class="keyword">val</span> bin_writer_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_word"><span class="keyword">val</span> compare_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> -> <a href="Bap.Std.html#TYPEword">word</a> -> int</code></pre>
<pre><span id="VALword_of_sexp"><span class="keyword">val</span> word_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEword">word</a></code></pre>
<pre><span id="VALsexp_of_word"><span class="keyword">val</span> sexp_of_word</span> : <code class="type"><a href="Bap.Std.html#TYPEword">word</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEaddr"><span class="keyword">type</span> <code class="type"></code>addr</span> = <code class="type"><a href="Bap.Std.html#TYPEword">word</a></code> </pre>
<div class="info ">
A synonym for <code class="code">word</code>, that should be used for words
      that are addresses<br>
</div>


<pre><span id="VALbin_addr"><span class="keyword">val</span> bin_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_addr"><span class="keyword">val</span> bin_read_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_addr__"><span class="keyword">val</span> __bin_read_addr__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEaddr">addr</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_addr"><span class="keyword">val</span> bin_reader_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_addr"><span class="keyword">val</span> bin_size_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_addr"><span class="keyword">val</span> bin_write_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_addr"><span class="keyword">val</span> bin_writer_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_addr"><span class="keyword">val</span> compare_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> -> <a href="Bap.Std.html#TYPEaddr">addr</a> -> int</code></pre>
<pre><span id="VALaddr_of_sexp"><span class="keyword">val</span> addr_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEaddr">addr</a></code></pre>
<pre><span id="VALsexp_of_addr"><span class="keyword">val</span> sexp_of_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Size.html">Size</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Size.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Type safe operand and register sizes.
</div>

<pre><span id="TYPEsize"><span class="keyword">type</span> <code class="type"></code>size</span> = <code class="type"><a href="Bap.Std.Size.html#TYPEt">Size.t</a></code> </pre>
<div class="info ">
size of operand<br>
</div>


<pre><span id="VALbin_size"><span class="keyword">val</span> bin_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_size"><span class="keyword">val</span> bin_read_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_size__"><span class="keyword">val</span> __bin_read_size__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEsize">size</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_size"><span class="keyword">val</span> bin_reader_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_size"><span class="keyword">val</span> bin_size_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_size"><span class="keyword">val</span> bin_write_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_size"><span class="keyword">val</span> bin_writer_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_size"><span class="keyword">val</span> compare_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEsize">size</a> -> int</code></pre>
<pre><span id="VALsize_of_sexp"><span class="keyword">val</span> size_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEsize">size</a></code></pre>
<pre><span id="VALsexp_of_size"><span class="keyword">val</span> sexp_of_size</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEaddr_size"><span class="keyword">type</span> <code class="type"></code>addr_size</span> = <code class="type">[ `r32 | `r64 ] <a href="Bap.Std.Size.html#TYPEp">Size.p</a></code> </pre>
<div class="info ">
size of address<br>
</div>


<pre><span id="VALbin_addr_size"><span class="keyword">val</span> bin_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_addr_size"><span class="keyword">val</span> bin_read_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_addr_size__"><span class="keyword">val</span> __bin_read_addr_size__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEaddr_size">addr_size</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_addr_size"><span class="keyword">val</span> bin_reader_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_addr_size"><span class="keyword">val</span> bin_size_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_addr_size"><span class="keyword">val</span> bin_write_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_addr_size"><span class="keyword">val</span> bin_writer_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_addr_size"><span class="keyword">val</span> compare_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> -> <a href="Bap.Std.html#TYPEaddr_size">addr_size</a> -> int</code></pre>
<pre><span id="VALaddr_size_of_sexp"><span class="keyword">val</span> addr_size_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEaddr_size">addr_size</a></code></pre>
<pre><span id="VALsexp_of_addr_size"><span class="keyword">val</span> sexp_of_addr_size</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr_size">addr_size</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEnat1"><span class="keyword">type</span> <code class="type"></code>nat1</span> = <code class="type">int</code> </pre>
<div class="info ">
just a fancy type abbreviation<br>
</div>


<pre><span id="VALbin_nat1"><span class="keyword">val</span> bin_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_nat1"><span class="keyword">val</span> bin_read_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_nat1__"><span class="keyword">val</span> __bin_read_nat1__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEnat1">nat1</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_nat1"><span class="keyword">val</span> bin_reader_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_nat1"><span class="keyword">val</span> bin_size_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_nat1"><span class="keyword">val</span> bin_write_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_nat1"><span class="keyword">val</span> bin_writer_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_nat1"><span class="keyword">val</span> compare_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> -> <a href="Bap.Std.html#TYPEnat1">nat1</a> -> int</code></pre>
<pre><span id="VALnat1_of_sexp"><span class="keyword">val</span> nat1_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEnat1">nat1</a></code></pre>
<pre><span id="VALsexp_of_nat1"><span class="keyword">val</span> sexp_of_nat1</span> : <code class="type"><a href="Bap.Std.html#TYPEnat1">nat1</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.html">Bitvector</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Bitvector -- a type for representing binary values.
</div>

<pre><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = <code class="type"><a href="Bap.Std.Bitvector.html#TYPEendian">Bitvector.endian</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>

</tr></table>

<div class="info ">
Expose <code class="code">endian</code> constructors to <code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span></code> namespace<br>
</div>


<pre><span id="VALendian_of_sexp"><span class="keyword">val</span> endian_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEendian">endian</a></code></pre>
<pre><span id="VALsexp_of_endian"><span class="keyword">val</span> sexp_of_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="VALbin_endian"><span class="keyword">val</span> bin_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_endian"><span class="keyword">val</span> bin_read_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_endian__"><span class="keyword">val</span> __bin_read_endian__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEendian">endian</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_endian"><span class="keyword">val</span> bin_reader_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_endian"><span class="keyword">val</span> bin_size_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_endian"><span class="keyword">val</span> bin_write_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_endian"><span class="keyword">val</span> bin_writer_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_endian"><span class="keyword">val</span> compare_endian</span> : <code class="type"><a href="Bap.Std.html#TYPEendian">endian</a> -> <a href="Bap.Std.html#TYPEendian">endian</a> -> int</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Word.html">Word</a>: <code class="type">module type of Bitvector</code><code class="type"> 
    with type t = word
     and type endian = endian
     and type comparator_witness = Bitvector.comparator_witness</code></pre><div class="info">
Shortcut for bitvectors that represent words
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Addr.html">Addr</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Addr.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Shortcut for bitvectors that represent addresses
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Type.html">Type</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Type.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The type of a BIL expression.
</div>

<pre><span id="TYPEtyp"><span class="keyword">type</span> <code class="type"></code>typ</span> = <code class="type"><a href="Bap.Std.Type.html#TYPEt">Type.t</a></code> </pre>
<div class="info ">
short abbreviation for a type<br>
</div>


<pre><span id="VALbin_typ"><span class="keyword">val</span> bin_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_typ"><span class="keyword">val</span> bin_read_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_typ__"><span class="keyword">val</span> __bin_read_typ__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEtyp">typ</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_typ"><span class="keyword">val</span> bin_reader_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_typ"><span class="keyword">val</span> bin_size_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_typ"><span class="keyword">val</span> bin_write_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_typ"><span class="keyword">val</span> bin_writer_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_typ"><span class="keyword">val</span> compare_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a> -> int</code></pre>
<pre><span id="VALtyp_of_sexp"><span class="keyword">val</span> typ_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre>
<pre><span id="VALsexp_of_typ"><span class="keyword">val</span> sexp_of_typ</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="VALbool_t"><span class="keyword">val</span> bool_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
one bit<br>
</div>

<pre><span id="VALreg8_t"><span class="keyword">val</span> reg8_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
8-bit width value<br>
</div>

<pre><span id="VALreg16_t"><span class="keyword">val</span> reg16_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
16-bit width value<br>
</div>

<pre><span id="VALreg32_t"><span class="keyword">val</span> reg32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
32-bit width value<br>
</div>

<pre><span id="VALreg64_t"><span class="keyword">val</span> reg64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
64-bit width value<br>
</div>

<pre><span id="VALreg128_t"><span class="keyword">val</span> reg128_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
128-bit width value<br>
</div>

<pre><span id="VALreg256_t"><span class="keyword">val</span> reg256_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
256-bit width value<br>
</div>

<pre><span id="VALmem32_t"><span class="keyword">val</span> mem32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem32_t size</code> creates a type for memory with <code class="code">32</code>-bit addresses
      and elements of size <code class="code">size</code>.<br>
</div>

<pre><span id="VALmem64_t"><span class="keyword">val</span> mem64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem64_t size</code> creates a type for memory with <code class="code">64</code>-bit addresses
      and elements of size <code class="code">size</code>.<br>
</div>

<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> </pre>
<div class="info ">
bil variable<br>
</div>


<pre><span id="VALbin_var"><span class="keyword">val</span> bin_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_var"><span class="keyword">val</span> bin_read_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_var__"><span class="keyword">val</span> __bin_read_var__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEvar">var</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_var"><span class="keyword">val</span> bin_reader_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_var"><span class="keyword">val</span> bin_size_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_var"><span class="keyword">val</span> bin_write_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_var"><span class="keyword">val</span> bin_writer_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_var"><span class="keyword">val</span> compare_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> -> <a href="Bap.Std.html#TYPEvar">var</a> -> int</code></pre>
<pre><span id="VALvar_of_sexp"><span class="keyword">val</span> var_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEvar">var</a></code></pre>
<pre><span id="VALsexp_of_var"><span class="keyword">val</span> sexp_of_var</span> : <code class="type"><a href="Bap.Std.html#TYPEvar">var</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Var.html">Var</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Var.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
BIL variable.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.html">Bil</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Main BIL module
</div>

<pre><span id="TYPEbil"><span class="keyword">type</span> <code class="type"></code>bil</span> = <code class="type"><a href="Bap.Std.Bil.html#TYPEt">Bil.t</a></code> </pre>


<pre><span id="VALbin_bil"><span class="keyword">val</span> bin_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_bil"><span class="keyword">val</span> bin_read_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_bil__"><span class="keyword">val</span> __bin_read_bil__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEbil">bil</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_bil"><span class="keyword">val</span> bin_reader_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_bil"><span class="keyword">val</span> bin_size_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_bil"><span class="keyword">val</span> bin_write_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_bil"><span class="keyword">val</span> bin_writer_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_bil"><span class="keyword">val</span> compare_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> -> <a href="Bap.Std.html#TYPEbil">bil</a> -> int</code></pre>
<pre><span id="VALbil_of_sexp"><span class="keyword">val</span> bil_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEbil">bil</a></code></pre>
<pre><span id="VALsexp_of_bil"><span class="keyword">val</span> sexp_of_bil</span> : <code class="type"><a href="Bap.Std.html#TYPEbil">bil</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEbinop"><span class="keyword">type</span> <code class="type"></code>binop</span> = <code class="type">Bil.binop</code> </pre>


<pre><span id="VALbin_binop"><span class="keyword">val</span> bin_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_binop"><span class="keyword">val</span> bin_read_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_binop__"><span class="keyword">val</span> __bin_read_binop__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEbinop">binop</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_binop"><span class="keyword">val</span> bin_reader_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_binop"><span class="keyword">val</span> bin_size_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_binop"><span class="keyword">val</span> bin_write_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_binop"><span class="keyword">val</span> bin_writer_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_binop"><span class="keyword">val</span> compare_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> -> <a href="Bap.Std.html#TYPEbinop">binop</a> -> int</code></pre>
<pre><span id="VALbinop_of_sexp"><span class="keyword">val</span> binop_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEbinop">binop</a></code></pre>
<pre><span id="VALsexp_of_binop"><span class="keyword">val</span> sexp_of_binop</span> : <code class="type"><a href="Bap.Std.html#TYPEbinop">binop</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEcast"><span class="keyword">type</span> <code class="type"></code>cast</span> = <code class="type">Bil.cast</code> </pre>


<pre><span id="VALbin_cast"><span class="keyword">val</span> bin_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_cast"><span class="keyword">val</span> bin_read_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_cast__"><span class="keyword">val</span> __bin_read_cast__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEcast">cast</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_cast"><span class="keyword">val</span> bin_reader_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_cast"><span class="keyword">val</span> bin_size_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_cast"><span class="keyword">val</span> bin_write_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_cast"><span class="keyword">val</span> bin_writer_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_cast"><span class="keyword">val</span> compare_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> -> <a href="Bap.Std.html#TYPEcast">cast</a> -> int</code></pre>
<pre><span id="VALcast_of_sexp"><span class="keyword">val</span> cast_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEcast">cast</a></code></pre>
<pre><span id="VALsexp_of_cast"><span class="keyword">val</span> sexp_of_cast</span> : <code class="type"><a href="Bap.Std.html#TYPEcast">cast</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> = <code class="type">Bil.exp</code> </pre>


<pre><span id="VALbin_exp"><span class="keyword">val</span> bin_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_exp"><span class="keyword">val</span> bin_read_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_exp__"><span class="keyword">val</span> __bin_read_exp__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEexp">exp</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_exp"><span class="keyword">val</span> bin_reader_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_exp"><span class="keyword">val</span> bin_size_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_exp"><span class="keyword">val</span> bin_write_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_exp"><span class="keyword">val</span> bin_writer_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_exp"><span class="keyword">val</span> compare_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> -> <a href="Bap.Std.html#TYPEexp">exp</a> -> int</code></pre>
<pre><span id="VALexp_of_sexp"><span class="keyword">val</span> exp_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEexp">exp</a></code></pre>
<pre><span id="VALsexp_of_exp"><span class="keyword">val</span> sexp_of_exp</span> : <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEstmt"><span class="keyword">type</span> <code class="type"></code>stmt</span> = <code class="type">Bil.stmt</code> </pre>


<pre><span id="VALbin_stmt"><span class="keyword">val</span> bin_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_stmt"><span class="keyword">val</span> bin_read_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_stmt__"><span class="keyword">val</span> __bin_read_stmt__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEstmt">stmt</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_stmt"><span class="keyword">val</span> bin_reader_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_stmt"><span class="keyword">val</span> bin_size_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_stmt"><span class="keyword">val</span> bin_write_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_stmt"><span class="keyword">val</span> bin_writer_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_stmt"><span class="keyword">val</span> compare_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> -> <a href="Bap.Std.html#TYPEstmt">stmt</a> -> int</code></pre>
<pre><span id="VALstmt_of_sexp"><span class="keyword">val</span> stmt_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEstmt">stmt</a></code></pre>
<pre><span id="VALsexp_of_stmt"><span class="keyword">val</span> sexp_of_stmt</span> : <code class="type"><a href="Bap.Std.html#TYPEstmt">stmt</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEunop"><span class="keyword">type</span> <code class="type"></code>unop</span> = <code class="type">Bil.unop</code> </pre>


<pre><span id="VALbin_unop"><span class="keyword">val</span> bin_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_unop"><span class="keyword">val</span> bin_read_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_unop__"><span class="keyword">val</span> __bin_read_unop__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEunop">unop</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_unop"><span class="keyword">val</span> bin_reader_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_unop"><span class="keyword">val</span> bin_size_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_unop"><span class="keyword">val</span> bin_write_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_unop"><span class="keyword">val</span> bin_writer_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_unop"><span class="keyword">val</span> compare_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> -> <a href="Bap.Std.html#TYPEunop">unop</a> -> int</code></pre>
<pre><span id="VALunop_of_sexp"><span class="keyword">val</span> unop_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEunop">unop</a></code></pre>
<pre><span id="VALsexp_of_unop"><span class="keyword">val</span> sexp_of_unop</span> : <code class="type"><a href="Bap.Std.html#TYPEunop">unop</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEvalue"><span class="keyword">type</span> <code class="type"></code>value</span> </pre>


<pre><span id="VALbin_value"><span class="keyword">val</span> bin_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_value"><span class="keyword">val</span> bin_read_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_value__"><span class="keyword">val</span> __bin_read_value__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEvalue">value</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_value"><span class="keyword">val</span> bin_reader_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_value"><span class="keyword">val</span> bin_size_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_value"><span class="keyword">val</span> bin_write_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_value"><span class="keyword">val</span> bin_writer_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_value"><span class="keyword">val</span> compare_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> -> <a href="Bap.Std.html#TYPEvalue">value</a> -> int</code></pre>
<pre><span id="VALvalue_of_sexp"><span class="keyword">val</span> value_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEvalue">value</a></code></pre>
<pre><span id="VALsexp_of_value"><span class="keyword">val</span> sexp_of_value</span> : <code class="type"><a href="Bap.Std.html#TYPEvalue">value</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEdict"><span class="keyword">type</span> <code class="type"></code>dict</span> </pre>


<pre><span id="VALbin_dict"><span class="keyword">val</span> bin_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_dict"><span class="keyword">val</span> bin_read_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_dict__"><span class="keyword">val</span> __bin_read_dict__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEdict">dict</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_dict"><span class="keyword">val</span> bin_reader_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_dict"><span class="keyword">val</span> bin_size_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_dict"><span class="keyword">val</span> bin_write_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_dict"><span class="keyword">val</span> bin_writer_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_dict"><span class="keyword">val</span> compare_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> -> <a href="Bap.Std.html#TYPEdict">dict</a> -> int</code></pre>
<pre><span id="VALdict_of_sexp"><span class="keyword">val</span> dict_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEdict">dict</a></code></pre>
<pre><span id="VALsexp_of_dict"><span class="keyword">val</span> sexp_of_dict</span> : <code class="type"><a href="Bap.Std.html#TYPEdict">dict</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Context.html">Context</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Context.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Base class for evaluation contexts.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Type_error.html">Type_error</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Type_error.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="TYPEtype_error"><span class="keyword">type</span> <code class="type"></code>type_error</span> = <code class="type"><a href="Bap.Std.Type_error.html#TYPEt">Type_error.t</a></code> </pre>
<div class="info ">
A BIL type error<br>
</div>


<pre><span id="VALbin_type_error"><span class="keyword">val</span> bin_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_type_error"><span class="keyword">val</span> bin_read_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_type_error__"><span class="keyword">val</span> __bin_read_type_error__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEtype_error">type_error</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_type_error"><span class="keyword">val</span> bin_reader_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_type_error"><span class="keyword">val</span> bin_size_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_type_error"><span class="keyword">val</span> bin_write_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_type_error"><span class="keyword">val</span> bin_writer_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_type_error"><span class="keyword">val</span> compare_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> -> <a href="Bap.Std.html#TYPEtype_error">type_error</a> -> int</code></pre>
<pre><span id="VALtype_error_of_sexp"><span class="keyword">val</span> type_error_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEtype_error">type_error</a></code></pre>
<pre><span id="VALsexp_of_type_error"><span class="keyword">val</span> sexp_of_type_error</span> : <code class="type"><a href="Bap.Std.html#TYPEtype_error">type_error</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Expi.html">Expi</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Expi.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
BIL Interpreter.
</div>

<pre><span name="TYPEexpi"><span class="keyword">class</span> <code class="type">[#<a href="Bap.Std.Expi.context-c.html">Expi.context</a>]</code> <a href="Bap.Std.expi-c.html">expi</a></span> : <code class="type"></code><code class="type">[#<a href="Bap.Std.Expi.context-c.html">Expi.context</a> as 'a]</code> <code class="type"><a href="Bap.Std.Expi.t-c.html">Expi.t</a></code></pre><div class="info">
Expression <a href="Bap.Std.Expi.html">interpreter</a>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bili.html">Bili</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bili.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
BIL Interpreter.
</div>

<pre><span name="TYPEbili"><span class="keyword">class</span> <code class="type">[#<a href="Bap.Std.Bili.context-c.html">Bili.context</a>]</code> <a href="Bap.Std.bili-c.html">bili</a></span> : <code class="type"></code><code class="type">[#<a href="Bap.Std.Bili.context-c.html">Bili.context</a> as 'a]</code> <code class="type"><a href="Bap.Std.Bili.t-c.html">Bili.t</a></code></pre><div class="info">
BIL <a href="Bap.Std.Bili.html">interpreter</a>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Exp.html">Exp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Exp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Regular</span></code> interface for BIL expressions
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Stmt.html">Stmt</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Stmt.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Regular</span></code> interface for BIL statements
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arch.html">Arch</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Arch.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Architecture
</div>

<pre><span id="TYPEarch"><span class="keyword">type</span> <code class="type"></code>arch</span> = <code class="type"><a href="Bap.Std.Arch.html#TYPEt">Arch.t</a></code> </pre>
<div class="info ">
architecture<br>
</div>


<pre><span id="VALbin_arch"><span class="keyword">val</span> bin_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_arch"><span class="keyword">val</span> bin_read_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_arch__"><span class="keyword">val</span> __bin_read_arch__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEarch">arch</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_arch"><span class="keyword">val</span> bin_reader_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_arch"><span class="keyword">val</span> bin_size_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_arch"><span class="keyword">val</span> bin_write_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_arch"><span class="keyword">val</span> bin_writer_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_arch"><span class="keyword">val</span> compare_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEarch">arch</a> -> int</code></pre>
<pre><span id="VALarch_of_sexp"><span class="keyword">val</span> arch_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEarch">arch</a></code></pre>
<pre><span id="VALsexp_of_arch"><span class="keyword">val</span> sexp_of_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Value.html">Value</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Universal Values.
</div>

<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type">'a</code> tag</span> = <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">Value.tag</a></code> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Dict.html">Dict</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Dict.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Universal Heterogeneous Map.
</div>

<pre><span id="TYPEvector"><span class="keyword">type</span> <code class="type">'a</code> vector</span> </pre>
<div class="info ">
<a href="Bap.Std.Vector.html">Resizable array</a><br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Vector.html">Vector</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Vector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Resizable Array.
</div>

<pre><span id="TYPEterm"><span class="keyword">type</span> <code class="type">'a</code> term</span> </pre>
<div class="info ">
BAP IR.
<p>

      Program is a tree of terms.<br>
</div>


<pre><span id="VALbin_term"><span class="keyword">val</span> bin_term</span> : <code class="type">'a Bin_prot.Type_class.t -><br>       'a <a href="Bap.Std.html#TYPEterm">term</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_term"><span class="keyword">val</span> bin_read_term</span> : <code class="type">'a Bin_prot.Read.reader -><br>       'a <a href="Bap.Std.html#TYPEterm">term</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_term__"><span class="keyword">val</span> __bin_read_term__</span> : <code class="type">'a Bin_prot.Read.reader -><br>       (int -> 'a <a href="Bap.Std.html#TYPEterm">term</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_term"><span class="keyword">val</span> bin_reader_term</span> : <code class="type">'a Bin_prot.Type_class.reader -><br>       'a <a href="Bap.Std.html#TYPEterm">term</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_term"><span class="keyword">val</span> bin_size_term</span> : <code class="type">'a Bin_prot.Size.sizer -><br>       'a <a href="Bap.Std.html#TYPEterm">term</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_term"><span class="keyword">val</span> bin_write_term</span> : <code class="type">'a Bin_prot.Write.writer -><br>       'a <a href="Bap.Std.html#TYPEterm">term</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_term"><span class="keyword">val</span> bin_writer_term</span> : <code class="type">'a Bin_prot.Type_class.writer -><br>       'a <a href="Bap.Std.html#TYPEterm">term</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_term"><span class="keyword">val</span> compare_term</span> : <code class="type">('a -> 'a -> int) -> 'a <a href="Bap.Std.html#TYPEterm">term</a> -> 'a <a href="Bap.Std.html#TYPEterm">term</a> -> int</code></pre>
<pre><span id="VALterm_of_sexp"><span class="keyword">val</span> term_of_sexp</span> : <code class="type">(Sexplib.Sexp.t -> 'a) -> Sexplib.Sexp.t -> 'a <a href="Bap.Std.html#TYPEterm">term</a></code></pre>
<pre><span id="VALsexp_of_term"><span class="keyword">val</span> sexp_of_term</span> : <code class="type">('a -> Sexplib.Sexp.t) -> 'a <a href="Bap.Std.html#TYPEterm">term</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEprogram"><span class="keyword">type</span> <code class="type"></code>program</span> </pre>


<pre><span id="VALbin_program"><span class="keyword">val</span> bin_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_program"><span class="keyword">val</span> bin_read_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_program__"><span class="keyword">val</span> __bin_read_program__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEprogram">program</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_program"><span class="keyword">val</span> bin_reader_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_program"><span class="keyword">val</span> bin_size_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_program"><span class="keyword">val</span> bin_write_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_program"><span class="keyword">val</span> bin_writer_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_program"><span class="keyword">val</span> compare_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> -> <a href="Bap.Std.html#TYPEprogram">program</a> -> int</code></pre>
<pre><span id="VALprogram_of_sexp"><span class="keyword">val</span> program_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEprogram">program</a></code></pre>
<pre><span id="VALsexp_of_program"><span class="keyword">val</span> sexp_of_program</span> : <code class="type"><a href="Bap.Std.html#TYPEprogram">program</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEsub"><span class="keyword">type</span> <code class="type"></code>sub</span> </pre>


<pre><span id="VALbin_sub"><span class="keyword">val</span> bin_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_sub"><span class="keyword">val</span> bin_read_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_sub__"><span class="keyword">val</span> __bin_read_sub__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEsub">sub</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_sub"><span class="keyword">val</span> bin_reader_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_sub"><span class="keyword">val</span> bin_size_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_sub"><span class="keyword">val</span> bin_write_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_sub"><span class="keyword">val</span> bin_writer_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_sub"><span class="keyword">val</span> compare_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> -> <a href="Bap.Std.html#TYPEsub">sub</a> -> int</code></pre>
<pre><span id="VALsub_of_sexp"><span class="keyword">val</span> sub_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEsub">sub</a></code></pre>
<pre><span id="VALsexp_of_sub"><span class="keyword">val</span> sexp_of_sub</span> : <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEarg"><span class="keyword">type</span> <code class="type"></code>arg</span> </pre>


<pre><span id="VALbin_arg"><span class="keyword">val</span> bin_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_arg"><span class="keyword">val</span> bin_read_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_arg__"><span class="keyword">val</span> __bin_read_arg__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEarg">arg</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_arg"><span class="keyword">val</span> bin_reader_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_arg"><span class="keyword">val</span> bin_size_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_arg"><span class="keyword">val</span> bin_write_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_arg"><span class="keyword">val</span> bin_writer_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_arg"><span class="keyword">val</span> compare_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> -> <a href="Bap.Std.html#TYPEarg">arg</a> -> int</code></pre>
<pre><span id="VALarg_of_sexp"><span class="keyword">val</span> arg_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEarg">arg</a></code></pre>
<pre><span id="VALsexp_of_arg"><span class="keyword">val</span> sexp_of_arg</span> : <code class="type"><a href="Bap.Std.html#TYPEarg">arg</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEblk"><span class="keyword">type</span> <code class="type"></code>blk</span> </pre>


<pre><span id="VALbin_blk"><span class="keyword">val</span> bin_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_blk"><span class="keyword">val</span> bin_read_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_blk__"><span class="keyword">val</span> __bin_read_blk__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEblk">blk</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_blk"><span class="keyword">val</span> bin_reader_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_blk"><span class="keyword">val</span> bin_size_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_blk"><span class="keyword">val</span> bin_write_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_blk"><span class="keyword">val</span> bin_writer_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_blk"><span class="keyword">val</span> compare_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> -> <a href="Bap.Std.html#TYPEblk">blk</a> -> int</code></pre>
<pre><span id="VALblk_of_sexp"><span class="keyword">val</span> blk_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEblk">blk</a></code></pre>
<pre><span id="VALsexp_of_blk"><span class="keyword">val</span> sexp_of_blk</span> : <code class="type"><a href="Bap.Std.html#TYPEblk">blk</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEphi"><span class="keyword">type</span> <code class="type"></code>phi</span> </pre>


<pre><span id="VALbin_phi"><span class="keyword">val</span> bin_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_phi"><span class="keyword">val</span> bin_read_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_phi__"><span class="keyword">val</span> __bin_read_phi__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEphi">phi</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_phi"><span class="keyword">val</span> bin_reader_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_phi"><span class="keyword">val</span> bin_size_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_phi"><span class="keyword">val</span> bin_write_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_phi"><span class="keyword">val</span> bin_writer_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_phi"><span class="keyword">val</span> compare_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> -> <a href="Bap.Std.html#TYPEphi">phi</a> -> int</code></pre>
<pre><span id="VALphi_of_sexp"><span class="keyword">val</span> phi_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEphi">phi</a></code></pre>
<pre><span id="VALsexp_of_phi"><span class="keyword">val</span> sexp_of_phi</span> : <code class="type"><a href="Bap.Std.html#TYPEphi">phi</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEdef"><span class="keyword">type</span> <code class="type"></code>def</span> </pre>


<pre><span id="VALbin_def"><span class="keyword">val</span> bin_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_def"><span class="keyword">val</span> bin_read_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_def__"><span class="keyword">val</span> __bin_read_def__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEdef">def</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_def"><span class="keyword">val</span> bin_reader_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_def"><span class="keyword">val</span> bin_size_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_def"><span class="keyword">val</span> bin_write_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_def"><span class="keyword">val</span> bin_writer_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_def"><span class="keyword">val</span> compare_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> -> <a href="Bap.Std.html#TYPEdef">def</a> -> int</code></pre>
<pre><span id="VALdef_of_sexp"><span class="keyword">val</span> def_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEdef">def</a></code></pre>
<pre><span id="VALsexp_of_def"><span class="keyword">val</span> sexp_of_def</span> : <code class="type"><a href="Bap.Std.html#TYPEdef">def</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEjmp"><span class="keyword">type</span> <code class="type"></code>jmp</span> </pre>


<pre><span id="VALbin_jmp"><span class="keyword">val</span> bin_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_jmp"><span class="keyword">val</span> bin_read_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_jmp__"><span class="keyword">val</span> __bin_read_jmp__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEjmp">jmp</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_jmp"><span class="keyword">val</span> bin_reader_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_jmp"><span class="keyword">val</span> bin_size_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_jmp"><span class="keyword">val</span> bin_write_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_jmp"><span class="keyword">val</span> bin_writer_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_jmp"><span class="keyword">val</span> compare_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> -> <a href="Bap.Std.html#TYPEjmp">jmp</a> -> int</code></pre>
<pre><span id="VALjmp_of_sexp"><span class="keyword">val</span> jmp_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEjmp">jmp</a></code></pre>
<pre><span id="VALsexp_of_jmp"><span class="keyword">val</span> sexp_of_jmp</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp">jmp</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEnil"><span class="keyword">type</span> <code class="type"></code>nil</span> </pre>


<pre><span id="VALbin_nil"><span class="keyword">val</span> bin_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_nil"><span class="keyword">val</span> bin_read_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_nil__"><span class="keyword">val</span> __bin_read_nil__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEnil">nil</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_nil"><span class="keyword">val</span> bin_reader_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_nil"><span class="keyword">val</span> bin_size_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_nil"><span class="keyword">val</span> bin_write_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_nil"><span class="keyword">val</span> bin_writer_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_nil"><span class="keyword">val</span> compare_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> -> <a href="Bap.Std.html#TYPEnil">nil</a> -> int</code></pre>
<pre><span id="VALnil_of_sexp"><span class="keyword">val</span> nil_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEnil">nil</a></code></pre>
<pre><span id="VALsexp_of_nil"><span class="keyword">val</span> sexp_of_nil</span> : <code class="type"><a href="Bap.Std.html#TYPEnil">nil</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEtid"><span class="keyword">type</span> <code class="type"></code>tid</span> </pre>


<pre><span id="VALbin_tid"><span class="keyword">val</span> bin_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_tid"><span class="keyword">val</span> bin_read_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_tid__"><span class="keyword">val</span> __bin_read_tid__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEtid">tid</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_tid"><span class="keyword">val</span> bin_reader_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_tid"><span class="keyword">val</span> bin_size_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_tid"><span class="keyword">val</span> bin_write_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_tid"><span class="keyword">val</span> bin_writer_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_tid"><span class="keyword">val</span> compare_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> -> <a href="Bap.Std.html#TYPEtid">tid</a> -> int</code></pre>
<pre><span id="VALtid_of_sexp"><span class="keyword">val</span> tid_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEtid">tid</a></code></pre>
<pre><span id="VALsexp_of_tid"><span class="keyword">val</span> sexp_of_tid</span> : <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEcall"><span class="keyword">type</span> <code class="type"></code>call</span> </pre>


<pre><span id="VALbin_call"><span class="keyword">val</span> bin_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_call"><span class="keyword">val</span> bin_read_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_call__"><span class="keyword">val</span> __bin_read_call__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEcall">call</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_call"><span class="keyword">val</span> bin_reader_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_call"><span class="keyword">val</span> bin_size_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_call"><span class="keyword">val</span> bin_write_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_call"><span class="keyword">val</span> bin_writer_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_call"><span class="keyword">val</span> compare_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> -> <a href="Bap.Std.html#TYPEcall">call</a> -> int</code></pre>
<pre><span id="VALcall_of_sexp"><span class="keyword">val</span> call_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEcall">call</a></code></pre>
<pre><span id="VALsexp_of_call"><span class="keyword">val</span> sexp_of_call</span> : <code class="type"><a href="Bap.Std.html#TYPEcall">call</a> -> Sexplib.Sexp.t</code></pre>
<pre><code><span id="TYPElabel"><span class="keyword">type</span> <code class="type"></code>label</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Direct"><span class="constructor">Direct</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
direct jump<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Indirect"><span class="constructor">Indirect</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a></code></code></td>

</tr></table>

<div class="info ">
target of control transfer<br>
</div>


<pre><span id="VALbin_label"><span class="keyword">val</span> bin_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_label"><span class="keyword">val</span> bin_read_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_label__"><span class="keyword">val</span> __bin_read_label__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPElabel">label</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_label"><span class="keyword">val</span> bin_reader_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_label"><span class="keyword">val</span> bin_size_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_label"><span class="keyword">val</span> bin_write_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_label"><span class="keyword">val</span> bin_writer_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_label"><span class="keyword">val</span> compare_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> -> <a href="Bap.Std.html#TYPElabel">label</a> -> int</code></pre>
<pre><span id="VALlabel_of_sexp"><span class="keyword">val</span> label_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPElabel">label</a></code></pre>
<pre><span id="VALsexp_of_label"><span class="keyword">val</span> sexp_of_label</span> : <code class="type"><a href="Bap.Std.html#TYPElabel">label</a> -> Sexplib.Sexp.t</code></pre>
<pre><code><span id="TYPEjmp_kind"><span class="keyword">type</span> <code class="type"></code>jmp_kind</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Call"><span class="constructor">Call</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEcall">call</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
call to subroutine<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Goto"><span class="constructor">Goto</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPElabel">label</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
jump inside subroutine<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Ret"><span class="constructor">Ret</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPElabel">label</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
return from call to label<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Int"><span class="constructor">Int</span></span> <span class="keyword">of</span> <code class="type">int * <a href="Bap.Std.html#TYPEtid">tid</a></code></code></td>

</tr></table>

<div class="info ">
control transfer variants<br>
</div>


<pre><span id="VALbin_jmp_kind"><span class="keyword">val</span> bin_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_jmp_kind"><span class="keyword">val</span> bin_read_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_jmp_kind__"><span class="keyword">val</span> __bin_read_jmp_kind__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_jmp_kind"><span class="keyword">val</span> bin_reader_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_jmp_kind"><span class="keyword">val</span> bin_size_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_jmp_kind"><span class="keyword">val</span> bin_write_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_jmp_kind"><span class="keyword">val</span> bin_writer_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_jmp_kind"><span class="keyword">val</span> compare_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> -> <a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> -> int</code></pre>
<pre><span id="VALjmp_kind_of_sexp"><span class="keyword">val</span> jmp_kind_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a></code></pre>
<pre><span id="VALsexp_of_jmp_kind"><span class="keyword">val</span> sexp_of_jmp_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEjmp_kind">jmp_kind</a> -> Sexplib.Sexp.t</code></pre>
<pre><code><span id="TYPEintent"><span class="keyword">type</span> <code class="type"></code>intent</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.In"><span class="constructor">In</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
input argument<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.Out"><span class="constructor">Out</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
output argument<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.Both"><span class="constructor">Both</span></span></code></td>

</tr></table>

<div class="info ">
argument intention<br>
</div>


<pre><span id="VALbin_intent"><span class="keyword">val</span> bin_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_intent"><span class="keyword">val</span> bin_read_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_intent__"><span class="keyword">val</span> __bin_read_intent__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEintent">intent</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_intent"><span class="keyword">val</span> bin_reader_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_intent"><span class="keyword">val</span> bin_size_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_intent"><span class="keyword">val</span> bin_write_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_intent"><span class="keyword">val</span> bin_writer_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_intent"><span class="keyword">val</span> compare_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> -> <a href="Bap.Std.html#TYPEintent">intent</a> -> int</code></pre>
<pre><span id="VALintent_of_sexp"><span class="keyword">val</span> intent_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEintent">intent</a></code></pre>
<pre><span id="VALsexp_of_intent"><span class="keyword">val</span> sexp_of_intent</span> : <code class="type"><a href="Bap.Std.html#TYPEintent">intent</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEcls"><span class="keyword">type</span> <code class="type">('a, 'b)</code> cls</span> </pre>

<br>
<h4 id="4_Termtypeclasses">Term type classes</h4><br>

<pre><span id="VALprogram_t"><span class="keyword">val</span> program_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEnil">nil</a>, <a href="Bap.Std.html#TYPEprogram">program</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
program<br>
</div>

<pre><span id="VALsub_t"><span class="keyword">val</span> sub_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEprogram">program</a>, <a href="Bap.Std.html#TYPEsub">sub</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
sub<br>
</div>

<pre><span id="VALarg_t"><span class="keyword">val</span> arg_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEsub">sub</a>, <a href="Bap.Std.html#TYPEarg">arg</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
arg<br>
</div>

<pre><span id="VALblk_t"><span class="keyword">val</span> blk_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEsub">sub</a>, <a href="Bap.Std.html#TYPEblk">blk</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
blk<br>
</div>

<pre><span id="VALphi_t"><span class="keyword">val</span> phi_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEphi">phi</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
phi<br>
</div>

<pre><span id="VALdef_t"><span class="keyword">val</span> def_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEdef">def</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
def<br>
</div>

<pre><span id="VALjmp_t"><span class="keyword">val</span> jmp_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEjmp">jmp</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
jmp<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Biri.html">Biri</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Biri.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
BIR Interpreter
</div>

<pre><span name="TYPEbiri"><span class="keyword">class</span> <code class="type">[#<a href="Bap.Std.Biri.context-c.html">Biri.context</a>]</code> <a href="Bap.Std.biri-c.html">biri</a></span> : <code class="type"></code><code class="type">[#<a href="Bap.Std.Biri.context-c.html">Biri.context</a> as 'a]</code> <code class="type"><a href="Bap.Std.Biri.t-c.html">Biri.t</a></code></pre><div class="info">
BIR <a href="Bap.Std.Biri.html">interpreter</a>
</div>
<br>
<h3 id="3_Somepredefinedtags">Some predefined tags</h3><br>

<pre><span id="TYPEcolor"><span class="keyword">type</span> <code class="type"></code>color</span> = <code class="type">[ `black<br>       | `blue<br>       | `cyan<br>       | `gray<br>       | `green<br>       | `magenta<br>       | `red<br>       | `white<br>       | `yellow ]</code> </pre>


<pre><span id="VALbin_color"><span class="keyword">val</span> bin_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_color"><span class="keyword">val</span> bin_read_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_color__"><span class="keyword">val</span> __bin_read_color__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEcolor">color</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_color"><span class="keyword">val</span> bin_reader_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_color"><span class="keyword">val</span> bin_size_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_color"><span class="keyword">val</span> bin_write_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_color"><span class="keyword">val</span> bin_writer_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_color"><span class="keyword">val</span> compare_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> -> <a href="Bap.Std.html#TYPEcolor">color</a> -> int</code></pre>
<pre><span id="VALcolor_of_sexp"><span class="keyword">val</span> color_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEcolor">color</a></code></pre>
<pre><span id="VAL__color_of_sexp__"><span class="keyword">val</span> __color_of_sexp__</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEcolor">color</a></code></pre>
<pre><span id="VALsexp_of_color"><span class="keyword">val</span> sexp_of_color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="VALcolor"><span class="keyword">val</span> color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Color something with a color<br>
</div>

<pre><span id="VALforeground"><span class="keyword">val</span> foreground</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
print marked entity with the specified color.  (the same
      as color, but pretty printing function will output ascii escape
      sequence of corresponding color.<br>
</div>

<pre><span id="VALbackground"><span class="keyword">val</span> background</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
print marked entity with specified color. See <code class="code">foreground</code>.<br>
</div>

<pre><span id="VALcomment"><span class="keyword">val</span> comment</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A human readable comment<br>
</div>

<pre><span id="VALpython"><span class="keyword">val</span> python</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A command in python language<br>
</div>

<pre><span id="VALshell"><span class="keyword">val</span> shell</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A command in shell language<br>
</div>

<pre><span id="VALmark"><span class="keyword">val</span> mark</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Mark something as marked<br>
</div>

<pre><span id="VALweight"><span class="keyword">val</span> weight</span> : <code class="type">float <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Give a weight<br>
</div>

<pre><span id="VALaddress"><span class="keyword">val</span> address</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A virtual address of an entity<br>
</div>

<pre><span id="VALfilename"><span class="keyword">val</span> filename</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A name of a file<br>
</div>

<pre><span id="TYPEimage"><span class="keyword">type</span> <code class="type"></code>image</span> </pre>
<div class="info ">
an image loaded into memory<br>
</div>


<pre><span id="TYPEmem"><span class="keyword">type</span> <code class="type"></code>mem</span> </pre>
<div class="info ">
opaque memory<br>
</div>


<pre><span id="VALsexp_of_mem"><span class="keyword">val</span> sexp_of_mem</span> : <code class="type"><a href="Bap.Std.html#TYPEmem">mem</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEtable"><span class="keyword">type</span> <code class="type">'a</code> table</span> </pre>
<div class="info ">
a table from memory to <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="VALsexp_of_table"><span class="keyword">val</span> sexp_of_table</span> : <code class="type">('a -> Sexplib.Sexp.t) -> 'a <a href="Bap.Std.html#TYPEtable">table</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEmemmap"><span class="keyword">type</span> <code class="type">'a</code> memmap</span> </pre>
<div class="info ">
interval trees from memory regions to <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="VALsexp_of_memmap"><span class="keyword">val</span> sexp_of_memmap</span> : <code class="type">('a -> Sexplib.Sexp.t) -> 'a <a href="Bap.Std.html#TYPEmemmap">memmap</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module type</span> <a href="Bap.Std.Memory_iterators.html">Memory_iterators</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory_iterators.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Iterators lifted into monad
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.html">Memory</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Memory region
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Table.html">Table</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Table.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Table.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Location.html">Location</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Location.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A locations of a chunk of memory
</div>

<pre><span id="TYPElocation"><span class="keyword">type</span> <code class="type"></code>location</span> = <code class="type"><a href="Bap.Std.Location.html#TYPEt">Location.t</a></code> </pre>
<div class="info ">
memory location<br>
</div>


<pre><span id="VALbin_location"><span class="keyword">val</span> bin_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_location"><span class="keyword">val</span> bin_read_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_location__"><span class="keyword">val</span> __bin_read_location__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPElocation">location</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_location"><span class="keyword">val</span> bin_reader_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_location"><span class="keyword">val</span> bin_size_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_location"><span class="keyword">val</span> bin_write_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_location"><span class="keyword">val</span> bin_writer_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_location"><span class="keyword">val</span> compare_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> -> <a href="Bap.Std.html#TYPElocation">location</a> -> int</code></pre>
<pre><span id="VALlocation_of_sexp"><span class="keyword">val</span> location_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPElocation">location</a></code></pre>
<pre><span id="VALsexp_of_location"><span class="keyword">val</span> sexp_of_location</span> : <code class="type"><a href="Bap.Std.html#TYPElocation">location</a> -> Sexplib.Sexp.t</code></pre><br>
A backend interface.
<p>

      This interface must be implemented by a backend plugin, and
      registered with <code class="code"><span class="constructor">Image</span>.register</code> function in order to be
      accessible for loading images.<br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Backend.html">Backend</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Backend.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Image.html">Image</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Image.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Binary Image.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memmap.html">Memmap</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memmap.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Memory maps.
</div>

<pre><span id="TYPEsymbolizer"><span class="keyword">type</span> <code class="type"></code>symbolizer</span> </pre>
<div class="info ">
Symbolizer defines a method for assigning symbolic names to addresses<br>
</div>


<pre><span id="TYPErooter"><span class="keyword">type</span> <code class="type"></code>rooter</span> </pre>
<div class="info ">
Rooter defines a method for finding function starts in a program<br>
</div>


<pre><span id="TYPEbrancher"><span class="keyword">type</span> <code class="type"></code>brancher</span> </pre>
<div class="info ">
Brancher defines a method for resolving branch instruction<br>
</div>


<pre><span id="TYPEreconstructor"><span class="keyword">type</span> <code class="type"></code>reconstructor</span> </pre>
<div class="info ">
Reconstructor  defines a method for reconstructing symbol tables<br>
</div>


<pre><span id="TYPEdisasm"><span class="keyword">type</span> <code class="type"></code>disasm</span> </pre>
<div class="info ">
value of type <code class="code">disasm</code> is a result of the disassembling of a
      memory region.<br>
</div>


<pre><span id="TYPEinsn"><span class="keyword">type</span> <code class="type"></code>insn</span> </pre>
<div class="info ">
values of type <code class="code">insn</code> represents machine instructions decoded
      from the a given piece of memory<br>
</div>


<pre><span id="VALbin_insn"><span class="keyword">val</span> bin_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_insn"><span class="keyword">val</span> bin_read_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_insn__"><span class="keyword">val</span> __bin_read_insn__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEinsn">insn</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_insn"><span class="keyword">val</span> bin_reader_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_insn"><span class="keyword">val</span> bin_size_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_insn"><span class="keyword">val</span> bin_write_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_insn"><span class="keyword">val</span> bin_writer_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_insn"><span class="keyword">val</span> compare_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> -> <a href="Bap.Std.html#TYPEinsn">insn</a> -> int</code></pre>
<pre><span id="VALsexp_of_insn"><span class="keyword">val</span> sexp_of_insn</span> : <code class="type"><a href="Bap.Std.html#TYPEinsn">insn</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEblock"><span class="keyword">type</span> <code class="type"></code>block</span> </pre>
<div class="info ">
<code class="code">block</code> is a region of memory that is believed to be a basic block
      of control flow graph to the best of our knowledge.<br>
</div>


<pre><span id="VALcompare_block"><span class="keyword">val</span> compare_block</span> : <code class="type"><a href="Bap.Std.html#TYPEblock">block</a> -> <a href="Bap.Std.html#TYPEblock">block</a> -> int</code></pre>
<pre><span id="VALsexp_of_block"><span class="keyword">val</span> sexp_of_block</span> : <code class="type"><a href="Bap.Std.html#TYPEblock">block</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEcfg"><span class="keyword">type</span> <code class="type"></code>cfg</span> </pre>


<pre><span id="VALcompare_cfg"><span class="keyword">val</span> compare_cfg</span> : <code class="type"><a href="Bap.Std.html#TYPEcfg">cfg</a> -> <a href="Bap.Std.html#TYPEcfg">cfg</a> -> int</code></pre>
<pre><span id="TYPEjump"><span class="keyword">type</span> <code class="type"></code>jump</span> = <code class="type">[ `Cond | `Jump ]</code> </pre>
<div class="info ">
a jump kind.
      A jump to another block can be conditional or unconditional.<br>
</div>


<pre><span id="VALcompare_jump"><span class="keyword">val</span> compare_jump</span> : <code class="type"><a href="Bap.Std.html#TYPEjump">jump</a> -> <a href="Bap.Std.html#TYPEjump">jump</a> -> int</code></pre>
<pre><span id="VALjump_of_sexp"><span class="keyword">val</span> jump_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEjump">jump</a></code></pre>
<pre><span id="VAL__jump_of_sexp__"><span class="keyword">val</span> __jump_of_sexp__</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEjump">jump</a></code></pre>
<pre><span id="VALsexp_of_jump"><span class="keyword">val</span> sexp_of_jump</span> : <code class="type"><a href="Bap.Std.html#TYPEjump">jump</a> -> Sexplib.Sexp.t</code></pre><div class="info ">
This type defines a relation between two basic blocks.<br>
</div>

<pre><span id="TYPEedge"><span class="keyword">type</span> <code class="type"></code>edge</span> = <code class="type">[ `Cond | `Fall | `Jump ]</code> </pre>


<pre><span id="VALcompare_edge"><span class="keyword">val</span> compare_edge</span> : <code class="type"><a href="Bap.Std.html#TYPEedge">edge</a> -> <a href="Bap.Std.html#TYPEedge">edge</a> -> int</code></pre>
<pre><span id="VALedge_of_sexp"><span class="keyword">val</span> edge_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEedge">edge</a></code></pre>
<pre><span id="VAL__edge_of_sexp__"><span class="keyword">val</span> __edge_of_sexp__</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEedge">edge</a></code></pre>
<pre><span id="VALsexp_of_edge"><span class="keyword">val</span> sexp_of_edge</span> : <code class="type"><a href="Bap.Std.html#TYPEedge">edge</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Kind.html">Kind</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Kind.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Kinds of instructions
</div>

<pre><span id="TYPEreg"><span class="keyword">type</span> <code class="type"></code>reg</span> </pre>
<div class="info ">
abstract and opaque register<br>
</div>


<pre><span id="VALbin_reg"><span class="keyword">val</span> bin_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_reg"><span class="keyword">val</span> bin_read_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_reg__"><span class="keyword">val</span> __bin_read_reg__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEreg">reg</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_reg"><span class="keyword">val</span> bin_reader_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_reg"><span class="keyword">val</span> bin_size_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_reg"><span class="keyword">val</span> bin_write_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_reg"><span class="keyword">val</span> bin_writer_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_reg"><span class="keyword">val</span> compare_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> -> <a href="Bap.Std.html#TYPEreg">reg</a> -> int</code></pre>
<pre><span id="VALreg_of_sexp"><span class="keyword">val</span> reg_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEreg">reg</a></code></pre>
<pre><span id="VALsexp_of_reg"><span class="keyword">val</span> sexp_of_reg</span> : <code class="type"><a href="Bap.Std.html#TYPEreg">reg</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEimm"><span class="keyword">type</span> <code class="type"></code>imm</span> </pre>
<div class="info ">
opaque immediate value<br>
</div>


<pre><span id="VALbin_imm"><span class="keyword">val</span> bin_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_imm"><span class="keyword">val</span> bin_read_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_imm__"><span class="keyword">val</span> __bin_read_imm__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEimm">imm</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_imm"><span class="keyword">val</span> bin_reader_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_imm"><span class="keyword">val</span> bin_size_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_imm"><span class="keyword">val</span> bin_write_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_imm"><span class="keyword">val</span> bin_writer_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_imm"><span class="keyword">val</span> compare_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> -> <a href="Bap.Std.html#TYPEimm">imm</a> -> int</code></pre>
<pre><span id="VALimm_of_sexp"><span class="keyword">val</span> imm_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEimm">imm</a></code></pre>
<pre><span id="VALsexp_of_imm"><span class="keyword">val</span> sexp_of_imm</span> : <code class="type"><a href="Bap.Std.html#TYPEimm">imm</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEfmm"><span class="keyword">type</span> <code class="type"></code>fmm</span> </pre>
<div class="info ">
floating point value<br>
</div>


<pre><span id="VALbin_fmm"><span class="keyword">val</span> bin_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_fmm"><span class="keyword">val</span> bin_read_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_fmm__"><span class="keyword">val</span> __bin_read_fmm__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEfmm">fmm</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_fmm"><span class="keyword">val</span> bin_reader_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_fmm"><span class="keyword">val</span> bin_size_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_fmm"><span class="keyword">val</span> bin_write_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_fmm"><span class="keyword">val</span> bin_writer_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_fmm"><span class="keyword">val</span> compare_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> -> <a href="Bap.Std.html#TYPEfmm">fmm</a> -> int</code></pre>
<pre><span id="VALfmm_of_sexp"><span class="keyword">val</span> fmm_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEfmm">fmm</a></code></pre>
<pre><span id="VALsexp_of_fmm"><span class="keyword">val</span> sexp_of_fmm</span> : <code class="type"><a href="Bap.Std.html#TYPEfmm">fmm</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="TYPEkind"><span class="keyword">type</span> <code class="type"></code>kind</span> = <code class="type"><a href="Bap.Std.Kind.html#TYPEt">Kind.t</a></code> </pre>
<div class="info ">
kind of instruction<br>
</div>


<pre><span id="VALbin_kind"><span class="keyword">val</span> bin_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_kind"><span class="keyword">val</span> bin_read_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_kind__"><span class="keyword">val</span> __bin_read_kind__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEkind">kind</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_kind"><span class="keyword">val</span> bin_reader_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_kind"><span class="keyword">val</span> bin_size_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_kind"><span class="keyword">val</span> bin_write_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_kind"><span class="keyword">val</span> bin_writer_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_kind"><span class="keyword">val</span> compare_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> -> <a href="Bap.Std.html#TYPEkind">kind</a> -> int</code></pre>
<pre><span id="VALkind_of_sexp"><span class="keyword">val</span> kind_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap.Std.html#TYPEkind">kind</a></code></pre>
<pre><span id="VALsexp_of_kind"><span class="keyword">val</span> sexp_of_kind</span> : <code class="type"><a href="Bap.Std.html#TYPEkind">kind</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Reg.html">Reg</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Reg.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Register.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Imm.html">Imm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Imm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Integer immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Fmm.html">Fmm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Fmm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Floating point immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Op.html">Op</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Op.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Operand
</div>

<pre><span id="TYPEop"><span class="keyword">type</span> <code class="type"></code>op</span> = <code class="type"><a href="Bap.Std.Op.html#TYPEt">Op.t</a></code> </pre>


<pre><span id="VALbin_op"><span class="keyword">val</span> bin_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_op"><span class="keyword">val</span> bin_read_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_op__"><span class="keyword">val</span> __bin_read_op__</span> : <code class="type">(int -> <a href="Bap.Std.html#TYPEop">op</a>) Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_op"><span class="keyword">val</span> bin_reader_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_op"><span class="keyword">val</span> bin_size_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_op"><span class="keyword">val</span> bin_write_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_op"><span class="keyword">val</span> bin_writer_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> Bin_prot.Type_class.writer</code></pre>
<pre><span id="VALcompare_op"><span class="keyword">val</span> compare_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> -> <a href="Bap.Std.html#TYPEop">op</a> -> int</code></pre>
<pre><span id="VALsexp_of_op"><span class="keyword">val</span> sexp_of_op</span> : <code class="type"><a href="Bap.Std.html#TYPEop">op</a> -> Sexplib.Sexp.t</code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm_expert.html">Disasm_expert</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Disasm_expert.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Expert interface to disassembler.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Insn.html">Insn</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Insn.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Assembly instruction.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Block.html">Block</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Access to block attributes.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Graphs.html">Graphs</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Graphs.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm.html">Disasm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Disasm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Disassembled program.
</div>

<pre><span id="TYPEsymtab"><span class="keyword">type</span> <code class="type"></code>symtab</span> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Symtab.html">Symtab</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Symtab.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Reconstructed symbol table.
</div>

<pre><span id="TYPElifter"><span class="keyword">type</span> <code class="type"></code>lifter</span> = <code class="type"><a href="Bap.Std.html#TYPEmem">mem</a> -><br>       <a href="Bap.Std.Disasm_expert.Basic.html#TYPEfull_insn">Disasm_expert.Basic.full_insn</a> -><br>       <a href="Bap.Std.html#TYPEbil">bil</a> Or_error.t</code> </pre>

<br>
A BIL model of CPU
<p>

      In general this is a model of a processor architecture, involving
      ALU, processing unit, registers and memory.<br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.CPU.html">CPU</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.CPU.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract interface to CPU
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Target.html">Target</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Target.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract interface for all targets.
</div>

<pre><span id="VALtarget_of_arch"><span class="keyword">val</span> target_of_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> (module Bap.Std.Target)</code></pre><div class="info ">
<code class="code">target_of_arch arch</code> returns a module packed into value, that
      abstracts target architecture. The returned module has type
      <a href="Bap.Std.Target.html"><code class="code"><span class="constructor">Target</span></code></a> and can be unpacked locally with:
      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">module</span>&nbsp;<span class="constructor">Target</span>&nbsp;=&nbsp;(<span class="keyword">val</span>&nbsp;target_of_arch&nbsp;arch)&nbsp;<span class="keyword">in</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><br>
</div>

<pre><span id="VALregister_target"><span class="keyword">val</span> register_target</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> (module Bap.Std.Target) -> unit</code></pre><div class="info ">
Register new target architecture. If target for the given arch
      already exists, then it will be superseeded by the new
      target.<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Tid.html">Tid</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Tid.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Term identifier
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Term.html">Term</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Term.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
IR language term.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Program.html">Program</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Program.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Program in Intermediate representation.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Sub.html">Sub</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Sub.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Blk.html">Blk</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Blk.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Block.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Def.html">Def</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Def.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Definition.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Jmp.html">Jmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Jmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A control transfer operation.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Phi.html">Phi</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Phi.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
PHI-node
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arg.html">Arg</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Arg.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine argument.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Call.html">Call</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Call.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A control transfer to another subroutine.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Label.html">Label</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Label.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Target of a control flow transfer.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Source.html">Source</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Source.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Source of information.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Taint.html">Taint</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Taint.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract taint.
</div>

<pre><span id="TYPEsource"><span class="keyword">type</span> <code class="type">'a</code> source</span> = <code class="type">'a <a href="Bap.Std.Source.html#TYPEt">Source.t</a></code> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Symbolizer.html">Symbolizer</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Symbolizer.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Symbolizer maps addresses to function names
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Rooter.html">Rooter</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Rooter.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Rooter find start of functions in the binary.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Brancher.html">Brancher</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Brancher.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Brancher is responsible for resolving destinations of branch
      instructions.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Reconstructor.html">Reconstructor</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Reconstructor.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Reconstructor is responsible for reconstructing symbol table
      from a CFG.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Event.html">Event</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Event.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="TYPEevent"><span class="keyword">type</span> <code class="type"></code>event</span> = <code class="type"><a href="Bap.Std.Event.html#TYPEt">Event.t</a></code> = ..</pre>


<pre><span id="TYPEproject"><span class="keyword">type</span> <code class="type"></code>project</span> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Project.html">Project</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Target of analysis.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Log.html">Log</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Log.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>