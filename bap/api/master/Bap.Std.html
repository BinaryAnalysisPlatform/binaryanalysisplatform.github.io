<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Bap.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html"><link title="Binary Analysis Platform Library" rel="Section" href="#1_BinaryAnalysisPlatformLibrary">
<link title="BAP API" rel="Section" href="#api">
<link title="Overview" rel="Subsection" href="#2_Overview">
<link title="Foundation Library" rel="Subsection" href="#bfl">
<link title="Memory model" rel="Subsection" href="#image">
<link title="Disassembler" rel="Subsection" href="#disasm">
<link title="Semantic Analysis" rel="Subsection" href="#sema">
<link title="Working with project" rel="Subsection" href="#project">
<link title="Auxiliary libraries" rel="Subsection" href="#aux">
<title>Bap.Std</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Bap.html" title="Bap">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Bap.Std.html">Bap.Std</a></h1>

<pre><span class="keyword">module</span> Std: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><hr width="100%">
<br>
<h1 id="1_BinaryAnalysisPlatformLibrary">Binary Analysis Platform Library</h1><br>
<br>
<h2 id="2_Overview">Overview</h2>
<p>

      BAP has a layered architecture consisting of four
      layers. Although the layers are not really observable from outside
      of the library, they make it easier to learn the library, as
      they introduce new concepts sequentially. On top of this layers,
      the <a href="Bap.Std.html#project">Project</a> module is defined, that
      consolidates all information about target of an
      analysis. <code class="code"><span class="constructor">Project</span></code> module may be viewed as an entry point to
      the library.
<p>

      <pre class="verbatim">        +-----------------------------------------------------+
        | +--------+   +-----------------------------------+  |
        | |        |   |                                   |  |
        | |        |   |       Foundation Library          |  |
        | |        |   |                                   |  |
        | |        |   +-----------------------------------+  |
        | |   P    |                                          |
        | |        |   +-----------------------------------+  |
        | |   R    |   |                                   |  |
        | |        |   |          Memory Model             |  |
        | |   O    |   |                                   |  |
        | |        |   +-----------------------------------+  |
        | |   J    |                                          |
        | |        |   +-----------------------------------+  |
        | |   E    |   |                                   |  |
        | |        |   |           Disassembly             |  |
        | |   C    |   |                                   |  |
        | |        |   +-----------------------------------+  |
        | |   T    |                                          |
        | |        |   +-----------------------------------+  |
        | |        |   |                                   |  |
        | |        |   |        Semantic Analysis          |  |
        | |        |   |                                   |  |
        | +--------+   +-----------------------------------+  |
        +-----------------------------------------------------+
     </pre>
<p>

      The <a href="Bap.Std.html#bfl">Foundation library</a> defines <a href="Bap.Std.Bil.html">BAP Instruction
      language</a> data types, as well as other useful data structures,
      like <a href="Bap.Std.Value.html"><code class="code"><span class="constructor">Value</span></code></a>, <a href="Bap.Std.Trie.html"><code class="code"><span class="constructor">Trie</span></code></a>, <a href="Bap.Std.Vector.html"><code class="code"><span class="constructor">Vector</span></code></a>, <a href="Bap.Std.Graph.html"><code class="code"><span class="constructor">Graph</span></code></a>, etc. The
      <a href="Bap.Std.html#image">Memory model</a> layer is responsible for loading
      and parsing binary objects and representing them in computer
      memory. It also defines a few useful data structures that are
      used extensively by later layers, like <a href="Bap.Std.Table.html"><code class="code"><span class="constructor">Table</span></code></a> and
      <a href="Bap.Std.Memmap.html"><code class="code"><span class="constructor">Memmap</span></code></a>. The next layer performs
      <a href="Bap.Std.html#disasm">disassembly</a> and lifting to BIL. Finally, the
      <a href="Bap.Std.html#sema">semantic analysis</a> layer transforms a binary
      into an IR representation, that is suitable for writing analysis.
<p>

      Another important point of view is the BAP plugin architecture.
      Similar to GIMP or Frama-C, BAP features a pluggable architecture
      with a number of extension points. For example, even the LLVM
      disassembler is considered a type of plugin.  Currently we
      support three such extension points in BAP:
<p>
<ul>
<li><a href="Bap.Std.Backend.html">loaders</a> - to add new binary object loaders;</li>
<li>disassemblers - to add new disassemblers;</li>
<li><a href="Bap.Std.html#project">program analysis</a> - to write analysis.</li>
</ul>

      The latter category of plugins is most widely used. Therefore,
      when we use the term "plugin" without making a distinction, we
      refer to a program analysis plugin. The following figure
      provides an overview of the BAP system.
<p>

      <pre class="verbatim">        +---------------------------------------------+
        |  +----------------+    +-----------------+  |
        |  |    Loader      |    |  Disassembler   |  |
        |  |    Plugins     |    |    Plugins      |  |
        |  +-------+--------+    +--------+--------+  |
        |          |                      |           |
        |  +-------+----------------------+--------+  |
        |  |                                       |  |
        |  |             BAP Library               |  |
        |  |                                       |  |
        |  +-------+-------------------------------+  |
        |          ^                      ^           |
        |          |                      |           |
        |  +-------+--------+    +--------+--------+  |
        |  |                |    |                 |  |
        |  |  BAP toolkit   |&lt;--&gt;|   BAP Plugins   |  |
        |  |                |    |                 |  |
        |  +----------------+    +-----------------+  |
        +---------------------------------------------+
     </pre>
<p>

      All plugins have full access to the library; an important
      consequence is that they can and should open <code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span></code>. The BAP
      library uses backend loader and disassembler plugins to provide
      its services. Program analysis plugins are loaded by BAP
      toolkit utilities. These utilities extend plugin functionality
      by providing access to the state of the target of analysis or,
      in our parlance, to the <a href="Bap.Std.html#TYPEproject">project</a>. (See
      <a href="Bap.Std.html#project"><i>Working with project</i></a>).
<p>

      Other than library itself, and the BAP toolkit, there are two
      additional libraries that are bundled with BAP:
<p>
<ul>
<li><code class="code">bap.plugins</code> to dynamically load code into BAP;</li>
<li><code class="code">bap.serialization</code> to serialize BAP data structures in
        different formats.</li>
</ul>
<br>
<br>
<h2 id="bfl">Foundation Library</h2>
<p>

      At this layer we define (<a href="Bap.Std.Bil.html">Binary Instruction language</a>)
      and few other useful data structures:
<p>
<ul>
<li><a href="Bap.Std.Arch.html">arch</a> - describes computer architecture;</li>
<li><a href="Bap.Std.Size.html">size</a> - word and register sizes;</li>
<li><a href="Bap.Std.Var.html">var</a>  - <a href="Bap.Std.Bil.html">BIL</a> variable;</li>
<li><a href="Bap.Std.Type.html">typ</a> - <a href="Bap.Std.Bil.html">BIL</a> type system;</li>
<li><a href="Bap.Std.Exp.html">exp</a>  - <a href="Bap.Std.Bil.html">BIL</a> expression sub-language;</li>
<li><a href="Bap.Std.Stmt.html">stmt</a> - <a href="Bap.Std.Bil.html">BIL</a> statements;</li>
<li><a href="Bap.Std.Bitvector.html">bitvector</a> - a bitvector data structure
        to represent immediate data, used usually by their aliases</li>
<li><a href="Bap.Std.html#TYPEword"><code class="code">word</code></a> and <a href="Bap.Std.html#TYPEaddr"><code class="code">addr</code></a>;</li>
<li><a href="Bap.Std.Value.html">value</a> - an extensible variant type;</li>
<li><a href="Bap.Std.Dict.html">dict</a> - an extensible record;</li>
<li><a href="Bap.Std.Vector.html">vector</a> - array that can grow;</li>
<li><a href="Bap.Std.Seq.html">'a seq</a> - slightly extended Core <code class="code"><span class="constructor">Sequence</span></code>, aka lazy
        list;</li>
<li><a href="Bap.Std.Trie.html">Trie</a> - prefix trees;</li>
<li><a href="Bap.Std.Graph.html">Graph</a> - graph implementations and library.</li>
</ul>

      Most of the types implement the <a href="Bap.Std.Regular.html">Regular</a>
      interface. This interface is very similar to Core's
      <code class="code"><span class="constructor">Identifiable</span></code>, and is supposed to represent a type that is as
      common as a built-in type. One should expect to find any
      function that is implemented for such types as <code class="code">int</code>, <code class="code">string</code>,
      <code class="code">char</code>, etc.  Namely, this interface includes:
<p>
<ul>
<li>comparison functions: (<code class="code">&lt;, &gt;, &lt;= , &gt;= , compare, between, ...</code>);</li>
<li>each type defines a polymorphic <code class="code"><span class="constructor">Map</span></code> with keys of type <code class="code">t</code>;</li>
<li>each type provides a <code class="code"><span class="constructor">Set</span></code> with values of type <code class="code">t</code>;</li>
<li>hashtable is exposed via <code class="code"><span class="constructor">Table</span></code> module;</li>
<li>hashset is available under <code class="code"><span class="constructor">Hash_set</span></code> name</li>
<li>sexpable and binable interface;</li>
<li><code class="code">to_string</code>, <code class="code">str</code>, <code class="code">pp</code>, <code class="code">ppo</code>, <code class="code">pps</code> functions
      for pretty-printing.</li>
</ul>

      Most types usually provide much more. For each type, there is a
      module with the same name that implements its interface. For
      example, type <code class="code">exp</code> is indeed a type abbreviation for <code class="code"><span class="constructor">Exp</span>.t</code>,
      and module <code class="code"><span class="constructor">Exp</span></code> contains all functions and types related to
      type <code class="code">exp</code>. For example, to create a hashtable of statements,
      just type:
<p>

      <code class="code"><span class="keyword">let</span> table = <span class="constructor">Stmt</span>.<span class="constructor">Table</span>.create ()</code>
<p>

      If a type is a variant type (i.e., defines constructors) then for
      each constructor named <code class="code"><span class="constructor">Name</span></code>, there exists a corresponding
      function named <code class="code">name</code> that will accept the same number of
      arguments as the arity of the constructor. For example, a
      <code class="code"><span class="constructor">Bil</span>.<span class="constructor">Int</span></code> can be constructed with the <code class="code"><span class="constructor">Bil</span>.int</code> function that
      has type <code class="code">word <span class="keywordsign">-&gt;</span> exp</code>. If a constructor has several arguments
      of the same type we usually disambiguate them with keywords,
      e.g., <code class="code"><span class="constructor">Bil</span>.<span class="constructor">Load</span> <span class="keyword">of</span> (exp,exp,endian,size)</code> has function
      <a href="Bap.Std.Bil.html#VALload">Bil.load</a> with type:
      <code class="code">mem:exp <span class="keywordsign">-&gt;</span> addr:exp <span class="keywordsign">-&gt;</span> endian <span class="keywordsign">-&gt;</span> size <span class="keywordsign">-&gt;</span> exp</code>
<p>

      <h3 id="value">Value</h3>
<p>

      <a href="Bap.Std.Value.html">Universal values</a> can be viewed as extensible variants on
      steroids. Not only they maybe extended, but they also can be
      serialized, compared with user-defined comparison function and
      even pretty printed.
<p>

      <h3 id="dict">Dict</h3>
<p>

      Like <a href="Bap.Std.Value.html">value</a> is an extensible sum type, <a href="Bap.Std.Dict.html">dict</a>
      can be viewed as extensible product type. Dict is a sequence of
      values of type <a href="Bap.Std.html#TYPEvalue"><code class="code">value</code></a>, with <a href="Bap.Std.Value.Tag.html">tags</a> used as field
      names. Of course, fields are unique.
<p>

      <h3 id="vector">Vector</h3>
<p>

      Vector is an implementation of STL like vectors with logarithmic
      push back.
<p>

      <h3 id="tries">Tries</h3>
<p>

      The Foundation library also defines a prefix tree data structure
      that proves to be useful for binary analysis applications.
      <a href="Bap.Std.Trie.html">Trie</a>s in BAP is a functor that derives a
      polymorphic trie data structure for a given
      <a href="Bap.Std.Trie.Key.html">Key</a>.
<p>

      For convenience we support instantiating tries for most of
      our data structures. For example, <a href="Bap.Std.Bitvector.html">Word</a> has several
      <a href="Bap.Std.Bitvector.Trie.html">tries</a> inside.
<p>

      For common strings, there's <a href="Bap.Std.Trie.String.html"><code class="code"><span class="constructor">Trie</span>.<span class="constructor">String</span></code></a>.
<p>

      <h3 id="3_Graphlibrary">Graph library</h3>
<p>

      <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> is a generic library that extends a well known
      OCamlGraph library. <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> uses its own, more reach,
      <a href="Bap.Std.Graph.html"><code class="code"><span class="constructor">Graph</span></code></a> interface that is isomorphic to OCamlGraph's <code class="code"><span class="constructor">Sigs</span>.<span class="constructor">P</span></code>
      signature for persistant graphs. Two functors witness the
      isomorphism of the interfaces:
      <a href="Bap.Std.Graphlib.To_ocamlgraph.html"><code class="code"><span class="constructor">Graphlib</span>.<span class="constructor">To_ocamlgraph</span></code></a> and <a href="Bap.Std.Graphlib.Of_ocamlgraph.html"><code class="code"><span class="constructor">Graphlib</span>.<span class="constructor">Of_ocamlgraph</span></code></a>. Thanks
      to this functors any algorithm written for OCamlGraph can be
      used on <code class="code"><span class="constructor">Graphlibs</span></code> graph and vice verse.
<p>

      The <a href="Bap.Std.Graph.html"><code class="code"><span class="constructor">Graph</span></code></a> interface provides a richer interface in a Core
      style. Nodes and Edges implements <a href="Bap.Std.Opaque.html"><code class="code"><span class="constructor">Opaque</span></code></a> data structure,
      i.e., they come with Maps, Sets, Hashtbls, etc, preloaded (e.g.,
      <code class="code"><span class="constructor">G</span>.<span class="constructor">Node</span>.<span class="constructor">Set</span></code> is a set of node for graph implementation, provided
      by a module named <code class="code"><span class="constructor">G</span></code>). Graphs also implement <a href="Bap.Std.Printable.html"><code class="code"><span class="constructor">Printable</span></code></a>
      interface, that makes them much easier to debug.
<p>

      Along with graphs, auxiliary data structures are provided, like
      <a href="Bap.Std.Path.html">path</a> to represent paths in graph, <a href="Bap.Std.Tree.html">tree</a> for
      representing different graph spannings, <a href="Bap.Std.Partition.html">partition</a>
      for graph partitioning, and more.
<p>

      <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> is a library that provides a set of generic
      algorithms, as well as implementations of a <a href="Bap.Std.Graph.html"><code class="code"><span class="constructor">Graph</span></code></a> interface,
      and a suite of preinstantiated graphs.
<p>

      Contrary to OCamlGraph, each <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> interface is provided
      as a function, not a functor. Thus making there use syntactically
      easier. Also, <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> heavily uses optional and keyword
      parameters. For die-hards, may algorithms are still have functor
      interface.
<p>

      All <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> algorithms accept a first-class module with
      graph implementation as a first argument. You can think of this
      parameter as an explicit type class. Later, when modular
      implicits will be accepted in OCaml, this parameter can be
      omitted. But for now, we need to pass it.
<p>

      A recommended way to work with <a href="Bap.Std.Graphlib.html"><code class="code"><span class="constructor">Graphlib</span></code></a> is to bind the
      chosen implementation with some short name, usually <code class="code"><span class="constructor">G</span></code> would be
      a good choice:
<p>

      <pre class="codepre"><code class="code"><span class="keyword">module</span>&nbsp;<span class="constructor">G</span>&nbsp;=&nbsp;<span class="constructor">Graphlib</span>.<span class="constructor">String</span>.<span class="constructor">Bool</span></code></pre>
<p>

      This will bind name <code class="code"><span class="constructor">G</span></code> with a graph implementation that has
      <code class="code">string</code> nodes, with edges marked by values of type <code class="code">bool</code>.
<p>

      To create a graph of type <code class="code"><span class="constructor">G</span>.t</code> one can use a generic
      <a href="Bap.Std.Graphlib.html#VALcreate"><code class="code"><span class="constructor">Graphlib</span>.create</code></a> function:
<p>

      <pre class="codepre"><code class="code"><span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;<span class="constructor">Graphlib</span>.create&nbsp;(<span class="keyword">module</span>&nbsp;<span class="constructor">G</span>)&nbsp;~edges:[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"entry"</span>,&nbsp;<span class="string">"loop"</span>,&nbsp;<span class="keyword">true</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"loop"</span>,&nbsp;<span class="string">"exit"</span>,&nbsp;<span class="keyword">true</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"loop"</span>,&nbsp;<span class="string">"loop"</span>,&nbsp;<span class="keyword">false</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;()</code></pre>
<p>

      This will create an instance of type <code class="code"><span class="constructor">G</span>.t</code>. Of course, it is
      still possible to use non-generic <code class="code"><span class="constructor">G</span>.empty</code>, <code class="code"><span class="constructor">G</span>.<span class="constructor">Node</span>.insert</code>,
      <code class="code"><span class="constructor">G</span>.<span class="constructor">Edge</span>.insert</code>.<br>
<br>
<h2 id="image">Memory model</h2>
<p>

      This layer provides everything you need to work with binary
      objects:
<p>
<ul>
<li><a href="Bap.Std.Memory.html">mem</a> - a contiguous array of bytes, indexed with
       absolute addresses;</li>
</ul>
<ul>
<li><a href="Bap.Std.Table.html"> 'a table</a> - a mapping from a memory regions to
       arbitrary data (no duplicates or intersections);</li>
</ul>
<ul>
<li><a href="Bap.Std.Memmap.html">a memmap</a> - a mapping from memory region to
        arbitrary data with duplicates and intersections allowed, aka
        segment tree or interval map;</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html">image</a> - represents a binary object with all its
       symbols, segments, sections and other meta information.</li>
</ul>

      The <code class="code"><span class="constructor">Image</span></code> module uses the plugin system to load binary
      objects. In order to add new loader, one should implement the
      <a href="Bap.Std.Backend.html">Backend.t</a> loader function and register it with the
      <a href="Bap.Std.Image.html#VALregister_backend">Image.register_backend</a> function.<br>
<br>
<h2 id="disasm">Disassembler</h2>
<p>

      This layer consists of disassemblers and lifters. They are
      tightly integrated, but in general we can disassemble all
      supported <a href="Bap.Std.Arch.html#TYPEt">architectures</a>. Currently we lift only arm,
      x86 and x86_64.
<p>

      There are two interfaces to disassemblers:
<p>
<ul>
<li><a href="Bap.Std.Disasm.html">Disasm</a> - a regular interface that hides all
       complexities, but may not always be very flexible.</li>
<li><a href="Bap.Std.Disasm_expert.html">Disasm_expert</a> - an expert interface that
      provides access to a low-level representation. It is very
      flexible and fast, but harder to use.</li>
</ul>

      To disassemble files or data with the regular interface, use
      one of the following functions:
<p>
<ul>
<li><a href="Bap.Std.html#VALdisassemble">disassemble</a> - to disassemble a region of
        memory;</li>
<li><a href="Bap.Std.html#VALdisassemble_image">disassemble_image</a> - to disassemble a
        loaded binary object;</li>
<li><a href="Bap.Std.html#VALdisassemble_file">disassemble_file</a> or
        <a href="Bap.Std.html#VALdisassemble_file_exn">disassemble_file</a> - to disassemble
        file.</li>
</ul>

      All these functions perform disassembly by recursive descent,
      reconstruct the control flow graph, and perform lifting. The
      result of disassembly is represented by the abstract value of
      type <a href="Bap.Std.Disasm.html">disasm</a>. Two main data structures that are used
      to represent disassembled program are:
<p>
<ul>
<li><a href="Bap.Std.Insn.html">insn</a> - a machine instruction;</li>
<li><a href="Bap.Std.Block.html">block</a> - a basic block, i.e., a linear sequence of
        instructions.</li>
</ul>

      The following figure shows the relationship between basic data
      structures of the disassembled program.
<p>

      <pre class="verbatim">        +-----------------+
        | +-------------+ |
        | |   disasm    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |    block    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     insn    | |
        | +-------------+ |
        |        |        |
        |        | *      |
        | +-------------+ |
        | |     stmt    | |
        | +-------------+ |
        +-----------------+
     </pre>
<p>

      A disassembled program is represented as a set of
      interconnected <a href="Bap.Std.Block.html">basic blocks</a>. You can navigate between
      blocks using <a href="Bap.Std.Block_traverse.html#VALsuccs">Block.succs</a> and
      <a href="Bap.Std.Block_traverse.html#VALpreds">Block.preds</a> functions, or you can
      transform a set of blocks into a real graph using
      the <a href="Bap.Std.Block.html#VALto_graph">Block.to_graph</a> function. Sometimes it
      is enough to traverse program using
      depth-first search.
<p>

      Each block is a container to a sequence of machine
      instructions. It is guaranteed that there's at least one
      instruction in the block, thus the
      <a href="Bap.Std.Block_accessors.html#VALleader">Block.leader</a> and
      <a href="Bap.Std.Block_accessors.html#VALterminator">Block.terminator</a> functions are
      total.
<p>

      Each <a href="Bap.Std.Insn.html">machine instruction</a> is represented by its
      <code class="code">opcode</code>, <code class="code">name</code> and <code class="code">array</code> of operands (these are machine and
      disassembler specific), a set of predicates (describing
      instruction semantics on a very high level), and a sequence of
      <a href="Bap.Std.Bil.html">BIL</a> statements that precisely define the semantics of
      the instruction.
<p>

      Modules of type <a href="Bap.Std.CPU.html">CPU</a> provide a high level abstraction of
      the CPU and allow one to reason about instruction semantics
      independently from the target platform. Modules of type
      <a href="Bap.Std.ABI.html">ABI</a> provide even more information, e.g., it maps
      registers to formals. The module type <a href="Bap.Std.Target.html">Target</a> brings
      <code class="code"><span class="constructor">CPU</span></code> and <code class="code"><span class="constructor">ABI</span></code> together. To get an instance of this module,
      you can use the <a href="Bap.Std.html#VALtarget_of_arch">target_of_arch</a> function. For
      accessing all information about target platform, use the
      following modules that expose low-level and platform-specific
      details:
<p>
<ul>
<li><a href="Bap.Std.ARM.html">ARM</a></li>
<li><a href="Bap.Std.IA32.html">IA32</a></li>
<li><a href="Bap.Std.AMD64.html">AMD64</a></li>
</ul>

      If you do not need cfg reconstruction, you can use
      <a href="Bap.Std.html#VALlinear_sweep">linear_sweep</a> function to disassemble a given
      memory region. If you need more granularity, then you can use
      the expert interface accordingly:
<p>
<ul>
<li><a href="Bap.Std.Disasm_expert.Basic.html">Basic</a> - provides access to a low-level
        disassembler on top of which all other disassemblers are
        built;</li>
<li><a href="Bap.Std.Disasm_expert.Recursive.html">Recursive</a> - an interface to a
        recursive descent algorithm.</li>
</ul>
<br>
<br>
<h2 id="sema">Semantic Analysis</h2>
<p>

      On semantic level the disassembled program is lifted into the
      intermediate representation (IR) suitable for writing analysis.
<p>

      IR is closely related to BIL. In fact it even reuses expression
      sub-language of BIL. But unlike BIL, IR is flat, (i.e., it
      doesn't contain recursive statements), and unstructured (no
      <code class="code"><span class="keyword">while</span></code>, <code class="code"><span class="keyword">if</span></code>, only jumps). Thus IR is much more low-level, so
      it is harder to read, but easier to analyze programmatically.
<p>

      The program in IR is build of terms. In fact the program itself
      is also a term. There're only 7 kinds of terms:
<p>
<ul>
<li><a href="Bap.Std.Program.html">program</a> - the program in whole;</li>
<li><a href="Bap.Std.Sub.html">sub</a> - subroutine;</li>
<li><a href="Bap.Std.Arg.html">arg</a> - subroutine argument;</li>
<li><a href="Bap.Std.Blk.html">blk</a> - basic block;</li>
<li><a href="Bap.Std.Def.html">def</a> - definition of a variable;</li>
<li><a href="Bap.Std.Phi.html">phi</a> - phi-node in the SSA form;</li>
<li><a href="Bap.Std.Jmp.html">jmp</a> - a transfer of control.</li>
</ul>

      Unlike expressions and statements in BIL, IR's terms are
      <em>concrete entities</em>.  Concrete entity is such entity that can
      change in time and space, as well as come in and out of
      existence.  Contrary, <em>abstract entity</em> is eternal and
      unchangeable.  <em>Identity</em> denotes the sameness of a concrete
      entity as it changes in time.  Abstract entities don't have an
      identity since they are immutable.  Program is built of concrete
      entities called terms.  Terms have <em>attributes</em> that can change in
      time, without affecting the identity of a term.  Attributes are
      abstract entities.  In each particular point of space and time a
      term is represented by a snapshot of all its attributes,
      colloquially called <em>value</em>.  Functions that change the value of a
      term in fact returns a new value with different set of
      attributes.  For example, <code class="code">def</code> term has two attributes: left
      hand side (lhs), that associates definition with abstract
      variable, and right hand side (rhs) that associates <code class="code">def</code> with
      an abstract expression. Suppose, that the definition was:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="keyword">let</span>&nbsp;d_1&nbsp;=&nbsp;<span class="constructor">Def</span>.create&nbsp;x&nbsp;<span class="constructor">Bil</span>.(var&nbsp;y&nbsp;+&nbsp;var&nbsp;z);;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;d_1&nbsp;:&nbsp;<span class="constructor">Def</span>.t&nbsp;=&nbsp;00000001:&nbsp;x&nbsp;:=&nbsp;y&nbsp;+&nbsp;z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      To change the right hand side of a definition we use
      <code class="code"><span class="constructor">Def</span>.with_rhs</code> that returns the <em>same</em> definition but with
      <em>different</em> value:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="keyword">let</span>&nbsp;d_2&nbsp;=&nbsp;<span class="constructor">Def</span>.with_rhs&nbsp;d_1&nbsp;<span class="constructor">Bil</span>.(int&nbsp;<span class="constructor">Word</span>.b1);;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;d_2&nbsp;:&nbsp;<span class="constructor">Def</span>.t&nbsp;=&nbsp;00000001:&nbsp;x&nbsp;:=&nbsp;<span class="keyword">true</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      <code class="code">d_1</code> and <code class="code">d_2</code> is different values
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="constructor">Def</span>.equal&nbsp;d_1&nbsp;d_2;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:&nbsp;bool&nbsp;=&nbsp;<span class="keyword">false</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>  of the same term <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">#</span>&nbsp;<span class="constructor">Term</span>.same&nbsp;d_1&nbsp;d_2;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;:&nbsp;bool&nbsp;=&nbsp;<span class="keyword">true</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      The identity of this terms is denoted by the term identifier
      (<code class="code">tid</code>). In the textual representation term identifiers are
      printed as ordinal numbers.
<p>

      Terms, can contain other terms. But unlike BIL expressions or
      statements, this relation is not truly recursive, since the
      structure of program term is fixed: <code class="code">arg</code>, <code class="code">phi</code>, <code class="code">def</code>, <code class="code">jmp</code>
      are leaf terms; <code class="code">sub</code> can only contain <code class="code">arg</code>'s or <code class="code">blk</code>'s; <code class="code">blk</code>
      consists of <code class="code">phi</code>, <code class="code">def</code> and <code class="code">jmp</code> sequences of terms, as
      pictured in the figure below.  Although, the term structure is
      closed to changes, you still can extend particular term with
      attributes, using <code class="code">set_attr</code> and <code class="code">get_attr</code> functions of the
      <a href="Bap.Std.Term.html">Term</a> module. This functions are using <a href="Bap.Std.Value.html">extensible
      variant</a> type to encode attributes.
<p>

      <pre class="verbatim">        +--------------------------------------------------------+
        |                +-------------------+                   |
        |                |      program      |                   |
        |                +---------+---------+                   |
        |                          |*                            |
        |                +---------+---------+                   |
        |                |        sub        |                   |
        |                +---------+---------+                   |
        |                          |                             |
        |        +-----------------+---------------+             |
        |        |*                                |*            |
        |  +-----+-------+                 +-------+-------+     |
        |  |    arg      |                 |      blk      |     |
        |  +-------------+                 +-------+-------+     |
        |                                          |             |
        |           +---------------+--------------+             |
        |           |*              |*             | *           |
        |     +-----+-----+   +-----+-----+   +----+-----+       |
        |     |    phi    |   |    def    |   |   jmp    |       |
        |     +-----------+   +-----------+   +----------+       |
        +--------------------------------------------------------+
     </pre><br>
<br>
<h2 id="project">Working with project</h2>
<p>

      There're two general approaches to obtain a value of type
      <a href="Bap.Std.Project.html">project</a>:<ul>
<li>create it manually using one of the <code class="code"><span class="constructor">Project</span>.from_*</code> function;</li>
<li>to write a plugin to a <code class="code">bap</code> utility</li>
</ul>

      Although the first approach is simplistic and gives you a full
      control, we still recommend to use the latter, as <code class="code">bap</code> utility
      will provide you integration with different tools, like IDA, as
      well as interaction with a user and other plugins.
<p>

      To write a program analysis plugin (or pass in short) you need to
      implement a function with one of the following interfaces:
<p>
<ul>
<li><code class="code">project <span class="keywordsign">-&gt;</span> project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_pass">register_pass</a>;</li>
<li><code class="code">project <span class="keywordsign">-&gt;</span> unit</code> and register it with
         <a href="Bap.Std.Project.html#VALregister_pass'">register_pass'</a>;</li>
<li><code class="code">string array <span class="keywordsign">-&gt;</span> project <span class="keywordsign">-&gt;</span> project</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_pass_with_args">register_pass_with_args</a>;</li>
<li><code class="code">string array <span class="keywordsign">-&gt;</span> project <span class="keywordsign">-&gt;</span> unit</code> and register it with
        <a href="Bap.Std.Project.html#VALregister_pass_with_args'">register_pass_with_args'</a>.</li>
</ul>

      Once loaded from the <code class="code">bap</code> utility (see <code class="code">man bap</code>) this function
      will be invoked with a value of type <a href="Bap.Std.Project.html#TYPEt">project</a> that
      provides access to all information gathered over the binary so
      far. If the registered function returns a non <code class="code">unit</code> type, then it
      can functionally update the project state, e.g., add
      annotations, discover new symbols, make corrections, and even
      change the architecture and re-disassemble everything.
<p>

      <h3 id="3_Example">Example</h3>
<p>

      The following plugin prints all sections in a file:
<p>

      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Core_kernel</span>.<span class="constructor">Std</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Bap</span>.<span class="constructor">Std</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Format</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;print_sections&nbsp;p&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Project</span>.memory&nbsp;p&nbsp;|&gt;&nbsp;<span class="constructor">Memmap</span>.to_sequence&nbsp;|&gt;&nbsp;<span class="constructor">Seq</span>.iter&nbsp;~f:(<span class="keyword">fun</span>&nbsp;(mem,x)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Option</span>.iter&nbsp;(<span class="constructor">Value</span>.get&nbsp;<span class="constructor">Image</span>.section&nbsp;x)&nbsp;~f:(<span class="keyword">fun</span>&nbsp;name&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;<span class="string">"Section:&nbsp;%s@.%a@."</span>&nbsp;name&nbsp;<span class="constructor">Memory</span>.pp&nbsp;mem))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;()&nbsp;=&nbsp;<span class="constructor">Project</span>.register_pass'&nbsp;<span class="string">"print-sections"</span>&nbsp;print_sections<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

      <h3 id="3_Exchanginginformation">Exchanging information</h3>
<p>

      For exchanging information in a type safe manner, we use
      <a href="Bap.Std.Value.html">universal values</a>. Values can be attached to a
      particular memory region, IR terms, or put into the <code class="code">storage</code>
      dictionary. For the first case we use the <a href="Bap.Std.Memmap.html">memmap</a> data
      structure.  It is an interval tree containing all the memory
      regions that are used during analysis. For the <code class="code">storage</code> we use
      <code class="code"><span class="constructor">Dict</span></code> data structure.
<p>

      <h3 id="3_Memorymarks">Memory marks</h3>
<p>

      By default the memory is marked with the following marks:
<p>
<ul>
<li><a href="Bap.Std.Image.html#VALsection">section</a> -- for regions of memory that had a
      particular name in the original binary. For example, in ELF,
      sections have names that annotate a corresponding memory
      region. If project was created from memory object, then the
      overall memory will be marked as a <code class="code"><span class="string">"bap.user"</span></code> section.</li>
</ul>
<ul>
<li><a href="Bap.Std.Image.html#VALsegment">segment</a> -- if the binary data was loaded
      from a binary format that contains segments, then the
      corresponding memory regions are be marked. Segments provide
      access to permission information.</li>
</ul>
<br>
<br>
<h2 id="aux">Auxiliary libraries</h2>
<p>

      <h3 id="dwarf">DWARF library</h3>
<p>

      The Dwarf library provides an access to DWARF debugging
      information. It implements parsing of some subset of DWARF
      features, and a high-level interface <a href="Bap.Std.Dwarf.Fbi.html">Fbi</a> that
      extracts function symbols from the given DWARF data.
<p>

      <h3 id="sigs">Byteweight</h3>
<p>

      This <a href="Bap.Std.Byteweight.html">library</a> implements a byteweight algorithm
      that identifies functions in stripped binaries, as well as
      being able to train itself on a provided training corpus.<br>
<br>
<h1 id="api">BAP API</h1><br>

<pre><span class="keyword">module</span> <a href="Bap.Std.Config.html">Config</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Config.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Access to BAP configuration variables
</div>

<pre><span id="TYPEprinter"><span class="keyword">type</span> <code class="type">'a</code> printer</span> = <code class="type">Format.formatter -> 'a -> unit</code> </pre>
<div class="info ">
<code class="code"><span class="keywordsign">'</span>a printer</code> defines a type for pretty-printers for a value of
      type <code class="code"><span class="keywordsign">'</span>a</code>. This is the type, that is required by <code class="code">%a</code> specifier,
      for <code class="code"><span class="constructor">Format</span>.printf</code>-family of functions. Also, this is the type,
      that can be installed into OCaml toplevel or debugger.
<p>

      Note: `bap.top` library automatically installs all printers.<br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Printable.html">Printable</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Printable.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Printable interface is implemented by a significant amount of
      BAP types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Regular.html">Regular</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Regular.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Regular types models a general concept of value, i.e., something
      that can be used in way similar to regular <code class="code">int</code>, <code class="code">string</code>,
      <code class="code">char</code> and other built in types.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Opaque.html">Opaque</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Opaque.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Opaque type is like regular type, except that we can print or
      examine it in any way.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Integer.html">Integer</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Integer.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Signature for integral type.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Regular.html">Regular</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Regular.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
In order to implement <code class="code"><span class="constructor">Regular</span></code> interface you need to provide a
      minimum implementation <code class="code"><span class="constructor">M</span></code>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Opaque.html">Opaque</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Opaque.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
creates a module implementing <code class="code"><span class="constructor">Opaque</span></code> interface.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Seq.html">Seq</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Seq.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Lazy sequence
</div>

<pre><span id="TYPEseq"><span class="keyword">type</span> <code class="type">'a</code> seq</span> = <code class="type">'a <a href="Bap.Std.Seq.html#TYPEt">Seq.t</a></code> </pre>
<div class="info ">
type abbreviation for <code class="code"><span class="keywordsign">'</span>a <span class="constructor">Sequence</span>.t</code><br>
</div>


<pre><span id="VAL(^::)"><span class="keyword">val</span> (^::)</span> : <code class="type">'a -> 'a <a href="Bap.Std.html#TYPEseq">seq</a> -> 'a <a href="Bap.Std.html#TYPEseq">seq</a></code></pre><div class="info ">
<code class="code">x ^:: xs</code> is a consing operator for sequences<br>
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Trie.html">Trie</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Prefix tries.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Trie.html">Trie</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Trie.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Constructs a trie
</div>

<pre><span id="TYPEword"><span class="keyword">type</span> <code class="type"></code>word</span> </pre>
<div class="info ">
Type to represent machine word<br>
</div>


<pre><span id="TYPEaddr"><span class="keyword">type</span> <code class="type"></code>addr</span> = <code class="type"><a href="Bap.Std.html#TYPEword">word</a></code> </pre>
<div class="info ">
A synonym for <code class="code">word</code>, that should be used for words
      that are addresses<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Size.html">Size</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Size.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Type safe operand and register sizes.
</div>

<pre><span id="TYPEsize"><span class="keyword">type</span> <code class="type"></code>size</span> = <code class="type"><a href="Bap.Std.Size.html#TYPEt">Size.t</a></code> </pre>
<div class="info ">
size of operand<br>
</div>


<pre><span id="TYPEaddr_size"><span class="keyword">type</span> <code class="type"></code>addr_size</span> = <code class="type">[ `r32 | `r64 ] <a href="Bap.Std.Size.html#TYPEp">Size.p</a></code> </pre>
<div class="info ">
size of address<br>
</div>


<pre><span id="TYPEnat1"><span class="keyword">type</span> <code class="type"></code>nat1</span> = <code class="type">int</code> </pre>
<div class="info ">
just a fancy type abbreviation<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Bitvector.html">Bitvector</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bitvector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Bitvector -- a type for representing binary values.
</div>

<pre><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = <code class="type"><a href="Bap.Std.Bitvector.html#TYPEendian">Bitvector.endian</a></code> = </pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>

</tr></table>

<div class="info ">
Expose <code class="code">endian</code> constructors to <code class="code"><span class="constructor">Bap</span>.<span class="constructor">Std</span></code> namespace<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Word.html">Word</a>: <code class="type">module type of Bitvector</code><code class="type"> 
    with type t = word
     and type endian = endian
     and type comparator_witness = Bitvector.comparator_witness</code></pre><div class="info">
Shortcut for bitvectors that represent words
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Addr.html">Addr</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Addr.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Shortcut for bitvectors that represent addresses
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Type.html">Type</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Type.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The type of a BIL expression.
</div>

<pre><span id="TYPEtyp"><span class="keyword">type</span> <code class="type"></code>typ</span> = <code class="type"><a href="Bap.Std.Type.html#TYPEt">Type.t</a></code> </pre>
<div class="info ">
short abbreviation for a type<br>
</div>


<pre><span id="VALbool_t"><span class="keyword">val</span> bool_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
one bit<br>
</div>

<pre><span id="VALreg8_t"><span class="keyword">val</span> reg8_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
8-bit width value<br>
</div>

<pre><span id="VALreg16_t"><span class="keyword">val</span> reg16_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
16-bit width value<br>
</div>

<pre><span id="VALreg32_t"><span class="keyword">val</span> reg32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
32-bit width value<br>
</div>

<pre><span id="VALreg64_t"><span class="keyword">val</span> reg64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
64-bit width value<br>
</div>

<pre><span id="VALreg128_t"><span class="keyword">val</span> reg128_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
128-bit width value<br>
</div>

<pre><span id="VALreg256_t"><span class="keyword">val</span> reg256_t</span> : <code class="type"><a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
256-bit width value<br>
</div>

<pre><span id="VALmem32_t"><span class="keyword">val</span> mem32_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem32_t size</code> creates a type for memory with <code class="code">32</code>-bit addresses
      and elements of size <code class="code">size</code>.<br>
</div>

<pre><span id="VALmem64_t"><span class="keyword">val</span> mem64_t</span> : <code class="type"><a href="Bap.Std.html#TYPEsize">size</a> -> <a href="Bap.Std.html#TYPEtyp">typ</a></code></pre><div class="info ">
<code class="code">mem64_t size</code> creates a type for memory with <code class="code">64</code>-bit addresses
      and elements of size <code class="code">size</code>.<br>
</div>

<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> </pre>
<div class="info ">
bil variable<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Var.html">Var</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Var.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
BIL variable.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Bil.html">Bil</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Bil.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Main BIL module
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Exp.html">Exp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Exp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Regular</span></code> interface for BIL expressions
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Stmt.html">Stmt</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Stmt.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Regular</span></code> interface for BIL statements
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arch.html">Arch</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Arch.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Architecture
</div>

<pre><span id="TYPEarch"><span class="keyword">type</span> <code class="type"></code>arch</span> = <code class="type"><a href="Bap.Std.Arch.html#TYPEt">Arch.t</a></code> </pre>
<div class="info ">
architecture<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Value.html">Value</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Value.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Universal Values.
</div>

<pre><span id="TYPEtag"><span class="keyword">type</span> <code class="type">'a</code> tag</span> = <code class="type">'a <a href="Bap.Std.Value.html#TYPEtag">Value.tag</a></code> </pre>

<br>
<h3 id="3_Somepredefinedtags">Some predefined tags</h3><br>

<pre><span id="TYPEcolor"><span class="keyword">type</span> <code class="type"></code>color</span> = <code class="type">[ `black | `blue | `cyan | `green | `magenta | `red | `white | `yellow ]</code> </pre>


<pre><span id="VALcolor"><span class="keyword">val</span> color</span> : <code class="type"><a href="Bap.Std.html#TYPEcolor">color</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre>
<pre><span id="VALcomment"><span class="keyword">val</span> comment</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A human readable comment<br>
</div>

<pre><span id="VALpython"><span class="keyword">val</span> python</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A command in python language<br>
</div>

<pre><span id="VALshell"><span class="keyword">val</span> shell</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A command in shell language<br>
</div>

<pre><span id="VALmark"><span class="keyword">val</span> mark</span> : <code class="type">unit <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Mark something as marked<br>
</div>

<pre><span id="VALweight"><span class="keyword">val</span> weight</span> : <code class="type">float <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Give a weight<br>
</div>

<pre><span id="VALtarget_addr"><span class="keyword">val</span> target_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
The real virtual address of a target<br>
</div>

<pre><span id="VALtarget_name"><span class="keyword">val</span> target_name</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Symbolic name of a target<br>
</div>

<pre><span id="VALsubroutine_name"><span class="keyword">val</span> subroutine_name</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Name of a subroutine<br>
</div>

<pre><span id="VALsubroutine_addr"><span class="keyword">val</span> subroutine_addr</span> : <code class="type"><a href="Bap.Std.html#TYPEaddr">addr</a> <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
Address of a subroutine entry point<br>
</div>

<pre><span id="VALfilename"><span class="keyword">val</span> filename</span> : <code class="type">string <a href="Bap.Std.html#TYPEtag">tag</a></code></pre><div class="info ">
A name of a file<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Dict.html">Dict</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Dict.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Universal Heterogeneous Map.
</div>

<pre><span id="TYPEvector"><span class="keyword">type</span> <code class="type">'a</code> vector</span> </pre>
<div class="info ">
<a href="Bap.Std.Vector.html">Resizable array</a><br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Vector.html">Vector</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Vector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Resizable Array.
</div>

<pre><span id="TYPEbil"><span class="keyword">type</span> <code class="type"></code>bil</span> = <code class="type"><a href="Bap.Std.Bil.html#TYPEt">Bil.t</a></code> </pre>


<pre><span id="TYPEbinop"><span class="keyword">type</span> <code class="type"></code>binop</span> = <code class="type">Bil.binop</code> </pre>


<pre><span id="TYPEcast"><span class="keyword">type</span> <code class="type"></code>cast</span> = <code class="type">Bil.cast</code> </pre>


<pre><span id="TYPEexp"><span class="keyword">type</span> <code class="type"></code>exp</span> = <code class="type"><a href="Bap.Std.Exp.html#TYPEt">Exp.t</a></code> </pre>


<pre><span id="TYPEstmt"><span class="keyword">type</span> <code class="type"></code>stmt</span> = <code class="type"><a href="Bap.Std.Stmt.html#TYPEt">Stmt.t</a></code> </pre>


<pre><span id="TYPEunop"><span class="keyword">type</span> <code class="type"></code>unop</span> = <code class="type">Bil.unop</code> </pre>


<pre><span id="TYPEvalue"><span class="keyword">type</span> <code class="type"></code>value</span> = <code class="type"><a href="Bap.Std.Value.html#TYPEt">Value.t</a></code> </pre>


<pre><span id="TYPEdict"><span class="keyword">type</span> <code class="type"></code>dict</span> = <code class="type"><a href="Bap.Std.Dict.html#TYPEt">Dict.t</a></code> </pre>


<pre><span id="TYPEterm"><span class="keyword">type</span> <code class="type">'a</code> term</span> </pre>
<div class="info ">
BAP IR.
<p>

      Program is a tree of terms.<br>
</div>


<pre><span id="TYPEprogram"><span class="keyword">type</span> <code class="type"></code>program</span> </pre>


<pre><span id="TYPEsub"><span class="keyword">type</span> <code class="type"></code>sub</span> </pre>


<pre><span id="TYPEarg"><span class="keyword">type</span> <code class="type"></code>arg</span> </pre>


<pre><span id="TYPEblk"><span class="keyword">type</span> <code class="type"></code>blk</span> </pre>


<pre><span id="TYPEphi"><span class="keyword">type</span> <code class="type"></code>phi</span> </pre>


<pre><span id="TYPEdef"><span class="keyword">type</span> <code class="type"></code>def</span> </pre>


<pre><span id="TYPEjmp"><span class="keyword">type</span> <code class="type"></code>jmp</span> </pre>


<pre><span id="TYPEtid"><span class="keyword">type</span> <code class="type"></code>tid</span> </pre>


<pre><span id="TYPEcall"><span class="keyword">type</span> <code class="type"></code>call</span> </pre>


<pre><code><span id="TYPElabel"><span class="keyword">type</span> <code class="type"></code>label</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Direct"><span class="constructor">Direct</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEtid">tid</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
direct jump<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabel.Indirect"><span class="constructor">Indirect</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEexp">exp</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
indirect jump<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
target of control transfer<br>
</div>


<pre><code><span id="TYPEjmp_kind"><span class="keyword">type</span> <code class="type"></code>jmp_kind</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Call"><span class="constructor">Call</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPEcall">call</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
call to subroutine<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Goto"><span class="constructor">Goto</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPElabel">label</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
jump inside subroutine<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Ret"><span class="constructor">Ret</span></span> <span class="keyword">of</span> <code class="type"><a href="Bap.Std.html#TYPElabel">label</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
return from call to label<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTjmp_kind.Int"><span class="constructor">Int</span></span> <span class="keyword">of</span> <code class="type">int * <a href="Bap.Std.html#TYPEtid">tid</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
interrupt and return to tid<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
control transfer variants<br>
</div>


<pre><code><span id="TYPEintent"><span class="keyword">type</span> <code class="type"></code>intent</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.In"><span class="constructor">In</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
input argument<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.Out"><span class="constructor">Out</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
output argument<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTintent.Both"><span class="constructor">Both</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
input/output<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
argument intention<br>
</div>


<pre><span id="TYPEcls"><span class="keyword">type</span> <code class="type">('a, 'b)</code> cls</span> </pre>

<br>
<h4 id="4_Termtypeclasses">Term type classes</h4><br>

<pre><span id="VALsub_t"><span class="keyword">val</span> sub_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEprogram">program</a>, <a href="Bap.Std.html#TYPEsub">sub</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
sub<br>
</div>

<pre><span id="VALarg_t"><span class="keyword">val</span> arg_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEsub">sub</a>, <a href="Bap.Std.html#TYPEarg">arg</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
arg<br>
</div>

<pre><span id="VALblk_t"><span class="keyword">val</span> blk_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEsub">sub</a>, <a href="Bap.Std.html#TYPEblk">blk</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
blk<br>
</div>

<pre><span id="VALphi_t"><span class="keyword">val</span> phi_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEphi">phi</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
phi<br>
</div>

<pre><span id="VALdef_t"><span class="keyword">val</span> def_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEdef">def</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
def<br>
</div>

<pre><span id="VALjmp_t"><span class="keyword">val</span> jmp_t</span> : <code class="type">(<a href="Bap.Std.html#TYPEblk">blk</a>, <a href="Bap.Std.html#TYPEjmp">jmp</a>) <a href="Bap.Std.html#TYPEcls">cls</a></code></pre><div class="info ">
jmp<br>
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Node.html">Node</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Node.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<a href="Bap.Std.Graph.html"><code class="code"><span class="constructor">Graph</span></code></a> nodes.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Edge.html">Edge</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Edge.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Interface that every Graph edge should provide
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Graph.html">Graph</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Graph.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Graph signature.
</div>

<pre><span id="TYPEgraph"><span class="keyword">type</span> <code class="type">('c, 'n, 'e)</code> graph</span> = <code class="type">(module Bap.Std.Graph with type edge = 'e and type node = 'n and type t = 'c)</code> </pre>
<div class="info ">
a type abbreviation for a packed module, implementing graph
      interface.
      Note: this type prenexes only 3 out of 8 type variables, so,
      sometimes it is not enough.<br>
</div>


<pre><span id="TYPEedge_kind"><span class="keyword">type</span> <code class="type"></code>edge_kind</span> = <code class="type">[ `Back | `Cross | `Forward | `Tree ]</code> </pre>
<div class="info ">
Graph edges classification.
      For explanations see <a href="Bap.Std.Graphlib.html#VALdepth_first_search">DFS</a>.<br>
</div>


<pre><span id="TYPEtree"><span class="keyword">type</span> <code class="type">'a</code> tree</span> </pre>
<div class="info ">
a <a href="Bap.Std.Tree.html"><code class="code"><span class="constructor">Tree</span></code></a> representation.<br>
</div>


<pre><span id="TYPEfrontier"><span class="keyword">type</span> <code class="type">'a</code> frontier</span> </pre>
<div class="info ">
a type representing <a href="Bap.Std.Frontier.html"><code class="code"><span class="constructor">Frontier</span></code></a>s<br>
</div>


<pre><span id="TYPEpartition"><span class="keyword">type</span> <code class="type">'a</code> partition</span> </pre>
<div class="info ">
a <a href="Bap.Std.Partition.html">result</a> of partitioning algorithms<br>
</div>


<pre><span id="TYPEgroup"><span class="keyword">type</span> <code class="type">'a</code> group</span> </pre>
<div class="info ">
a partition <a href="Bap.Std.Group.html">Cell</a><br>
</div>


<pre><span id="TYPEpath"><span class="keyword">type</span> <code class="type">'a</code> path</span> </pre>
<div class="info ">
walk without a repetition of edges and inner nodes<br>
</div>


<pre><span id="TYPEequiv"><span class="keyword">type</span> <code class="type"></code>equiv</span> </pre>
<div class="info ">
runtime witness of the <a href="Bap.Std.Equiv.html">equivalence class</a><br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Tree.html">Tree</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Tree.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Tree is a particular subtype of a graph for which
      each node has only one predecessor, and there is only
      one path between tree root and any other node.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Frontier.html">Frontier</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Frontier.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Frontier maps each node into a possibly empty set of nodes.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Path.html">Path</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Path.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Path between two nodes.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Partition.html">Partition</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Partition.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Result of a set partitioning.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Group.html">Group</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Group.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Group is a non-empty set that is a result of partitioning of an
      underlying set <code class="code"><span class="constructor">S</span></code> into a set of non-intersecting and non-empty
      subsets that cover set <code class="code"><span class="constructor">S</span></code>.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Equiv.html">Equiv</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Equiv.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Ordinal for representing equivalence.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Aux.html">Aux</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Aux.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Printable auxiliary graph structures
</div>
<br>
<h5 id="5_Auxiliarygraphdatastructures">Auxiliary graph data structures</h5><br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Predicate.html">Predicate</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Predicate.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A type of modules for filtering graphs.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Isomorphism.html">Isomorphism</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Isomorphism.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code"><span class="constructor">Isomorphism</span></code> is a bijection between type <code class="code">s</code> and <code class="code">t</code>.
</div>

<pre><span id="TYPEdfs_visitor"><span class="keyword">class type</span> <code class="type">[['n, 'e, 's]]</code> <a href="Bap.Std.dfs_visitor-c.html">dfs_visitor</a></span> = <code class="code"><span class="keyword">object</span></code> <a href="Bap.Std.dfs_visitor-c.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h4 id="4_Visualattributesforgraphvizualization">Visual attributes for graphvizualization.</h4>
      Consult OCamlGraph library for more information.<br>

<pre><span id="TYPEnode_attr"><span class="keyword">type</span> <code class="type"></code>node_attr</span> = <code class="type">Graph.Graphviz.DotAttributes.vertex</code> </pre>


<pre><span id="TYPEedge_attr"><span class="keyword">type</span> <code class="type"></code>edge_attr</span> = <code class="type">Graph.Graphviz.DotAttributes.edge</code> </pre>


<pre><span id="TYPEgraph_attr"><span class="keyword">type</span> <code class="type"></code>graph_attr</span> = <code class="type">Graph.Graphviz.DotAttributes.graph</code> </pre>


<pre><code><span id="TYPElabeled"><span class="keyword">type</span> <code class="type">('n, 'a)</code> labeled</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabeled.node">node</span>&nbsp;: <code class="type">'n</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlabeled.node_label">node_label</span>&nbsp;: <code class="type">'a</code>;</code></td>

</tr></table>
}



<pre><span class="keyword">module</span> <a href="Bap.Std.Graphlib.html">Graphlib</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Graphlib.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Generic Graph Library
</div>

<pre><span id="TYPEimage"><span class="keyword">type</span> <code class="type"></code>image</span> </pre>
<div class="info ">
an image loaded into memory<br>
</div>


<pre><span id="TYPEmem"><span class="keyword">type</span> <code class="type"></code>mem</span> </pre>
<div class="info ">
opaque memory<br>
</div>


<pre><span id="TYPEtable"><span class="keyword">type</span> <code class="type">'a</code> table</span> </pre>
<div class="info ">
a table from memory to <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="TYPEmemmap"><span class="keyword">type</span> <code class="type">'a</code> memmap</span> </pre>
<div class="info ">
interval trees from memory regions to <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Memory_iterators.html">Memory_iterators</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory_iterators.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Iterators lifted into monad
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memory.html">Memory</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memory.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Memory region
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Table.html">Table</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Table.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Table.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Location.html">Location</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Location.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A locations of a chunk of memory
</div>

<pre><span id="TYPElocation"><span class="keyword">type</span> <code class="type"></code>location</span> = <code class="type"><a href="Bap.Std.Location.html#TYPEt">Location.t</a></code> </pre>
<div class="info ">
memory location<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Backend.html">Backend</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Backend.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A backend interface.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Image.html">Image</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Image.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Binary Image.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Memmap.html">Memmap</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Memmap.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Memory maps.
</div>

<pre><span id="TYPEdisasm"><span class="keyword">type</span> <code class="type"></code>disasm</span> </pre>
<div class="info ">
value of type <code class="code">disasm</code> is a result of the disassembling of a
      memory region. To create values of this type use <code class="code">disassemble</code>
      function<br>
</div>


<pre><span id="TYPEinsn"><span class="keyword">type</span> <code class="type"></code>insn</span> </pre>
<div class="info ">
values of type <code class="code">insn</code> represents machine instructions decoded
      from the given piece of memory<br>
</div>


<pre><span id="TYPEblock"><span class="keyword">type</span> <code class="type"></code>block</span> </pre>
<div class="info ">
<code class="code">block</code> is a region of memory that is believed to be a basic block
      of control flow graph to the best of our knowledge.<br>
</div>


<pre><span id="VALdisassemble"><span class="keyword">val</span> disassemble</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble ?roots arch mem</code> disassemble provided memory region
      <code class="code">mem</code> using best available algorithm and backend for the specified
      <code class="code">arch</code>. Roots, if provided, should point to memory regions, that
      are believed to contain code. At best, this should be a list of
      function starts. If no roots are provided, then the starting
      address of the provided memory <code class="code">mem</code> will be used as a root.
<p>

      The returned value will contain all memory reachable from the
      given set of roots, at our best knowledge.<br>
</div>

<pre><span id="VALdisassemble_image"><span class="keyword">val</span> disassemble_image</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> <a href="Bap.Std.html#TYPEimage">image</a> -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_image image</code> disassemble given image.
      Will take executable segments of the image and disassemble it,
      applying <code class="code">disassemble</code> function. If no roots are specified, then
      symbol table will be used as a source of roots. If file doesn't
      contain one, then entry point will be used.<br>
</div>

<pre><span id="VALdisassemble_file"><span class="keyword">val</span> disassemble_file</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -><br>       string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a> Or_error.t</code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALdisassemble_file_exn"><span class="keyword">val</span> disassemble_file_exn</span> : <code class="type">?roots:<a href="Bap.Std.html#TYPEaddr">addr</a> list -> string -> <a href="Bap.Std.html#TYPEdisasm">disasm</a></code></pre><div class="info ">
<code class="code">disassemble_file ?roots path</code> takes a path to a binary and
      disassembles it<br>
</div>

<pre><span id="VALlinear_sweep"><span class="keyword">val</span> linear_sweep</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -><br>       <a href="Bap.Std.html#TYPEmem">mem</a> -><br>       (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list Or_error.t</code></pre><div class="info ">
<code class="code">linear_sweep arch mem</code> will perform a linear sweep disassembly on
      the specified memory <code class="code">mem</code><br>
</div>

<pre><span id="VALlinear_sweep_exn"><span class="keyword">val</span> linear_sweep_exn</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> <a href="Bap.Std.html#TYPEmem">mem</a> -> (<a href="Bap.Std.html#TYPEmem">mem</a> * <a href="Bap.Std.html#TYPEinsn">insn</a> option) list</code></pre><div class="info ">
<code class="code">linear_sweep_exn</code> same as <code class="code">linear_sweep</code>, but raises an
      exception, instead of returning <code class="code"><span class="constructor">Or_error</span></code> monad<br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm.html">Disasm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Disasm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Disassembled program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Kind.html">Kind</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Kind.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Kinds of instructions
</div>

<pre><span id="TYPEreg"><span class="keyword">type</span> <code class="type"></code>reg</span> </pre>
<div class="info ">
abstract and opaque register<br>
</div>


<pre><span id="TYPEimm"><span class="keyword">type</span> <code class="type"></code>imm</span> </pre>
<div class="info ">
opaque immediate value<br>
</div>


<pre><span id="TYPEfmm"><span class="keyword">type</span> <code class="type"></code>fmm</span> </pre>
<div class="info ">
floating point value<br>
</div>


<pre><span id="TYPEkind"><span class="keyword">type</span> <code class="type"></code>kind</span> = <code class="type"><a href="Bap.Std.Kind.html#TYPEt">Kind.t</a></code> </pre>
<div class="info ">
kind of instruction<br>
</div>


<pre><span class="keyword">module</span> <a href="Bap.Std.Reg.html">Reg</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Reg.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Register.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Imm.html">Imm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Imm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Integer immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Fmm.html">Fmm</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Fmm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Floating point immediate operand
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Op.html">Op</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Op.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Operand
</div>

<pre><span id="TYPEop"><span class="keyword">type</span> <code class="type"></code>op</span> = <code class="type"><a href="Bap.Std.Op.html#TYPEt">Op.t</a></code> </pre>


<pre><span id="TYPEsymtab"><span class="keyword">type</span> <code class="type"></code>symtab</span> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Symtab.html">Symtab</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Symtab.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Reconstructed symbol table.
</div>

<pre><span id="TYPEabi"><span class="keyword">class type</span> <a href="Bap.Std.abi-c.html">abi</a></span> = <code class="code"><span class="keyword">object</span></code> <a href="Bap.Std.abi-c.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
ABI interface.
</div>

<pre><span id="TYPEabi_constructor"><span class="keyword">type</span> <code class="type"></code>abi_constructor</span> = <code class="type"><a href="Bap.Std.html#TYPEsub">sub</a> <a href="Bap.Std.html#TYPEterm">term</a> -> <a href="Bap.Std.abi-c.html">abi</a></code> </pre>
<div class="info ">
symbol name may be provided if known. Also an access
      to the whole binary image is provided if there is one.<br>
</div>

<br>
A BIL model of CPU
<p>

      In general this is a model of a processor architecture, involving
      ALU, processing unit, registers and memory.<br>

<pre><span class="keyword">module type</span> <a href="Bap.Std.CPU.html">CPU</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.CPU.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract interface to CPU
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.ABI.html">ABI</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.ABI.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Application Binary Interface
</div>

<pre><span id="TYPEjump"><span class="keyword">type</span> <code class="type"></code>jump</span> = <code class="type">[ `Cond | `Jump ]</code> </pre>
<div class="info ">
a jump kind.
      A jump to another block can be conditional or unconditional.
<p>
This type defines a relation between two basic blocks.<br>
</div>


<pre><span id="TYPEedge"><span class="keyword">type</span> <code class="type"></code>edge</span> = <code class="type">[ `Cond | `Fall | `Jump ]</code> </pre>


<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_accessors.html">Block_accessors</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block_accessors.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Access to block attributes.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Block_traverse.html">Block_traverse</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block_traverse.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Navigate to neighborhood blocks.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Disasm_expert.html">Disasm_expert</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Disasm_expert.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Expert interface to disassembler.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Insn.html">Insn</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Insn.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Assembly instruction.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Block.html">Block</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Block.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Basic block of machine instructions.
</div>

<pre><span class="keyword">module type</span> <a href="Bap.Std.Target.html">Target</a> = <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Target.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Abstract interface for all targets.
</div>

<pre><span id="VALtarget_of_arch"><span class="keyword">val</span> target_of_arch</span> : <code class="type"><a href="Bap.Std.html#TYPEarch">arch</a> -> (module Bap.Std.Target)</code></pre><div class="info ">
<code class="code">target_of_arch arch</code> returns a module packed into value, that
      abstracts target architecture. The returned module has type
      <a href="Bap.Std.Target.html"><code class="code"><span class="constructor">Target</span></code></a> and can be unpacked locally with:
      <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">module</span>&nbsp;<span class="constructor">Target</span>&nbsp;=&nbsp;(<span class="keyword">val</span>&nbsp;target_of_arch&nbsp;arch)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><br>
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.ARM.html">ARM</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.ARM.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
ARM architecture.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.IA32.html">IA32</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.IA32.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code">x86</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.AMD64.html">AMD64</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.AMD64.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<code class="code">x86-64</code> architecture
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Tid.html">Tid</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Tid.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Term identifier
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Term.html">Term</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Term.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
IR language term.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Program.html">Program</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Program.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Sub.html">Sub</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Sub.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Blk.html">Blk</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Blk.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Block.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Def.html">Def</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Def.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Definition.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Jmp.html">Jmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Jmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A control transfer operation.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Phi.html">Phi</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Phi.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
PHI-node
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Arg.html">Arg</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Arg.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Subroutine argument.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Call.html">Call</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Call.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
A control transfer to another subroutine.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Label.html">Label</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Label.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Target of a control flow transfer.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Project.html">Project</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Project.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Target of analysis.
</div>

<pre><span id="TYPEproject"><span class="keyword">type</span> <code class="type"></code>project</span> = <code class="type"><a href="Bap.Std.Project.html#TYPEt">Project.t</a></code> </pre>


<pre><span class="keyword">module</span> <a href="Bap.Std.Dwarf.html">Dwarf</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Dwarf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Dwarf library
      This library gives an access to debugging information stored
      in a binary program.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Elf.html">Elf</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Elf.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Parse binary data in ELF format.
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Signatures.html">Signatures</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Signatures.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Binary signatures storage
</div>

<pre><span class="keyword">module</span> <a href="Bap.Std.Byteweight.html">Byteweight</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap.Std.Byteweight.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Byteweight Algorithm implementation
</div>
</body></html>