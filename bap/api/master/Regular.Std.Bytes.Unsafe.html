<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Regular.Std.Bytes.To_string.html">
<link rel="Up" href="Regular.Std.Bytes.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Regular.Std.Bytes.Unsafe</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Regular.Std.Bytes.To_string.html" title="Regular.Std.Bytes.To_string">Previous</a>
&nbsp;<a class="up" href="Regular.Std.Bytes.html" title="Regular.Std.Bytes">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Regular.Std.Bytes.Unsafe.html">Regular.Std.Bytes.Unsafe</a></h1>

<pre><span id="MODULEUnsafe"><span class="keyword">module</span> Unsafe</span>: <code class="code"><span class="keyword">sig</span></code> <a href="Regular.Std.Bytes.Unsafe.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<div class="info-desc">
<h5 id="4_Unsafeconversionsforadvancedusers">Unsafe conversions (for advanced users)</h5>
<p>This section describes unsafe, low-level conversion functions
        between <code class="code">bytes</code> and <code class="code">string</code>. They do not copy the internal data;
        used improperly, they can break the immutability invariant on
        strings provided by the <code class="code">-safe-string</code> option. They are available for
        expert library authors, but for most purposes you should use the
        always-correct <a href="Regular.Std.Bytes.html#VALto_string"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Bytes</span>.to_string</code></a> and <a href="Regular.Std.Bytes.html#VALof_string"><code class="code"><span class="constructor">Std</span>.<span class="constructor">Bytes</span>.of_string</code></a> instead.</p>
</div>
</div>
<hr width="100%">

<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type"><a href="Regular.Std.Bytes.html#TYPEt">Std.Bytes.t</a> -> string</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">to_string&nbsp;b</code> - unsafely converts a byte sequence into a string.</p>

<p>To reason about the use of <code class="code">to_string</code>, it is convenient to
          consider an "ownership" discipline. A piece of code that
          manipulates some data "owns" it; there are several disjoint ownership
          modes, including:</p>
<ul>
<li>Unique ownership: the data may be accessed and mutated</li>
<li>Shared ownership: the data has several owners, that may only
            access it, not mutate it.</li>
</ul>
<p>Unique ownership is linear: passing the data to another piece of
          code means giving up ownership (we cannot write the
          data again). A unique owner may decide to make the data shared
          (giving up mutation rights on it), but shared data may not become
          uniquely-owned again.</p>

<p><code class="code">to_string&nbsp;s</code> can only be used when the caller owns the byte
          sequence <code class="code">s</code> -- either uniquely or as shared immutable data. The
          caller gives up ownership of <code class="code">s</code>, and gains ownership of the
          returned string.</p>

<p>There are two valid use-cases that respect this ownership
          discipline:</p>

<p>1. Creating a string by initializing and mutating a byte sequence
          that is never changed after initialization is performed.</p>

<pre class="codepre"><code class="code">            <span class="keyword">let</span> string_init len f : string =
              <span class="keyword">let</span> s = <span class="constructor">Bytes</span>.create len <span class="keyword">in</span>
              <span class="keyword">for</span> i = 0 <span class="keyword">to</span> len - 1 <span class="keyword">do</span> <span class="constructor">Bytes</span>.set s i (f i) <span class="keyword">done</span>;
              <span class="constructor">Bytes</span>.<span class="constructor">Unsafe</span>.to_string s
          </code></pre>
<p>This function is safe because the byte sequence <code class="code">s</code> will never be
          accessed or mutated after <code class="code">to_string</code> is called. The
          <code class="code">string_init</code> code gives up ownership of <code class="code">s</code>, and returns the
          ownership of the resulting string to its caller.</p>

<p>Note that it would be unsafe if <code class="code">s</code> was passed as an additional
          parameter to the function <code class="code">f</code> as it could escape this way and be
          mutated in the future -- <code class="code">string_init</code> would give up ownership of
          <code class="code">s</code> to pass it to <code class="code">f</code>, and could not call <code class="code">to_string</code>
          safely.</p>

<p>We have provided the <code class="code"><span class="constructor">String</span>.init</code>, <code class="code"><span class="constructor">String</span>.map</code> and
          <code class="code"><span class="constructor">String</span>.mapi</code> functions to cover most cases of building
          new strings. You should prefer those over <code class="code">to_string</code> or
          <code class="code">to_string</code> whenever applicable.</p>

<p>2. Temporarily giving ownership of a byte sequence to a function
          that expects a uniquely owned string and returns ownership back, so
          that we can mutate the sequence again after the call ended.</p>

<pre class="codepre"><code class="code">            <span class="keyword">let</span> bytes_length (s : bytes) =
              <span class="constructor">String</span>.length (<span class="constructor">Bytes</span>.<span class="constructor">Unsafe</span>.to_string s)
          </code></pre>
<p>In this use-case, we do not promise that <code class="code">s</code> will never be mutated
          after the call to <code class="code">bytes_length&nbsp;s</code>. The <code class="code"><span class="constructor">String</span>.length</code> function
          temporarily borrows unique ownership of the byte sequence
          (and sees it as a <code class="code">string</code>), but returns this ownership back to
          the caller, which may assume that <code class="code">s</code> is still a valid byte
          sequence after the call. Note that this is only correct because we
          know that <code class="code"><span class="constructor">String</span>.length</code> does not capture its argument -- it could
          escape by a side-channel such as a memoization combinator.</p>

<p>The caller may not mutate <code class="code">s</code> while the string is borrowed (it has
          temporarily given up ownership). This affects concurrent programs,
          but also higher-order functions: if <code class="code"><span class="constructor">String</span>.length</code> returned
          a closure to be called later, <code class="code">s</code> should not be mutated until this
          closure is fully applied and returns ownership.</p>
</div>
</div>

<pre><span id="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">string -> <a href="Regular.Std.Bytes.html#TYPEt">Std.Bytes.t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">of_string&nbsp;s</code> - unsafely converts a shared string to a byte
          sequence that should not be mutated.</p>

<p>The same ownership discipline that makes <code class="code">to_string</code>
          correct applies to <code class="code">of_string</code>: you may use it if you were
          the owner of the <code class="code">string</code> value, and you will own the return
          <code class="code">bytes</code> in the same mode.</p>

<p>In practice, unique ownership of string values is extremely
          difficult to reason about correctly. You should always assume
          strings are shared, never uniquely owned.</p>

<p>For example, string literals are implicitly shared by the
          compiler, so you never uniquely own them.</p>

<pre class="codepre"><code class="code">            <span class="keyword">let</span> incorrect = <span class="constructor">Bytes</span>.<span class="constructor">Unsafe</span>.of_string <span class="string">"hello"</span>
            <span class="keyword">let</span> s = <span class="constructor">Bytes</span>.of_string <span class="string">"hello"</span>
          </code></pre>
<p>The first declaration is incorrect, because the string literal
          <code class="code"><span class="string">"hello"</span></code> could be shared by the compiler with other parts of the
          program, and mutating <code class="code">incorrect</code> is a bug. You must always use
          the second version, which performs a copy and is thus correct.</p>

<p>Assuming unique ownership of strings that are not string
          literals, but are (partly) built from string literals, is also
          incorrect. For example, mutating <code class="code">of_string&nbsp;(<span class="string">"foo"</span>&nbsp;^&nbsp;s)</code>
          could mutate the shared string <code class="code"><span class="string">"foo"</span></code> -- assuming a rope-like
          representation of strings. More generally, functions operating on
          strings will assume shared ownership, they do not preserve unique
          ownership. It is thus incorrect to assume unique ownership of the
          result of <code class="code">of_string</code>.</p>

<p>The only case we have reasonable confidence is safe is if the
          produced <code class="code">bytes</code> is shared -- used as an immutable byte
          sequence. This is possibly useful for incremental migration of
          low-level programs that manipulate immutable sequences of bytes
          (for example <code class="code"><span class="constructor">Marshal</span>.from_bytes</code>) and previously used the
          <code class="code">string</code> type for this purpose.</p>
</div>
</div>
</body></html>
