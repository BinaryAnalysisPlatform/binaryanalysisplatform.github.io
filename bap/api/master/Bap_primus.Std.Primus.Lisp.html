<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap_primus.Std.Primus.Memory.html">
<link rel="next" href="Bap_primus.Std.Primus.Exn.html">
<link rel="Up" href="Bap_primus.Std.Primus.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Monads" rel="Chapter" href="Monads.html">
<link title="Ogre" rel="Chapter" href="Ogre.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Bap_taint" rel="Chapter" href="Bap_taint.html">
<link title="Bap_primus" rel="Chapter" href="Bap_primus.html">
<link title="Bare" rel="Chapter" href="Bare.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_asm_reg" rel="Chapter" href="X86_asm_reg.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_llvm_env" rel="Chapter" href="X86_llvm_env.html">
<link title="X86_asm" rel="Chapter" href="X86_asm.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="X86_asm_reg_types" rel="Chapter" href="X86_asm_reg_types.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html">
<link title="Bap_llvm_loader" rel="Chapter" href="Bap_llvm_loader.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_strings_index" rel="Chapter" href="Bap_strings_index.html">
<link title="Bap_strings_scanner" rel="Chapter" href="Bap_strings_scanner.html">
<link title="Bap_strings" rel="Chapter" href="Bap_strings.html">
<link title="Bap_strings_detector" rel="Chapter" href="Bap_strings_detector.html">
<link title="Bap_strings_unscrambler" rel="Chapter" href="Bap_strings_unscrambler.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><title>BAR: BAP Annotated Reference : Bap_primus.Std.Primus.Lisp</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap_primus.Std.Primus.Memory.html" title="Bap_primus.Std.Primus.Memory">Previous</a>
&nbsp;<a class="up" href="Bap_primus.Std.Primus.html" title="Bap_primus.Std.Primus">Up</a>
&nbsp;<a class="post" href="Bap_primus.Std.Primus.Exn.html" title="Bap_primus.Std.Primus.Exn">Next</a>
</div>
<h1>Module <a href="type_Bap_primus.Std.Primus.Lisp.html">Bap_primus.Std.Primus.Lisp</a></h1>

<pre><span id="MODULELisp"><span class="keyword">module</span> Lisp</span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<div class="info-desc">
<p>Lisp machine.</p>

<p>The Lisp Machine is an extensible Lisp Machine embedded into
        the Primus Machine. The Lisp machine is used to provide
        function stubs (summaries), as well as to control the Primus
        Machine using a dialect of Lisp.</p>

<h2 id="1_PrimusLispLanguage">Primus Lisp Language</h2>
<h3 id="2_Overview">Overview</h3>
<p>Primus Lisp is a dialect of Lisp, that can be used to interact
        with a native program. Primus Lisp is close to Common Lisp and
        to the Emacs Lisp dialect.</p>

<p>Primus Lips is a low-level language that doesn't provide many
        abstractions, as it tries to be as close to the machine
        language as possible. In that sense Primus Lisp can be seen as
        an assembler, except that it can't really assemble binaries,
        as it operates over already existing and assembled
        program. Primus Lisp, however is still quite powerfull, as the
        absence of suitable abstractions is compensated with powerful
        and versatile meta-programming system.</p>

<p>Primus Lisp is primarily used for the following tasks:</p>
<ul>
<li>writing function summaries (aka stubs);</li>
<li>setting up program environment;</li>
<li>exploring and observing program behavior.</li>
</ul>
<p>A Primus Lisp program is a file, that can contain the
        following entities:</p>
<ul>
<li>feature requests;</li>
<li>declarations;</li>
<li>constants</li>
<li>substitutions;</li>
<li>methods;</li>
<li>macros;</li>
<li>functions;</li>
</ul>
<p>The entities may be specified in any order, however the above
        order constitutes a good programming practice.</p>

<p>Each file provides (implements) a feature, that has the same
        name as the name of the file without an extension and
        directories. Thus the namespace of features is flat. A feature
        is usually a function, macro definition, or any other
        definition, or a collection of definition, gathered under the
        same theme. For example, the <code class="code">getopt</code> feature implements C
        <code class="code">getopt</code> function, and accompanying definitions. The features
        maybe very specific, i.e., providing an implementation for
        only one small function, or they can be a collection of other
        features. For example, the <code class="code">posix</code> feature provides an
        implementation of all functions specified in the POSIX
        standard (not all at the time of writing).</p>

<p>A collection of files is called a library.  To use features
        provided by another file, the file should be requested with
        the <code class="code">(require&nbsp;&lt;ident&gt;)</code> form, where <code class="code">&lt;ident&gt;</code> is the name of
        the feature. A file with the requested name is searched in the
        library, and loaded, making all its definitions available in
        the lexical scope, that follows the <code class="code">require</code> form. If a
        feature is already provided, then nothing
        happens. Dependencies should not contain cycles.</p>

<p>Top-level declarations specify attributes that are shared by
        all definitions in a file. For example, a declaration</p>

<pre class="verbatim">(declare (context (arch armv7))</pre>
<p>makes all definitions visible only in the context of the ARMv7
        architecture.</p>

<p>Constants and substitutions are primitive abstractions that
        give names to code fragments. Macros are program
        transformations. Functions add parameters to a code, and are
        basic building blocks. Scope of all definitions can be limited
        with the context declarations. Finally, a function can be
        advised with another function using the <code class="code">advice-add</code> function.</p>

<h3 id="2_Typesystem">Type system</h3>
<p>A type defines all possible values of an expression. In Primus
        Lisp, expression values can be only scalar, i.e., machine
        words of different widths. The width is always specified in
        the number of bits. A maximum width of a word is equal to the
        width of the architecture machine word, thus a family of types
        is dependent on the context of evaluation. (Note, current
        implementation limits maximum width of the machine word to 64
        bits). We denote a type of expression with a decimal number,
        e.g., <code class="code">(exp&nbsp;:&nbsp;16)</code> means that an expression ranges over all 16
        bit words.</p>

<p>An expression can have a polymorphic type <code class="code">t</code> that denotes a
        powerset of all types for the given architecture. For example,
        for ARMv7, <b>t = 32 \/ 31 \/ .. \/ 1 </b>. Thus a value of any
        type, is a also a value of type <code class="code">t</code>.</p>

<p>Side note -- the type system doesn't include the unit type,
        i.e., the <code class="code">0</code> type. An expression <code class="code">()</code> evaluates to the <code class="code">0:1</code>
        value.</p>

<h3 id="2_Functionsandexpressions">Functions and expressions</h3>
<p>Functions are named abstractions of code, where a code is a
        sequence of expressions. Since a value of an expression is
        a machine word, functions are not first-class values in Primus
        Lisp. However, functions and types can be manipulated on the
        meta-programming level.</p>

<p>A function is defined with the <code class="code">defun</code> form, that has the
        following syntax:</p>

<pre class="codepre"><code class="code">          (defun &lt;name&gt; (&lt;arg&gt; ...) &lt;exp&gt; ...)
        </code></pre>
<p>A list of arguments (that can be empty) defines function
        arity. Functions in Primus Lisp has fixed arity, unlike
        macros.</p>

<p>A function definition may optionally contain a documentation
        strings and a declaration section. For example,</p>

<pre class="verbatim">         (defun strlen (p)
           "returns a length of the null-terminated string pointed by P"
           (declare (external "strlen"))
           (msg "strlen was called with $p")
           (let ((len 0))
             (while (not (points-to-null p))
               (incr len p))
             len))
       </pre>
<p>A function can be called (applied) using the function
        application form:</p>

<pre class="verbatim">(&lt;name&gt; &lt;exp&gt; ...)</pre>
<p>The first element of the function application form is not an
        expression and must be an identified. The rest arguments are
        expressions, that are evaluated from left to right. All
        arguments are passed by value.</p>

<p>The body of a function is a sequence of expressions, that is
        evaluated in the lexical order (i.e., from left to right). A
        value of the last expression is the result of the function
        evaluation. An expression is either a function application or
        or a special form. Primus Lisp defines only 5 special forms,
        the rest of the syntax is defined using the macro system.</p>

<h4 id="3_Conditionals">Conditionals</h4>
<p>The <b>(if &lt;test-expr&gt; &lt;then-expr&gt; &lt;else-expr&gt; ...)</b> form is a basic
        control flow structure. If <b>&lt;test-expr&gt;</b> evaluates to a non-zero word
        then the result of the <b>&lt;if&gt;</b> form is the result of evaluation
        of the <b>&lt;then-expr&gt;</b>, otherwise a sequence of <b>&lt;else-expr&gt;</b> ...
        is evaluated and the result of the form evaluation
        would be a result of the last expression in a form</p>

<p>For example,</p>

<pre class="verbatim">        (if (&lt; 4 3)
            (msg "shouldn't happen")
          (msg "that's right")
          (- 4 3))
       </pre>
<p>Note that the the <b>&lt;else-expr&gt; </b> sequence maybe empty.</p>

<p>Several derived forms are defined as macros, e.g.,</p>

<pre class="verbatim">          (when &lt;cond&gt; &lt;expr&gt; ...)
          (or &lt;expr&gt; ...)
          (and &lt;expr&gt; ...)
       </pre>
<h4 id="3_Loops">Loops</h4>
<p>Iterations can be implemented either using recursion or with
        the <code class="code"><span class="keyword">while</span></code> special form. Since the interpreter doesn't
        provide the tail-call optimization it is better to use the
        latter (although the interpreter itself is using a constant
        stack size, as it uses the host language heap memory to
        represent the Primus Lisp call stack).</p>

<p>The <b>(while &lt;cond&gt; &lt;expr&gt; ...) </b> form, will evaluate the
        &lt;cond&gt; expression first, and if it is a non-zero value, then
        the sequence of expressions <b>&lt;expr&gt; ... </b> is evaluated, and
        the value of the last expression becomes the value of the
        <code class="code"><span class="keyword">while</span></code> form. If the value of the <b>&lt;cond&gt; </b> expression is a
        false value, then this value becomes the value of the <code class="code"><span class="keyword">while</span></code>
        form.</p>

<h4 id="3_Variables">Variables</h4>
<p>The <code class="code"><span class="keyword">let</span></code> form binds values to names in the lexical scope.</p>

<pre class="verbatim">         (let (&lt;binding&gt; ...)  &lt;body-expr&gt; ...)
         binding ::= (&lt;var&gt; &lt;expr&gt;)
       </pre>
<p>Evaluates each <b>&lt;binding&gt;</b> in order binding the <b>&lt;var&gt;</b>
        identifier to a result of <b>&lt;expr&gt;</b>. The newly created
        binding is available in consequent bindings and in the
        &lt;body-expr&gt;, but is not visible outside of the scope of the
        let-form.</p>

<p>Example,</p>
<pre class="verbatim">        (let ((x 4)
              (y (+ x 2)))
          (+ x 3))
       </pre>
<p>The value of the <code class="code"><span class="keyword">let</span></code> form is the value of the last
        expression <b>&lt;sN&gt; </b>.</p>

<h4 id="3_Sequencing">Sequencing </h4>
<p>The <b>(prog &lt;expr&gt; ...) </b> form combines a sequence of
        expressions into one expression, and is useful in the contexts
        where an expression is required. The expressions are evaluated
        from left to right, and the value of the <code class="code">prog</code> form is the
        value of the last expression.</p>

<h4 id="3_Messaging">Messaging </h4>
<p>The <b>(msg &lt;fmt&gt; &lt;expr&gt; ...) </b> form constructs
        logging/debugging messages using an embedded formatting
        language. The formed message will be sent to the logging
        facility, that was set up during the Primus Lisp library
        initialization.</p>

<p>The format language interprets all symbols literally, unless
        they start with the dollar sign ($).</p>

<p>A pair of characters of the form <b>$&lt;n&gt; </b>, where <b>&lt;n&gt; </b>
        is a decimal digit, will be substituted with the value of the
        n'th expression (counting from zero).</p>

<p>Example,</p>

<pre class="verbatim">(msg "hello, $0 $0 world, (+ 7 8) = $1" "cruel" (+ 7 8))</pre>
<p>will be rendered to a message:</p>

<pre class="verbatim">"hello, cruel cruel world, (+ 7 8) = 15"</pre>
<h3 id="2_Metaprogramming">Metaprogramming</h3>
<p>Ordinary Primus Lisp expressions are evaluated at the runtime
        in the Primus emulator, and are quite limited as they need to
        be evaluated directly on the CPU model. To mitigate this
        limitation, Primus Lisp provides a powerful metaprogramming
        system. The metaprogram is evaluated when the Primus Lisp
        program is read. A metaprogram generates a program, that will
        be evaluated by the CPU. The metaprogram itself is Turing
        complete, thus any transformation can be applied to a
        program. The Primus Lisp metaprogramming system use
        term-rewriting as a computational model, with Lisp code
        fragments as terms. Primus Lisp provides three facilities for
        metaprogramming:</p>

<ul>
<li>syntactic constants;</li>
<li>syntactic substitutions;</li>
<li>macro definitions.</li>
</ul>
<h4 id="3_Constants">Constants</h4>
<p>The syntactic constants is the simplest syntactic
        substitution, it just substitutes atoms for atoms. Constants
        are introduced with the <code class="code">defconstant</code> form, that has the
        following syntax:</p>

<pre class="verbatim">         (defconstant &lt;name&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;docstring&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;declarations&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;docstring&gt; &lt;declarations&gt; &lt;atom&gt;)
       </pre>
<p>For example,</p>

<pre class="verbatim">(defconstant main-address 0xDEAD)</pre>
<p>During the program parsing, each occurrence of the
        <b>&lt;name&gt; </b> term will be rewritten with the <b>&lt;value&gt; </b>
        term, that should be an atom.</p>

<h4 id="3_Substitutions">Substitutions</h4>
<p>The syntactic substitution is a generalization of syntactic
        constant, and has quite a similar syntax:</p>

<pre class="verbatim">          | (defsubst &lt;name&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; &lt;declarations&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; :&lt;syntax&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; &lt;declarations&gt; :&lt;syntax&gt; &lt;value&gt; ...)
       </pre>
<p>During parsing, every occurrence of the term <b>&lt;name&gt; </b> (that
        should be an atom), will be rewritten with a sequence of
        values</p>
<pre class="codepre"><code class="code"> {&lt;value&gt;} </code></pre><p>.</p>

<p>Example,</p>

<pre class="verbatim">(defsubst ten-digits 0 1 2 3 4 5 6 7 8 9)</pre>
<p>A process of applying of the substitutions is called
        "expansion". Since the expansion transforms an atom to a list
        of atoms, it can be applied only inside the macro or function
        application. For example,</p>

<pre class="verbatim">(+ ten-digits)</pre>
<p>will be expanded to</p>

<pre class="verbatim">(+ 0 1 2 3 4 5 6 7 8 9 )</pre>
<h5 id="4_Specialsyntax">Special syntax</h5>
<p>Expansions also provide a support for extensible value
        specification syntax, that enables domain-specific data
        specification languages. Currently, we support only two
        syntaxes: <code class="code">:ascii</code> and <code class="code">:hex</code>.</p>

<p>In the <code class="code">:ascii</code> syntax the values should be atoms, possibly
        delimited with double quotes. Each character of each atom will
        be expanded to its corresponding ASCII code. Strings can
        contain special characters prefixed with a backslash. The
        special character can be one of the well-known ASCII special
        character, e.g., <code class="code">\n</code>, <code class="code">\r</code>, etc, or it can be a decimal or a
        hexadecimal code of a character.</p>

<p>Example, given the following substitution:</p>

<pre class="verbatim">(defsubst hello-cruel-world :ascii "hello, cruel world\n\000")</pre>
<p>the following application:</p>

<pre class="verbatim">(write-block SP hello-cruel-world</pre>
<p>will be expanded with</p>

<pre class="codepre"><code class="code">          (write-block <span class="constructor">SP</span>
             0x68 0x65 0x6c 0x6c 0x6f 0x2c 0x20 0x63
             0x72 0x75 0x65 0x6c 0x20 0x77 0x6f 0x72
             0x6c 0x64 0x0a 0x00)
        </code></pre>
<p>In the <code class="code">:hex</code> syntax the sequence of atoms is split into
        two-characters subsequences each treated as a hex value. This
        syntax is useful for encoding memory dumps in a format that is
        close to the hexdump (without offsets). E.g., given the
        following substitution rule</p>

<pre class="codepre"><code class="code">          (defsubt example :hex 68656c 6c 6f2c2063)
        </code></pre>
<p>an application</p>

<pre class="codepre"><code class="code">          (write-block <span class="constructor">SP</span> example)
        </code></pre>
<p>will be expanded into</p>

<pre class="codepre"><code class="code">          (write-block <span class="constructor">SP</span> 0x68 0x65 0x6c 0x6c 0x6f 0x2c 0x20 0x63)
        </code></pre>
<h4 id="3_Macro">Macro</h4>
<p>The macros provide the most versatile and powerful way to
        specify arbitrary code transformations. The macro definitions
        introduce abstractions on the meta-programming level. I.e., it
        allows a programmer to write a function that operates on code
        terms, making the code a first class value.</p>

<p>The macro definition has the following syntax:</p>

<pre class="verbatim">          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;docstring&gt; &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;declarations&gt; &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;value&gt;)
       </pre>
<p>A macro definition adds a term rewriting rule, that rewrites
        each occurrence of <b>(&lt;name&gt; &lt;arg&gt; ...) </b>, where the number
        of arguments <code class="code"><span class="constructor">N</span></code> is greater or equal then the number of
        parameters <code class="code"><span class="constructor">M</span></code>, with the <b>&lt;value&gt; </b> in which occurrences of the
        <code class="code">i</code>th parameter is substituted with the term <code class="code">i</code>th argument. If <code class="code"><span class="constructor">N</span></code> is
        bigger than <code class="code"><span class="constructor">M</span></code>, then the last parameter is bound with the
        sequence of arguments  <b>&lt;argM&gt;...&lt;argN&gt; </b>.</p>

<p>The macro subsystem doesn't provide any specific looping or
        control-flow facilities, however, the macro-overloading
        mechanism along with the recursion make it possible to encode
        arbitrary meta-transformations.</p>

<p>Other than a standard context-based ad-hoc overloading
        mechanism, the macro application uses the arity-based
        resolution. As it was described above, if a number of
        arguments is greater than the number of parameters, then the
        last parameter is bound to the rest of the arguments. When
        several macro definitions matches, then a definition that has
        fewer unmatched arguments is chosen. For example, suppose we
        have the following definitions:</p>

<pre class="verbatim">          (defmacro list-length (x) 1)
          (defmacro list-length (x xs) (+ 1 (list-length xs)))
       </pre>
<p>The the following term</p>

<pre class="verbatim">(list-length 1 2 3)</pre>
<p>will be normalized (after a series of transformations) with
        the following:</p>

<pre class="verbatim">(+ 1 (+ 1 1))</pre>
<pre class="verbatim">          1: (list-length 1 2 3) =&gt; (+ 1 (list-length 2 3))
          2: (+ 1 (list-length 2 3)) =&gt; (+ 1 (+ 1 (list-length 3)))
          3: (+ 1 (+ 1 (list-length 3))) =&gt; (+ 1 (+ 1 1))
       </pre>
<p>In the first step, both definition match. In the first
        definition <code class="code">x</code> is bound to <code class="code">1&nbsp;2&nbsp;3</code>, while in the second
        <code class="code">x</code> is bound to <code class="code">1</code> and <code class="code">xs</code> is bound to <code class="code">2&nbsp;3</code>. Since the last
        parameter is bound to fewer arguments, the second definition
        is chosen as the most certain. In the second step the second
        definition is still more concrete. Finally at the last step,
        the second definition doesn't match at all, as it has more
        parameters than arguments.</p>

<p>A slightly more complex example, is a fold iterator, that
        applies a function to a sequence of arguments  of arbitrary
        length, e.g.,</p>

<pre class="verbatim">          (defmacro fold (f a x) (f a x))
          (defmacro fold (f a x xs) (fold f (f a x) xs))
       </pre>
<p>Using this definition we can define a sum function (although
        it is not needed as the <code class="code">+</code> function defined in the Primus Lisp
        standard library, already accepts arbitrary number of
        arguments), as:</p>

<pre class="verbatim">(defmacro sum (xs) (fold + 0 xs))</pre>
<p>The <b>(sum 1 2 3) </b> will be rewritten as follows:</p>

<pre class="verbatim">          1: (sum 1 2 3) =&gt; (fold + 0 1 2 3)
          2: (fold + 0 1 2 3) =&gt; (fold + (+ 0 1) 2 3)
          3: (fold + (+ 0 1) 2 3) =&gt; (fold + (+ (+ 0 1) 2) 3)
          4: (fold + (+ (+ 0 1) 2) 3) =&gt; (+ (+ (+ 0 1) 2) 3)
       </pre>
<p>A more real example is the <code class="code">write-block</code> macro, that takes a
        sequence of bytes, and writes them starting from the given
        address:</p>

<pre class="verbatim">          (defmacro write-block (addr bytes)
             (fold memory-write addr bytes))
       </pre>
<p>The definition uses the <code class="code">memory-write</code> primitive, that writes
        a byte at the given address and returns an address of the next
        byte.</p>

<h3 id="2_Polymorphism">Polymorphism</h3>
<p>Primus Lisp provides both kinds of polymorphism: parametric
        and ad hoc.</p>

<p>Expressions in Primus Lisp have types, that are denoted with
        natural numbers starting with one. Each type defines a set of
        values that can be represented with the given number of
        bits. Values with different widths are different, even if they
        represent the same number. Expressions can be polymorphic,
        e.g., function</p>

<pre class="verbatim">(defun square (x) ( * x x))</pre>
<p>has type `forall n. n -&gt; n -&gt; n`. Thus it can be applied to
        values of different types, e.g., <code class="code">(square&nbsp;4:4)</code>, that will be
        evaluated to the <code class="code">0:4</code> value, or <code class="code">(square&nbsp;4:8)</code>, that will be
        evaluated to <code class="code">16:8</code>, etc. The parametric polymorphism doesn't
        require any special annotations or type specifications so we
        will not stop on it anymore.</p>

<p>The ad hoc polymorphism provides a facilities for overloading
        definitions. That is, the same entity may have multiple
        definitions, and depending on a context, only one definition
        should be chosen. Not only functions can have multiple
        definitions, but also macros, constants, and
        substitutions. Since the latter three entities operate on the
        syntactic level, the syntax of Primus Lisp itself is
        context-dependent.</p>

<h4 id="3_Context">Context</h4>
<p>A context (from the perspective of the type system) is a set
        of type class instances. The context is fixed when a program
        is parsed. A Primus Lisp program may not change the context;
        neither in runtime, nor it the parse time, thus a program is
        parsed and evaluated at the specific context. However, a
        definition may declare that it makes sense only in some
        context. If more than one definition make sense under the
        given context, then the most specific one is chosen. If no
        definition is more specific than another, then an error
        occurs.</p>

<p>A type class defines a type as a set of features. The subset
        relation induces a subtyping relation over types - a type <code class="code">t'</code>
        is a subtype of a type <code class="code">t</code> if <code class="code">t'&nbsp;&lt;=&nbsp;t</code> (i.e., if <code class="code">t'</code> is a
        subset of <code class="code">t</code>). Each feature is a textual tag, called a
        feature constructor.</p>

<p>The context declaration limits an associated definition to the
        specified type class(es), and has the following syntax:</p>

<pre class="verbatim">          (declare (context (&lt;type-class&gt; &lt;feature&gt; ...) ...))
       </pre>
<p>Let's use the following two definitions for a concrete example,</p>

<pre class="verbatim">          (defmacro get-arg-0 ()
             (declare (context (arch arm gnueabi)))
             R0)

          (defmacro get-arg-0 ()
             (declare (context (arch x86 cdecl)))
             (read-word word-width (+ SP (sizeof word-width))))
       </pre>
<p>We have two definitions of the same macro <code class="code">get-arg-0</code>, that
        are applicable to different contexts. The first definition,
        is only applicable in the context of the ARM architecture and
        the gnueabi ABI. The second is applicable in the context of
        the x86 architecture and the cdecl ABI. More formally, a
        definition is considered only if its context is a subtype of
        the current type context.</p>

<h3 id="2_Advicemechanism">Advice mechanism</h3>
<p>Primus Lisp also provides a mechanism for non-intrusive
        extending existing function definitions. An existing
        definition maybe advised with another definition. A piece of
        advice maybe added to a function that will be called either
        before or after the evaluation of an advised function, e.g.,</p>

<pre class="verbatim">          (defun memory-written (a x)
            (declare (advice :before memory-write))
            (msg "write $x to $a"))
       </pre>
<p>This definition not only defines a new function called
        <code class="code">memory-written</code>, but also proclaims it as advice function to
        the <code class="code">memory-write</code> function that should before it is called.</p>

<p>If an advisor is attached before the advised function, then
        it the advisor will be called with the same arguments as the
        advised function. The return value of the advisor is
        ignored. The advisor function will be called as a normal Lisp
        function, with all expected overloading and name resolving. So
        it is possible to provide context specific advice. If there
        are several advice to the same function, then they will be
        called in the unspecified order.</p>

<p>An advisor that is attached after the advised function will be
        called with one extra argument - the result of evaluation of
        the advised function. The value returned by the advisor will
        override the result of the advised function. If there are
        several advisors attached after the same function, then they
        will be called in the unspecified order.</p>

<h3 id="2_SignalingMechanims">Signaling Mechanims</h3>
<p>The Primus Observation system is reflected onto the Primus
        Lisp Machine Signals. Every time a reflected observation
        occurs the Lisp Machine receives a signal that is dispatched
        to handlers. A handler can be declared defined with the
        <code class="code">defmethod</code> form, e.g.,</p>

<pre class="verbatim">        (defmethod call (name arg)
          (when (= name 'malloc)
            (msg "malloc($0) was called" arg)))
       </pre>
<p>The <code class="code">defmethod</code> form follows the general definiton template,
        i.e., it can contain a docstring and declaration section, and
        selection and resolution rules are applicable to
        methods. Methods of the same signal are invoked in an
        unspecified order.</p>

<h3 id="2_Formalsyntax">Formal syntax</h3>
<p>Each entity is an s-expression with the grammar, specified
        below.We use BNF-like syntax with the following conventions.
        Metavariables are denoted like <code class="code">&lt;this&gt;</code>. The <code class="code">&lt;this&gt;&nbsp;...</code>
        stands of any number of <code class="code">&lt;this&gt;</code> (possibly zero). Ordinary
        parentheses do not bear any notation, and should be read
        literally. Note, since the grammar is not context free, and is
        extensible, the following is an approximation of the language
        grammar. Grammar extension points are defined with the
        '?extensible?'comment in a production definition.</p>

<pre class="verbatim">module ::= &lt;entity&gt; ...

entity ::=
  | &lt;feature-request&gt;
  | &lt;declarations&gt;
  | &lt;constant-definition&gt;
  | &lt;substitution-definition&gt;
  | &lt;parameter-definition&gt;
  | &lt;macro-definition&gt;
  | &lt;function-definition&gt;
  | &lt;method-definition&gt;

feature-request ::= (require &lt;ident&gt;)

declarations ::= (declare &lt;attribute&gt; ...)

constant-definition ::=
  | (defconstant &lt;ident&gt; &lt;atom&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;docstring&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt; &lt;docstring&gt;)

parameter-definition ::=
  | (defparameter &lt;ident&gt; &lt;atom&gt;)
  | (defparameter &lt;ident&gt; &lt;atom&gt; &lt;docstring&gt;)
  | (defparameter &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt; &lt;docstring&gt;)

substitution-definition ::=
  | (defsubst &lt;ident&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; &lt;declarations&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; :&lt;syntax&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; &lt;declarations&gt; :&lt;syntax&gt; &lt;atom&gt; ...)

macro-definition ::=
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;docstring&gt; &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;declarations&gt; &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt;)

function-definition ::=
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;declarations&gt; &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt; ...)

method-definition ::=
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;declarations&gt; &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt; ...)


exp ::=
  | ()
  | &lt;var&gt;
  | &lt;word&gt;
  | &lt;sym&gt;
  | (if &lt;exp&gt; &lt;exp&gt; &lt;exp&gt; ...)
  | (let (&lt;binding&gt; ...) &lt;exp&gt; ...)
  | (set &lt;var&gt; &lt;exp&gt;)
  | (while &lt;exp&gt; &lt;exp&gt; &lt;exp&gt; ...)
  | (prog &lt;exp&gt; ...)
  | (msg &lt;format&gt; &lt;exp&gt; ...)
  | (&lt;ident&gt; &lt;exp&gt; ...)

binding ::= (&lt;var&gt; &lt;exp&gt;)

var ::= &lt;ident&gt; | &lt;ident&gt;:&lt;size&gt;

attribute ::=
  | (external &lt;ident&gt; ...)
  | (context (&lt;ident&gt; &lt;ident&gt; ...) ...)
  | (&lt;ident&gt; ?ident-specific-format?)

docstring ::= &lt;text&gt;

syntax ::= :hex | :ascii | ...

atom  ::= &lt;word&gt; | &lt;text&gt;

word  ::= ?ascii-char? | &lt;int&gt; | &lt;int&gt;:&lt;size&gt;

sym   ::= '&lt;atom&gt;

int   ::= ?decimal-octal-hex-or-bin format?

size  ::= ?decimal?

ident ::= ?any atom that is not recognized as a &lt;word&gt;?
       </pre></div>
</div>
<hr width="100%">

<pre><span id="TYPEprogram"><span class="keyword">type</span> <code class="type"></code>program</span> </pre>
<div class="info ">
<div class="info-desc">
<p>an abstract type representing a lisp program</p>
</div>
</div>


<pre><span id="TYPEmessage"><span class="keyword">type</span> <code class="type"></code>message</span> </pre>
<div class="info ">
<div class="info-desc">
<p>an abstract type that represents messages send with the
          <code class="code">msg</code> form.</p>
</div>
</div>


<pre><span id="MODULELoad"><span class="keyword">module</span> <a href="Bap_primus.Std.Primus.Lisp.Load.html">Load</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Load.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<p>Primus Lisp program loader</p>

</div>

<pre><span id="MODULEDoc"><span class="keyword">module</span> <a href="Bap_primus.Std.Primus.Lisp.Doc.html">Doc</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Doc.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="MODULEType"><span class="keyword">module</span> <a href="Bap_primus.Std.Primus.Lisp.Type.html">Type</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Type.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<p>Lisp Type System.</p>

</div>

<pre><span id="MODULEMessage"><span class="keyword">module</span> <a href="Bap_primus.Std.Primus.Lisp.Message.html">Message</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Message.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<p>Lisp Machine Message interface.</p>

</div>

<pre><span id="MODULETYPEClosure"><span class="keyword">module type</span> <a href="Bap_primus.Std.Primus.Lisp.Closure.html">Closure</a></span> = <code class="code">(</code><code class="code"><span class="constructor">Machine</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Bap_primus.Std.Primus.Machine.S.html">Std.Primus.Machine.S</a></code><code class="code">)&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Closure.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<p>Machine independent closure.</p>

</div>

<pre><span id="TYPEclosure"><span class="keyword">type</span> <code class="type"></code>closure</span> = <code class="type">(module Bap_primus.Std.Primus.Lisp.Closure)</code> </pre>
<div class="info ">
<div class="info-desc">
<p>a closure packed as an OCaml value</p>
</div>
</div>


<pre><span id="MODULEPrimitive"><span class="keyword">module</span> <a href="Bap_primus.Std.Primus.Lisp.Primitive.html">Primitive</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Primitive.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="MODULETYPEPrimitives"><span class="keyword">module type</span> <a href="Bap_primus.Std.Primus.Lisp.Primitives.html">Primitives</a></span> = <code class="code">(</code><code class="code"><span class="constructor">Machine</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Bap_primus.Std.Primus.Machine.S.html">Std.Primus.Machine.S</a></code><code class="code">)&nbsp;</code><code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Primitives.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="TYPEprimitives"><span class="keyword">type</span> <code class="type"></code>primitives</span> = <code class="type">(module Bap_primus.Std.Primus.Lisp.Primitives)</code> </pre>
<div class="info ">
<div class="info-desc">
<p>a list of primitives.</p>
</div>
</div>

<pre><code><span class="keyword">type</span> <code class="type"></code><a href="Bap_primus.Std.Primus.html#TYPEexn">Std.Primus.exn</a> += </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="EXTENSIONRuntime_error">Runtime_error</span> <span class="keyword">of</span> <code class="type">string</code></code></td>

</tr></table>



<pre><span id="VALmessage"><span class="keyword">val</span> message</span> : <code class="type"><a href="Bap_primus.Std.Primus.Lisp.html#TYPEmessage">message</a> <a href="Bap_primus.Std.Primus.html#TYPEobservation">Std.Primus.observation</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">message</code> observation occurs every time a message is sent
          from the Primus Machine.</p>
</div>
</div>

<pre><span id="MODULEMake"><span class="keyword">module</span> <a href="Bap_primus.Std.Primus.Lisp.Make.html">Make</a></span> <code class="code">(</code><code class="code"><span class="constructor">Machine</span></code><code class="code">&nbsp;:&nbsp;</code><code class="type"><a href="Bap_primus.Std.Primus.Machine.S.html">Std.Primus.Machine.S</a></code><code class="code">)&nbsp;</code>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_primus.Std.Primus.Lisp.Make.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
<p>Make(Machine) creates a Lisp machine embedded into the
          Primus <code class="code"><span class="constructor">Machine</span></code>.</p>

</div>
</body></html>
