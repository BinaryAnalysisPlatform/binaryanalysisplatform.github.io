<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Regular.Std.Data.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_bundle" rel="Chapter" href="Bap_bundle.html">
<link title="Bap_config" rel="Chapter" href="Bap_config.html">
<link title="Core_printers" rel="Chapter" href="Core_printers.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Regular" rel="Chapter" href="Regular.html">
<link title="Bap_future" rel="Chapter" href="Bap_future.html">
<link title="Graphlib" rel="Chapter" href="Graphlib.html">
<link title="Arm_insn" rel="Chapter" href="Arm_insn.html">
<link title="Arm_mul" rel="Chapter" href="Arm_mul.html">
<link title="Arm_utils" rel="Chapter" href="Arm_utils.html">
<link title="Arm_mem_shift" rel="Chapter" href="Arm_mem_shift.html">
<link title="Arm_flags" rel="Chapter" href="Arm_flags.html">
<link title="Arm_env" rel="Chapter" href="Arm_env.html">
<link title="Arm_mem" rel="Chapter" href="Arm_mem.html">
<link title="Arm_op" rel="Chapter" href="Arm_op.html">
<link title="Arm_bit" rel="Chapter" href="Arm_bit.html">
<link title="Arm_branch" rel="Chapter" href="Arm_branch.html">
<link title="ARM" rel="Chapter" href="ARM.html">
<link title="Arm_shift" rel="Chapter" href="Arm_shift.html">
<link title="Arm_mov" rel="Chapter" href="Arm_mov.html">
<link title="Arm_cond" rel="Chapter" href="Arm_cond.html">
<link title="Arm_types" rel="Chapter" href="Arm_types.html">
<link title="Arm_reg" rel="Chapter" href="Arm_reg.html">
<link title="Arm_helpers" rel="Chapter" href="Arm_helpers.html">
<link title="Arm_lifter" rel="Chapter" href="Arm_lifter.html">
<link title="X86_types" rel="Chapter" href="X86_types.html">
<link title="X86_env" rel="Chapter" href="X86_env.html">
<link title="X86_cpu" rel="Chapter" href="X86_cpu.html">
<link title="Bap_api" rel="Chapter" href="Bap_api.html">
<link title="Bap_abi" rel="Chapter" href="Bap_abi.html">
<link title="Bap_c_type" rel="Chapter" href="Bap_c_type.html">
<link title="Bap_c_data" rel="Chapter" href="Bap_c_data.html">
<link title="Bap_c_attr" rel="Chapter" href="Bap_c_attr.html">
<link title="Bap_c_type_mapper_intf" rel="Chapter" href="Bap_c_type_mapper_intf.html">
<link title="Bap_c_type_printer" rel="Chapter" href="Bap_c_type_printer.html">
<link title="Bap_c_term_attributes" rel="Chapter" href="Bap_c_term_attributes.html">
<link title="Bap_c_abi" rel="Chapter" href="Bap_c_abi.html">
<link title="Bap_c_type_mapper" rel="Chapter" href="Bap_c_type_mapper.html">
<link title="Bap_c" rel="Chapter" href="Bap_c.html">
<link title="Bap_c_parser" rel="Chapter" href="Bap_c_parser.html">
<link title="Bap_c_size" rel="Chapter" href="Bap_c_size.html">
<link title="Bap_traces" rel="Chapter" href="Bap_traces.html">
<link title="Bap_bml" rel="Chapter" href="Bap_bml.html">
<link title="Bap_byteweight_signatures" rel="Chapter" href="Bap_byteweight_signatures.html">
<link title="Bap_byteweight" rel="Chapter" href="Bap_byteweight.html">
<link title="Bap_demangle" rel="Chapter" href="Bap_demangle.html">
<link title="Bap_ida" rel="Chapter" href="Bap_ida.html">
<link title="Bap_elf" rel="Chapter" href="Bap_elf.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Microx" rel="Chapter" href="Microx.html">
<link title="Microx_conqueror" rel="Chapter" href="Microx_conqueror.html">
<link title="Microx_concretizer" rel="Chapter" href="Microx_concretizer.html">
<link title="Bap_build" rel="Chapter" href="Bap_build.html">
<link title="Text_tags" rel="Chapter" href="Text_tags.html"><link title="Low level access to serializers" rel="Section" href="#2_Lowlevelaccesstoserializers">
<title>BAR: BAP Annotated Reference : Regular.Std.Data.S</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Regular.Std.Data.html" title="Regular.Std.Data">Up</a>
&nbsp;</div>
<h1>Module type <a href="type_Regular.Std.Data.S.html">Regular.Std.Data.S</a></h1>

<pre><span class="keyword">module type</span> S = <code class="code"><span class="keyword">sig</span></code> <a href="Regular.Std.Data.S.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info modtype top">
Data type interface.
<p>

        Types that implement this interface have a concrete
        representation, that can be serialized and deserialized.
<p>

        The only requirement is to provide a <code class="code">version</code> value, that
        represents a version number of the representation. Every time
        the representation changes, the version should be incremented.
<p>

        The interface allows to implement more than one format and
        several versions of the same format. By default, the OCaml
        Marshal format is used.
<p>

        All <code class="code"><span class="constructor">Regular</span></code> modules include this interface. The <code class="code"><span class="constructor">Regular</span></code>
        modules provide <code class="code">sexp</code> and <code class="code">bin_io</code> formats in addition to
        the <code class="code"><span class="constructor">Marshal</span></code>. They may provide more formats.
<p>

        <h3 id="3_Example">Example</h3>
<p>

        Given a module <code class="code"><span class="constructor">Bil</span></code> that implements <code class="code"><span class="constructor">Regular</span></code> interface, it
        is possible to read a value of type <code class="code"><span class="constructor">Bil</span>.t</code> as simple, as:
<p>

        <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prog&nbsp;=&nbsp;<span class="constructor">Bil</span>.<span class="constructor">Io</span>.read&nbsp;filename
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
type constructor<br>
</div>


<pre><span id="TYPEinfo"><span class="keyword">type</span> <code class="type"></code>info</span> = <code class="type">string * [ `Ver of string ] * string option</code> </pre>
<div class="info ">
<code class="code">name,<span class="constructor">Ver</span> v,desc</code> information attached to a particular
          reader or writer.<br>
</div>


<pre><span id="VALversion"><span class="keyword">val</span> version</span> : <code class="type">string</code></pre><div class="info ">
Data representation version. After any change in data
          representation the version should be increased.
<p>

          Serializers that are derived from a data representation must have
          the same version as a version of the data structure, from which
          it is derived. This kind of serializers can only read and write
          data of the same version.
<p>

          Other serializers can actually read and write data independent
          on its representation version. A serializer, that can't store
          data of current version simply shouldn't be added to a set of
          serializers.
<p>

          It is assumed, that if a reader and a writer has the same name
          and version, then whatever was written by the writer should be
          readable by the reader. The round-trip equality is not required,
          thus it is acceptable if some information is lost.
<p>

          It is also possible, that a reader and a writer that has the
          same name are compatible. In that case it is recommended to use
          semantic versioning.<br>
</div>

<pre><span id="VALsize_in_bytes"><span class="keyword">val</span> size_in_bytes</span> : <code class="type">?ver:string -> ?fmt:string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">size_in_bytes ?ver ?fmt datum</code> returns the amount of bytes
          that is needed to represent <code class="code">datum</code> in the given format
          and version<br>
</div>

<pre><span id="VALof_bytes"><span class="keyword">val</span> of_bytes</span> : <code class="type">?ver:string -> ?fmt:string -> <a href="Regular.Std.html#TYPEbytes">bytes</a> -> <a href="Regular.Std.Data.S.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_bytes ?ver ?fmt bytes</code> deserializes a value from bytes.<br>
</div>

<pre><span id="VALto_bytes"><span class="keyword">val</span> to_bytes</span> : <code class="type">?ver:string -> ?fmt:string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> -> <a href="Regular.Std.html#TYPEbytes">bytes</a></code></pre><div class="info ">
<code class="code">to_bytes ?ver ?fmt datum</code> serializes a <code class="code">datum</code> to a sequence of
          bytes.<br>
</div>

<pre><span id="VALblit_to_bytes"><span class="keyword">val</span> blit_to_bytes</span> : <code class="type">?ver:string -><br>       ?fmt:string -> <a href="Regular.Std.html#TYPEbytes">bytes</a> -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> -> int -> unit</code></pre><div class="info ">
<code class="code">blit_to_bytes ?ver ?fmt buffer datum offset</code> copies a
          serialized representation of datum into a <code class="code">buffer</code>, starting from
          the <code class="code">offset</code>.<br>
</div>

<pre><span id="VALof_bigstring"><span class="keyword">val</span> of_bigstring</span> : <code class="type">?ver:string -><br>       ?fmt:string -> bigstring -> <a href="Regular.Std.Data.S.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_bigstring ?ver ?fmt buf</code> deserializes a datum from bigstring<br>
</div>

<pre><span id="VALto_bigstring"><span class="keyword">val</span> to_bigstring</span> : <code class="type">?ver:string -><br>       ?fmt:string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> -> bigstring</code></pre><div class="info ">
<code class="code">of_bigstring ?ver ?fmt datum</code> serializes a datum to a sequence of
          bytes represented as bigstring<br>
</div>

<pre><span id="VALblit_to_bigstring"><span class="keyword">val</span> blit_to_bigstring</span> : <code class="type">?ver:string -><br>       ?fmt:string -><br>       bigstring -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> -> int -> unit</code></pre><div class="info ">
<code class="code">blit_to_bigstring ?ver ?fmt buffer datum offset</code> copies a
          serialized representation of datum into a <code class="code">buffer</code>, starting from
          <code class="code">offset</code>.<br>
</div>

<pre><span class="keyword">module</span> <a href="Regular.Std.Data.S.Io.html">Io</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Regular.Std.Data.S.Io.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Input/Output functions for the given datum.
</div>

<pre><span class="keyword">module</span> <a href="Regular.Std.Data.S.Cache.html">Cache</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Regular.Std.Data.S.Cache.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Data cache.
</div>

<pre><span id="VALadd_reader"><span class="keyword">val</span> add_reader</span> : <code class="type">?desc:string -><br>       ver:string -> string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEreader">reader</a> -> unit</code></pre><div class="info ">
<code class="code">add_reader ?desc ~ver name reader</code> registers a new <code class="code">reader</code>
          with a provided <code class="code">name</code>, version <code class="code">ver</code> and optional description
          <code class="code">desc</code><br>
</div>

<pre><span id="VALadd_writer"><span class="keyword">val</span> add_writer</span> : <code class="type">?desc:string -><br>       ver:string -> string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEwriter">writer</a> -> unit</code></pre><div class="info ">
<code class="code">add_writer ?desc ~ver name writer</code> registers a new <code class="code">writer</code>
          with a provided <code class="code">name</code>, version <code class="code">ver</code> and optional description
          <code class="code">desc</code><br>
</div>

<pre><span id="VALavailable_readers"><span class="keyword">val</span> available_readers</span> : <code class="type">unit -> <a href="Regular.Std.Data.S.html#TYPEinfo">info</a> list</code></pre><div class="info ">
<code class="code">available_reader ()</code> lists available readers for the data type<br>
</div>

<pre><span id="VALdefault_reader"><span class="keyword">val</span> default_reader</span> : <code class="type">unit -> <a href="Regular.Std.Data.S.html#TYPEinfo">info</a></code></pre><div class="info ">
<code class="code">default_reader</code> returns information about default reader<br>
</div>

<pre><span id="VALset_default_reader"><span class="keyword">val</span> set_default_reader</span> : <code class="type">?ver:string -> string -> unit</code></pre><div class="info ">
<code class="code">set_default_reader ?ver name</code> sets new default reader. If
          version is not specifed then the latest available version is
          used. Raises an exception if a reader with a given name doesn't
          exist.<br>
</div>

<pre><span id="VALwith_reader"><span class="keyword">val</span> with_reader</span> : <code class="type">?ver:string -> string -> (unit -> 'a) -> 'a</code></pre><div class="info ">
<code class="code">with_reader ?ver name operation</code> temporary sets a default
          reader to a reader with a specified name and version. The default
          reader is restored after <code class="code">operation</code> is finished.<br>
</div>

<pre><span id="VALavailable_writers"><span class="keyword">val</span> available_writers</span> : <code class="type">unit -> <a href="Regular.Std.Data.S.html#TYPEinfo">info</a> list</code></pre><div class="info ">
<code class="code">available_writer ()</code> lists available writers for the data type<br>
</div>

<pre><span id="VALdefault_writer"><span class="keyword">val</span> default_writer</span> : <code class="type">unit -> <a href="Regular.Std.Data.S.html#TYPEinfo">info</a></code></pre><div class="info ">
<code class="code">default_writer</code> returns information about the default writer<br>
</div>

<pre><span id="VALset_default_writer"><span class="keyword">val</span> set_default_writer</span> : <code class="type">?ver:string -> string -> unit</code></pre><div class="info ">
<code class="code">set_default_writer ?ver name</code> sets new default writer. If
          version is not specifed then the latest available version is
          used. Raises an exception if a writer with a given name doesn't
          exist.<br>
</div>

<pre><span id="VALwith_writer"><span class="keyword">val</span> with_writer</span> : <code class="type">?ver:string -> string -> (unit -> 'a) -> 'a</code></pre><div class="info ">
<code class="code">with_writer ?ver name operation</code> temporary sets a default
          writer to a writer with a specified name and version. The default
          writer is restored after <code class="code">operation</code> is finished.<br>
</div>

<pre><span id="VALdefault_printer"><span class="keyword">val</span> default_printer</span> : <code class="type">unit -> <a href="Regular.Std.Data.S.html#TYPEinfo">info</a> option</code></pre><div class="info ">
<code class="code">default_writer</code> optionally returns an information about
          default printer<br>
</div>

<pre><span id="VALset_default_printer"><span class="keyword">val</span> set_default_printer</span> : <code class="type">?ver:string -> string -> unit</code></pre><div class="info ">
<code class="code">set_default_printer ?ver name</code> sets new default printer. If
          version is not specifed then the latest available version is
          used. Raises an exception if a printer with a given name doesn't
          exist.<br>
</div>

<pre><span id="VALwith_printer"><span class="keyword">val</span> with_printer</span> : <code class="type">?ver:string -> string -> (unit -> 'a) -> 'a</code></pre><div class="info ">
<code class="code">with_printer ?ver name operation</code> temporary sets a default
          printer to a printer with a specified name and version. The default
          printer is restored after <code class="code">operation</code> is finished.<br>
</div>
<br>
<h2 id="2_Lowlevelaccesstoserializers">Low level access to serializers</h2><br>

<pre><span id="VALfind_reader"><span class="keyword">val</span> find_reader</span> : <code class="type">?ver:string -> string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEreader">reader</a> option</code></pre><div class="info ">
<code class="code">find_reader ?ver name</code> lookups a reader with a given name. If
          version is not specified, then a reader with maximum version is
          returned.<br>
</div>

<pre><span id="VALfind_writer"><span class="keyword">val</span> find_writer</span> : <code class="type">?ver:string -> string -> <a href="Regular.Std.Data.S.html#TYPEt">t</a> <a href="Regular.Std.html#TYPEwriter">writer</a> option</code></pre><div class="info ">
<code class="code">find_writer ?ver name</code> lookups a writer with a given name. If
          version is not specified, then a writer with maximum version is
          returned.<br>
</div>
</body></html>