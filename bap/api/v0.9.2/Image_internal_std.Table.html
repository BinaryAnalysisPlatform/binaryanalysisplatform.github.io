<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Image_internal_std.Backend.html">
<link rel="Up" href="Image_internal_std.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_plugin" rel="Chapter" href="Bap_plugin.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Bap_types" rel="Chapter" href="Bap_types.html">
<link title="Bap_addr" rel="Chapter" href="Bap_addr.html">
<link title="Bap_arch" rel="Chapter" href="Bap_arch.html">
<link title="Bap_bil" rel="Chapter" href="Bap_bil.html">
<link title="Bap_bitvector" rel="Chapter" href="Bap_bitvector.html">
<link title="Bap_common" rel="Chapter" href="Bap_common.html">
<link title="Bap_exp" rel="Chapter" href="Bap_exp.html">
<link title="Bap_int_conversions" rel="Chapter" href="Bap_int_conversions.html">
<link title="Bap_integer" rel="Chapter" href="Bap_integer.html">
<link title="Bap_integer_intf" rel="Chapter" href="Bap_integer_intf.html">
<link title="Bap_regular" rel="Chapter" href="Bap_regular.html">
<link title="Bap_seq" rel="Chapter" href="Bap_seq.html">
<link title="Bap_size" rel="Chapter" href="Bap_size.html">
<link title="Bap_stmt" rel="Chapter" href="Bap_stmt.html">
<link title="Bap_type" rel="Chapter" href="Bap_type.html">
<link title="Bap_var" rel="Chapter" href="Bap_var.html">
<link title="Bap_image" rel="Chapter" href="Bap_image.html">
<link title="Bap_memory" rel="Chapter" href="Bap_memory.html">
<link title="Bap_table" rel="Chapter" href="Bap_table.html">
<link title="Image_backend" rel="Chapter" href="Image_backend.html">
<link title="Image_common" rel="Chapter" href="Image_common.html">
<link title="Image_internal_std" rel="Chapter" href="Image_internal_std.html">
<link title="Bap_disasm" rel="Chapter" href="Bap_disasm.html">
<link title="Bap_disasm_arm" rel="Chapter" href="Bap_disasm_arm.html">
<link title="Bap_disasm_arm_bit" rel="Chapter" href="Bap_disasm_arm_bit.html">
<link title="Bap_disasm_arm_branch" rel="Chapter" href="Bap_disasm_arm_branch.html">
<link title="Bap_disasm_arm_env" rel="Chapter" href="Bap_disasm_arm_env.html">
<link title="Bap_disasm_arm_flags" rel="Chapter" href="Bap_disasm_arm_flags.html">
<link title="Bap_disasm_arm_lifter" rel="Chapter" href="Bap_disasm_arm_lifter.html">
<link title="Bap_disasm_arm_mem" rel="Chapter" href="Bap_disasm_arm_mem.html">
<link title="Bap_disasm_arm_mem_shift" rel="Chapter" href="Bap_disasm_arm_mem_shift.html">
<link title="Bap_disasm_arm_mov" rel="Chapter" href="Bap_disasm_arm_mov.html">
<link title="Bap_disasm_arm_mul" rel="Chapter" href="Bap_disasm_arm_mul.html">
<link title="Bap_disasm_arm_shift" rel="Chapter" href="Bap_disasm_arm_shift.html">
<link title="Bap_disasm_arm_types" rel="Chapter" href="Bap_disasm_arm_types.html">
<link title="Bap_disasm_arm_utils" rel="Chapter" href="Bap_disasm_arm_utils.html">
<link title="Bap_disasm_basic" rel="Chapter" href="Bap_disasm_basic.html">
<link title="Bap_disasm_block" rel="Chapter" href="Bap_disasm_block.html">
<link title="Bap_disasm_insn" rel="Chapter" href="Bap_disasm_insn.html">
<link title="Bap_disasm_prim" rel="Chapter" href="Bap_disasm_prim.html">
<link title="Bap_disasm_rec" rel="Chapter" href="Bap_disasm_rec.html">
<link title="Bap_disasm_types" rel="Chapter" href="Bap_disasm_types.html">
<link title="Bap_insn_kind" rel="Chapter" href="Bap_insn_kind.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Dwarf_data" rel="Chapter" href="Dwarf_data.html">
<link title="Dwarf_fbi" rel="Chapter" href="Dwarf_fbi.html">
<link title="Dwarf_input" rel="Chapter" href="Dwarf_input.html">
<link title="Dwarf_leb128" rel="Chapter" href="Dwarf_leb128.html">
<link title="Dwarf_types" rel="Chapter" href="Dwarf_types.html">
<link title="Bap_elf" rel="Chapter" href="Bap_elf.html">
<link title="Elf_parse" rel="Chapter" href="Elf_parse.html">
<link title="Elf_types" rel="Chapter" href="Elf_types.html">
<link title="Elf_utils" rel="Chapter" href="Elf_utils.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html"><link title="Iterators" rel="Section" href="#3_Iterators">
<link title="Table relations" rel="Subsection" href="#4_Tablerelations">
<link title="Table relations" rel="Subsection" href="#4_Tablerelations">
<title>Image_internal_std.Table</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Image_internal_std.html" title="Image_internal_std">Up</a>
&nbsp;<a class="post" href="Image_internal_std.Backend.html" title="Image_internal_std.Backend">Next</a>
</div>
<h1>Module <a href="type_Image_internal_std.Table.html">Image_internal_std.Table</a></h1>

<pre><span class="keyword">module</span> Table: <code class="type"><a href="Bap_table.html">Bap_table</a></code></pre><hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>


<pre><span id="TYPEmem"><span class="keyword">type</span> <code class="type"></code>mem</span> = <code class="type"><a href="Bap_memory.html#TYPEt">Bap_memory.t</a></code> </pre>


<pre><span id="TYPEhashable"><span class="keyword">type</span> <code class="type">'a</code> hashable</span> = <code class="type">'a Core_kernel.Std.Hashtbl.Hashable.t</code> </pre>


<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a></code></pre><div class="info ">
creates an empty table<br>
</div>

<pre><span id="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type"><a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'a <a href="Bap_table.html#TYPEt">t</a></code></pre><div class="info ">
creates a table containing one bindins<br>
</div>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -><br>       <a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'a <a href="Bap_table.html#TYPEt">t</a> Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">add table mem v</code> returns a new table with added mapping from a
    mem region <code class="code">mem</code> to a data value <code class="code">v</code><br>
</div>

<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> 'a <a href="Bap_table.html#TYPEt">t</a></code></pre><div class="info ">
returns a new table with all mappings from the mem region
    <code class="code">mem</code> removed<br>
</div>

<pre><span id="VALchange"><span class="keyword">val</span> change</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -><br>       <a href="Bap_table.html#TYPEmem">mem</a> -><br>       f:((<a href="Bap_table.html#TYPEmem">mem</a> * 'a) <a href="Bap_types.Std.html#TYPEseq">Bap_types.Std.seq</a> -><br>          [ `ignore<br>          | `rebind of <a href="Bap_table.html#TYPEmem">mem</a> * 'a<br>          | `remove<br>          | `update of <a href="Bap_table.html#TYPEmem">mem</a> * 'a -> 'a ]) -><br>       'a <a href="Bap_table.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">change tab mem ~f</code> function <code class="code">f</code> is applied to a set of all memory
    regions that intersects with <code class="code">mem</code>. If function <code class="code">f</code> evaluates to
    <code class="code"><span class="keywordsign">`</span>remap (new_mem,y)</code> then all memory regions that have had
    intersections with <code class="code">mem</code> will be removed from the new map and
    memory region <code class="code">new_mem</code> will be mapped to <code class="code">y</code>. If <code class="code">f</code> evaluates to
    <code class="code"><span class="keywordsign">`</span>remove</code>, then the regions will be removed, and nothing will be
    added. If it evaluates to <code class="code"><span class="keywordsign">`</span>skip</code> then the table will be returned
    unchanged.  Intersections are passed sorted in an ascending order.<br>
</div>

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">length table</code> returns a number of entries in the table<br>
</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> 'a option</code></pre><div class="info ">
<code class="code">find table mem</code> finds an element mapped to the memory region <code class="code">mem</code><br>
</div>

<pre><span id="VALfind_addr"><span class="keyword">val</span> find_addr</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_types.Std.html#TYPEaddr">Bap_types.Std.addr</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) option</code></pre><div class="info ">
<code class="code">find_addr tab addr</code> finds a memory region that contains a
    specified <code class="code">addr</code><br>
</div>

<pre><span id="VALintersections"><span class="keyword">val</span> intersections</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) <a href="Bap_types.Std.html#TYPEseq">Bap_types.Std.seq</a></code></pre><div class="info ">
<code class="code">intersections table mem</code> returns all mappings in a <code class="code">table</code> that
    have intersections with <code class="code">mem</code><br>
</div>

<pre><span id="VALfold_intersections"><span class="keyword">val</span> fold_intersections</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -><br>       <a href="Bap_table.html#TYPEmem">mem</a> -> init:'b -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'b -> 'b) -> 'b</code></pre><div class="info ">
<code class="code">fold_intersections table mem</code> folds over all regions
    intersecting with <code class="code">mem</code><br>
</div>

<pre><span id="VALhas_intersections"><span class="keyword">val</span> has_intersections</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> bool</code></pre><div class="info ">
<code class="code">has_intersections tab mem</code> is true iff some portion of <code class="code">mem</code> is
    is already mapped in <code class="code">tab</code>.<br>
</div>

<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> bool</code></pre><div class="info ">
<code class="code">mem table mem</code> is true if table contains mem region <code class="code">mem</code><br>
</div>

<pre><span id="VALnext"><span class="keyword">val</span> next</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) option</code></pre><div class="info ">
<code class="code">next table elt</code> returns element next to <code class="code">elt</code>, if any<br>
</div>

<pre><span id="VALprev"><span class="keyword">val</span> prev</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) option</code></pre><div class="info ">
<code class="code">next table elt</code> returns element preceding to <code class="code">elt</code>, if any<br>
</div>

<pre><span id="VALmin"><span class="keyword">val</span> min</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) option</code></pre><div class="info ">
<code class="code">min tab</code> return the lowest binding<br>
</div>

<pre><span id="VALmax"><span class="keyword">val</span> max</span> : <code class="type">'a <a href="Bap_table.html#TYPEt">t</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) option</code></pre><div class="info ">
<code class="code">max tab</code> return the highest binding<br>
</div>

<pre><span id="TYPEr"><span class="keyword">type</span> <code class="type">('a, 'm)</code> r</span> </pre>
<div class="info ">
Relation multiplicity.
    For a given type <code class="code"><span class="keywordsign">'</span>a</code> creates type <code class="code"><span class="keywordsign">'</span>m</code><br>
</div>

<br>
<h4 id="4_Tablerelations">Table relations</h4><br>

<pre><span id="VALmany"><span class="keyword">val</span> many</span> : <code class="type">('a, 'a <a href="Bap_types.Std.html#TYPEseq">Bap_types.Std.seq</a>) <a href="Bap_table.html#TYPEr">r</a></code></pre><div class="info ">
<code class="code">0..*</code><br>
</div>

<pre><span id="VALat_least_one"><span class="keyword">val</span> at_least_one</span> : <code class="type">('a, 'a * 'a <a href="Bap_types.Std.html#TYPEseq">Bap_types.Std.seq</a>) <a href="Bap_table.html#TYPEr">r</a></code></pre>
<pre><span id="VALone"><span class="keyword">val</span> one</span> : <code class="type">('a, 'a) <a href="Bap_table.html#TYPEr">r</a></code></pre><div class="info ">
<code class="code">1..1</code><br>
</div>

<pre><span id="VALmaybe_one"><span class="keyword">val</span> maybe_one</span> : <code class="type">('a, 'a option) <a href="Bap_table.html#TYPEr">r</a></code></pre><div class="info ">
<code class="code">0..1</code><br>
</div>
<br>
<code class="code">link relation t t1 t2</code> takes two tables and returns a mapping
    from elements of one table to elements of other table.
<p>

    Parameter <code class="code">t</code> specifies a <code class="code">hashable</code> typeclass of the type <code class="code"><span class="keywordsign">'</span>a</code>. If
    type <code class="code"><span class="keywordsign">'</span>a</code> implements <code class="code"><span class="constructor">Hashable</span></code> interface, then you can obtain it
    with <code class="code">hashable</code> function, e.g. <code class="code"><span class="constructor">Int</span>.hashable</code> with return the
    appropriate type class. If <code class="code"><span class="keywordsign">'</span>a</code> doesn't implement <code class="code"><span class="constructor">Hashable</span></code>, then
    it can be implemented manually.
<p>

    Relation specifies the multiplicity of the relation between
    entities from table <code class="code">t1</code> to entities from table <code class="code">t2</code>, and is
    summarized below:
<p>
<ul>
<li><code class="code">one_to_many</code> means that a particular region from table <code class="code">t1</code> can
      span several memory regions from table <code class="code">t2</code>. Example: segments
      to symbols relation.</li>
</ul>
<ul>
<li><code class="code">one_to_one</code> means that for each value of type <code class="code"><span class="keywordsign">'</span>a</code> there is
      exactly one value of type <code class="code"><span class="keywordsign">'</span>b</code>. This relation should be used with
      caution, since it is quantified over _all_ values of type
      <code class="code"><span class="keywordsign">'</span>a</code>. Indeed, it should be used only for cases, when it can be
      guaranteed, that it is impossible to create such value of type
      <code class="code"><span class="keywordsign">'</span>b</code>, that has no correspondence in table <code class="code">t2</code>. Otherwise,
      <code class="code">one_to_maybe_one</code> relation should be used. Example: llvm
      machine code to assembly string relation.</li>
</ul>
<ul>
<li><code class="code">one_to_maybe_one</code> means that for each value in table <code class="code">t1</code> there
      exists at most one value in table <code class="code">t2</code>. Example: function to
      symbol relation.</li>
</ul>

    <h5 id="5_Examples">Examples</h5>
    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mc_of_insn&nbsp;&nbsp;=&nbsp;link&nbsp;one_to:one&nbsp;<span class="constructor">Insn</span>.hashable&nbsp;insns&nbsp;mcs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;syms_of_sec&nbsp;=&nbsp;link&nbsp;one_to:many&nbsp;<span class="constructor">Sec</span>.hashable&nbsp;&nbsp;secs&nbsp;syms<br>
&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><br>

<pre><span id="VALlink"><span class="keyword">val</span> link</span> : <code class="type">one_to:('b, 'r) <a href="Bap_table.html#TYPEr">r</a> -><br>       'a <a href="Bap_table.html#TYPEhashable">hashable</a> -> 'a <a href="Bap_table.html#TYPEt">t</a> -> 'b <a href="Bap_table.html#TYPEt">t</a> -> 'a -> 'r</code></pre>
<pre><span id="VALrev_map"><span class="keyword">val</span> rev_map</span> : <code class="type">one_to:(<a href="Bap_table.html#TYPEmem">mem</a>, 'r) <a href="Bap_table.html#TYPEr">r</a> -><br>       'a <a href="Bap_table.html#TYPEhashable">hashable</a> -><br>       'a <a href="Bap_table.html#TYPEt">t</a> -> ('a -> 'r) Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">rev_map arity t tab</code> creates a reverse mapping from values of
    typeclass <code class="code">t</code> stored in table <code class="code">tab</code> to memory regions.
<p>

    Note. not every mapping is reversable, for example, trying to obtain
    a reverse of surjective mapping as a one-to-one mapping will
    result in an error. But surjective mappings can be reversed
    using <code class="code">~one_to:many</code> mapping. A particular example of surjective
    mapping is <code class="code">symbol</code> tables, in a case when functions can occupy
    several non-contiguous regions of memory.
<p>

    <h5 id="5_Examples">Examples</h5>
<p>

    To create a mapping from a function symbol to sequence of memory
    regions with it code:
<p>

    <pre class="codepre"><code class="code">rev_map&nbsp;one_to:many&nbsp;<span class="constructor">Sym</span>.hashable&nbsp;tab</code></pre><br>
</div>

<pre><span id="TYPEranged"><span class="keyword">type</span> <code class="type">'a</code> ranged</span> = <code class="type">?start:<a href="Bap_table.html#TYPEmem">mem</a> -> ?until:<a href="Bap_table.html#TYPEmem">mem</a> -> 'a</code> </pre>
<div class="info ">
<h3 id="3_Iterators">Iterators</h3>
<p>

    This section provides a common set of iterators. Note: name
    iterator is used in a functional meaning, i.e., an iterator is a
    function that takes a data structure and another function, and
    applies it to all elements in some manner.
<p>

    All iterators share some common part of interface that was lifted
    to a <code class="code"><span class="keywordsign">'</span>a ranged</code> type. When you see
<p>

    <code class="code">(<span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> f:(<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> bool) ranged</code>
<p>

    just mentally substitute it with:
<p>

    <code class="code">?start <span class="keywordsign">-&gt;</span> ?until <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> f:(<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> bool</code>.
<p>

    In other words <code class="code"><span class="keywordsign">'</span>f ranged</code> just prepends <code class="code">?start <span class="keywordsign">-&gt;</span> ?until <span class="keywordsign">-&gt;</span></code> to
    function with type <code class="code"><span class="keywordsign">'</span>f</code> (do not forget that <code class="code"><span class="keywordsign">'</span>f</code> can be an arrow
    type).
<p>

    <code class="code">start</code> and <code class="code">until</code> parameters allows to narrow iteration to some
    subset of table. If they are unspecified then iteration would be
    performed on all table entries in an ascending order of
    addresses. If they are specified, then if <code class="code">start &lt;= until</code>, then
    iteration will be performed in the same order but on a specified
    subset. In the case, when <code class="code">start &gt; until</code>, iteration will be
    performed in a decreasing order.<br>
</div>


<pre><span id="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> bool) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfor_all"><span class="keyword">val</span> for_all</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> bool) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> bool) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfor_all"><span class="keyword">val</span> for_all</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> bool) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALcount"><span class="keyword">val</span> count</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> int) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfind_if"><span class="keyword">val</span> find_if</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> 'a option) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfind_map"><span class="keyword">val</span> find_map</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> 'b option) -> 'b option) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> init:'b -> f:('a -> 'b -> 'b) -> 'b) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> unit) -> unit) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfind_mapi"><span class="keyword">val</span> find_mapi</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'b option) -> 'b option)<br>       <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfoldi"><span class="keyword">val</span> foldi</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> init:'b -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'b -> 'b) -> 'b)<br>       <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> unit) -> unit) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> 'b) -> 'b <a href="Bap_table.html#TYPEt">t</a>) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'b) -> 'b <a href="Bap_table.html#TYPEt">t</a>)<br>       <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> bool) -> 'a <a href="Bap_table.html#TYPEt">t</a>) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre><div class="info ">
removes all mappings that do not satisfy the predicate<br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:('a -> 'b option) -> 'b <a href="Bap_table.html#TYPEt">t</a>) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfilteri"><span class="keyword">val</span> filteri</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> bool) -> 'a <a href="Bap_table.html#TYPEt">t</a>)<br>       <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALfilter_mapi"><span class="keyword">val</span> filter_mapi</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> f:(<a href="Bap_table.html#TYPEmem">mem</a> -> 'a -> 'b option) -> 'b <a href="Bap_table.html#TYPEt">t</a>)<br>       <a href="Bap_table.html#TYPEranged">ranged</a></code></pre>
<pre><span id="VALto_sequence"><span class="keyword">val</span> to_sequence</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> (<a href="Bap_table.html#TYPEmem">mem</a> * 'a) Core_kernel.Std.Sequence.t)<br>       <a href="Bap_table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<code class="code">to_sequence_in tab</code> converts the table <code class="code">t</code> to a
    sequence of key-value pairs.<br>
</div>

<pre><span id="VALregions"><span class="keyword">val</span> regions</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> <a href="Bap_table.html#TYPEmem">mem</a> <a href="Bap_types.Std.html#TYPEseq">Bap_types.Std.seq</a>) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<code class="code">regions table</code> returns in an ascending order of addresses all
    memory regions mapped in a <code class="code">table</code><br>
</div>

<pre><span id="VALelements"><span class="keyword">val</span> elements</span> : <code class="type">('a <a href="Bap_table.html#TYPEt">t</a> -> 'a <a href="Bap_types.Std.html#TYPEseq">Bap_types.Std.seq</a>) <a href="Bap_table.html#TYPEranged">ranged</a></code></pre><div class="info ">
<code class="code">regions table</code> returns in an ascending order of addresses all
    elements mapped in a <code class="code">table</code><br>
</div>

<pre><span id="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -> Sexplib.Sexp.t) -> 'a <a href="Bap_table.html#TYPEt">t</a> -> Sexplib.Sexp.t</code></pre><br>
creates an empty table<br>
<br>
creates a table containing one bindins<br>
<br>
<code class="code">add table mem v</code> returns a new table with added mapping from a
    mem region <code class="code">mem</code> to a data value <code class="code">v</code><br>
<br>
returns a new table with all mappings from the mem region
    <code class="code">mem</code> removed<br>
<br>
<code class="code">change tab mem ~f</code> function <code class="code">f</code> is applied to a set of all memory
    regions that intersects with <code class="code">mem</code>. If function <code class="code">f</code> evaluates to
    <code class="code"><span class="keywordsign">`</span>remap (new_mem,y)</code> then all memory regions that have had
    intersections with <code class="code">mem</code> will be removed from the new map and
    memory region <code class="code">new_mem</code> will be mapped to <code class="code">y</code>. If <code class="code">f</code> evaluates to
    <code class="code"><span class="keywordsign">`</span>remove</code>, then the regions will be removed, and nothing will be
    added. If it evaluates to <code class="code"><span class="keywordsign">`</span>skip</code> then the table will be returned
    unchanged.  Intersections are passed sorted in an ascending order.<br>
<br>
add new mapping instead<br>
<br>
update all bindings<br>
<br>
remove all bindings<br>
<br>
don't touch anything<br>
<br>
<code class="code">length table</code> returns a number of entries in the table<br>
<br>
<code class="code">find table mem</code> finds an element mapped to the memory region <code class="code">mem</code><br>
<br>
<code class="code">find_addr tab addr</code> finds a memory region that contains a
    specified <code class="code">addr</code><br>
<br>
<code class="code">intersections table mem</code> returns all mappings in a <code class="code">table</code> that
    have intersections with <code class="code">mem</code><br>
<br>
<code class="code">fold_intersections table mem</code> folds over all regions
    intersecting with <code class="code">mem</code><br>
<br>
<code class="code">has_intersections tab mem</code> is true iff some portion of <code class="code">mem</code> is
    is already mapped in <code class="code">tab</code>.<br>
<br>
<code class="code">mem table mem</code> is true if table contains mem region <code class="code">mem</code><br>
<br>
<code class="code">next table elt</code> returns element next to <code class="code">elt</code>, if any<br>
<br>
<code class="code">next table elt</code> returns element preceding to <code class="code">elt</code>, if any<br>
<br>
<code class="code">min tab</code> return the lowest binding<br>
<br>
<code class="code">max tab</code> return the highest binding<br>
<br>
Relation multiplicity.
    For a given type <code class="code"><span class="keywordsign">'</span>a</code> creates type <code class="code"><span class="keywordsign">'</span>m</code><br>
<br>
<h4 id="4_Tablerelations">Table relations</h4><br>
<br>
<code class="code">0..*</code><br>
<br>
<code class="code">1..1</code><br>
<br>
<code class="code">0..1</code><br>
<br>
<code class="code">link relation t t1 t2</code> takes two tables and returns a mapping
    from elements of one table to elements of other table.
<p>

    Parameter <code class="code">t</code> specifies a <code class="code">hashable</code> typeclass of the type <code class="code"><span class="keywordsign">'</span>a</code>. If
    type <code class="code"><span class="keywordsign">'</span>a</code> implements <code class="code"><span class="constructor">Hashable</span></code> interface, then you can obtain it
    with <code class="code">hashable</code> function, e.g. <code class="code"><span class="constructor">Int</span>.hashable</code> with return the
    appropriate type class. If <code class="code"><span class="keywordsign">'</span>a</code> doesn't implement <code class="code"><span class="constructor">Hashable</span></code>, then
    it can be implemented manually.
<p>

    Relation specifies the multiplicity of the relation between
    entities from table <code class="code">t1</code> to entities from table <code class="code">t2</code>, and is
    summarized below:
<p>
<ul>
<li><code class="code">one_to_many</code> means that a particular region from table <code class="code">t1</code> can
      span several memory regions from table <code class="code">t2</code>. Example: segments
      to symbols relation.</li>
</ul>
<ul>
<li><code class="code">one_to_one</code> means that for each value of type <code class="code"><span class="keywordsign">'</span>a</code> there is
      exactly one value of type <code class="code"><span class="keywordsign">'</span>b</code>. This relation should be used with
      caution, since it is quantified over _all_ values of type
      <code class="code"><span class="keywordsign">'</span>a</code>. Indeed, it should be used only for cases, when it can be
      guaranteed, that it is impossible to create such value of type
      <code class="code"><span class="keywordsign">'</span>b</code>, that has no correspondence in table <code class="code">t2</code>. Otherwise,
      <code class="code">one_to_maybe_one</code> relation should be used. Example: llvm
      machine code to assembly string relation.</li>
</ul>
<ul>
<li><code class="code">one_to_maybe_one</code> means that for each value in table <code class="code">t1</code> there
      exists at most one value in table <code class="code">t2</code>. Example: function to
      symbol relation.</li>
</ul>

    <h5 id="5_Examples">Examples</h5>
    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mc_of_insn&nbsp;&nbsp;=&nbsp;link&nbsp;one_to:one&nbsp;<span class="constructor">Insn</span>.hashable&nbsp;insns&nbsp;mcs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;syms_of_sec&nbsp;=&nbsp;link&nbsp;one_to:many&nbsp;<span class="constructor">Sec</span>.hashable&nbsp;&nbsp;secs&nbsp;syms<br>
&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><br>
<br>
<code class="code">rev_map arity t tab</code> creates a reverse mapping from values of
    typeclass <code class="code">t</code> stored in table <code class="code">tab</code> to memory regions.
<p>

    Note. not every mapping is reversable, for example, trying to obtain
    a reverse of surjective mapping as a one-to-one mapping will
    result in an error. But surjective mappings can be reversed
    using <code class="code">~one_to:many</code> mapping. A particular example of surjective
    mapping is <code class="code">symbol</code> tables, in a case when functions can occupy
    several non-contiguous regions of memory.
<p>

    <h5 id="5_Examples">Examples</h5>
<p>

    To create a mapping from a function symbol to sequence of memory
    regions with it code:
<p>

    <pre class="codepre"><code class="code">rev_map&nbsp;one_to:many&nbsp;<span class="constructor">Sym</span>.hashable&nbsp;tab</code></pre><br>
<br>
<h3 id="3_Iterators">Iterators</h3>
<p>

    This section provides a common set of iterators. Note: name
    iterator is used in a functional meaning, i.e., an iterator is a
    function that takes a data structure and another function, and
    applies it to all elements in some manner.
<p>

    All iterators share some common part of interface that was lifted
    to a <code class="code"><span class="keywordsign">'</span>a ranged</code> type. When you see
<p>

    <code class="code">(<span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> f:(<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> bool) ranged</code>
<p>

    just mentally substitute it with:
<p>

    <code class="code">?start <span class="keywordsign">-&gt;</span> ?until <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> f:(<span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> bool) <span class="keywordsign">-&gt;</span> bool</code>.
<p>

    In other words <code class="code"><span class="keywordsign">'</span>f ranged</code> just prepends <code class="code">?start <span class="keywordsign">-&gt;</span> ?until <span class="keywordsign">-&gt;</span></code> to
    function with type <code class="code"><span class="keywordsign">'</span>f</code> (do not forget that <code class="code"><span class="keywordsign">'</span>f</code> can be an arrow
    type).
<p>

    <code class="code">start</code> and <code class="code">until</code> parameters allows to narrow iteration to some
    subset of table. If they are unspecified then iteration would be
    performed on all table entries in an ascending order of
    addresses. If they are specified, then if <code class="code">start &lt;= until</code>, then
    iteration will be performed in the same order but on a specified
    subset. In the case, when <code class="code">start &gt; until</code>, iteration will be
    performed in a decreasing order.<br>
<br>
defaults to the lowest mapped region<br>
<br>
defaults to the highest mapped area<br>
<br>
removes all mappings that do not satisfy the predicate<br>
<br>
<code class="code">to_sequence_in tab</code> converts the table <code class="code">t</code> to a
    sequence of key-value pairs.<br>
<br>
<code class="code">regions table</code> returns in an ascending order of addresses all
    memory regions mapped in a <code class="code">table</code><br>
<br>
<code class="code">regions table</code> returns in an ascending order of addresses all
    elements mapped in a <code class="code">table</code><br>
</body></html>