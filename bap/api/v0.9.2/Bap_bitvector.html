<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Bap_bil.html">
<link rel="next" href="Bap_common.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Bap" rel="Chapter" href="Bap.html">
<link title="Bap_plugin" rel="Chapter" href="Bap_plugin.html">
<link title="Bap_plugins" rel="Chapter" href="Bap_plugins.html">
<link title="Bap_types" rel="Chapter" href="Bap_types.html">
<link title="Bap_addr" rel="Chapter" href="Bap_addr.html">
<link title="Bap_arch" rel="Chapter" href="Bap_arch.html">
<link title="Bap_bil" rel="Chapter" href="Bap_bil.html">
<link title="Bap_bitvector" rel="Chapter" href="Bap_bitvector.html">
<link title="Bap_common" rel="Chapter" href="Bap_common.html">
<link title="Bap_exp" rel="Chapter" href="Bap_exp.html">
<link title="Bap_int_conversions" rel="Chapter" href="Bap_int_conversions.html">
<link title="Bap_integer" rel="Chapter" href="Bap_integer.html">
<link title="Bap_integer_intf" rel="Chapter" href="Bap_integer_intf.html">
<link title="Bap_regular" rel="Chapter" href="Bap_regular.html">
<link title="Bap_seq" rel="Chapter" href="Bap_seq.html">
<link title="Bap_size" rel="Chapter" href="Bap_size.html">
<link title="Bap_stmt" rel="Chapter" href="Bap_stmt.html">
<link title="Bap_type" rel="Chapter" href="Bap_type.html">
<link title="Bap_var" rel="Chapter" href="Bap_var.html">
<link title="Bap_image" rel="Chapter" href="Bap_image.html">
<link title="Bap_memory" rel="Chapter" href="Bap_memory.html">
<link title="Bap_table" rel="Chapter" href="Bap_table.html">
<link title="Image_backend" rel="Chapter" href="Image_backend.html">
<link title="Image_common" rel="Chapter" href="Image_common.html">
<link title="Image_internal_std" rel="Chapter" href="Image_internal_std.html">
<link title="Bap_disasm" rel="Chapter" href="Bap_disasm.html">
<link title="Bap_disasm_arm" rel="Chapter" href="Bap_disasm_arm.html">
<link title="Bap_disasm_arm_bit" rel="Chapter" href="Bap_disasm_arm_bit.html">
<link title="Bap_disasm_arm_branch" rel="Chapter" href="Bap_disasm_arm_branch.html">
<link title="Bap_disasm_arm_env" rel="Chapter" href="Bap_disasm_arm_env.html">
<link title="Bap_disasm_arm_flags" rel="Chapter" href="Bap_disasm_arm_flags.html">
<link title="Bap_disasm_arm_lifter" rel="Chapter" href="Bap_disasm_arm_lifter.html">
<link title="Bap_disasm_arm_mem" rel="Chapter" href="Bap_disasm_arm_mem.html">
<link title="Bap_disasm_arm_mem_shift" rel="Chapter" href="Bap_disasm_arm_mem_shift.html">
<link title="Bap_disasm_arm_mov" rel="Chapter" href="Bap_disasm_arm_mov.html">
<link title="Bap_disasm_arm_mul" rel="Chapter" href="Bap_disasm_arm_mul.html">
<link title="Bap_disasm_arm_shift" rel="Chapter" href="Bap_disasm_arm_shift.html">
<link title="Bap_disasm_arm_types" rel="Chapter" href="Bap_disasm_arm_types.html">
<link title="Bap_disasm_arm_utils" rel="Chapter" href="Bap_disasm_arm_utils.html">
<link title="Bap_disasm_basic" rel="Chapter" href="Bap_disasm_basic.html">
<link title="Bap_disasm_block" rel="Chapter" href="Bap_disasm_block.html">
<link title="Bap_disasm_insn" rel="Chapter" href="Bap_disasm_insn.html">
<link title="Bap_disasm_prim" rel="Chapter" href="Bap_disasm_prim.html">
<link title="Bap_disasm_rec" rel="Chapter" href="Bap_disasm_rec.html">
<link title="Bap_disasm_types" rel="Chapter" href="Bap_disasm_types.html">
<link title="Bap_insn_kind" rel="Chapter" href="Bap_insn_kind.html">
<link title="Bap_dwarf" rel="Chapter" href="Bap_dwarf.html">
<link title="Dwarf_data" rel="Chapter" href="Dwarf_data.html">
<link title="Dwarf_fbi" rel="Chapter" href="Dwarf_fbi.html">
<link title="Dwarf_input" rel="Chapter" href="Dwarf_input.html">
<link title="Dwarf_leb128" rel="Chapter" href="Dwarf_leb128.html">
<link title="Dwarf_types" rel="Chapter" href="Dwarf_types.html">
<link title="Bap_elf" rel="Chapter" href="Bap_elf.html">
<link title="Elf_parse" rel="Chapter" href="Elf_parse.html">
<link title="Elf_types" rel="Chapter" href="Elf_types.html">
<link title="Elf_utils" rel="Chapter" href="Elf_utils.html">
<link title="Bap_llvm" rel="Chapter" href="Bap_llvm.html"><link title="Container interfaces" rel="Section" href="#2_Containerinterfaces">
<link title="Conversions to integers " rel="Section" href="#2_Conversionstointegers">
<link title="Iteration over bitvector components " rel="Section" href="#2_Iterationoverbitvectorcomponents">
<link title="Container interfaces" rel="Section" href="#2_Containerinterfaces">
<link title="Constructors" rel="Section" href="#2_Constructors">
<link title="Conversions to integers " rel="Section" href="#2_Conversionstointegers">
<link title="Iteration over bitvector components " rel="Section" href="#2_Iterationoverbitvectorcomponents">
<link title="Some predefined constant constructors " rel="Subsection" href="#3_Somepredefinedconstantconstructors">
<link title="Helpful shortcuts " rel="Subsection" href="#3_Helpfulshortcuts">
<link title="Some predefined constant constructors " rel="Subsection" href="#3_Somepredefinedconstantconstructors">
<link title="Helpful shortcuts " rel="Subsection" href="#3_Helpfulshortcuts">
<link title="Signed conversions " rel="Subsection" href="#3_Signedconversions">
<title>Bap_bitvector</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bap_bil.html" title="Bap_bil">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Bap_common.html" title="Bap_common">Next</a>
</div>
<h1>Module <a href="type_Bap_bitvector.html">Bap_bitvector</a></h1>

<pre><span class="keyword">module</span> Bap_bitvector: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_bitvector.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Bitvector -- a type for representing binary values.
<p>

    <h2 id="2_Overview">Overview </h2>
<p>

    A numeric value with a 2-complement binary representation. It is
    good for representing addresses, offsets and other numeric values.
<p>

    Each value is attributed by a its bit-width. All arithmetic
    operations over values are done modulo their widths. It is an
    error to apply arithmetic operation to values with different
    widths. Default implementations will raise a <code class="code"><span class="constructor">Width</span></code> exception,
    however there exists a family of modules that provide arithmetic
    operations lifted to an <code class="code"><span class="constructor">Or_error</span>.t</code> monad. It is suggested to use
    them, if you know what kind of operands you're expecting.
<p>

    <h3 id="3_Clarificationsendiannessandbitordering">Clarifications endianness and bit-ordering </h3>
<p>

    Bitvector should be considered as an number with an arbitrary
    width. That means, that as with all numbers it is subject to
    endianness. When we iterate over bitvector using some container
    interface we always start from the byte with the lower
    address. Depending on endianness it will be either least
    significant bytes (little-endian), or most significant
    (big-endian). Sometimes id does matter, sometimes it doesn't. In a
    latter case you can just use a default native-endian
    interface. But in a former case, please consider using explicit
    modules, either <code class="code"><span class="constructor">Bytes_LE</span></code> or <code class="code"><span class="constructor">Bytes_BE</span></code>, even if you know that
    your system is <code class="code"><span class="constructor">LE</span></code>. Things change.
<p>

    Bits are always numbered from right to left, with least
    significant bit having a zero index, and most significant having
    index equal to <code class="code">width - 1</code>. That means, they're endianness
    agnostic.
<p>

    <h3 id="3_Clarificationonsizemorphism">Clarification on size-morphism </h3>
<p>

    Size-monomorphic operations (as opposed to size-polymorphic
    comparison) doesn't allow to compare two operands with different
    sizes, and either raise exception or return <code class="code"><span class="constructor">Error</span></code>. If we would
    have type safe interface, with type <code class="code">t</code> defined as <code class="code"><span class="keyword">type</span> <span class="keywordsign">'</span>a t</code>,
    where <code class="code"><span class="keywordsign">'</span>a</code> stands for size, then size-monomorphic operations will
    have type <code class="code"><span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> _</code>, and size-polymorphic <code class="code"><span class="keywordsign">'</span>a t <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>b t <span class="keywordsign">-&gt;</span> _</code>.
<p>

    By default, size-polymorphic comparison is used (for rationale of
    this decision look at the implementation of a hash function). To
    understand the ordering relation one can think that a lexical
    ordering is specified on a tuple <code class="code">(x,n)</code>, where <code class="code">x</code> is the number
    and <code class="code">n</code> is the size. For example, the following sequence is in an
    ascending order:
<p>

    <pre class="codepre"><code class="code">&nbsp;0x0:1,&nbsp;0x0:32,&nbsp;0x0:64,&nbsp;0x1:1,&nbsp;0x1:32,&nbsp;0xD:4,&nbsp;0xDEADBEEF:32</code></pre>.
<p>

    A size-monomorphic interfaced is exposed in a <code class="code"><span class="constructor">Mono</span></code> submodule. So
    if you want a monomorphic map, then just use <code class="code"><span class="constructor">Mono</span>.<span class="constructor">Map</span></code> module.
    Note, <code class="code"><span class="constructor">Mono</span></code> submodule doesn't provide <code class="code"><span class="constructor">Table</span></code>, since we cannot
    guarantee that all keys in a hash-table have equal size.
<p>

    <h3 id="3_Clarificationonsigns">Clarification on signs</h3>
<p>

    By default all numbers represented by a bitvector are considered
    unsigned. This includes comparisons, e.g., <code class="code">of_int (-1) ~width:32</code>
    is greater than zero. If you need to perform signed operation, you
    can use <code class="code">signed</code> operator to temporary cast your value to signed.
    We use temporary to emphasize that, the signedness property won't
    propagate to the result of the operation, e.g. result of the
    following expression: <code class="code"><span class="constructor">Int_exn</span>.(signed x / y)</code> will not be signed.
<p>

    If any operand of a binary operation is signed, then a signed
    version of an operation is used.
<p>

    Remember to use explicit casts, whenever you really need a signed
    representation. Examples:
    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;x&nbsp;=&nbsp;of_int&nbsp;<span class="keywordsign">~-</span>6&nbsp;~width:8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;y&nbsp;=&nbsp;to_int&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;y&nbsp;=&nbsp;250&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;z&nbsp;=&nbsp;to_int&nbsp;(signed&nbsp;x)&nbsp;<span class="comment">(*&nbsp;z&nbsp;=&nbsp;~-6&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;zero&nbsp;=&nbsp;of_int&nbsp;0&nbsp;~width:8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;x&nbsp;&lt;&nbsp;zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;p&nbsp;=&nbsp;false&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;q&nbsp;=&nbsp;signed&nbsp;x&nbsp;&lt;&nbsp;zero&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;p&nbsp;=&nbsp;true&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

    <h3 id="3_Clarificationonstringrepresentation">Clarification on string representation </h3>
<p>

    As a part of <code class="code"><span class="constructor">Identifiable</span></code> interface bitvector provides a pair of
    complement functions: <code class="code">to_string</code> and <code class="code">of_string</code>, that provides
    facilities to store bitvector as a human readable string, and to
    restore it from string. The format of the representation is the
    following (in EBNF):
    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repr&nbsp;&nbsp;=&nbsp;[sign],&nbsp;base,&nbsp;digit,&nbsp;{digit},&nbsp;<span class="string">":"</span>,&nbsp;size&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="keyword">true</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="keyword">false</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sign&nbsp;&nbsp;=&nbsp;<span class="string">"+"</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="string">"-"</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base&nbsp;&nbsp;=&nbsp;<span class="string">"0x"</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="string">"0b"</span>&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="string">"0o"</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;&nbsp;=&nbsp;dec,&nbsp;{dec};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digit&nbsp;=&nbsp;dec&nbsp;<span class="keywordsign">|</span>&nbsp;oct&nbsp;<span class="keywordsign">|</span>&nbsp;hex;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dec&nbsp;&nbsp;&nbsp;=&nbsp;?decimal&nbsp;digit?;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oct&nbsp;&nbsp;&nbsp;=&nbsp;?octal&nbsp;digit?;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hex&nbsp;&nbsp;&nbsp;=&nbsp;?hexadecimal&nbsp;digit?;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>
<p>

    Examples: <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x5D:32,&nbsp;0b0101:16,&nbsp;5:64,&nbsp;+5:8,&nbsp;+0x5D:16,&nbsp;<span class="keyword">true</span>,&nbsp;<span class="keyword">false</span>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;</code></pre>.
<p>

    Form <code class="code"><span class="keyword">false</span></code> is a shortcut for <code class="code">0:1</code>, as well as <code class="code"><span class="keyword">true</span></code> is
    <code class="code">1:1</code>.
<p>

    If <code class="code">base</code> is omitted base-10 is assumed. The output format is
    always <code class="code"><span class="string">"0x"</span>, hex, {hex}</code> in an unsigned form.<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
<h2 id="2_CommonInterfaces">Common Interfaces</h2>
<p>

    Bitvector is a value, first of all, so it supports a common set of
    a value interface: it can be stored, compared, it can be a key in
    a dictionary, etc. Moreover, being a number it can be compared
    with zero and applied to a common set of integer operations.<br>
</div>


<pre><span id="EXCEPTIONWidth"><span class="keyword">exception</span> Width</span></pre>
<div class="info ">
<code class="code"><span class="constructor">Width</span></code> exception is raised when size-monomorphic operation is
    applied to operands with different sizes.<br>
</div>

<pre><code><span id="TYPEendian"><span class="keyword">type</span> <code class="type"></code>endian</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.LittleEndian"><span class="constructor">LittleEndian</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
least significant byte comes first<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTendian.BigEndian"><span class="constructor">BigEndian</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
most  significant byte comes first<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
Specifies the order of bytes in a word.<br>
</div>


<pre><span class="keyword">include</span> <a href="Bap_regular.S.html">Bap_regular.S</a></pre>

<pre><span class="keyword">include</span> Comparable.With_zero</pre>
<br>
<h2 id="2_Containerinterfaces">Container interfaces</h2>
<p>

    Bitvector is also a container for bytes and bits. You can access
    individual bytes using a <code class="code"><span class="constructor">Container</span></code> interface.<br>

<pre><span class="keyword">module</span> <a href="Bap_bitvector.Mono.html">Mono</a>: <code class="type">Comparable</code><code class="type">  with type t := t</code></pre><div class="info">
A comparable interface with size-monomorphic comparison.
</div>

<pre><span id="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">string -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<h2 id="2_Constructors">Constructors</h2>
<p>

    We provide several conversions from primitive data types. Also, do
    not forget about <code class="code">of_string</code> function, exposed via <code class="code"><span class="constructor">Identifiable</span></code>
    interface.<br>
</div>

<pre><span id="VALof_bool"><span class="keyword">val</span> of_bool</span> : <code class="type">bool -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_int"><span class="keyword">val</span> of_int</span> : <code class="type">width:int -> int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_int32"><span class="keyword">val</span> of_int32</span> : <code class="type">?width:int -> int32 -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_int64"><span class="keyword">val</span> of_int64</span> : <code class="type">?width:int -> int64 -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><br>
<h3 id="3_Somepredefinedconstantconstructors">Some predefined constant constructors </h3><br>

<pre><span id="VALb0"><span class="keyword">val</span> b0</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">b0 = of_bool <span class="keyword">false</span></code> - a zero bit
<p>
<code class="code">b1 = of_bool <span class="keyword">true</span></code> - a one bit<br>
</div>

<pre><span id="VALb1"><span class="keyword">val</span> b1</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a></code></pre><br>
<h3 id="3_Helpfulshortcuts">Helpful shortcuts </h3><br>

<pre><span id="VALone"><span class="keyword">val</span> one</span> : <code class="type">int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">one width</code> number one with a specified <code class="code">width</code>, is a shortcut for
    <code class="code">of_int 1 ~width</code>
<p>
<code class="code">zero width</code> zero with a specified <code class="code">width</code>, is a shortcut for
    <code class="code">of_int 0 ~width</code><br>
</div>

<pre><span id="VALzero"><span class="keyword">val</span> zero</span> : <code class="type">int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre>
<pre><span id="VALones"><span class="keyword">val</span> ones</span> : <code class="type">int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">ones width</code> is a number with a specified <code class="code">width</code>, and all bits
    set to 1. It is a shortcut for <code class="code">of_int (lnot 0) ~width</code><br>
</div>

<pre><span id="VALof_binary"><span class="keyword">val</span> of_binary</span> : <code class="type">?width:int -> <a href="Bap_bitvector.html#TYPEendian">endian</a> -> string -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_binary ?width endian num</code> creates a bitvector from a string
    interpreted as a sequence of bytes in a specified order.
<p>

    The result is always positive.
<p>

    <code class="code">num</code> argument is copied
<p>

    <code class="code">width</code> defaults to <code class="code"><span class="constructor">String</span>.length num</code><br>
</div>
<br>
<h2 id="2_Conversionstointegers">Conversions to integers </h2><br>

<pre><span id="VALto_int"><span class="keyword">val</span> to_int</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<h3 id="3_Signedconversions">Signed conversions </h3><br>
</div>

<pre><span id="VALto_int32"><span class="keyword">val</span> to_int32</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int32 Core_kernel.Std.Or_error.t</code></pre>
<pre><span id="VALto_int64"><span class="keyword">val</span> to_int64</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int64 Core_kernel.Std.Or_error.t</code></pre>
<pre><span id="VALstring_of_value"><span class="keyword">val</span> string_of_value</span> : <code class="type">?hex:bool -> <a href="Bap_bitvector.html#TYPEt">t</a> -> string</code></pre>
<pre><span id="VALsigned"><span class="keyword">val</span> signed</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">signed t</code> casts t to a signed type, so that any operations
    applied on <code class="code">t</code> will be signed<br>
</div>

<pre><span id="VALis_zero"><span class="keyword">val</span> is_zero</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">is_zero bv</code> is true iff all bits are set to zero.<br>
</div>

<pre><span id="VALbitwidth"><span class="keyword">val</span> bitwidth</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">bitwidth bv</code> return a bit-width, i.e., the amount of bits<br>
</div>

<pre><span id="VALbitsub"><span class="keyword">val</span> bitsub</span> : <code class="type">?hi:int -><br>       ?lo:int -> <a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a> Core_kernel.Std.Or_error.t</code></pre><div class="info ">
<code class="code">bitsub bv ~signed ~hi ~lo</code> extracts a subvector from <code class="code">bv</code>, starting
    from bit <code class="code">hi</code> and ending with <code class="code">lo</code>. Bits are enumerated from
    right to left (from least significant to most), starting from
    zero.
<p>

    <code class="code">hi</code> defaults to <code class="code">width bv</code>
    <code class="code">lo</code> defaults to <code class="code">0</code>.
    <code class="code">signed</code> defaults to <code class="code"><span class="keyword">false</span></code>
<p>

    Example:
<p>

    <code class="code">bitsub (of_int 17 ~width:8) ~hi:4 ~lo:3</code>
<p>

    will result in a two bit vector consisting of the forth and
    third bits, i.e., equal to a number <code class="code">2</code>.
<p>

    <code class="code">lo</code> and <code class="code">hi</code> should be non-negative numbers less then a
    <code class="code">width bv</code> and  <code class="code">hi &gt; lo</code>.<br>
</div>

<pre><span id="VALbitsub_exn"><span class="keyword">val</span> bitsub_exn</span> : <code class="type">?hi:int -> ?lo:int -> <a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">bitsub_exn bv ~hi ~lo</code> is the same as <code class="code">bitsub</code>, but will raise
    an exception on error.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">concat b1 b2</code> concatenates two bitvectors<br>
</div>

<pre><span id="VAL(@.)"><span class="keyword">val</span> (@.)</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">b1 @. b2</code> is equal to <code class="code">concat b1 b2</code><br>
</div>

<pre><span id="VALsucc"><span class="keyword">val</span> succ</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">succ n</code> returns next value after <code class="code">n</code>. Of course it is not
    guaranteed that <code class="code">succ n &gt; n</code><br>
</div>

<pre><span id="VALpred"><span class="keyword">val</span> pred</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">pred n</code> returns a value preceding <code class="code">n</code><br>
</div>

<pre><span id="VALnsucc"><span class="keyword">val</span> nsucc</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">nsucc m n</code> is <code class="code"><span class="constructor">Fn</span>.apply_n_times ~n succ m</code>, but more
    efficient.<br>
</div>

<pre><span id="VALnpred"><span class="keyword">val</span> npred</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">npred m n</code> is <code class="code"><span class="constructor">Fn</span>.apply_n_times ~n pred addr</code>, but more
    efficient.<br>
</div>

<pre><span id="VAL(++)"><span class="keyword">val</span> (++)</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">a ++ n</code> is <code class="code">nsucc a n</code><br>
</div>

<pre><span id="VAL(--)"><span class="keyword">val</span> (--)</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> int -> <a href="Bap_bitvector.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">a -- n</code> is <code class="code">npred a n</code><br>
</div>
<br>
<h2 id="2_Iterationoverbitvectorcomponents">Iteration over bitvector components </h2><br>

<pre><span id="VALto_bytes"><span class="keyword">val</span> to_bytes</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -><br>       <a href="Bap_bitvector.html#TYPEendian">endian</a> -> <a href="Bap_bitvector.html#TYPEt">t</a> Core_kernel.Std.Sequence.t</code></pre><div class="info ">
<code class="code">to_bytes x order</code> returns bytes of <code class="code">x</code> in a specified <code class="code">order</code>.
    Each byte is represented as a <code class="code">bitvector</code> itself.
<p>
<code class="code">to_bytes x order</code> returns bytes of <code class="code">x</code> in a specified <code class="code">order</code>,
    with bytes represented by <code class="code">char</code> type<br>
</div>

<pre><span id="VALto_chars"><span class="keyword">val</span> to_chars</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEendian">endian</a> -> char Core_kernel.Std.Sequence.t</code></pre>
<pre><span id="VALto_bits"><span class="keyword">val</span> to_bits</span> : <code class="type"><a href="Bap_bitvector.html#TYPEt">t</a> -> <a href="Bap_bitvector.html#TYPEendian">endian</a> -> bool Core_kernel.Std.Sequence.t</code></pre><div class="info ">
<code class="code">to_bits x order</code> returns bits of <code class="code">x</code> in a specified <code class="code">order</code>.
    <code class="code">order</code> defines only the ordering of words in a bitvector, bits
    will always be in MSB first order.<br>
</div>
<br>
A type safe integer interface.
<p>

    All binary integer operations are only well defined on operands
    with equal sizes.
<p>

    Module <code class="code"><span class="constructor">Int</span></code> provides a set of integer operations that do not
    raise exceptions, but return values raised to an Or_error
    monad.
<p>

    Example:
<p>

       <code class="code"><span class="constructor">Z</span>.(i16 v1 + i16 v2 / int 16 v3)</code>,
<p>

    or just:
<p>

       <code class="code"><span class="constructor">Z</span>.(!$v1 + !$v2 / !$v3)</code>.<br>

<pre><span class="keyword">module</span> <a href="Bap_bitvector.Int.html">Int</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Bap_bitvector.Int.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="Bap_bitvector.Int_exn.html">Int_exn</a>: <code class="type"><a href="Bap_integer.S.html">Bap_integer.S</a></code><code class="type">  with type t = t</code></pre><div class="info">
This module exposes a common integer interface with
    operations not lifted into <code class="code"><span class="constructor">Or_error</span></code> monad, but raising
    <code class="code"><span class="constructor">Width</span></code> exception if operands sizes mismatch.
</div>

<pre><span id="VALendian_of_sexp"><span class="keyword">val</span> endian_of_sexp</span> : <code class="type">Sexplib.Sexp.t -> <a href="Bap_bitvector.html#TYPEendian">endian</a></code></pre>
<pre><span id="VALsexp_of_endian"><span class="keyword">val</span> sexp_of_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> -> Sexplib.Sexp.t</code></pre>
<pre><span id="VALcompare_endian"><span class="keyword">val</span> compare_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> -> <a href="Bap_bitvector.html#TYPEendian">endian</a> -> int</code></pre>
<pre><span id="VALbin_endian"><span class="keyword">val</span> bin_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> Core_kernel.Std.Bin_prot.Type_class.t</code></pre>
<pre><span id="VALbin_read_endian"><span class="keyword">val</span> bin_read_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> Core_kernel.Std.Bin_prot.Read.reader</code></pre>
<pre><span id="VAL__bin_read_endian__"><span class="keyword">val</span> __bin_read_endian__</span> : <code class="type">(int -> <a href="Bap_bitvector.html#TYPEendian">endian</a>) Core_kernel.Std.Bin_prot.Read.reader</code></pre>
<pre><span id="VALbin_reader_endian"><span class="keyword">val</span> bin_reader_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> Core_kernel.Std.Bin_prot.Type_class.reader</code></pre>
<pre><span id="VALbin_size_endian"><span class="keyword">val</span> bin_size_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> Core_kernel.Std.Bin_prot.Size.sizer</code></pre>
<pre><span id="VALbin_write_endian"><span class="keyword">val</span> bin_write_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> Core_kernel.Std.Bin_prot.Write.writer</code></pre>
<pre><span id="VALbin_writer_endian"><span class="keyword">val</span> bin_writer_endian</span> : <code class="type"><a href="Bap_bitvector.html#TYPEendian">endian</a> Core_kernel.Std.Bin_prot.Type_class.writer</code></pre><div class="info ">
most  significant byte comes first<br>
</div>
<br>
<h2 id="2_Containerinterfaces">Container interfaces</h2>
<p>

    Bitvector is also a container for bytes and bits. You can access
    individual bytes using a <code class="code"><span class="constructor">Container</span></code> interface.<br>
<br>
A comparable interface with size-monomorphic comparison.<br>
<br>
<h2 id="2_Constructors">Constructors</h2>
<p>

    We provide several conversions from primitive data types. Also, do
    not forget about <code class="code">of_string</code> function, exposed via <code class="code"><span class="constructor">Identifiable</span></code>
    interface.<br>
<br>
<h3 id="3_Somepredefinedconstantconstructors">Some predefined constant constructors </h3><br>
<br>
<code class="code">b0 = of_bool <span class="keyword">false</span></code> - a zero bit<br>
<br>
<code class="code">b1 = of_bool <span class="keyword">true</span></code> - a one bit<br>
<br>
<h3 id="3_Helpfulshortcuts">Helpful shortcuts </h3><br>
<br>
<code class="code">one width</code> number one with a specified <code class="code">width</code>, is a shortcut for
    <code class="code">of_int 1 ~width</code><br>
<br>
<code class="code">zero width</code> zero with a specified <code class="code">width</code>, is a shortcut for
    <code class="code">of_int 0 ~width</code><br>
<br>
<code class="code">ones width</code> is a number with a specified <code class="code">width</code>, and all bits
    set to 1. It is a shortcut for <code class="code">of_int (lnot 0) ~width</code><br>
<br>
<code class="code">of_binary ?width endian num</code> creates a bitvector from a string
    interpreted as a sequence of bytes in a specified order.
<p>

    The result is always positive.
<p>

    <code class="code">num</code> argument is copied
<p>

    <code class="code">width</code> defaults to <code class="code"><span class="constructor">String</span>.length num</code><br>
<br>
<h2 id="2_Conversionstointegers">Conversions to integers </h2><br>
<br>
<h3 id="3_Signedconversions">Signed conversions </h3><br>
<br>
<code class="code">signed t</code> casts t to a signed type, so that any operations
    applied on <code class="code">t</code> will be signed<br>
<br>
<code class="code">is_zero bv</code> is true iff all bits are set to zero.<br>
<br>
<code class="code">bitwidth bv</code> return a bit-width, i.e., the amount of bits<br>
<br>
<code class="code">bitsub bv ~signed ~hi ~lo</code> extracts a subvector from <code class="code">bv</code>, starting
    from bit <code class="code">hi</code> and ending with <code class="code">lo</code>. Bits are enumerated from
    right to left (from least significant to most), starting from
    zero.
<p>

    <code class="code">hi</code> defaults to <code class="code">width bv</code>
    <code class="code">lo</code> defaults to <code class="code">0</code>.
    <code class="code">signed</code> defaults to <code class="code"><span class="keyword">false</span></code>
<p>

    Example:
<p>

    <code class="code">bitsub (of_int 17 ~width:8) ~hi:4 ~lo:3</code>
<p>

    will result in a two bit vector consisting of the forth and
    third bits, i.e., equal to a number <code class="code">2</code>.
<p>

    <code class="code">lo</code> and <code class="code">hi</code> should be non-negative numbers less then a
    <code class="code">width bv</code> and  <code class="code">hi &gt; lo</code>.<br>
<br>
<code class="code">bitsub_exn bv ~hi ~lo</code> is the same as <code class="code">bitsub</code>, but will raise
    an exception on error.<br>
<br>
<code class="code">concat b1 b2</code> concatenates two bitvectors<br>
<br>
<code class="code">b1 @. b2</code> is equal to <code class="code">concat b1 b2</code><br>
<br>
<code class="code">succ n</code> returns next value after <code class="code">n</code>. Of course it is not
    guaranteed that <code class="code">succ n &gt; n</code><br>
<br>
<code class="code">pred n</code> returns a value preceding <code class="code">n</code><br>
<br>
<code class="code">nsucc m n</code> is <code class="code"><span class="constructor">Fn</span>.apply_n_times ~n succ m</code>, but more
    efficient.<br>
<br>
<code class="code">npred m n</code> is <code class="code"><span class="constructor">Fn</span>.apply_n_times ~n pred addr</code>, but more
    efficient.<br>
<br>
<code class="code">a ++ n</code> is <code class="code">nsucc a n</code><br>
<br>
<code class="code">a -- n</code> is <code class="code">npred a n</code><br>
<br>
<h2 id="2_Iterationoverbitvectorcomponents">Iteration over bitvector components </h2><br>
<br>
<code class="code">to_bytes x order</code> returns bytes of <code class="code">x</code> in a specified <code class="code">order</code>.
    Each byte is represented as a <code class="code">bitvector</code> itself.<br>
<br>
<code class="code">to_bytes x order</code> returns bytes of <code class="code">x</code> in a specified <code class="code">order</code>,
    with bytes represented by <code class="code">char</code> type<br>
<br>
<code class="code">to_bits x order</code> returns bits of <code class="code">x</code> in a specified <code class="code">order</code>.
    <code class="code">order</code> defines only the ordering of words in a bitvector, bits
    will always be in MSB first order.<br>
<br>
A type safe integer interface.
<p>

    All binary integer operations are only well defined on operands
    with equal sizes.
<p>

    Module <code class="code"><span class="constructor">Int</span></code> provides a set of integer operations that do not
    raise exceptions, but return values raised to an Or_error
    monad.
<p>

    Example:
<p>

       <code class="code"><span class="constructor">Z</span>.(i16 v1 + i16 v2 / int 16 v3)</code>,
<p>

    or just:
<p>

       <code class="code"><span class="constructor">Z</span>.(!$v1 + !$v2 / !$v3)</code>.<br>
<br>
<code class="code">!$v</code> lifts <code class="code">v</code> to an Or_error monad. It is, essentially, the
      same as <code class="code"><span class="constructor">Ok</span> v</code><br>
<br>
The following lifter will check that their operand has a
      corresponding width.<br>
<br>
<code class="code">int w v</code> will be <code class="code"><span class="constructor">Ok</span></code> if <code class="code">v</code> has width <code class="code">w</code><br>
<br>
<code class="code">of_word_size w</code> creates a lifter for a specified word size
      <code class="code">w</code>, i.e. either <code class="code">i64</code> or <code class="code">i32</code><br>
<br>
This module exposes a common integer interface with
    operations not lifted into <code class="code"><span class="constructor">Or_error</span></code> monad, but raising
    <code class="code"><span class="constructor">Width</span></code> exception if operands sizes mismatch.<br>
</body></html>