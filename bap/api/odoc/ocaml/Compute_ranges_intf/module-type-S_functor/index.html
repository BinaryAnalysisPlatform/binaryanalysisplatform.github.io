<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S_functor (ocaml.Compute_ranges_intf.S_functor)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Compute_ranges_intf</a> &#x00BB; S_functor</nav><h1>Module type <code>Compute_ranges_intf.S_functor</code></h1><p>This module type specifies what the caller has to provide in order to instantiate a module to compute ranges.</p></header><dl><dt class="spec module" id="module-Index"><a href="#module-Index" class="anchor"></a><code><span class="keyword">module</span> <a href="Index/index.html">Index</a> : <a href="../../Identifiable/index.html#module-type-S">Identifiable.S</a></code></dt><dd><p>The module <code>Index</code> is used to filter and group the generated subranges. Inclusion of a computed subrange in the result is conditional upon the existence of an index that can be associated to it. To give a concrete example, the keys associated to ranges might be pseudoregisters, and the indexes variable names (c.f. <code>Available_ranges_vars</code>). Every register that is not known to hold the value of some variable is dropped from the result.</p></dd></dl><dl><dt class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module</span> <a href="Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The module <code>Key</code> corresponds to the identifiers that define the ranges in <code>Linearize</code> instructions. Each instruction should have two sets of keys, <code>available_before</code> and <code>available_across</code>, with accessor functions of these names being provided to retrieve them. The notion of &quot;availability&quot; is not prescribed. The availability sets are used to compute subranges associated to each key.</p></dd></dl><dl><dt class="spec module" id="module-Range_info"><a href="#module-Range_info" class="anchor"></a><code><span class="keyword">module</span> <a href="Range_info/index.html">Range_info</a> : <a href="../index.html#module-type-S_range_info">S_range_info</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_range_info/index.html#type-key">key</a> := <a href="Key/index.html#type-t">Key.t</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_range_info/index.html#type-index">index</a> := <a href="Index/index.html#type-t">Index.t</a></code></dt><dd><p>The module <code>Range_info</code> is used to store additional information on a range that is associated to a range at its creation and can be retrieved from the result. The association between keys and indices is also done here: <code>Range_info.create</code> serves both as a map between keys and indices; and also as the creator of the <code>Range_info.t</code> structure. When several subranges are contained in a single range, the associated <code>Range_info.t</code> will correspond to the first closed subrange.</p></dd></dl><dl><dt class="spec module" id="module-Subrange_state"><a href="#module-Subrange_state" class="anchor"></a><code><span class="keyword">module</span> <a href="Subrange_state/index.html">Subrange_state</a> : <a href="../index.html#module-type-S_subrange_state">S_subrange_state</a></code></dt><dd><p>The module <code>Subrange_state</code> describes information that needs to be propagated and passed to <code>Subrange_info.create</code>. The state that will be used for subrange creation is the state at the end of the subrange, not at the beginning.</p></dd></dl><dl><dt class="spec module" id="module-Subrange_info"><a href="#module-Subrange_info" class="anchor"></a><code><span class="keyword">module</span> <a href="Subrange_info/index.html">Subrange_info</a> : <a href="../index.html#module-type-S_subrange_info">S_subrange_info</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_subrange_info/index.html#type-key">key</a> := <a href="Key/index.html#type-t">Key.t</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_subrange_info/index.html#type-subrange_state">subrange_state</a> := <a href="Subrange_state/index.html#type-t">Subrange_state.t</a></code></dt><dd><p>The module <code>Subrange_info</code> has a similar purpose to <code>Range_info</code>, but for subranges. Its distinguishing property is that it can store information about its context using the additional <code>subrange_state</code> parameter of its <code>create</code> function.</p></dd></dl><dl><dt class="spec value" id="val-available_before"><a href="#val-available_before" class="anchor"></a><code><span class="keyword">val</span> available_before : <a href="../../Linearize/index.html#type-instruction">L.instruction</a> <span>&#45;&gt;</span> <a href="Key/Set/index.html#type-t">Key.Set.t</a></code></dt><dd><p>How to retrieve from an instruction those keys that are available immediately before the instruction starts executing.</p></dd></dl><dl><dt class="spec value" id="val-available_across"><a href="#val-available_across" class="anchor"></a><code><span class="keyword">val</span> available_across : <a href="../../Linearize/index.html#type-instruction">L.instruction</a> <span>&#45;&gt;</span> <a href="Key/Set/index.html#type-t">Key.Set.t</a></code></dt><dd><p>How to retrieve from an instruction those keys that are available between the points at which the instruction reads its arguments and writes its results.</p></dd></dl><dl><dt class="spec value" id="val-must_restart_ranges_upon_any_change"><a href="#val-must_restart_ranges_upon_any_change" class="anchor"></a><code><span class="keyword">val</span> must_restart_ranges_upon_any_change : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>This <code>must_restart_ranges_upon_any_change</code> boolean exists because some consumers of the range information may require that two subranges are disjoint rather than including one in another. When this function returns <code>true</code>, whenever a subrange is opened or closed, all other overlapping subranges will be split in two at the same point.</p></dd></dl></div></body></html>