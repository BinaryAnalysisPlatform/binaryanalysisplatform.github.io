<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (ocaml.Compute_ranges_intf.S)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Compute_ranges_intf</a> &#x00BB; S</nav><h1>Module type <code>Compute_ranges_intf.S</code></h1><p>This module type is the result type of the <code>Compute_ranges.Make</code> functor.</p><p>The _ranges_ being computed are composed of contiguous _subranges_ delimited by two labels (of type <code>Linearize.label</code>). These labels will be added by this pass to the code being inspected, which is why the <code>create</code> function in the result of the functor returns not only the ranges but also the updated function with the labels added. The <code>start_pos_offset</code> and <code>end_pos_offset</code> components of the subranges are there to allow a distinction between ranges starting (or ending) right at the start of the corresponding instruction (offset of zero), and ranges starting or ending one byte after the actual instruction (offset of one).</p></header><dl><dt class="spec module" id="module-Index"><a href="#module-Index" class="anchor"></a><code><span class="keyword">module</span> <a href="Index/index.html">Index</a> : <a href="../../Identifiable/index.html#module-type-S">Identifiable.S</a></code></dt><dd><p>Corresponds to <code>Index</code> in the <code>S_functor</code> module type.</p></dd></dl><dl><dt class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module</span> <a href="Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Corresponds to <code>Key</code> in the <code>S_functor</code> module type.</p></dd></dl><dl><dt class="spec module" id="module-Subrange_state"><a href="#module-Subrange_state" class="anchor"></a><code><span class="keyword">module</span> <a href="Subrange_state/index.html">Subrange_state</a> : <a href="../index.html#module-type-S_subrange_state">S_subrange_state</a></code></dt><dd><p>Corresponds to <code>Subrange_state</code> in the <code>S_functor</code> module type.</p></dd></dl><dl><dt class="spec module" id="module-Subrange_info"><a href="#module-Subrange_info" class="anchor"></a><code><span class="keyword">module</span> <a href="Subrange_info/index.html">Subrange_info</a> : <a href="../index.html#module-type-S_subrange_info">S_subrange_info</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_subrange_info/index.html#type-key">key</a> := <a href="Key/index.html#type-t">Key.t</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_subrange_info/index.html#type-subrange_state">subrange_state</a> := <a href="Subrange_state/index.html#type-t">Subrange_state.t</a></code></dt><dd><p>Corresponds to <code>Subrange_info</code> in the <code>S_functor</code> module type.</p></dd></dl><dl><dt class="spec module" id="module-Range_info"><a href="#module-Range_info" class="anchor"></a><code><span class="keyword">module</span> <a href="Range_info/index.html">Range_info</a> : <a href="../index.html#module-type-S_range_info">S_range_info</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_range_info/index.html#type-key">key</a> := <a href="Key/index.html#type-t">Key.t</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-S_range_info/index.html#type-index">index</a> := <a href="Index/index.html#type-t">Index.t</a></code></dt><dd><p>Corresponds to <code>Range_info</code> in the <code>S_functor</code> module type.</p></dd></dl><div class="spec module" id="module-Subrange"><a href="#module-Subrange" class="anchor"></a><code><span class="keyword">module</span> <a href="Subrange/index.html">Subrange</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Range"><a href="#module-Range" class="anchor"></a><code><span class="keyword">module</span> <a href="Range/index.html">Range</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type holding information on computed ranges.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></dt><dd><p>A value of type <code>t</code> that holds no range information.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="../../Linearize/index.html#type-fundecl">Linearize.fundecl</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="../../Linearize/index.html#type-fundecl">Linearize.fundecl</a></code></dt><dd><p>Compute ranges for the code in the given linearized function declaration, returning the ranges as a value of type <code>t</code> and the rewritten code that must go forward for emission.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="Index/index.html#type-t">Index.t</a> <span>&#45;&gt;</span> <a href="Range/index.html#type-t">Range.t</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate through ranges. Each range is associated with an index.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="Index/index.html#type-t">Index.t</a> <span>&#45;&gt;</span> <a href="Range/index.html#type-t">Range.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Like <code>iter</code>, but a fold.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Index/index.html#type-t">Index.t</a> <span>&#45;&gt;</span> <a href="Range/index.html#type-t">Range.t</a></code></dt><dd><p>Find the range for the given index, or raise an exception.</p></dd></dl><dl><dt class="spec value" id="val-all_indexes"><a href="#val-all_indexes" class="anchor"></a><code><span class="keyword">val</span> all_indexes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Index/Set/index.html#type-t">Index.Set.t</a></code></dt><dd><p>All indexes for which the given value of type <code>t</code> contains ranges.</p></dd></dl><dl><dt class="spec value" id="val-rewrite_labels_and_remove_empty_subranges_and_ranges"><a href="#val-rewrite_labels_and_remove_empty_subranges_and_ranges" class="anchor"></a><code><span class="keyword">val</span> rewrite_labels_and_remove_empty_subranges_and_ranges : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>env:<span>int <a href="../../Numbers/Int/Map/index.html#type-t">Numbers.Int.Map.t</a></span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>An internal function used by <code>Coalesce_labels</code>. The <code>env</code> should come from <code>Coalesce_labels.fundecl</code>.</p></dd></dl></div></body></html>