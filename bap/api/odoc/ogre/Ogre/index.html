<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ogre (ogre.Ogre)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ogre</a> &#x00BB; Ogre</nav><header class="odoc-preamble"><h1>Module <code><span>Ogre</span></code></h1><p>OGRE - Open Generic Representation.</p><p>OGRE is a self-describing data storage. It is open for extensibility, i.e., adding new types of knowledge doesn't break the storage. It also has a well-specified open representation, so that any tool written in any language (or even a human itself) can create, modify and understand the contents (like XML). Ogre provides data persitance and, more importantly, a type safe way of querying and updating the data. The query language is rich enough, and supports joins and boolean constraints</p><p>It can be seen as a document NoSQL database engine. As a backing storage Ogre uses S-Expressions, and the structure of a document is close to JSON. In fact it is a restricted subset of JSON, where only scalar values are allowed.</p><p>A database, called a &quot;document&quot; (or just &quot;doc&quot;) in Ogre parlance, is a set of facts. Each fact is described with a proposition having the following syntax,</p><pre>(&lt;attribute-name&gt; &lt;v1&gt; &lt;v2&gt; ... &lt;vM&gt; )</pre><p>where <code>&lt;attribute-name&gt;</code> is a name of a proposition and <code>&lt;vN&gt;</code> is the value of <code>N</code>'th object (or subject) of a proposition. For example,</p><pre>(student (name Joe) (gpa 3.5))</pre><p>is a proposition that a student named <code>Joe</code> has a GPA rate <code>3.5</code>. Thus a proposition is a tuple with named fields. All propositions must be well-typed, so the predicate <code>student</code> should be declared before used. The field values maybe stored (and are by default) without the names in the order in which they are specified in the declaration, e.g., the following definition is equivalent to the previous one:</p><pre>(student Joe 3.5)</pre><p>Given, that the predicate is declared as:</p><pre>(declare student (name str) (gpa float))</pre><p>where the declaration has the following syntax:</p><pre>     declaration ::= ( declare &lt;attribute-name&gt; &lt;field&gt; &lt;field&gt; ... )
     field ::= ( &lt;field-name&gt; &lt;field-type&gt; )
     field-type ::= int | str | bool | float</pre><p>Each declaration declare an attribute, that defines a type of the propositions. Unlike the SQL, we denote each tuple type with the word attribute, as under our model each document describes some knowledge (an attribute) about some abstract entity. For example, a document &quot;college.ogre&quot; that contains definitions of attributes named <code>student</code>, <code>teacher</code>, <code>class</code>, <code>assignments</code> is a set of knowledge about a college. Thus an attribute maps to a SQL notion of table (or a relvar). Correspondingly, a column of a table (that is usually referred as an attribute in the relational model), maps to Ogre's field.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-doc"><a href="#type-doc" class="anchor"></a><code><span><span class="keyword">type</span> doc</span></code></div><div class="spec-doc"><p>the document</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-typeinfo"><a href="#type-typeinfo" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'k) typeinfo</span></span><span> <span class="keyword">constraint</span> <span class="type-var">'k</span> = <span><span class="type-var">_</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">_</span></span></code></div><div class="spec-doc"><p>type information associated with an attribute</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-attribute"><a href="#type-attribute" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'k) attribute</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-typeinfo">typeinfo</a></span></span></code></div><div class="spec-doc"><p>a descriptor of an attribute.</p><p>Used to construct attribute values, and to query documents. Created with <code>declare</code> function.</p><p>Note, that due to a value restriction, an attribute should be defined as a function returning a type information.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-field"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a field</span></span></code></div><div class="spec-doc"><p><code>t field</code> a descriptor of an attribute field.</p><p>Used to construct attributes, and to construct variables that reference particular fields of an attribute.</p><p>the type variable <code>t</code> range is <code>float</code>, <code>int64</code>, <code>string</code> or <code>bool</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-query"><a href="#type-query" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a query</span></span></code></div><div class="spec-doc"><p><code>attrs query</code> constructs a query type.</p><p>Created using the <code>Query</code> module. The <code>attrs</code> type variable encodes the types of requested attributes. For example,</p><p><code>((student -&gt; teacher -&gt; 'a) -&gt; 'a) query</code></p><p>represents a query for two attributes of type <code>student</code> and <code>teacher</code> correspondingly. It is represented as a continuation, denoting the fact, that the query can be executed later for an arbitrary result.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-seq"><a href="#type-seq" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a seq</span></span><span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span></span></code></div><div class="spec-doc"><p>a result of a selection.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-scheme"><a href="#type-scheme" class="anchor"></a><code><span><span class="keyword">type</span> <span>('f, 'k) scheme</span></span><span> <span class="keyword">constraint</span> <span class="type-var">'f</span> = <span><span class="type-var">_</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">_</span> <span class="keyword">constraint</span> <span class="type-var">'k</span> = <span><span class="type-var">_</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">_</span></span></code></div><div class="spec-doc"><p>type that describes an attribute.</p><p>The two type variables describe the constructor and destructor interface. The <code>'a</code> variable, the accessor, describes how an attribute can be constructed. The <code>'s</code> variable, describes how an attribute can be packed in the database. These two types come along and differ only in a return type. The general form of a type variable is <code>('a -&gt; 'r) -&gt; 'r</code>, where <code>'r</code> is the return type (a type of attribute for instance), and <code>'a</code> variable is extended every time a new field is added to a scheme.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-declare"><a href="#val-declare" class="anchor"></a><code><span><span class="keyword">val</span> declare : <span>name:string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'f</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-scheme">scheme</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'f</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-typeinfo">typeinfo</a></span></span></code></div><div class="spec-doc"><p><code>let attr () = declare ~name scheme</code> declares an attribute named with <code>name</code>, and having a type described by the <code>scheme</code>.</p><p>Due to a value restriction, each attribute should be defined as a thunk (a function).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Type/index.html">Type</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Ogre type system.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Query"><a href="#module-Query" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Query/index.html">Query</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Domain specific language for constructing queries.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Doc"><a href="#module-Doc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Doc/index.html">Doc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An Ogre document.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Monadic interface to the document.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-M/index.html">M</a> : <a href="../../monads/Monads/Std/Monad/module-type-S/index.html">Monads.Std.Monad.S</a>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> := <span><span class="type-var">'a</span> <a href="Make/argument-1-M/index.html#type-t">M.t</a></span></span></span></code></div><div class="spec-doc"><p><code>Make(M)</code> returns an Ogre monad implementation wrapped in a monad <code>M</code>.</p></div></div><div class="odoc-include"><div class="spec-doc"><p>Default implementation of the Orge monad, that is not wrapped into any other monads (in other words, that is wrapped into the identity)</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-S/index.html">S</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="Make/index.html#type-t">Make(Monads.Std.Monad.Ident).t</a></span></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-e">e</a></span> = <span><a href="#type-doc">doc</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <a href="#type-doc">doc</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../monads/Monads/Std/Monad/module-type-S/index.html">Monads.Std.Monad.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/module-type-S/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="Make/index.html#type-t">Make(Monads.Std.Monad.Ident).t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="Make/index.html#type-t">Make(Monads.Std.Monad.Ident).t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-void"><a href="#val-void" class="anchor"></a><code><span><span class="keyword">val</span> void : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>void m</code> computes <code>m</code> and discrards the result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sequence"><a href="#val-sequence" class="anchor"></a><code><span><span class="keyword">val</span> sequence : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sequence xs</code> computes a sequence of computations <code>xs</code> in the left to right order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forever"><a href="#val-forever" class="anchor"></a><code><span><span class="keyword">val</span> forever : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>forever xs</code> creates a computationt that never returns.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fn"><a href="#module-Fn" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fn/index.html">Fn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Various function combinators lifted into the Kleisli category.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Pair"><a href="#module-Pair" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Pair/index.html">Pair</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The pair interface lifted into the monad.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Triple"><a href="#module-Triple" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Triple/index.html">Triple</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The triple interface lifted into a monad.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Lift"><a href="#module-Lift" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lift/index.html">Lift</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Lifts functions into the monad.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Exn"><a href="#module-Exn" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Exn/index.html">Exn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Interacting between monads and language exceptions</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Collection"><a href="#module-Collection" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Collection/index.html">Collection</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Lifts collection interface into the monad.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-List"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> <a href="List/index.html">List</a></span><span> : <a href="Collection/module-type-S/index.html">Collection.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="Collection/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> list</span></span></span></code></div><div class="spec-doc"><p>The <span class="xref-unresolved">Monad.Collection.S</span> interface for lists</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Seq"><a href="#module-Seq" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Seq/index.html">Seq</a></span><span> : <a href="Collection/module-type-S/index.html">Collection.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="Collection/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span></span></span></code></div><div class="spec-doc"><p>The <span class="xref-unresolved">Monad.Collection.S</span> interface for sequences</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html">Monads.Std.Monad.Syntax.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;=&gt;)"><a href="#val-(&gt;=&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=&gt;) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>f &gt;=&gt; g</code> is <code>fun x -&gt; f x &gt;&gt;= g</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(!!)"><a href="#val-(!!)" class="anchor"></a><code><span><span class="keyword">val</span> (!!) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!!x</code> is <code>return x</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(!$)"><a href="#val-(!$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$f</code> is <code>Lift.unary f</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(!$$)"><a href="#val-(!$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$f</code> is <code>Lift.binary f</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(!$$$)"><a href="#val-(!$$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$$) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$$f</code> is <code>Lift.ternary f</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(!$$$$)"><a href="#val-(!$$$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$$$) : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'e</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'e</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$$$f</code> is <code>Lift.quaternary f</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(!$$$$$)"><a href="#val-(!$$$$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$$$$) : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'f</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'f</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$$$$f</code> is <code>Lift.quinary f</code></p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html">Monads.Std.Monad.Syntax.Let.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let* r = f x in b</code> is <code>f x &gt;&gt;= fun r -&gt; b</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and*"><a href="#val-and*" class="anchor"></a><code><span><span class="keyword">val</span> and* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>monoidal product</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let+ r = f x in b</code> is <code>f x &gt;&gt;| fun r -&gt; b</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and+"><a href="#val-and+" class="anchor"></a><code><span><span class="keyword">val</span> and+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>monoidal product</p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Monad.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <span class="xref-unresolved">t</span></span> := <span><span class="type-var">'a</span> <span class="xref-unresolved">t</span></span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-join"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span><span class="keyword">val</span> ignore_m : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span><span class="keyword">val</span> all_unit : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec module anchored" id="module-Let"><a href="#module-Let" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let/index.html">Let</a></span><span> : <a href="../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html">Monads.Std.Monad.Syntax.Let.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></div><div class="spec-doc"><p>Monadic operators, see <span class="xref-unresolved">Monad.Syntax.S</span> for more.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a></span><span> : <a href="../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html">Monads.Std.Monad.Syntax.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></div><div class="spec-doc"><p>Monadic operators, see <span class="xref-unresolved">Monad.Syntax.S</span> for more.</p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../monads/Monads/Std/Monad/Trans/module-type-S/index.html">Monads.Std.Monad.Trans.S</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Trans/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Trans/module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></span>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../monads/Monads/Std/Monad/Trans/module-type-S/index.html#type-e">e</a></span> = <span><a href="#type-doc">doc</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <a href="#type-doc">doc</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-m"><a href="#type-m" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a m</span></span><span> = <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-e"><a href="#type-e" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a e</span></span><span> = <span><a href="#type-doc">doc</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <a href="#type-doc">doc</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span><span class="keyword">val</span> lift : <span><span><span class="type-var">'a</span> <a href="#type-m">m</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>lifts inner monad into the resulting monad</p></div></div></details></div><div class="odoc-spec"><div class="spec value anchored" id="val-require"><a href="#val-require" class="anchor"></a><code><span><span class="keyword">val</span> require : <span>?that:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-attribute">attribute</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>require a ~that:p</code> requires that an attribute <code>a</code> has one and only one value that satisfies a predicate <code>p</code>. It is an error, if there are no such values, or if there are more than one value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-request"><a href="#val-request" class="anchor"></a><code><span><span class="keyword">val</span> request : <span>?that:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-attribute">attribute</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>request a ~that:p</code> request no more than one value of an attribute <code>a</code>, that satisfies a predicate <code>p</code>. The returned value is wrapped in an option. If there are more than one satisfying value, then it is an error.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-foreach"><a href="#val-foreach" class="anchor"></a><code><span><span class="keyword">val</span> foreach : <span><span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <a href="#type-query">query</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-seq">seq</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>foreach query ~f:action</code> applies an <code>action</code> for each value of an attributes specified in the query. The <code>query</code> value is built using a domain specific language embedded into OCaml. This language is very similar to SQL, and has join and where clauses, e.g.,</p><pre class="language-ocaml"><code>let better_than_average_students =
  foreach Query.(begin
      select
        ~where:(students.(gpa) &gt; float 3.5)
        ~join:[
          [field classid];
          [
            field teacher ~from:students;
            field id ~from:teachers
          ]]
        (from students $ teachers)
    end)
    ~f:(fun s t -&gt; return (s,t))</code></pre><p>The type of the <code>query</code> value encodes the type of the function <code>f</code>. A well formed query has a type of form <code>(t1 -&gt; t2 -&gt; .. -&gt; tm -&gt; 'a t) -&gt; 'a t</code>, where <code>t1</code> till <code>tm</code> are types of attributes enumerated in the <code>from clause</code> (in that particular order).</p><p>See the <code>Query</code> module documentation for more information about the query EDSL.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collect"><a href="#val-collect" class="anchor"></a><code><span><span class="keyword">val</span> collect : <span><span><span>(<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <a href="#type-query">query</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-seq">seq</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>collect query</code> is the same as <code>foreach query ~f:Fn.id</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-provide"><a href="#val-provide" class="anchor"></a><code><span><span class="keyword">val</span> provide : <span><span><span>(<span class="type-var">_</span>, <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span>)</span> <a href="#type-attribute">attribute</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>provide attr v1 v2 ... vm</code> stores the constituents of an attribute value in the document. An attribute type encodes not only the type of an attribute value, but also a type and the order of the fields. Thus, the <code>attribute</code> itself captures a format of the attribute representation, the same as <code>format</code> is used in printf-like functions. In that sense, the <code>provide</code> function is variadic, where the first argument (the attribute) defines the type and the arity of the function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><span class="xref-unresolved">Core_kernel</span>.Error.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fail error</code> aborts an inference process with the specified <code>error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-failf"><a href="#val-failf" class="anchor"></a><code><span><span class="keyword">val</span> failf : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit, <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="xref-unresolved">Core_kernel</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>failf fmt args... ()</code> constructs an error based on the specified format <code>fmt</code> and arguments, terminated by the unit value <code>()</code>. Example:</p><pre class="language-ocaml"><code>failf &quot;the file type %s is unsupported&quot; name ()</code></pre><p>Note: don't forget to terminate a sequence of arguments with an extra unit value. See the corresponding <code>invalid_argf</code> and <code>failwithf</code> function for the reason, why this extra argument is needed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-doc">doc</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>eval property document</code> makes an inference of a <code>property</code> based on facts stored in a <code>document</code>. If all requirements are satisfied and no errors occurred the inferred result.</p><p>For example, given the property <code>names_of_best_students</code>, defined as,</p><pre class="language-ocaml"><code>let names_of_best_students =
  foreach Query.(select (from students)
                   ~where:(students.(gpa) &gt; float 3.8))
    ~f:(fun s -&gt; return (Student.name s))</code></pre><p>we can evaluate this property, with</p><pre class="language-ocaml"><code>eval names_of_best_students</code></pre><p>to get a sequence (possibly empty) of all students that have the GPA score greater than 3.8.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec"><a href="#val-exec" class="anchor"></a><code><span><span class="keyword">val</span> exec : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-doc">doc</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-doc">doc</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>exec op doc</code> executes an operation <code>op</code> that, presumably, updates the document <code>doc</code>, returns an updated version.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-doc">doc</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <a href="#type-doc">doc</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>run op doc</code> runs an operation <code>op</code> that does some inference as well as may update the document. This function is a usual part of a generic state monad interface, and is provided for the consistency. Usually, it is a bad idea, or a notion of a bad style to use this function.</p></div></div></details></div></div></body></html>