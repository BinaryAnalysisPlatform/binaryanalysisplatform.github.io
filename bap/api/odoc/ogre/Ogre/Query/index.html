<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Query (ogre.Ogre.Query)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">ogre</a> &#x00BB; <a href="../index.html">Ogre</a> &#x00BB; Query</nav><h1>Module <code>Ogre.Query</code></h1><p>Domain specific language for constructing queries.</p><p>Currently only a select query is supported.</p><p>Currently, the expression language permits construction arithmetic and logical expressions on the base types (int, float, str and bool).</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-query">query</a></span></code></dt><dt class="spec type" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span class="keyword">type</span> exp</code></dt><dd><p>logical expression language, defined as</p><pre>      exp ::= str `string`
            | int `int64`
            | float `float`
            | bool `bool`
            | `'a attribute`.(`'b field`)
            | `'b field`.[`int`]
            | exp &lt;bop&gt; exp
            | &lt;uop&gt; exp

      bop ::=  &lt;aop&gt; | &lt;lop&gt; | &lt;cop&gt;
      uop ::=  not
      aop ::= + | -
      lop ::= || | &amp;&amp; | ==&gt;
      cop ::= &lt; | &gt; | = | &lt;&gt; | &lt;= | &gt;=</pre><p>In the grammar above, the names delimited with backticks represent types of OCaml values, that should be passed at these syntactic locations (sort of an unquoting), for example, <code>str &quot;hello&quot;</code> is an expression, as well as <code>student.(gpa)</code> assuming that <code>student</code> is a value of type <code>'a attribute</code> and <code>gpa</code> is a field of type <code>'b field</code>.</p><p>Not all expressions are well-formed, as they also must obey to the typing rules. The typing rules are simple (informally):</p><p>0. <code>x &lt;bop&gt; y</code> is wff if <code>x</code> and <code>y</code> are of the same type; 1. <code>x.(y)</code> is wff if <code>y</code> is a field of attribute <code>x</code>; 2. <code>x &lt;aop&gt; y</code> is wff if <code>x</code> and <code>y</code> are float or int; 3. <code>not x</code> is wff if <code>x</code> is bool 4. <code>x &lt;lop&gt; y</code> is wff if <code>x</code> and <code>y</code> are bool 5. <code>x &lt;cop&gt; y</code> has type bool.</p></dd></dl><dl><dt class="spec type" id="type-join"><a href="#type-join" class="anchor"></a><code><span class="keyword">type</span> join</code></dt><dd><p>join statement.</p><p>The <code>join</code> statement is a list of equality classes. Each equality class defines a query constraint, requiring all elements of the class to be equal. The elements of the class are field variables, constructed with the <code>field</code> function. There are two kinds of the field variables:</p><ul><li>A fully qualified field variable, defined with the expression <code>field y ~from:x</code>.</li></ul><ul><li>An unqualified field variable, defined as <code>field y</code>.</li></ul><p>A fully qualified variable matches only with the corresponding field expression, e.g., an equality class</p><p><code>[field teacher ~from:student; field id ~from:teacher]</code></p><p>emposes a constraint <code>student.(teacher) = teacher.(id)</code>, and is roughly equivalent to the SQL's</p><p><code>INNER JOIN teacher ON student.id = teacher.id</code></p><p>Note: it is OK to use <code>where</code> clause instead of the <code>join</code> clause to join attributes, if it makes the query more readable. There is no performance penalty.</p><p>The unqualified variable matches with the same fields ignoring the attribute name, for example, an equality class <code>field
      classid</code>, will impose an equality constraint on values from all <code>classid</code> fields of the selected attributes. Given a concrete select query:</p><pre><code class="ml">select (from student $teacher) ~join:[[field classid]]</code></pre><p>a constraint <code>student.(classid) = teacher.(classid)</code> is constructed. Another way to construct the same selection is:</p><pre><code class="ml">select (from student $teacher)
  ~where:student.(classid) = teacher.(classid)</code></pre></dd></dl><dl><dt class="spec type" id="type-tables"><a href="#type-tables" class="anchor"></a><code><span class="keyword">type</span> <span>'a tables</span></code></dt><dd><p>a selection of attributes.</p><p>The tables clause can be constructed using the following grammar:</p><pre>tables ::= from attr | &lt;tables&gt; $ attr</pre><p>In other words, there are two constructors, a prefix <code>from
      attr</code>, and an infix <code>attr1 $ attr2</code>, e.g.,</p><p><code>from students $ teachers $ classes</code></p></dd></dl><dl><dt class="spec value" id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val</span> select : <span>?&#8288;where:<a href="index.html#type-exp">exp</a></span> <span>&#45;&gt;</span> <span>?&#8288;join:<span><span><a href="index.html#type-join">join</a> list</span> list</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-tables">tables</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>select ~where ~join (from t1 t2 ... tm)</code> selects attributes <code>t1</code>, <code>t2</code>, ..., <code>tm</code>, join them by the fields specified in the <code>join</code> clause, and filters those that satisfy the condition defined with the <code>where</code> clause.</p><p>Examples:</p><p>Select all students that has the GPA rate greater than 3.8.</p><pre><code class="ml">select
  ~where:(student.(gpa) &gt; float 3.8)
  (from students)</code></pre><p>Select all students and their corresponding teachers, that have a GPA greater than 3.8 (assuming that teacher is a foreign key to the table of teachers).</p><pre><code class="ml">select
  ~where:(student.(gpa) &gt; float 3.8)
  ~join:[[field teacher ~from:student; field id ~from:teacher]]
  (from students)</code></pre><p>You may notice, that the <code>select</code> query lacks the SQL's <code>WHAT</code> clause, i.e., it is not possible or needed to specify columns. The reason for this, is that the query used as a value that is passed to some command constructor, (e.g.,<code>foreach</code>), that can work with fields individually, e.g., the following is a complete correspondence of the SQL's:</p><pre>SELECT name FROM students WHERE gpa &gt; 3.5</pre><pre><code class="ml">foreach Query.(select
                 ~where:(student.(gpa) &gt; float 3.8)
                 (from students))
  ~f:(fun s -&gt; return (Student.name s))</code></pre><p>It is nearly three times as long, but in return it is type-safe, and composable.</p></dd></dl><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-attribute">attribute</a></span> <span>&#45;&gt;</span> <span><span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <a href="index.html#type-tables">tables</a></span></code></dt><dd><p><code>from attr</code> adds an attribute <code>attr</code> to the query. An attribute can be referenced in the query if it occurs in the from clause. Otherwise the query is not well-formed.</p></dd></dl><dl><dt class="spec value" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val</span> ($) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <a href="index.html#type-tables">tables</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-attribute">attribute</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <a href="index.html#type-tables">tables</a></span></code></dt><dd><p><code>attrs $ attr</code> appends an attribute <code>attr</code> to the sequence of chosen attributes <code>attrs</code>.</p></dd></dl><dl><dt class="spec value" id="val-field"><a href="#val-field" class="anchor"></a><code><span class="keyword">val</span> field : <span>?&#8288;from:<span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-attribute">attribute</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="../index.html#type-field">field</a></span> <span>&#45;&gt;</span> <a href="index.html#type-join">join</a></code></dt><dd><p><code>field name</code> creates an unqualified join variable. <code>field name ~from:attr</code> creates a qualified join variable.</p><p>See the <a href="index.html#type-join"><code>join</code></a> type description, for the explanation of the <code>join</code> expressions and joining.</p></dd></dl><dl><dt class="spec module" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span class="keyword">module</span> <a href="Array/index.html">Array</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Defines a subscripting syntax for creating field variables.</p></dd></dl><dl><dt class="spec module" id="module-String"><a href="#module-String" class="anchor"></a><code><span class="keyword">module</span> <a href="String/index.html">String</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Defines field subscripting syntax.</p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : string <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>str x</code> creates a string constant.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : int64 <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>int x</code> creates an integer constant</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : bool <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>bool x</code> creates a logic constant</p></dd></dl><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : float <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>float x</code> creates a real number constant.</p></dd></dl><dl><dt class="spec value" id="val-(&amp;&amp;)"><a href="#val-(&amp;&amp;)" class="anchor"></a><code><span class="keyword">val</span> (&amp;&amp;) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x &amp;&amp; y</code> conjunction</p></dd></dl><dl><dt class="spec value" id="val-(||)"><a href="#val-(||)" class="anchor"></a><code><span class="keyword">val</span> (||) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x || y</code> disjunction</p></dd></dl><dl><dt class="spec value" id="val-(==&gt;)"><a href="#val-(==&gt;)" class="anchor"></a><code><span class="keyword">val</span> (==&gt;) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x ==&gt; y</code> implication.</p><p>Be aware that the precedence of OCaml operator ==&gt; is higher than a common precedence of the implication operator in mathematics.</p><p>That means, that an expression <code>x &amp;&amp; y ==&gt; x &amp;&amp; z</code> is parsed as <code>x &amp;&amp; (y ==&gt; x) &amp;&amp; z</code>.</p><p>The rule of the thumb is to always put parenthesis in an expression, that has an implication, as even if you're aware of the precedence issue, it is not known to a reader of your code, whether you were aware, or wrote this code by a mistake.</p></dd></dl><dl><dt class="spec value" id="val-not"><a href="#val-not" class="anchor"></a><code><span class="keyword">val</span> not : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>not x</code> logical negation.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;)"><a href="#val-(&lt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x &lt; y</code> less than</p></dd></dl><dl><dt class="spec value" id="val-(&gt;)"><a href="#val-(&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x &gt; y</code> greater than</p></dd></dl><dl><dt class="spec value" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span class="keyword">val</span> (=) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x = y</code> equality</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&gt;) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x &lt;&gt; y</code> nonequality</p></dd></dl><dl><dt class="spec value" id="val-(&lt;=)"><a href="#val-(&lt;=)" class="anchor"></a><code><span class="keyword">val</span> (&lt;=) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x &lt;= y</code> less than or equal</p></dd></dl><dl><dt class="spec value" id="val-(&gt;=)"><a href="#val-(&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;=) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x &gt;= y</code> greater or equal</p></dd></dl><dl><dt class="spec value" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span class="keyword">val</span> (+) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x + y</code> summation</p></dd></dl><dl><dt class="spec value" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span class="keyword">val</span> (-) : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a></code></dt><dd><p><code>x - y</code> subtracting</p></dd></dl></div></body></html>