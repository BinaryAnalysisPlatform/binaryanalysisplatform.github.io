<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Query (ogre.Ogre.Query)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">ogre</a> &#x00BB; <a href="../index.html">Ogre</a> &#x00BB; Query</nav><header class="odoc-preamble"><h1>Module <code><span>Ogre.Query</span></code></h1><p>Domain specific language for constructing queries.</p><p>Currently only a select query is supported.</p><p>Currently, the expression language permits construction arithmetic and logical expressions on the base types (int, float, str and bool).</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../index.html#type-query">query</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span><span class="keyword">type</span> exp</span></code></div><div class="spec-doc"><p>logical expression language, defined as</p><pre>      exp ::= str `string`
            | int `int64`
            | float `float`
            | bool `bool`
            | `'a attribute`.(`'b field`)
            | `'b field`.[`int`]
            | exp &lt;bop&gt; exp
            | &lt;uop&gt; exp

      bop ::=  &lt;aop&gt; | &lt;lop&gt; | &lt;cop&gt;
      uop ::=  not
      aop ::= + | -
      lop ::= || | &amp;&amp; | ==&gt;
      cop ::= &lt; | &gt; | = | &lt;&gt; | &lt;= | &gt;=</pre><p>In the grammar above, the names delimited with backticks represent types of OCaml values, that should be passed at these syntactic locations (sort of an unquoting), for example, <code>str &quot;hello&quot;</code> is an expression, as well as <code>student.(gpa)</code> assuming that <code>student</code> is a value of type <code>'a attribute</code> and <code>gpa</code> is a field of type <code>'b field</code>.</p><p>Not all expressions are well-formed, as they also must obey to the typing rules. The typing rules are simple (informally):</p><p>0. <code>x &lt;bop&gt; y</code> is wff if <code>x</code> and <code>y</code> are of the same type; 1. <code>x.(y)</code> is wff if <code>y</code> is a field of attribute <code>x</code>; 2. <code>x &lt;aop&gt; y</code> is wff if <code>x</code> and <code>y</code> are float or int; 3. <code>not x</code> is wff if <code>x</code> is bool 4. <code>x &lt;lop&gt; y</code> is wff if <code>x</code> and <code>y</code> are bool 5. <code>x &lt;cop&gt; y</code> has type bool.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-join"><a href="#type-join" class="anchor"></a><code><span><span class="keyword">type</span> join</span></code></div><div class="spec-doc"><p>join statement.</p><p>The <code>join</code> statement is a list of equality classes. Each equality class defines a query constraint, requiring all elements of the class to be equal. The elements of the class are field variables, constructed with the <code>field</code> function. There are two kinds of the field variables:</p><ul><li>A fully qualified field variable, defined with the expression <code>field y ~from:x</code>.</li></ul><ul><li>An unqualified field variable, defined as <code>field y</code>.</li></ul><p>A fully qualified variable matches only with the corresponding field expression, e.g., an equality class</p><p><code>[field teacher ~from:student; field id ~from:teacher]</code></p><p>emposes a constraint <code>student.(teacher) = teacher.(id)</code>, and is roughly equivalent to the SQL's</p><p><code>INNER JOIN teacher ON student.id = teacher.id</code></p><p>Note: it is OK to use <code>where</code> clause instead of the <code>join</code> clause to join attributes, if it makes the query more readable. There is no performance penalty.</p><p>The unqualified variable matches with the same fields ignoring the attribute name, for example, an equality class <code>field
      classid</code>, will impose an equality constraint on values from all <code>classid</code> fields of the selected attributes. Given a concrete select query:</p><pre class="language-ocaml"><code>select (from student $teacher) ~join:[[field classid]]</code></pre><p>a constraint <code>student.(classid) = teacher.(classid)</code> is constructed. Another way to construct the same selection is:</p><pre class="language-ocaml"><code>select (from student $teacher)
  ~where:student.(classid) = teacher.(classid)</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tables"><a href="#type-tables" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tables</span></span></code></div><div class="spec-doc"><p>a selection of attributes.</p><p>The tables clause can be constructed using the following grammar:</p><pre>tables ::= from attr | &lt;tables&gt; $ attr</pre><p>In other words, there are two constructors, a prefix <code>from
      attr</code>, and an infix <code>attr1 $ attr2</code>, e.g.,</p><p><code>from students $ teachers $ classes</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select"><a href="#val-select" class="anchor"></a><code><span><span class="keyword">val</span> select : <span>?where:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span>?join:<span><span><a href="#type-join">join</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tables">tables</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>select ~where ~join (from t1 t2 ... tm)</code> selects attributes <code>t1</code>, <code>t2</code>, ..., <code>tm</code>, join them by the fields specified in the <code>join</code> clause, and filters those that satisfy the condition defined with the <code>where</code> clause.</p><p>Examples:</p><p>Select all students that has the GPA rate greater than 3.8.</p><pre class="language-ocaml"><code>select
  ~where:(student.(gpa) &gt; float 3.8)
  (from students)</code></pre><p>Select all students and their corresponding teachers, that have a GPA greater than 3.8 (assuming that teacher is a foreign key to the table of teachers).</p><pre class="language-ocaml"><code>select
  ~where:(student.(gpa) &gt; float 3.8)
  ~join:[[field teacher ~from:student; field id ~from:teacher]]
  (from students)</code></pre><p>You may notice, that the <code>select</code> query lacks the SQL's <code>WHAT</code> clause, i.e., it is not possible or needed to specify columns. The reason for this, is that the query used as a value that is passed to some command constructor, (e.g.,<code>foreach</code>), that can work with fields individually, e.g., the following is a complete correspondence of the SQL's:</p><pre>SELECT name FROM students WHERE gpa &gt; 3.5</pre><pre class="language-ocaml"><code>foreach Query.(select
                 ~where:(student.(gpa) &gt; float 3.8)
                 (from students))
  ~f:(fun s -&gt; return (Student.name s))</code></pre><p>It is nearly three times as long, but in return it is type-safe, and composable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from"><a href="#val-from" class="anchor"></a><code><span><span class="keyword">val</span> from : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-attribute">attribute</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <a href="#type-tables">tables</a></span></span></code></div><div class="spec-doc"><p><code>from attr</code> adds an attribute <code>attr</code> to the query. An attribute can be referenced in the query if it occurs in the from clause. Otherwise the query is not well-formed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span><span class="keyword">val</span> ($) : <span><span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <a href="#type-tables">tables</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-attribute">attribute</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <a href="#type-tables">tables</a></span></span></code></div><div class="spec-doc"><p><code>attrs $ attr</code> appends an attribute <code>attr</code> to the sequence of chosen attributes <code>attrs</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-field"><a href="#val-field" class="anchor"></a><code><span><span class="keyword">val</span> field : <span>?from:<span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-attribute">attribute</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="../index.html#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-join">join</a></span></code></div><div class="spec-doc"><p><code>field name</code> creates an unqualified join variable. <code>field name ~from:attr</code> creates a qualified join variable.</p><p>See the <a href="#type-join"><code>join</code></a> type description, for the explanation of the <code>join</code> expressions and joining.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Array/index.html">Array</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Defines a subscripting syntax for creating field variables.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-String"><a href="#module-String" class="anchor"></a><code><span><span class="keyword">module</span> <a href="String/index.html">String</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Defines field subscripting syntax.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-str"><a href="#val-str" class="anchor"></a><code><span><span class="keyword">val</span> str : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>str x</code> creates a string constant.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>int x</code> creates an integer constant</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>bool x</code> creates a logic constant</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>float x</code> creates a real number constant.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&amp;&amp;)"><a href="#val-(&amp;&amp;)" class="anchor"></a><code><span><span class="keyword">val</span> (&amp;&amp;) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x &amp;&amp; y</code> conjunction</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(||)"><a href="#val-(||)" class="anchor"></a><code><span><span class="keyword">val</span> (||) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x || y</code> disjunction</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(==&gt;)"><a href="#val-(==&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (==&gt;) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x ==&gt; y</code> implication.</p><p>Be aware that the precedence of OCaml operator ==&gt; is higher than a common precedence of the implication operator in mathematics.</p><p>That means, that an expression <code>x &amp;&amp; y ==&gt; x &amp;&amp; z</code> is parsed as <code>x &amp;&amp; (y ==&gt; x) &amp;&amp; z</code>.</p><p>The rule of the thumb is to always put parenthesis in an expression, that has an implication, as even if you're aware of the precedence issue, it is not known to a reader of your code, whether you were aware, or wrote this code by a mistake.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not"><a href="#val-not" class="anchor"></a><code><span><span class="keyword">val</span> not : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>not x</code> logical negation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;)"><a href="#val-(&lt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x &lt; y</code> less than</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;)"><a href="#val-(&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x &gt; y</code> greater than</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span><span class="keyword">val</span> (=) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x = y</code> equality</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&gt;) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x &lt;&gt; y</code> nonequality</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;=)"><a href="#val-(&lt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;=) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x &lt;= y</code> less than or equal</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;=)"><a href="#val-(&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x &gt;= y</code> greater or equal</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x + y</code> summation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span><span class="keyword">val</span> (-) : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p><code>x - y</code> subtracting</p></div></div></div></body></html>