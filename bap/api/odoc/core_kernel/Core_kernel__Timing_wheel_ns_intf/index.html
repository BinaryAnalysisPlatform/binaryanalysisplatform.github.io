<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_kernel__Timing_wheel_ns_intf (core_kernel.Core_kernel__Timing_wheel_ns_intf)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core_kernel</a> &#x00BB; Core_kernel__Timing_wheel_ns_intf</nav><h1>Module <code>Core_kernel__Timing_wheel_ns_intf</code></h1><p>A specialized priority queue for a set of time-based alarms.</p><p>A timing wheel is a data structure that maintains a clock with the current time and a set of alarms scheduled to fire in the future. One can add and remove alarms, and advance the clock to cause alarms to fire. There is nothing asynchronous about a timing wheel. Alarms only fire in response to an <code>advance_clock</code> call.</p><p>When one <code>create</code>s a timing wheel, one supplies an initial time, <code>start</code>, and an <code>alarm_precision</code>. The timing wheel breaks all time from the epoch onwards into half-open intervals of size <code>alarm_precision</code>, with the bottom half of each interval closed, and the top half open. Alarms in the same interval fire in the same call to <code>advance_clock</code>, as soon as <code>now t</code> is greater than all the times in the interval. When an alarm <code>a</code> fires on a timing wheel <code>t</code>, the implementation guarantees that:</p><pre><code class="ml">Alarm.at a &lt; now t</code></pre><p>That is, alarms never fire early. Furthermore, the implementation guarantees that alarms don't go off too late. More precisely, for all alarms <code>a</code> in <code>t</code>:</p><pre><code class="ml">interval_start t (Alarm.at a) &gt;= interval_start t (now t)</code></pre><p>This implies that for all alarms <code>a</code> in <code>t</code>:</p><pre><code class="ml">Alarm.at a &gt; now t - alarm_precision t</code></pre><p>Of course, an <code>advance_clock</code> call can advance the clock to an arbitrary time in the future, and thus alarms may fire at a clock time arbitrarily far beyond the time for which they were set. But the implementation has no control over the times supplied to <code>advance_clock</code>; it can only guarantee that alarms will fire when <code>advance_clock</code> is called with a time at least <code>alarm_precision</code> greater than their scheduled time.</p><p>There are two implementations of timing wheel, <code>Timing_wheel_float</code> and <code>Timing_wheel_ns</code>, which differ in the representation of time that they use, <code>Time</code> or <code>Time_ns</code>. <code>Timing_wheel_ns</code> is the underlying implementation, whereas <code>Timing_wheel_float</code> is a wrapper around <code>Timing_wheel_ns</code> that converts between the two representations of time.</p><h3 id="implementation"><a href="#implementation" class="anchor"></a>Implementation</h3><p>A timing wheel is implemented using a specialized priority queue in which the half-open intervals from the epoch onwards are numbered 0, 1, 2, etc. Each time is stored in the priority queue with the key of its interval number. Thus all alarms with a time in the same interval get the same key, and hence fire at the same time. More specifically, an alarm is fired when the clock reaches or passes the time at the start of the next interval.</p><p>Alarms that fire in the same interval will fire in the order in which they were added to the timing wheel, rather than the time they were set to go off. This is consistent with the guarantees of timing wheel mentioned above, but may nontheless be surprising to users.</p><p>The priority queue is implemented with an array of levels of decreasing precision, with the lowest level having the most precision and storing the closest upcoming alarms, while the highest level has the least precision and stores the alarms farthest in the future. As time increases, the timing wheel does a lazy radix sort of the alarm keys.</p><p>This implementation makes <code>add_alarm</code> and <code>remove_alarm</code> constant time, while <code>advance_clock</code> takes time proportional to the amount of time the clock is advanced. With a sufficient number of alarms, this is more efficient than a log(N) heap implementation of a priority queue.</p><h3 id="representable-times"><a href="#representable-times" class="anchor"></a>Representable times</h3><p>A timing wheel <code>t</code> can only handle a (typically large) bounded range of times as determined by the current time, <code>now t</code>, and the <code>level_bits</code> and <code>alarm_precision</code> arguments supplied to <code>create</code>. Various functions raise if they are supplied a time smaller than <code>now t</code> or <code>&gt;= alarm_upper_bound t</code>. This situation likely indicates a misconfiguration of the <code>level_bits</code> and/or <code>alarm_precision</code>. Here is the duration of <code>alarm_upper_bound t - now t</code> using the default <code>level_bits</code>.</p><pre>      | # intervals | alarm_precision | duration |
      +-------------+-----------------+----------|
      |        2^61 | nanosecond      | 73 years |</pre></header><dl><dt class="spec module-type" id="module-type-Timing_wheel_time"><a href="#module-type-Timing_wheel_time" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Timing_wheel_time/index.html">Timing_wheel_time</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Timing_wheel_time</code> is used to parameterize the timing-wheel interface over both <code>Time</code> and <code>Time_ns</code>.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Interval_num"><a href="#module-type-Interval_num" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Interval_num/index.html">Interval_num</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An <code>Interval_num.t</code> is an index of one of the intervals into which a timing-wheel partitions time.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Alarm_precision"><a href="#module-type-Alarm_precision" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Alarm_precision/index.html">Alarm_precision</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An <code>Alarm_precision</code> is a time span that is a power of two number of nanoseconds, used to specify the precision of a timing wheel.</p></dd></dl><div class="spec module-type" id="module-type-Timing_wheel"><a href="#module-type-Timing_wheel" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Timing_wheel/index.html">Timing_wheel</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-Timing_wheel_ns"><a href="#module-type-Timing_wheel_ns" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Timing_wheel_ns/index.html">Timing_wheel_ns</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A timing wheel can be thought of as a set of alarms.</p></dd></dl></div></body></html>