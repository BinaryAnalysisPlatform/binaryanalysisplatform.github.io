<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Binary_packing (core_kernel.Binary_packing)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core_kernel</a> &#x00BB; Binary_packing</nav><h1>Module <code>Binary_packing</code></h1><p>Packs and unpacks various types of integers into and from strings.</p><p>Functions ending in <code>_int</code> should not be used in 32-bit programs because native OCaml ints will not be big enough.</p><p><code>pos</code> arguments refer to the location in the buf string.</p><p>We support big- and little-endian ints. Note that for an 8-bit (1-byte) integer, there is no difference, because endian-ness only changes the order of bytes, not bits.</p></header><dl><dt class="spec type" id="type-endian"><a href="#type-endian" class="anchor"></a><code><span class="keyword">type</span> endian</code> = <code>[ </code><table class="variant"><tr id="type-endian.Big_endian" class="anchored"><td class="def constructor"><a href="#type-endian.Big_endian" class="anchor"></a><code>| </code><code>`Big_endian</code></td></tr><tr id="type-endian.Little_endian" class="anchored"><td class="def constructor"><a href="#type-endian.Little_endian" class="anchor"></a><code>| </code><code>`Little_endian</code></td></tr></table><code> ]</code></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-compare_endian"><a href="#val-compare_endian" class="anchor"></a><code><span class="keyword">val</span> compare_endian : <a href="index.html#type-endian">endian</a> <span>&#45;&gt;</span> <a href="index.html#type-endian">endian</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-hash_fold_endian"><a href="#val-hash_fold_endian" class="anchor"></a><code><span class="keyword">val</span> hash_fold_endian : <a href="../../base/Base/Hash/index.html#type-state">Base.Hash.state</a> <span>&#45;&gt;</span> <a href="index.html#type-endian">endian</a> <span>&#45;&gt;</span> <a href="../../base/Base/Hash/index.html#type-state">Base.Hash.state</a></code></dt><dt class="spec value" id="val-hash_endian"><a href="#val-hash_endian" class="anchor"></a><code><span class="keyword">val</span> hash_endian : <a href="index.html#type-endian">endian</a> <span>&#45;&gt;</span> <a href="../../base/Base/Hash/index.html#type-hash_value">Base.Hash.hash_value</a></code></dt><dt class="spec value" id="val-sexp_of_endian"><a href="#val-sexp_of_endian" class="anchor"></a><code><span class="keyword">val</span> sexp_of_endian : <a href="index.html#type-endian">endian</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt><dt class="spec value" id="val-endian_of_sexp"><a href="#val-endian_of_sexp" class="anchor"></a><code><span class="keyword">val</span> endian_of_sexp : <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-endian">endian</a></code></dt><dt class="spec value" id="val-__endian_of_sexp__"><a href="#val-__endian_of_sexp__" class="anchor"></a><code><span class="keyword">val</span> __endian_of_sexp__ : <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-endian">endian</a></code></dt></dl></div></div></div><dl><dt class="spec value" id="val-unpack_signed_8"><a href="#val-unpack_signed_8" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_8 : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_8"><a href="#val-pack_signed_8" class="anchor"></a><code><span class="keyword">val</span> pack_signed_8 : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_unsigned_8"><a href="#val-unpack_unsigned_8" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_8 : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_unsigned_8"><a href="#val-pack_unsigned_8" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_8 : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_16"><a href="#val-unpack_signed_16" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_16 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dd><p>The functions ending with <code>_big_endian</code> or <code>_little_endian</code> are faster than the ones with an explicit <code>byte_order</code> argument:</p><pre>                                Name | Run time | S. dev. | Warnings
  ---------------------------------- | -------- | ------- | --------
        pack_signed_16_little_endian |     4 ns |    0 ns |
      unpack_signed_16_little_endian |     5 ns |    0 ns |
                  pack_signed_32_int |    12 ns |    0 ns |
                unpack_signed_32_int |    12 ns |    0 ns |
    pack_signed_32_int_little_endian |     4 ns |    0 ns |
  unpack_signed_32_int_little_endian |     5 ns |    0 ns |        M
                  pack_signed_64_int |    21 ns |    0 ns |        M
                unpack_signed_64_int |    21 ns |    0 ns |        M
        pack_signed_64_little_endian |     8 ns |    0 ns |
      unpack_signed_64_little_endian |     9 ns |    0 ns |        M</pre></dd></dl><dl><dt class="spec value" id="val-pack_signed_16"><a href="#val-pack_signed_16" class="anchor"></a><code><span class="keyword">val</span> pack_signed_16 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_unsigned_16_big_endian"><a href="#val-unpack_unsigned_16_big_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_16_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unpack_unsigned_16_little_endian"><a href="#val-unpack_unsigned_16_little_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_16_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_unsigned_16_big_endian"><a href="#val-pack_unsigned_16_big_endian" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_16_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_unsigned_16_little_endian"><a href="#val-pack_unsigned_16_little_endian" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_16_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_16_big_endian"><a href="#val-unpack_signed_16_big_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_16_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unpack_signed_16_little_endian"><a href="#val-unpack_signed_16_little_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_16_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_16_big_endian"><a href="#val-pack_signed_16_big_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_16_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_signed_16_little_endian"><a href="#val-pack_signed_16_little_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_16_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_unsigned_16"><a href="#val-unpack_unsigned_16" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_16 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_unsigned_16"><a href="#val-pack_unsigned_16" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_16 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_32"><a href="#val-unpack_signed_32" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_32 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int32</code></dt><dt class="spec value" id="val-unpack_signed_32_int"><a href="#val-unpack_signed_32_int" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_32_int : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_32"><a href="#val-pack_signed_32" class="anchor"></a><code><span class="keyword">val</span> pack_signed_32 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <a href="../Core_kernel/Int32/index.html#type-t">Core_kernel.Int32.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_signed_32_int"><a href="#val-pack_signed_32_int" class="anchor"></a><code><span class="keyword">val</span> pack_signed_32_int : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_unsigned_32_int_big_endian"><a href="#val-unpack_unsigned_32_int_big_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_32_int_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unpack_unsigned_32_int_little_endian"><a href="#val-unpack_unsigned_32_int_little_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_32_int_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_unsigned_32_int_big_endian"><a href="#val-pack_unsigned_32_int_big_endian" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_32_int_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_unsigned_32_int_little_endian"><a href="#val-pack_unsigned_32_int_little_endian" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_32_int_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_32_int_big_endian"><a href="#val-unpack_signed_32_int_big_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_32_int_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-unpack_signed_32_int_little_endian"><a href="#val-unpack_signed_32_int_little_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_32_int_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_32_int_big_endian"><a href="#val-pack_signed_32_int_big_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_32_int_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_signed_32_int_little_endian"><a href="#val-pack_signed_32_int_little_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_32_int_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_unsigned_32_int"><a href="#val-unpack_unsigned_32_int" class="anchor"></a><code><span class="keyword">val</span> unpack_unsigned_32_int : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_unsigned_32_int"><a href="#val-pack_unsigned_32_int" class="anchor"></a><code><span class="keyword">val</span> pack_unsigned_32_int : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_64"><a href="#val-unpack_signed_64" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_64 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int64</code></dt><dt class="spec value" id="val-unpack_signed_64_int"><a href="#val-unpack_signed_64_int" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_64_int : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_64"><a href="#val-pack_signed_64" class="anchor"></a><code><span class="keyword">val</span> pack_signed_64 : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <a href="../Core_kernel/Int64/index.html#type-t">Core_kernel.Int64.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_signed_64_int"><a href="#val-pack_signed_64_int" class="anchor"></a><code><span class="keyword">val</span> pack_signed_64_int : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_64_int_little_endian"><a href="#val-unpack_signed_64_int_little_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_64_int_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_64_int_little_endian"><a href="#val-pack_signed_64_int_little_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_64_int_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_64_int_big_endian"><a href="#val-unpack_signed_64_int_big_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_64_int_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pack_signed_64_int_big_endian"><a href="#val-pack_signed_64_int_big_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_64_int_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_signed_64_big_endian"><a href="#val-unpack_signed_64_big_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_64_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int64</code></dt><dt class="spec value" id="val-unpack_signed_64_little_endian"><a href="#val-unpack_signed_64_little_endian" class="anchor"></a><code><span class="keyword">val</span> unpack_signed_64_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int64</code></dt><dt class="spec value" id="val-pack_signed_64_big_endian"><a href="#val-pack_signed_64_big_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_64_big_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pack_signed_64_little_endian"><a href="#val-pack_signed_64_little_endian" class="anchor"></a><code><span class="keyword">val</span> pack_signed_64_little_endian : <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unpack_float"><a href="#val-unpack_float" class="anchor"></a><code><span class="keyword">val</span> unpack_float : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> float</code></dt><dd><p>As with integers, floats can be be packed big-endian or little-endian, depending on the order in which the bytes of the float are layed out. There is nothing interesting going on computationally from a floating-point perspective, just laying out eight bytes in one order or the other.</p></dd></dl><dl><dt class="spec value" id="val-pack_float"><a href="#val-pack_float" class="anchor"></a><code><span class="keyword">val</span> pack_float : <span>byte_order:<a href="index.html#type-endian">endian</a></span> <span>&#45;&gt;</span> <span>buf:bytes</span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt></dl><aside><p>The following functions operate on &quot;fixed-length tail-padded strings&quot;, by which is meant a string possibly followed by some padding, such that the length of the string plus the length of the padding equals the fixed length.</p></aside><dl><dt class="spec value" id="val-unpack_tail_padded_fixed_string"><a href="#val-unpack_tail_padded_fixed_string" class="anchor"></a><code><span class="keyword">val</span> unpack_tail_padded_fixed_string : <span>?&#8288;padding:char</span> <span>&#45;&gt;</span> <span>buf:<a href="../Core_kernel/Bytes/index.html#type-t">Core_kernel.Bytes.t</a></span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> string</code></dt><dd><p>Decode the fixed-length tail-padded string having length <code>len</code> from <code>buf</code> starting at <code>pos</code>. Return a string containing only the non-padding characters. The default padding is '\x00'.</p></dd></dl><dl><dt class="spec value" id="val-pack_tail_padded_fixed_string"><a href="#val-pack_tail_padded_fixed_string" class="anchor"></a><code><span class="keyword">val</span> pack_tail_padded_fixed_string : <span>?&#8288;padding:char</span> <span>&#45;&gt;</span> <span>buf:<a href="../Core_kernel/Bytes/index.html#type-t">Core_kernel.Bytes.t</a></span> <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Encode and pack the given string as a tail padded fixed length string having length <code>len</code>. Place it in <code>buf</code> starting at position <code>pos</code>. If the length of the string is less then <code>len</code> pad it with the padding characters until its length is equal to <code>len</code>. If the string is longer than <code>len</code> raise <code>Invalid_argument</code>. The default padding is '\x00'.</p></dd></dl><div class="spec module" id="module-Private"><a href="#module-Private" class="anchor"></a><code><span class="keyword">module</span> <a href="Private/index.html">Private</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>