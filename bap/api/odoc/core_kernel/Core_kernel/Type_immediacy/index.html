<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type_immediacy (core_kernel.Core_kernel.Type_immediacy)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">core_kernel</a> &#x00BB; <a href="../index.html">Core_kernel</a> &#x00BB; Type_immediacy</nav><h1>Module <code>Core_kernel.Type_immediacy</code></h1><p>Witnesses that express whether a type's values are always, sometimes, or never immediate.</p><p>A value is immediate when it is internally represented unboxed, using one word of memory rather than a pointer to a heap-allocated block.</p><p>Some examples:</p><ul><li>All <code>int</code> values are by definition immediate, i.e., unboxed, and so <code>int</code> is always immediate.</li></ul><ul><li>A <code>'a list</code> is either <code>[]</code>, which is internally represented as 0 (immediate), or a non-empty list, which is represented as a pointer to a heap block (boxed), which contains the first element and the pointer to the rest of the list. Therefore <code>'a
      list</code> is sometimes immediate.</li></ul><ul><li>All values of type <code>'a ref</code> are represented as a pointer to a heap block containing the actual values <code>'a</code>. Therefore <code>'a ref</code> is never immediate.</li></ul><p>The witness values can be used to perform safe optimizations such as allowing a more efficient <code>'a array</code> blit operations if <code>'a</code> is always immediate. These witnesses can also be used to perform safe conversions between immediate values of type <code>'a</code> and <code>int</code> instead of using <code>Obj.magic</code>.</p><h3 id="converting-between-values-and-ints"><a href="#converting-between-values-and-ints" class="anchor"></a>Converting between values and ints</h3><p>Consider an arbitrary type <code>'a</code> for which you have built a type-immediacy witness using this interface. Let's call it <code>w : 'a t</code>.</p><p>You can use the two following functions and <code>w</code> to cast back and forth values from the type <code>'a</code> to the type <code>int</code>:</p><pre><code class="ml">val int_as_value : 'a t -&gt; int -&gt; 'a option
val value_as_int : 'a t -&gt; 'a  -&gt; int option</code></pre><p>For the rest of this section, we will assume <code>int_as_value</code> and <code>value_as_int</code> partially applied to <code>w</code>.</p><p>Consider the following cases:</p><ul><li><p>let <code>v</code> be an immediate value.</p><p>Let <code>i</code> be the <code>int</code> that internally represents <code>v</code>. Then, <code>value_as_int v</code> returns <code>Some i</code>.</p><p>We can also recover <code>v</code> by using the conversions that go the other way. In particular, <code>int_as_value i</code> returns <code>Some v</code>.</p></li></ul><ul><li><p>let <code>v</code> be a boxed value that cannot be converted to an <code>int</code>.</p><p><code>value_as_int v</code> returns <code>None</code> because there does not exist an int s.t. <code>int_as_value
    i</code> evaluates to <code>Some v</code>.</p></li></ul><ul><li><p>let <code>i</code> be an int that does not represent any value of type <code>'a</code></p><p><code>int_as_value i</code> returns <code>None</code>.</p></li></ul><h3 id="faster-*_exn-functions-and-functions-with-boolean-results"><a href="#faster-*_exn-functions-and-functions-with-boolean-results" class="anchor"></a>Faster *_exn functions and functions with boolean results</h3><p><code>value_is_int v</code> is a faster equivalent to <code>Option.is_some   (value_as_int v)</code>. <code>value_as_int_exn v</code> is a faster equivalent to <code>Option.value_exn (value_as_int v)</code>.</p><p><code>int_is_value i</code> is a faster equivalent to <code>Option.is_some   (int_as_value i)</code>. <code>int_as_value_exn i</code> is a faster equivalent to <code>Option.value_exn (int_as_value i)</code>.</p><p>These are lightweight functions that avoid allocating the option. <code>value_is_int</code> (resp <code>int_is_value</code>) can be used with <code>value_as_int_exn</code> (resp <code>int_as_value_exn</code>) to avoid both allocation or using a <code>try with</code> statement, paying only some small amount of CPU time for calling <code>value_is_int</code> (resp <code>int_is_value</code>):</p><pre><code class="ml">match value_as_int v with
| Some v -&gt; some v
| None -&gt; none</code></pre><p>VS</p><pre><code class="ml">if value_is_int v
then some (value_as_int_exn v)
else none</code></pre><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>Consider the following type:</p><pre><code class="ml">type test =
  | A
  | B
  | C of int
with typerep</code></pre><p>Type <code>test</code> is sometimes immediate, as <code>A</code> is represented as <code>0</code>, <code>B</code> as <code>1</code>, and <code>C</code> is a boxed value. We can construct a witness of type <code>test Sometimes.t</code> by using <code>Sometimes.of_typerep</code> or <code>of_typerep</code> and extracting the witness. Let's call the witness <code>w</code> here. We can now use it to safely convert between values of <code>test</code> and <code>int</code>:</p><p><code>Sometimes.value_as_int w A</code> evaluates to <code>Some 0</code> <code>Sometimes.value_as_int w B</code> evaluates to <code>Some 1</code> <code>Sometimes.value_as_int w (C 1)</code> evaluates to <code>None</code></p><p><code>Sometimes.int_as_value w 0</code> evaluates to <code>Some A</code> <code>Sometimes.int_as_value w 1</code> evaluates to <code>Some B</code> <code>Sometimes.int_as_value w n</code> evaluates to <code>None</code> for all other values n</p><p>Consider this other example:</p><pre><code class="ml">type test = bool with typerep</code></pre><p>Type <code>test</code> is always immediate, since <code>true</code> is represented as <code>1</code> and <code>false</code> as <code>0</code>. We can construct a witness of type <code>test Always.t</code> by using <code>Always.of_typerep</code> or <code>of_typerep</code> and extracting the witness. Let's call the witness <code>w</code>:</p><p><code>Always.value_as_int w false</code> evaluates to <code>Some 0</code> <code>Always.value_as_int w true</code> evaluates to <code>Some 1</code></p><p><code>Always.value_as_int_exn w false</code> evaluates to <code>0</code> <code>Always.value_as_int_exn w true</code> evaluates to <code>1</code></p><p><code>Always.int_as_value w 0</code> evaluates to <code>Some false</code> <code>Always.int_as_value w 1</code> evaluates to <code>Some true</code> <code>Always.int_as_value w (-1)</code> evaluates to <code>None</code></p><p><code>Always.int_as_value_exn w 0</code> evaluates to <code>false</code> <code>Always.int_as_value_exn w 1</code> evaluates to <code>true</code> <code>Always.int_as_value_exn w (-1)</code> raises</p><h3 id="n-ary-types-that-are-immediate-independently-of-their-type-arguments"><a href="#n-ary-types-that-are-immediate-independently-of-their-type-arguments" class="anchor"></a>N-ary types that are immediate independently of their type arguments</h3><p>We also provide <code>For_all_parameters_S*</code> functors. Those are useful when one has a type with type parameters, but knows that values of that type will always be immediate (for example) no matter what the actual parameter is. They can use <code>Always.For_all_parameters_S*</code> to obtain access to a polymorphic witness.</p><p>An exception is raised on functor application if such witness cannot be obtained. That happens either because the witness depends on the actual type parameter, or because the type has a different witness (e.g. <code>Sometimes</code> instead of <code>Always</code>).</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><div class="spec module" id="module-Always"><a href="#module-Always" class="anchor"></a><code><span class="keyword">module</span> <a href="Always/index.html">Always</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Sometimes"><a href="#module-Sometimes" class="anchor"></a><code><span class="keyword">module</span> <a href="Sometimes/index.html">Sometimes</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Never"><a href="#module-Never" class="anchor"></a><code><span class="keyword">module</span> <a href="Never/index.html">Never</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-of_typerep"><a href="#val-of_typerep" class="anchor"></a><code><span class="keyword">val</span> of_typerep : <span><span class="type-var">'a</span> <a href="../../../typerep/Typerep_lib__Std_internal/Typerep/index.html#type-t">Core_kernel__.Import.Typerep.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt></dl><dl><dt class="spec type" id="type-dest"><a href="#type-dest" class="anchor"></a><code><span class="keyword">type</span> <span>'a dest</span></code><code> = </code><table class="variant"><tr id="type-dest.Always" class="anchored"><td class="def constructor"><a href="#type-dest.Always" class="anchor"></a><code>| </code><code><span class="constructor">Always</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Always/index.html#type-t">Always.t</a></span></code></td></tr><tr id="type-dest.Sometimes" class="anchored"><td class="def constructor"><a href="#type-dest.Sometimes" class="anchor"></a><code>| </code><code><span class="constructor">Sometimes</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Sometimes/index.html#type-t">Sometimes.t</a></span></code></td></tr><tr id="type-dest.Never" class="anchored"><td class="def constructor"><a href="#type-dest.Never" class="anchor"></a><code>| </code><code><span class="constructor">Never</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="Never/index.html#type-t">Never.t</a></span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-dest"><a href="#val-dest" class="anchor"></a><code><span class="keyword">val</span> dest : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-dest">dest</a></span></code></dt><dt class="spec value" id="val-int_as_value"><a href="#val-int_as_value" class="anchor"></a><code><span class="keyword">val</span> int_as_value : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../Core_kernel__/Import/index.html#type-option">Core_kernel__.Import.option</a></span></code></dt><dt class="spec value" id="val-int_as_value_exn"><a href="#val-int_as_value_exn" class="anchor"></a><code><span class="keyword">val</span> int_as_value_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-int_is_value"><a href="#val-int_is_value" class="anchor"></a><code><span class="keyword">val</span> int_is_value : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-bool">Core_kernel__.Import.bool</a></code></dt><dt class="spec value" id="val-value_as_int"><a href="#val-value_as_int" class="anchor"></a><code><span class="keyword">val</span> value_as_int : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a> <a href="../../Core_kernel__/Import/index.html#type-option">Core_kernel__.Import.option</a></span></code></dt><dt class="spec value" id="val-value_as_int_exn"><a href="#val-value_as_int_exn" class="anchor"></a><code><span class="keyword">val</span> value_as_int_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-int">Core_kernel__.Import.int</a></code></dt><dt class="spec value" id="val-value_is_int"><a href="#val-value_is_int" class="anchor"></a><code><span class="keyword">val</span> value_is_int : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Core_kernel__/Import/index.html#type-bool">Core_kernel__.Import.bool</a></code></dt></dl></div></body></html>