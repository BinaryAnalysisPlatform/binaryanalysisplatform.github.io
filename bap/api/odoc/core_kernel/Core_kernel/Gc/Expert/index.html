<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Expert (core_kernel.Core_kernel.Gc.Expert)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">core_kernel</a> &#x00BB; <a href="../../index.html">Core_kernel</a> &#x00BB; <a href="../index.html">Gc</a> &#x00BB; Expert</nav><h1>Module <code>Gc.Expert</code></h1><p>The <code>Expert</code> module contains functions that novice users should not use, due to their complexity.</p><p>In particular, finalizers are difficult to use correctly, because they can run at any time, even in the middle of other code, and because unhandled exceptions in a finalizer can be raised at any point in other code. This introduces all the semantic complexities of multithreading, which is usually a bad idea. It is much easier to use async finalizers, see <span class="xref-unresolved" title="unresolved reference to &quot;Async_kernel.Async_gc.add_finalizer&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Async_kernel.Async_gc&quot;"><code>Async_kernel</code>.Async_gc</span>.add_finalizer</span>, which do not involve multithreading, and runs user code as ordinary async jobs.</p><p>If you do use <code>Core</code> finalizers, you should strive to make the finalization function perform a simple idempotent action, like setting a ref. The same rules as for signal handlers apply to finalizers.</p></header><dl><dt class="spec value" id="val-add_finalizer"><a href="#val-add_finalizer" class="anchor"></a><code><span class="keyword">val</span> add_finalizer : <span><span class="type-var">'a</span> <a href="../../../../base/Base/Heap_block/index.html#type-t">Core_kernel__.Import.Heap_block.t</a></span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="../../../../base/Base/Heap_block/index.html#type-t">Core_kernel__.Import.Heap_block.t</a></span> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>)</span> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p><code>add_finalizer b f</code> ensures that <code>f</code> runs after <code>b</code> becomes unreachable. The OCaml runtime only supports finalizers on heap blocks, hence <code>add_finalizer</code> requires <code>b :
      _ Heap_block.t</code>. The runtime essentially maintains a set of finalizer pairs:</p><pre>        'a Heap_block.t * ('a Heap_block.t -&gt; unit)</pre><p>Each call to <code>add_finalizer</code> adds a new pair to the set. It is allowed for many pairs to have the same heap block, the same function, or both. Each pair is a distinct element of the set.</p><p>After a garbage collection determines that a heap block <code>b</code> is unreachable, it removes from the set of finalizers all finalizer pairs <code>(b, f)</code> whose block is <code>b</code>, and then and runs <code>f b</code> for all such pairs. Thus, a finalizer registered with <code>add_finalizer</code> will run at most once.</p><p>The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to <code>add_finalizer</code>. If <code>add_finalizer</code> is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</p><p>In a finalizer pair <code>(b, f)</code>, it is a mistake for the closure of <code>f</code> to reference (directly or indirectly) <code>b</code> -- <code>f</code> should only access <code>b</code> via its argument. Referring to <code>b</code> in any other way will cause <code>b</code> to be kept alive forever, since <code>f</code> itself is a root of garbage collection, and can itself only be collected after the pair <code>(b, f)</code> is removed from the set of finalizers.</p><p>The <code>f</code> function can use all features of OCaml, including assignments that make the value reachable again. It can also loop forever (in this case, the other finalisation functions will be called during the execution of f). It can call <code>add_finalizer</code> on <code>v</code> or other values to register other functions or even itself.</p><p>All finalizers are called with <code>Exn.handle_uncaught_and_exit</code>, to prevent the finalizer from raising, because raising from a finalizer could raise to any allocation or GC point in any thread, which would be impossible to reason about.</p><p><code>add_finalizer_exn b f</code> is like <code>add_finalizer</code>, but will raise if <code>b</code> is not a heap block.</p></dd></dl><dl><dt class="spec value" id="val-add_finalizer_exn"><a href="#val-add_finalizer_exn" class="anchor"></a><code><span class="keyword">val</span> add_finalizer_exn : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>)</span> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dt class="spec value" id="val-add_finalizer_last"><a href="#val-add_finalizer_last" class="anchor"></a><code><span class="keyword">val</span> add_finalizer_last : <span><span class="type-var">'a</span> <a href="../../../../base/Base/Heap_block/index.html#type-t">Core_kernel__.Import.Heap_block.t</a></span> <span>&#45;&gt;</span> <span>(<a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>)</span> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>Same as <a href="index.html#val-add_finalizer"><code>add_finalizer</code></a> except that the function is not called until the value has become unreachable for the last time. This means that the finalization function does not recieve the value as an argument. Every weak pointer and ephemeron that contained this value as key or data is unset before running the finalization function.</p></dd></dl><dl><dt class="spec value" id="val-add_finalizer_last_exn"><a href="#val-add_finalizer_last_exn" class="anchor"></a><code><span class="keyword">val</span> add_finalizer_last_exn : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a>)</span> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dt class="spec value" id="val-finalize_release"><a href="#val-finalize_release" class="anchor"></a><code><span class="keyword">val</span> finalize_release : <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a> <span>&#45;&gt;</span> <a href="../../../Core_kernel__/Import/index.html#type-unit">Core_kernel__.Import.unit</a></code></dt><dd><p>The runtime essentially maintains a bool ref:</p><pre><code class="ml">val finalizer_is_running : bool ref</code></pre><p>The runtime uses this bool ref to ensure that only one finalizer is running at a time, by setting it to <code>true</code> when a finalizer starts and setting it to <code>false</code> when a finalizer finishes. The runtime will not start running a finalizer if <code>!finalizer_is_running = true</code>. Calling <code>finalize_release</code> essentially does <code>finalizer_is_running := false</code>, which allows another finalizer to start whether or not the current finalizer finishes.</p></dd></dl><dl><dt class="spec module" id="module-Alarm"><a href="#module-Alarm" class="anchor"></a><code><span class="keyword">module</span> <a href="Alarm/index.html">Alarm</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A GC alarm calls a user function at the end of each major GC cycle.</p></dd></dl></div></body></html>