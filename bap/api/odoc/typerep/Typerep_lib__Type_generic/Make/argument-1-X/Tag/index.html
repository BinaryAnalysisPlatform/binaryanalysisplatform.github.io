<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tag (typerep.Typerep_lib__Type_generic.Make.1-X.Tag)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../../index.html">typerep</a> &#x00BB; <a href="../../../index.html">Typerep_lib__Type_generic</a> &#x00BB; <a href="../../index.html">Make</a> &#x00BB; <a href="../index.html">1-X</a> &#x00BB; Tag</nav><h1>Module <code>1-X.Tag</code></h1><p>Witness of a tag, that is an item in a variant type, also called an &quot;applied variant Constructor&quot;</p><p>The first parameter is the variant type, the second is the type of the tag parameters. Example:</p><pre><code class="ml">type t =
  | A of (int * string)
  | B of string
  | C of { x : int; y : string }</code></pre><p>this type has two constructors. for each of them we'll have a corresponding <code>Tag.t</code></p><pre><code class="ml">val tag_A : (t, (int * string)) Tag.t
val tag_B : (t, string        ) Tag.t
val tag_C : (t, (int * string)) Tag.t</code></pre><p>Inline record in variant are typed as if their definition was using tuples, without the parenthesis. This is consistent with their runtime representation. But the distinction is carried and available for introspection as part of the <code>Tag.t</code>. See <code>args_labels</code>.</p></header><dl><dt class="spec type" id="type-create"><a href="#type-create" class="anchor"></a><code><span class="keyword">type</span> <span>('variant, 'args) create</span></code><code> = </code><table class="variant"><tr id="type-create.Args" class="anchored"><td class="def constructor"><a href="#type-create.Args" class="anchor"></a><code>| </code><code><span class="constructor">Args</span> <span class="keyword">of</span> <span class="type-var">'args</span> <span>&#45;&gt;</span> <span class="type-var">'variant</span></code></td></tr><tr id="type-create.Const" class="anchored"><td class="def constructor"><a href="#type-create.Const" class="anchor"></a><code>| </code><code><span class="constructor">Const</span> <span class="keyword">of</span> <span class="type-var">'variant</span></code></td></tr></table></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('variant, 'args) t</span></code></dt></dl><dl><dt class="spec value" id="val-label"><a href="#val-label" class="anchor"></a><code><span class="keyword">val</span> label : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p>The name of the constructor as it is given in the concrete syntax Examples:</p><pre>         Constructor        | label
         -------------------------
         | A of int         |  &quot;A&quot;
         | `a of int        |  &quot;a&quot;
         | `A of int        |  &quot;A&quot;
         | A of { x : int } |  &quot;A&quot;</pre><p>for standard variant, the ocaml syntax implies that this label will always starts with a capital letter. For polymorphic variants, this might be a lowercase char. For polymorphic variant, this label does not include the <code>`</code> character.</p></dd></dl><dl><dt class="spec value" id="val-arity"><a href="#val-arity" class="anchor"></a><code><span class="keyword">val</span> arity : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>The size of the ocaml heap block containing the arguments</p><p>Examples:</p><pre>          0: | A | 'A
          1: | A of int | `A of int | A of (int * int) | `A of (int * int)
             | `A of int * int
             | A of { x : int}
          2: | A of int * float
             | A of { x : int; y : string }
          etc.</pre></dd></dl><dl><dt class="spec value" id="val-args_labels"><a href="#val-args_labels" class="anchor"></a><code><span class="keyword">val</span> args_labels : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p>The label of the fields for inline records. For other forms of tags, this is the empty list. When this returns a non empty list, the length of the returned list is equal to the arity.</p><p>Example:</p><pre>         (1) Empty:

           | A | 'A
           | A of int | `A of int | A of (int * int) | `A of (int * int)
           | `A of int * int
           | A of int * float

         (2) Non empty:

           | A of { x : int }               -&gt; [ &quot;x&quot; ]
           | A of { x : int; y : string }   -&gt; [ &quot;x&quot; ; &quot;y&quot; ]</pre></dd></dl><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val</span> index : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>The index of the constructor in the list of all the variant type's constructors Examples:</p><pre><code class="ml">type t =
  | A of int          (* 0 *)
  | B                 (* 1 *)
  | C of int          (* 2 *)
  | D of char         (* 3 *)
  | E of { x : int }  (* 4 *)</code></pre></dd></dl><dl><dt class="spec value" id="val-ocaml_repr"><a href="#val-ocaml_repr" class="anchor"></a><code><span class="keyword">val</span> ocaml_repr : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>ocaml_repr is related to the runtime of objects. this is essentially a way of giving one the ability to rebuild dynamically an <code>Obj.t</code> representing a tag.</p><p>Polymorphic variants: ---------------------</p><p><code>ocaml_repr</code> is the hash of the label, as done by the compiler. Example: print_int (Obj.magic `bar) (* 4895187 *) print_int (Obj.magic 'foo) (* 5097222 *)</p><p>Standards variants: -------------------</p><p><code>ocaml_repr</code> is the tag corresponding to the constructor within the type. the way it works in the ocaml runtime is by partitioning the constructors regarding if they have some arguments or not, preserving the order, then assign increasing index withing each partition. Example:</p><pre><code class="ml">type t =                  (* no arg *)  (* args *)
  | A                       (* 0 *)
  | B of int                              (* 0 *)
  | C                       (* 1 *)
  | D of (float * string)                 (* 1 *)
  | E                       (* 2 *)
  | F                       (* 3 *)
  | G of string                           (* 2 *)
  | H of { x : int }                      (* 3 *)</code></pre></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span><span>(<span class="type-var">'variant</span>, <span class="type-var">'args</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'variant</span>, <span class="type-var">'args</span>)</span> <a href="index.html#type-create">create</a></span></code></dt><dd><p>Give back a way of constructing a value of that constructor from its arguments.</p><p>Examples:</p><pre><code class="ml">type t =
  | A of (int * string)
  | B of int * float
  | C
  | D of { x : int; y : string }</code></pre><p><code>create</code> will return something equivalent to: tag_A : <code>Args (fun (d : (int * string) -&gt; A d)</code> tag_B : <code>Args (fun (i, f) -&gt; B (i, f))</code> tag_C : <code>Const C</code> tag_D : <code>Args (fun (x, y) -&gt; D { x; y })</code></p></dd></dl><dl><dt class="spec value" id="val-tyid"><a href="#val-tyid" class="anchor"></a><code><span class="keyword">val</span> tyid : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'args</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'args</span> <a href="../../../../Typerep_lib/Typename/index.html#type-t">Typerep_lib.Typename.t</a></span></code></dt><dd><p>return the type_name of the arguments. might be used to perform some lookup based on it while building a computation for example</p></dd></dl><dl><dt class="spec value" id="val-traverse"><a href="#val-traverse" class="anchor"></a><code><span class="keyword">val</span> traverse : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'args</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'args</span> <a href="../index.html#type-t">t</a></span></code></dt><dd><p>get the representation/computation of the arguments</p></dd></dl><dl><dt class="spec value" id="val-internal_use_only"><a href="#val-internal_use_only" class="anchor"></a><code><span class="keyword">val</span> internal_use_only : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Tag_internal/index.html#type-t">Tag_internal.t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt></dl></div></body></html>