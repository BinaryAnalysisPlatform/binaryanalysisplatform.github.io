<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bap_core_theory (bap-core-theory.Bap_core_theory)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bap-core-theory</a> &#x00BB; Bap_core_theory</nav><h1>Module <code>Bap_core_theory</code></h1><p>BAP Semantics Representation.</p><h2 id="a-gentle-introduction-to-the-core-theory"><a href="#a-gentle-introduction-to-the-core-theory" class="anchor"></a>A Gentle Introduction to the Core Theory</h2><p>The Core Theory is an intermediate language that is designed to express the semantics of computer programs. It focuses on programs that are represented in binary machine code and is capable of an accurate representation of the architectural and micro-architectural details of the program behavior.</p><p>The language is extensible. It is possible to add new language features, without affecting existing analyses and even without recompilation. Adding new analyses also doesn't require any changes to the existing code, which also could be reused without recompilation. Thus the language doesn't suffer from the expression problem.</p><p>The language is rigidly typed with types expressed as OCaml types. A type of a Core Theory term is inferred (and checked) by the OCaml type system, which can statically ascertain that the term is not ill-formed and no analysis will get stuck.</p><p>The language is adaptable. Analysts can select a designated subset of the language which is relevant to their tasks without getting bogged down by the irrelevant architectural details.</p><p>The language can express the semantics of the floating point operations including operations, but not limiting to, specified in the IEEE754 standard.</p><p>The language facilitates developing custom intermediate representation and languages, which could be seamlessly introduced in the analysis pipeline without breaking existing components. The new language is compatible with BIL, BIR, and older variants of BIL. It is potentially compatible with any other intermediate representations.</p><h3 id="the-language-hierarchy"><a href="#the-language-hierarchy" class="anchor"></a>The Language Hierarchy</h3><p>The Core Theory is not really a language but a family of languages. If we will order the languages in this family by subsumption, then we will get the following Hasse diagram:</p><pre>                             o Core
                             |
              Trans o--------+--------o Float
                             |        |
                             o Basic  o FBasic
                             |
                             o Minimal
                             |
            +-------+--------+--------+-------+
            |       |        |        |       |
            o       o        o        o       o
          Init    Bool     Bitv    Memory   Effect</pre><p>The Core language subsumes all other sub-languages and includes modular arithmetic and other operations on bitvectos, operations with memories, registers, floating points including transcendental functions.</p><p>The reason to have so many languages is purely pragmatic: to enable specialized implementations of analyses and lifters. This structure is not really mandated, the languages are defined structurally, not nominally, so it is possible to combine languages in arbitrary ways, as well as define new languages.</p><p>The Core language, despite being at the top of our hierarchy, is still very low-level and basic. It is intended to reflect operations carried by classical computers with Harvard or Princeton architectures. Therefore we chose the name &quot;Core&quot; to reflect our vision of the Core language as the base for higher-level hierarchies of languages.</p><h3 id="hierarchy-of-terms"><a href="#hierarchy-of-terms" class="anchor"></a>Hierarchy of Terms</h3><p>Terms and operations of the Core Theory languages are typed to prevent the creation of ill-formed programs. We use the word sort to denote a set of terms that share the same properties. The Core Theory comes with a collection of predefined sorts, which are used to specify the Core language, but it is possible to define new sorts, to keep the theory extensible.</p><p>The terms of the Core Theory are divided in two classes - values and effects. A value term denotes the semantics of programs that produce values. Roughly, values correspond to the syntactic class of language expressions.</p><p>Effects is a class of terms that do not produce values, but side effects or just effects, e.g., changing a value of a register, loading or storing memory location, performing I/O operation on a port or issuing a synchronization barrier, etc. Roughly, effects correspond to the syntactic class of language statements.</p><p>Both values and effects are knowledge classes. Each class is further subdivided into an infinite set of sorts. The class of values is inhabited with terms of Bool, Bitv, Mem, Float, and Rmode. Some sorts are indexed, so they represent an (infinite) family of sorts. For example, Bitv<code>s</code> is a family of bitvector sorts indexed by their widths, e.g, Bitv<code>8</code>, Bitv<code>32</code>, etc.</p><p>The class of effects is subdivided into two sorts of effect, those that affect the control flow and those that affect the data flow.</p><pre>                              Term
                                o
                                |
                         +------+------+
                         |             |
                   Value o             o Effect
                         |             |
                 Bool o--+         +---+---+
                         |         |       |
              Bitv[s] o--+         o       o
                         |      Ctrl[i]  Data[i]
             Mem[k,s] o--+
                         |
           Float[f,s] o--+
                         |
                Rmode o--+</pre><h3 id="vars"><a href="#vars" class="anchor"></a>Variables</h3><p>Variables are ubiquitous in programming languages and could be used to reference memory locations, CPU registers, or just be bound to expressions. Sometimes variables are typed, sometimes they are just identifiers with not associated type.</p><p>In the Core Theory all variables are sorted, i.e., the have an associated value sort. Variables are also having scope and extent. Finally, variables could be mutable or immutable.</p><p>A physical variable is a global mutable variable with infinite scope and extent. They are used to refer predefined (micro) architectural locations of a modeled system, e.g., registers, memory banks, caches, register files, etc. Global variables has identifiers that are the same as names, e.g., `RAX`, `R0`, `mem`, etc. The important thing, is that a global variable usually has some physical representation.</p><p>Virtual variables are dual to physical variables and are further subdivided into mutable and immutable.</p><p>A mutable virtual variable represents an unspecified scratch location that holds data of the specified sort. They could be used to abstract an actual physical location in a modeled system (when it is not relevant or just not known) or just to simplify the analysis. The mutable virtual variables have identifier of the form <code>#&lt;number&gt;</code>, e.g, <code>#1</code>, <code>#2048</code>, etc.</p><p>Finally, an immutable virtual variable is a local variable that holds a value of an expression. It has a limited scope and its immutability is ensured by the type system since the scope of a local binding can contain only pure terms, i.e., no side-effects. These variables have identifiers of the form <code>$&lt;number&gt;</code>, e.g., <code>$1</code>, <code>$2</code>, etc, and since their scope is limited, those identifiers are reused in different scopes.</p><h3 id="theories-and-semantics"><a href="#theories-and-semantics" class="anchor"></a>Theories and Semantics</h3><p>Languages of the Core Theory, including the Core itself are represented as module signatures, i.e., they are pure abstractions or interfaces that do not define any data types, functions, or values.</p><p>This approach is called tagless-final style <code>1</code>, pioneered by Carette and Kiselyov and later rediscovered under the name &quot;Object algebras&quot; by Oliviera and Cook <code>2</code>. We encourage to read those papers and accompanying literature, but it is not strictly needed, especially since the underlying idea is pretty simple.</p><p>In the final style, an embedded language is not represented by an abstract syntax tree or some intermediate representation data structure, but by denotations in a semantic algebra. Where the semantic algebra is an implementation (structure) of the language signature. Or, in other words, it is its denotational semantics.</p><p>The structure may choose, basically, any denotations, as long as it fits the signature. For example, the language could be denoted with its textual representation, BIL code, LLVM IR, BIR, sets of reachable addresses, and so on. In other words, an implementation of the Core signature could be seen as an analysis that computes the property of a term.</p><p>Unlike a classical final approach described in <code>1</code> the Core Theory signatures do not include any abstract types, all types mentioned in the theories are defined on the scope of the Core Theory. This constraint basically turns a structure, which implements the Theory, into a simple array of functions, a first class value with no caveats (like types escaping the scope, etc).</p><p>To enable each semantic algebra to have its own denotation we employ <code>'a Knowledge.Value.t</code>. Thus both Core Theory values and effects are instances of the Knowledge Value, parametrized by corresponding class indices. The Knowledge Value is an instance of Domain, that makes it ideal for representing the denotational semantics of programs. The Knowledge value is an extensible record, where each field corresponds to a particular denotation, it is possible to store several denotations in one Knowledge value.</p><p>Denotational semantics is composable, i.e., a denotation of a term is composed from denotations of its constituent terms. However, some denotations are context dependent. To enable this, we made a term denotation an instance of <code>'a knowledge</code>, i.e., a knowledge dependent computation.</p><p>To summarize, a denotation is a structure that implements methods of the corresponding structure. Each method corresponds to a language form, e.g, <code>val add  : 'a bitv -&gt; 'a bitv -&gt; 'a bitv</code>, corresponds to an addition of two bitvectors. The implementation, builds the denotation of the term from the denotations of its inputs, e.g.,</p><pre><code class="ml">let add x y =
  x &gt;&gt;-&gt; fun x -&gt;
  y &gt;&gt;-&gt; fun y -&gt;
  match x, y with
  | Some x, Some y -&gt; const (Bitvec.(x + y))
  | _ -&gt; nonconst</code></pre><p>Where <code>&gt;&gt;-&gt;</code> extracts the module specific denotation and <code>const</code>, <code>noncost</code> put them back (assuming that the denotation is the classical constant folding lattice).</p><p>The final style makes it easy to write a fold-style analysis, such as constant folding, taint analysis, etc. Since all terms are knowledge dependent computations, i.e., wrapped into the knowledge monad, which turns any computation into a fixed-point computation, it is also possible to write data-flow analysis and other forms of abstract interpretation. In fact, it was shown, that any optimization or analysis could be written in the final style in a modular and composable way <code>3</code>. However, the classical approach, that uses tagged AST and pattern matching is not denied at all.</p><p>Since the denotation could be anything (that is an instance of domain), it is quite natural to use BIL, and BIR, or any other concrete syntax tree as a possible denotation. Therefore, it is possible to extract those denotations and write your analysis using the save haven of pattern matching.</p><h3 id="writing-a-new-denotation"><a href="#writing-a-new-denotation" class="anchor"></a>Writing a new denotation</h3><p>Any denotation must be an instance of the Core signature. However, it is not always required to implement all methods, as they could be inherited from other instance or filled in with the Empty Theory. Once analysis is written it should be declared, so that it could be later run, e.g., let's extend a hypothetical <code>&quot;constant-tracker&quot;</code> analysis:</p><pre><code class="ml">let () =
  Theory.declare &quot;my-constant-tracker&quot;
    Theory.instance ~require:[&quot;bap.std:constant-tracker&quot;] &gt;&gt;=
  Theory.require &gt;&gt;|
  fun (module Base) : Theory.core -&gt; (module struct
    include Base
    let add x y =
      printf &quot;add is called!\n%!&quot;;
      add x y
  end</code></pre><p>The real analysis should store it results either in the knowledge base or directly in denotations of the terms (or in both places).</p><h3 id="instantiating-a-theory"><a href="#instantiating-a-theory" class="anchor"></a>Instantiating a theory</h3><p>To use a theory we need to instantiate it. In the previous section we instantiated a theory using the <code>Theory.require</code> function, that returns a previously declared theory. But what if we need to use several denotations, e.g., when we want to have both a constant-tracker and BIL for our analysis.</p><p>The final style implementations, in Scala, OCaml, and Haskell, usually employ functors or type classes, which both require a user to select an instance of a type class, which should be used in the given context. Some languages allow only one instance of a class per type, others allow multiple, but still needs a declaration of some instances as canonical.</p><p>The Core Theory addresses this issue by leveraging the structure of the Knowledge universal values and instantiating all theory instances simultaneously, so that for each language term the sum of all denotations is provided. To exclude the overhead of evaluating denotations that might be unused, it is possible to limit the set of instantiated theories by specifying a concrete list of required theories. The requirements are specified in the form of semantic tags instead of concrete theory names, to prevent explicit dependencies on implementations. However, it is still possible to explicitly request a particular theory.</p><p>It is also possible to define the context of the theory, to enable those theories that are not generic and are applicable only to the specified context. For example,</p><pre><code class="ml">Theory.instance ()
  ~context:[&quot;arm&quot;; &quot;arm-gnueabi&quot;]
  ~requires:[
    &quot;variable-recovery&quot;;
    &quot;stack-frame-analysis&quot;;
    &quot;structural-analysis&quot;;
    &quot;floating-point&quot;;
    &quot;bap.std:bil-semantics&quot;
  ] &gt;&gt;=
Theory.require &gt;&gt;= fun (module Theory) -&gt;</code></pre><p>In the example above, theories that are specific to ARM architecture, in particular to the arm-gnueabi ABI, will be instantiated (in addition to other general theories). The <code>requires</code> parameter specifies a few semantic tags, describing what kind of semantic information is needed, as well as one theory explicitly, the <code>bap.std:bil-semantics</code>, to ensure that each term has a BIL denotation.</p><p>References:</p><ul><li><code>1</code>: http://okmij.org/ftp/tagless-final/JFP.pdf</li><li><code>2</code>: http://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf</li><li><code>3</code>: http://okmij.org/ftp/tagless-final/course/optimizations.html</li></ul><h3 id="parsing-binary-code"><a href="#parsing-binary-code" class="anchor"></a>Parsing binary code</h3><p>After a theory is instantiated it could be used to build terms, which will trigger analyses associated with each instantiated theory.</p><p>However, a program is usually represented as a binary machine code, which should be parsed into the Core Theory terms. This process is called <i>lifting</i> and program components that do lifting are called <i>lifters</i>.</p><p>Lifting is a notoriously hard task, since the machine code is an untyped representation and Core Theory terms are rigidly typed. To alleviate this problem, the Core Theory library provides a helper module <code>Parser</code> which could be used to lift an untyped representation into the typed Core Theory term.</p><p>It is also possible to reuse lifters which translate the machine code in some IL, but writing a parser form that IL. The <code>Parser</code> module is especially useful here, since it was specifically designed for such use-cases.</p></header><div class="spec module" id="module-KB"><a href="#module-KB" class="anchor"></a><code><span class="keyword">module</span> KB = <a href="../../bap-knowledge/Bap_knowledge/index.html#module-Knowledge">Bap_knowledge.Knowledge</a></code></div><dl><dt class="spec module" id="module-Theory"><a href="#module-Theory" class="anchor"></a><code><span class="keyword">module</span> <a href="Theory/index.html">Theory</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Core Theory.</p></dd></dl></div></body></html>