<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Theory (bap-core-theory.Bap_core_theory.Theory)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">bap-core-theory</a> &#x00BB; <a href="../index.html">Bap_core_theory</a> &#x00BB; Theory</nav><h1>Module <code>Bap_core_theory.Theory</code></h1><p>The Core Theory.</p></header><dl><dt class="spec type" id="type-cls"><a href="#type-cls" class="anchor"></a><code><span class="keyword">type</span> cls</code></dt><dd><p>The class index for all Core Theories.</p></dd></dl><dl><dt class="spec type" id="type-theory"><a href="#type-theory" class="anchor"></a><code><span class="keyword">type</span> theory</code><code> = <span><a href="index.html#type-cls">cls</a> <a href="../../../bap-knowledge/Bap_knowledge/Knowledge/index.html#type-obj">KB.obj</a></span></code></dt><dd><p>A theory instance. To create a new theory instance use the <a href="index.html#val-instance"><code>instance</code></a> function. To manifest a theory into an OCaml module, use the <a href="index.html#val-require"><code>require</code></a> function.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="index.html#type-theory">theory</a></code></dt><dd><p>Theory.t is theory.</p></dd></dl><dl><dt class="spec module" id="module-Value"><a href="#module-Value" class="anchor"></a><code><span class="keyword">module</span> <a href="Value/index.html">Value</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The denotation of expression.</p></dd></dl><dl><dt class="spec module" id="module-Effect"><a href="#module-Effect" class="anchor"></a><code><span class="keyword">module</span> <a href="Effect/index.html">Effect</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The denotation of statements.</p></dd></dl><dl><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type</span> <span>'a value</span></code><code> = <span><span class="type-var">'a</span> <a href="Value/index.html#type-t">Value.t</a></span></code></dt><dt class="spec type" id="type-effect"><a href="#type-effect" class="anchor"></a><code><span class="keyword">type</span> <span>'a effect</span></code><code> = <span><span class="type-var">'a</span> <a href="Effect/index.html#type-t">Effect.t</a></span></code></dt></dl><dl><dt class="spec module" id="module-Bool"><a href="#module-Bool" class="anchor"></a><code><span class="keyword">module</span> <a href="Bool/index.html">Bool</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The sort for boolean values.</p></dd></dl><dl><dt class="spec module" id="module-Bitv"><a href="#module-Bitv" class="anchor"></a><code><span class="keyword">module</span> <a href="Bitv/index.html">Bitv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sorts of bitvectors</p></dd></dl><dl><dt class="spec module" id="module-Mem"><a href="#module-Mem" class="anchor"></a><code><span class="keyword">module</span> <a href="Mem/index.html">Mem</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sorts of memories.</p></dd></dl><dl><dt class="spec module" id="module-Float"><a href="#module-Float" class="anchor"></a><code><span class="keyword">module</span> <a href="Float/index.html">Float</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sorts for floating point numbers.</p></dd></dl><dl><dt class="spec module" id="module-Rmode"><a href="#module-Rmode" class="anchor"></a><code><span class="keyword">module</span> <a href="Rmode/index.html">Rmode</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Rounding modes.</p></dd></dl><dl><dt class="spec type" id="type-pure"><a href="#type-pure" class="anchor"></a><code><span class="keyword">type</span> <span>'a pure</span></code><code> = <span><span><span class="type-var">'a</span> <a href="index.html#type-value">value</a></span> <a href="../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dt class="spec type" id="type-eff"><a href="#type-eff" class="anchor"></a><code><span class="keyword">type</span> <span>'a eff</span></code><code> = <span><span><span class="type-var">'a</span> <a href="index.html#type-effect">effect</a></span> <a href="../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dt class="spec type" id="type-format"><a href="#type-format" class="anchor"></a><code><span class="keyword">type</span> <span>('r, 's) format</span></code><code> = <span><span>(<span class="type-var">'r</span>, <span class="type-var">'s</span>)</span> <a href="Float/index.html#type-format">Float.format</a></span></code></dt></dl><dl><dt class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module</span> <a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Variables.</p></dd></dl><dl><dt class="spec type" id="type-data"><a href="#type-data" class="anchor"></a><code><span class="keyword">type</span> data</code><code> = <a href="Effect/Sort/index.html#type-data">Effect.Sort.data</a></code></dt><dt class="spec type" id="type-ctrl"><a href="#type-ctrl" class="anchor"></a><code><span class="keyword">type</span> ctrl</code><code> = <a href="Effect/Sort/index.html#type-ctrl">Effect.Sort.ctrl</a></code></dt><dt class="spec type" id="type-word"><a href="#type-word" class="anchor"></a><code><span class="keyword">type</span> word</code><code> = <a href="../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a></code></dt><dd><p>a concrete representation of words in the Core Theory.</p></dd></dl><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> <span>'a var</span></code><code> = <span><span class="type-var">'a</span> <a href="Var/index.html#type-t">Var.t</a></span></code></dt><dd><p>a concrete representation of variables.</p></dd></dl><dl><dt class="spec type" id="type-program"><a href="#type-program" class="anchor"></a><code><span class="keyword">type</span> program</code></dt><dd><p>a class index for class of programs.</p></dd></dl><dl><dt class="spec type" id="type-label"><a href="#type-label" class="anchor"></a><code><span class="keyword">type</span> label</code><code> = <span><a href="index.html#type-program">program</a> <a href="../../../bap-knowledge/Bap_knowledge/Knowledge/Object/index.html#type-t">KB.Object.t</a></span></code></dt><dd><p>label is an object of the program class.</p></dd></dl><dl><dt class="spec module" id="module-Program"><a href="#module-Program" class="anchor"></a><code><span class="keyword">module</span> <a href="Program/index.html">Program</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The denotation of programs.</p></dd></dl><dl><dt class="spec module" id="module-Label"><a href="#module-Label" class="anchor"></a><code><span class="keyword">module</span> <a href="Label/index.html">Label</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A program label.</p></dd></dl><dl><dt class="spec type" id="type-bool"><a href="#type-bool" class="anchor"></a><code><span class="keyword">type</span> bool</code><code> = <span><a href="Bool/index.html#type-t">Bool.t</a> <a href="index.html#type-pure">pure</a></span></code></dt><dd><p>a boolean terms</p></dd></dl><dl><dt class="spec type" id="type-bitv"><a href="#type-bitv" class="anchor"></a><code><span class="keyword">type</span> <span>'a bitv</span></code><code> = <span><span><span class="type-var">'a</span> <a href="Bitv/index.html#type-t">Bitv.t</a></span> <a href="index.html#type-pure">pure</a></span></code></dt><dd><p>a bitvector term</p></dd></dl><dl><dt class="spec type" id="type-mem"><a href="#type-mem" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) mem</span></code><code> = <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="Mem/index.html#type-t">Mem.t</a></span> <a href="index.html#type-pure">pure</a></span></code></dt><dd><p>a memory term</p></dd></dl><dl><dt class="spec type" id="type-float"><a href="#type-float" class="anchor"></a><code><span class="keyword">type</span> <span>'f float</span></code><code> = <span><span><span class="type-var">'f</span> <a href="Float/index.html#type-t">Float.t</a></span> <a href="index.html#type-pure">pure</a></span></code></dt><dd><p>a floating point term</p></dd></dl><dl><dt class="spec type" id="type-rmode"><a href="#type-rmode" class="anchor"></a><code><span class="keyword">type</span> rmode</code><code> = <span><a href="Rmode/index.html#type-t">Rmode.t</a> <a href="index.html#type-pure">pure</a></span></code></dt><dd><p>a rounding mode term</p></dd></dl><dl><dt class="spec module-type" id="module-type-Init"><a href="#module-type-Init" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Init/index.html">Init</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The initial theory.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Bool"><a href="#module-type-Bool" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Bool/index.html">Bool</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The theory of booleans.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Bitv"><a href="#module-type-Bitv" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Bitv/index.html">Bitv</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The theory of bitvectors.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Memory"><a href="#module-type-Memory" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Memory/index.html">Memory</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The theory of memories.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Effect"><a href="#module-type-Effect" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Effect/index.html">Effect</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The theory of effects.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Minimal"><a href="#module-type-Minimal" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Minimal/index.html">Minimal</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Minimal theory.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Basic"><a href="#module-type-Basic" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Basic/index.html">Basic</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Basic theory of bitvector machines.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Fbasic"><a href="#module-type-Fbasic" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Fbasic/index.html">Fbasic</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Basic Theory of Floating Points.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Float"><a href="#module-type-Float" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Float/index.html">Float</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The theory of floating point numbers modulo transcendental functions.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Trans"><a href="#module-type-Trans" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Trans/index.html">Trans</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Theory of Transcendental Functions.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Core"><a href="#module-type-Core" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Core/index.html">Core</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Core Theory signature.</p></dd></dl><dl><dt class="spec type" id="type-core"><a href="#type-core" class="anchor"></a><code><span class="keyword">type</span> core</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-Core/index.html">Core</a>)</span></code></dt><dd><p>a type abbreviation for the core theory module type.</p></dd></dl><dl><dt class="spec module" id="module-Basic"><a href="#module-Basic" class="anchor"></a><code><span class="keyword">module</span> <a href="Basic/index.html">Basic</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Basic Theory.</p></dd></dl><dl><dt class="spec module" id="module-Empty"><a href="#module-Empty" class="anchor"></a><code><span class="keyword">module</span> <a href="Empty/index.html">Empty</a> : <a href="index.html#module-type-Core">Core</a></code></dt><dd><p>The empty theory.</p></dd></dl><dl><dt class="spec value" id="val-declare"><a href="#val-declare" class="anchor"></a><code><span class="keyword">val</span> declare : <span>?&#8288;desc:string</span> <span>&#45;&gt;</span> <span>?&#8288;extends:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;context:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;provides:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;package:string</span> <span>&#45;&gt;</span> <span>name:string</span> <span>&#45;&gt;</span> <span><span>(<span class="keyword">module</span> <a href="module-type-Core/index.html">Core</a>)</span> <a href="../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>declare name s</code> that structure <code>s</code> as an instance of the Core Theory.</p><p>The qualified with the <code>package</code> <code>name</code> shall be unique, otherwise the declaration fails.</p><p>The <code>extends</code> list shall contain all theories that are included in the structure <code>s</code> (except the <code>Empty</code> theory, which is the base theory of all core theories, so there is no need to add it). Failure to list a theory in the <code>extends</code> list will prevent optimization during theory instantiation and may lead to less efficient theories (when the same denotation is computed twice) or even conflicts, when the extension overrides the extended theory.</p><dl><dt>parameter context</dt><dd><p>defines a context in which a theory is applicable. The declared theory could be only instantiated if the context, provided during the instantiation, contains all features specified in the <code>context</code> argument.</p></dd></dl><dl><dt>parameter provides</dt><dd><p>is a set of semantic tags that describe capabilities provided by the theory. The fully qualified name of the theory is automatically provided.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-instance"><a href="#val-instance" class="anchor"></a><code><span class="keyword">val</span> instance : <span>?&#8288;context:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;requires:<span>string list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><a href="index.html#type-theory">theory</a> <a href="../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dd><p><code>instance ()</code> creates an instance of the Core Theory.</p><p>The instance is built from all theories that match the context specified by the <code>features</code> list and provide features specified by the <code>requires</code> list. If any theory is subsumed by other theory, then it is excluded.</p><p>If no instances satisfy this requirement than the empty theory is returned. If only one theory satisfies the requirement, then it is returned. If many theories match, then a join of all theories is computed, stored in the knowledge base, and the resulting theory is returned.</p><p>To manifest a theory into an structure, use the <code>require</code> function.</p><dl><dt>parameter features</dt><dd><p>is a set of features that define the context, only those theories that have a context that is a subset of provided will be instantiated.</p></dd></dl><dl><dt>parameter requires</dt><dd><p>is a set of semantic features that are required. Defaults to the set of all possible features, i.e., if unspecified, then all instances applicable to the context will be loaded.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-require"><a href="#val-require" class="anchor"></a><code><span class="keyword">val</span> require : <a href="index.html#type-theory">theory</a> <span>&#45;&gt;</span> <span><span>(<span class="keyword">module</span> <a href="module-type-Core/index.html">Core</a>)</span> <a href="../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dd><p><code>require theory</code> manifests the <code>theory</code> as an OCaml structure.</p><p>It is only possible to create an instance of theory using the <a href="index.html#val-instance"><code>instance</code></a> function. For example, the following will create an theory that is a join all currently declared theories (which are not specific to any context),</p><pre><code class="ml">Theory.(instance&gt;=&gt;require) () -&gt; fun (module Core) -&gt;</code></pre><p>To a create an instance for a specific context and requirements,</p><pre><code class="ml">Theory.instance ()
  ~context:[&quot;arm-gnueabi&quot;; &quot;arm&quot;]
  ~require:[&quot;bil&quot;; &quot;stack-frame-analysis&quot;] &gt;&gt;=
Theory.require &gt;&gt;= fun (module Core) -&gt;</code></pre><p>Finally, to manifest a theory with a specific name, specify the name of the theory in the list of requirements.</p><pre><code class="ml">Theory.instance ~requires:[&quot;bap.std:bil&quot;] () &gt;&gt;=
Theory.require &gt;&gt;= fun (module Core) -&gt;</code></pre></dd></dl><dl><dt class="spec module" id="module-IEEE754"><a href="#module-IEEE754" class="anchor"></a><code><span class="keyword">module</span> <a href="IEEE754/index.html">IEEE754</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sorts implementing IEEE754 formats.</p></dd></dl><dl><dt class="spec module" id="module-Parser"><a href="#module-Parser" class="anchor"></a><code><span class="keyword">module</span> <a href="Parser/index.html">Parser</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Generates parsers of untyped ASTs into type Core Theory terms.</p></dd></dl><dl><dt class="spec module" id="module-Documentation"><a href="#module-Documentation" class="anchor"></a><code><span class="keyword">module</span> <a href="Documentation/index.html">Documentation</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Documents all declared theories.</p></dd></dl></div></body></html>