<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sort (bap-core-theory.Bap_core_theory.Theory.Value.Sort)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap-core-theory</a> &#x00BB; <a href="../../../index.html">Bap_core_theory</a> &#x00BB; <a href="../../index.html">Theory</a> &#x00BB; <a href="../index.html">Value</a> &#x00BB; Sort</nav><h1>Module <code>Value.Sort</code></h1><p>Value Sorts.</p><p>A concrete and extensible representation of a value sort. The sort usually holds the static information about the value representation, like the width of a bitvector, the representation format of a floating point number, and so on.</p><p>This module is mostly needed when a new sort is defined. The Core Theory provides a predefined collection of sorts, here is the list:</p><ul><li><a href="../../Bitv/index.html"><code>Bitv</code></a> - bitvectors, e.g., <code>BitVec(i)</code></li><li><a href="../../Mem/index.html"><code>Mem</code></a> - memories, e.g., <code>Mem(BitVec(i), BitVec(j)</code></li><li><a href="../../Float/index.html"><code>Float</code></a> - floating points, e.g., <code>Float(IEEE754(2, 8, 23), BitVec(32)</code>;</li><li><a href="../../Rmode/index.html"><code>Rmode</code></a> - rounding mode, e.g., <code>Rmode</code>.</li></ul><p>This module defines a simple DSL for specifying sorts, the DSL grammar is made only from three rules:</p><pre>           sort = sym | int | sort(sort)</pre><p>The DSL is embedded into the host language with an infix operator <code>@-&gt;</code> for application, e.g., OCaml grammar for sorts is:</p><p><code>v
          sort = sym exp | int exp | sort &quot;@-&gt;&quot; sort
          exp  = ?a valid OCaml expression?
        v</code></p><p>Both symbols and numbers are indexed with a type index, which serves as a witness of the sort value, e.g.,</p><pre><code class="ml">type int8
let int8 : int8 num sort = Sort.int 8</code></pre><p>Type indices enable explicit reflection of the target language type system in the host type system, while still keeping the typing rules under designer's control.</p><p>As a working example, let's develop a sort for binary fixed-point numbers. We need to encode the type of the underlying bitvector as well as the scaling factor. Suppose, we chose to encode the scaling factor by an integer position of the point, e.g., 8 means scaling factor 2^8, i.e., a point fixed on 8th bit from the left.</p><p>The syntax of our sort will be <code>Fixpoint(&lt;num&gt;,BitVec(&lt;num&gt;))</code>, but we will keep it private to enable further extensions. The structure of the sort is explicitly captured in its type, in our case, it will be <code>'p num -&gt; 's Bitv.t -&gt; fixpoint sym</code>, but since we want to keep it is hidden by our type <code>('p,'s) t</code>. The same as with the built-in <code>Bitv</code> and <code>Mem</code> sorts.</p><p>We declare a <code>fixpoint</code> constructor and keep it private, to ensure that only we can construct (and refine) fixpoint sorts. Since the sort type is abstract, we also need to provide functions that access arguments of our sort.</p><p>Finally, we need to provide the <code>refine</code> function, that will cast an untyped sort to its type representation, essentially proving that the sort is a valid fixpoint sort.</p><pre><code class="ml">module Fixpoint : sig
  type ('p, 's) t
  val define : int -&gt; 's Bitv.t sort -&gt; ('p,'s) t sort
  val refine : unit sort -&gt; ('p,'s) t sort option
  val bits : ('p,'s) t sort -&gt; 's Bitv.t sort
  val logscale : ('p,'s) t sort -&gt; int
end = struct
  type fixpoint

  type ('m,'s) t =
    'm Value.Sort.num -&gt;
    's Bitv.t -&gt;
    fixpoint Value.Sort.sym

  let fixpoint = Value.Sort.Name.declare &quot;FixPoint&quot;

  let define p s = Value.Sort.(int p @-&gt; s @-&gt; sym fixpoint)
  let refine s = Value.Sort.refine fixpoint s
  let bits s = Value.Sort.(hd (tl s))
  let logscale s = Value.Sort.(hd s)
end

(* Example of usage: *)


type ('m,'s) fixpoint = Fixpoint.t Value.sort

type u32              (* type index for 32 bit ints *)
type p8               (* type index for points at 8th bit *)

(* a sort of 32-bit bitvectors, usually provided by the CPU model *)
let u32 : u32 Bitv.t Value.sort = Bitv.define 32

(* a sort of 8.32 fixed-point numbers. *)
let fp8_32 : (p8,u32) fixpoint = Fixpoint.define 8 u32</code></pre></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>+'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-sort">sort</a></span></code></dt><dt class="spec type" id="type-sym"><a href="#type-sym" class="anchor"></a><code><span class="keyword">type</span> <span>+'a sym</span></code></dt><dt class="spec type" id="type-num"><a href="#type-num" class="anchor"></a><code><span class="keyword">type</span> <span>+'a num</span></code></dt><dt class="spec type" id="type-name"><a href="#type-name" class="anchor"></a><code><span class="keyword">type</span> name</code></dt></dl><dl><dt class="spec value" id="val-sym"><a href="#val-sym" class="anchor"></a><code><span class="keyword">val</span> sym : <a href="index.html#type-name">name</a> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-sym">sym</a></span> <a href="../index.html#type-sort">sort</a></span></code></dt><dd><p><code>sym name</code> constructs a sort with the given name.</p><p>A symbolic sort could represent an abstract data type with no further information available, e.g., some machine status word of unknown size or representation; it may also be used to denote data with obvious representation, e.g., the <code>Bool</code> sort; finally, a symbolic sort could be used as a constructor name for an indexed sort, e.g., (BitVec(width)).</p><p>See the Example in the module description for more information.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : int <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-num">num</a></span> <a href="../index.html#type-sort">sort</a></span></code></dt><dd><p><code>int x</code> a numeric sort.</p><p>While it is possible to create a standalone numeric sort, it wouldn't be possible to refine it, since only symbolic sorts re refinable.</p><p>Numeric sorts are used mostly as parameters. See the Example section of the module documentation for more information.</p></dd></dl><dl><dt class="spec value" id="val-app"><a href="#val-app" class="anchor"></a><code><span class="keyword">val</span> app : <span><span class="type-var">'a</span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="../index.html#type-sort">sort</a></span></code></dt><dd><p><code>app s1 s2</code> constructs a sort of sort <code>s1</code> and <code>s2</code>.</p><p>An application could be seen as a tuple building operators, thus this operation defines a sort that is described by two other sorts.</p><p>Basically, the <code>app</code> operator builds a heterogenous list, with elements which should be other sorts. The list could be then traversed using the <code>Sort.hd</code> and <code>Sort.tl</code> operators, and individual elements could be read with the <code>value</code> and <code>name</code> operators. Since the structure of the sort is fully encoded in this type, those operations are total.</p></dd></dl><dl><dt class="spec value" id="val-(@-&gt;)"><a href="#val-(@-&gt;)" class="anchor"></a><code><span class="keyword">val</span> (@-&gt;) : <span><span class="type-var">'a</span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="../index.html#type-sort">sort</a></span></code></dt><dd><p><code>s1 @-&gt; s2</code> is <code>app s1 s2</code></p></dd></dl><dl><dt class="spec value" id="val-value"><a href="#val-value" class="anchor"></a><code><span class="keyword">val</span> value : <span><span><span class="type-var">'a</span> <a href="index.html#type-num">num</a></span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>value s</code> returns the number associated with the numeric sort.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <span><span><span class="type-var">'a</span> <a href="index.html#type-sym">sym</a></span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <a href="index.html#type-name">name</a></code></dt><dd><p><code>name s</code> returns the symbol associated with a symbolic sort</p></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-sort">sort</a></span></code></dt><dd><p><code>hd s</code> the first argument of sort <code>s</code></p></dd></dl><dl><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-sort">sort</a></span></code></dt><dd><p><code>tl</code> the list of arguments of sort <code>s</code> excluding the first one</p></dd></dl><dl><dt class="spec value" id="val-refine"><a href="#val-refine" class="anchor"></a><code><span class="keyword">val</span> refine : <a href="index.html#type-name">name</a> <span>&#45;&gt;</span> <span>unit <a href="../index.html#type-sort">sort</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> option</span></code></dt><dd><p><code>refine witness s</code> restores the type of the sort.</p><p>The sort type is an index type which could be lost, e.g., when the <code>forget</code> function is applied or when the sort is stored and read from its textual representation.</p><p>The <code>refine</code> function will re-instantiate the type index if the constructor name of the sort <code>s</code> is the <code>name</code>.</p><p>This function gives a mandate for the refine function to index the sort <code>s</code> with any type, which will breach the sort type safety, therefore this function should be used with care and be hidden behind the abstraction barrier and have a concrete type.</p><p>See the Example section in the module documentation for the demonstration of how refine should be used.</p></dd></dl><dl><dt class="spec value" id="val-forget"><a href="#val-forget" class="anchor"></a><code><span class="keyword">val</span> forget : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>forget s</code> forgets the type index associated with the sort <code>s</code>.</p><p>This is effectively an upcasting function, that could be used when the typing information is not necessary anymore or is not representable. The type index could be later restored with the <code>refine</code> function.</p></dd></dl><dl><dt class="spec value" id="val-same"><a href="#val-same" class="anchor"></a><code><span class="keyword">val</span> same : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>same x y</code> is true if <code>x</code> and <code>y</code> are of the same structure.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Core_kernel.Caml.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>prints the sort.</p></dd></dl><dl><dt class="spec module" id="module-Top"><a href="#module-Top" class="anchor"></a><code><span class="keyword">module</span> <a href="Top/index.html">Top</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sorts with erased type indices.</p></dd></dl><dl><dt class="spec module" id="module-Name"><a href="#module-Name" class="anchor"></a><code><span class="keyword">module</span> <a href="Name/index.html">Name</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The name registry.</p></dd></dl></div></body></html>