<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Origin (bap-core-theory.Bap_core_theory.Theory.Origin)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap-core-theory</a> &#x00BB; <a href="../../index.html">Bap_core_theory</a> &#x00BB; <a href="../index.html">Theory</a> &#x00BB; Origin</nav><header class="odoc-preamble"><h1>Module <code><span>Theory.Origin</span></code></h1><p>The description of the origin of an aliased register.</p><p>When a register is defined in terms of other registers, <code>Origin.t</code> describes the relationship between an aliased register and its origin register or registers.</p><p>The <code>('s,'k) Origin.t</code> data type is parameterized with two type variables. The <code>'s</code> type variable denotes the width of the origin register(s) and <code>'k</code> denotes the kind of relationship between the alias and its origin.</p><p>Currently, we recognize two kinds of relationships. The <code>sub</code> kind defines the alias as a subset of the origin register, i.e., a contiguous sequnce of bits that are fully enclosed in the origin register. The <code>sup</code> kind defines an alias as a superset of a number of origin registers, i.e., it is a contiguous sequence of bits formed as a concatenation of the origin registers.</p><p>More kinds of relationships could be added later.</p></header><nav class="odoc-toc"><ul><li><a href="#example-of-a-subset-relation">Example of a subset relation</a></li></ul></nav><div class="odoc-content"><h4 id="example-of-a-subset-relation"><a href="#example-of-a-subset-relation" class="anchor"></a>Example of a subset relation</h4><p>Example, given the aliasing definition,</p><pre><code>[
  def rax [unk; reg eax];
  def eax [unk; reg ax];
  def ax [ah; al];
]</code></pre><p>the <code>unalias ah</code> will retun the <code>origin</code> of <code>sub</code>-kind, so that <code>reg origin</code> is <code>rax</code>, <code>hi origin</code> is <code>15</code> and <code>lo origin</code> is <code>8</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4.0</li></ul><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('s, 'k) t</span></span><span> = <span><span>( <span class="type-var">'s</span>, <span class="type-var">'k</span> )</span> <a href="../index.html#type-origin">origin</a></span></span></code></div><div class="spec-doc"><p>the abstract representation of an aliased register origin.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sub" class="anchored"><a href="#type-sub" class="anchor"></a><code><span><span class="keyword">type</span> sub</span></code></div><div class="spec-doc"><p>the type index of the sub-registers</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sup" class="anchored"><a href="#type-sup" class="anchor"></a><code><span><span class="keyword">type</span> sup</span></code></div><div class="spec-doc"><p>the type index for the super-registers</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cast_sub" class="anchored"><a href="#val-cast_sub" class="anchor"></a><code><span><span class="keyword">val</span> cast_sub : <span><span><span>( <span class="type-var">'a</span>, unit )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sub">sub</a> )</span> <a href="#type-t">t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>cast_sub origin</code> recovers the kind of the origin.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cast_sup" class="anchored"><a href="#val-cast_sup" class="anchor"></a><code><span><span class="keyword">val</span> cast_sup : <span><span><span>( <span class="type-var">'a</span>, unit )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sup">sup</a> )</span> <a href="#type-t">t</a></span> option</span></span></code></div><div class="spec-doc"><p><code>cast_sup origin</code> recovers the kind of the origin.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reg" class="anchored"><a href="#val-reg" class="anchor"></a><code><span><span class="keyword">val</span> reg : <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sub">sub</a> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Bitv/index.html#type-t">Bitv.t</a></span> <a href="../Var/index.html#type-t">Var.t</a></span></span></code></div><div class="spec-doc"><p><code>reg origin</code> is the base register.</p><p>The returned value is never an alias itself, i.e., it is a base register.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_alias" class="anchored"><a href="#val-is_alias" class="anchor"></a><code><span><span class="keyword">val</span> is_alias : <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sub">sub</a> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_alias origin</code> if the the base register has the same size and sort as the aliased register.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hi" class="anchored"><a href="#val-hi" class="anchor"></a><code><span><span class="keyword">val</span> hi : <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sub">sub</a> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hi origin</code> the inclusive upper bound. When an alias is a subset of the <code>origin</code> register, <code>hi origin</code> is the most significant bit of the alias register.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lo" class="anchored"><a href="#val-lo" class="anchor"></a><code><span><span class="keyword">val</span> lo : <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sub">sub</a> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>lo origin</code> returns the inclusive upper bound of the origin register to which an alias belongs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-regs" class="anchored"><a href="#val-regs" class="anchor"></a><code><span><span class="keyword">val</span> regs : <span><span><span>( <span class="type-var">'a</span>, <a href="#type-sup">sup</a> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="../Bitv/index.html#type-t">Bitv.t</a></span> <a href="../Var/index.html#type-t">Var.t</a></span> list</span></span></code></div><div class="spec-doc"><p><code>regs origin</code> returns an ordered list of constituent registers.</p><p>The registers are sorted in the big endian order, i.e., the first element of the list corresponds to the most significant part of the base register. This is the same order, in which the aliasing was specified, e.g., if the aliasing was defined as, <code>def x [reg hix; reg lox], then [regs] will
        return [hix; lox].</code></p></div></div></div></body></html>