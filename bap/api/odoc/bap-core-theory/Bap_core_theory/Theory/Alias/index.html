<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Alias (bap-core-theory.Bap_core_theory.Theory.Alias)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap-core-theory</a> &#x00BB; <a href="../../index.html">Bap_core_theory</a> &#x00BB; <a href="../index.html">Theory</a> &#x00BB; Alias</nav><header class="odoc-preamble"><h1>Module <code><span>Theory.Alias</span></code></h1><p>A simple DSL for describing registers aliasing rules.</p><p>CPU architectures commonly give names to registers parts or, contrary, give names to a concatenation of registers. For example, in x86 it is possible to address the second byte of the <code>RAX</code> register using the <code>AH</code> register. Or, in AVR, the <code>Y</code> register is refers to the concatenation of <code>R19</code> and <code>R18</code> registers.</p><p>Such kind of relationships between the CPU registers could be described using a system of equations of the form,</p><pre>         Rn = Ri * ... * Rj
         ...
         Rm = Rj * ... * Rk</pre><p>In this system, the same register can occur on the left and right-hand sides multiple times. The system is solved for the set of basis registers, <code>b1;...;bN</code> so that each register that occurs in the system but which is not a basis register can be expressed in terms of the basis registers.</p><p>For example, given the following system,</p><pre><code>def r25r24 [reg 25; reg r24];
def w [reg r25r24];
def w [reg whi; reg wlo];</code></pre><p>And assuming that <code>r25</code> and <code>r24</code> are basis registers, it will be inferred that the <code>r25r24</code> and <code>w</code> are both concatenations of <code>r25</code> and <code>r24</code> and that <code>whi</code> and <code>wlo</code> are synonyms for <code>r25</code> and <code>r24</code>, correspondingly. This information is available via the <a href="../Target/index.html#val-unalias"><code>Target.unalias</code></a> function that will express an alias register in terms of corresponding basis registers, see <a href="../Origin/index.html"><code>Origin</code></a> for more information.</p><p>The set of basis registers is defined from the register roles using a simple rule that all registers that are not <code>alias</code> are basis registers, therefore it is necessary to mark alias registers as such, otherwise the system of equations will not have a solution.</p><p>In a well-formed system of equations each alias is uniquely defined in terms of a basis register.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.4.0</li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../index.html#type-alias">alias</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-part" class="anchored"><a href="#type-part" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a part</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-def" class="anchored"><a href="#val-def" class="anchor"></a><code><span><span class="keyword">val</span> def : <span><span><span><span class="type-var">'a</span> <a href="../Bitv/index.html#type-t">Bitv.t</a></span> <a href="../Var/index.html#type-t">Var.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'b</span> <a href="#type-part">part</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>def x parts</code> defines <code>x</code> as a concatenation of <code>parts</code>.</p><p>All elements of <code>parts</code> must have the same size <code>n</code> and the size of <code>x</code> should be equal to <code>n * List.length parts</code>. If this doesn't hold then the aliasing definition will fail.</p><p>The left-most position of the list of <code>parts</code> correspond to the most-significant parts (the high part) of the base register <code>x</code>.</p><p>Example,</p><pre><code>[
  def rax [unk; reg eax];
  def eax [unk; reg ax];
  def ax [reg ah; reg al]
]</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-reg" class="anchored"><a href="#val-reg" class="anchor"></a><code><span><span class="keyword">val</span> reg : <span><span><span><span class="type-var">'a</span> <a href="../Bitv/index.html#type-t">Bitv.t</a></span> <a href="../Var/index.html#type-t">Var.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-part">part</a></span></span></code></div><div class="spec-doc"><p><code>reg x</code> defines <code>x</code> as a part.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unk" class="anchored"><a href="#val-unk" class="anchor"></a><code><span><span class="keyword">val</span> unk : <span><span class="type-var">'a</span> <a href="#type-part">part</a></span></span></code></div><div class="spec-doc"><p><code>unk</code> defines an unnamed part of the register.</p></div></div></div></body></html>