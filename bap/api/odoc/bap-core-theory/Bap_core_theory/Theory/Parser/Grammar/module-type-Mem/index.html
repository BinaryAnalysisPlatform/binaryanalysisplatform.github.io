<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mem (bap-core-theory.Bap_core_theory.Theory.Parser.Grammar.Mem)</title><link rel="stylesheet" href="../../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">bap-core-theory</a> &#x00BB; <a href="../../../../index.html">Bap_core_theory</a> &#x00BB; <a href="../../../index.html">Theory</a> &#x00BB; <a href="../../index.html">Parser</a> &#x00BB; <a href="../index.html">Grammar</a> &#x00BB; Mem</nav><h1>Module type <code>Grammar.Mem</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>an abstract type denoting a Core Theory memory term.</p></dd></dl><dl><dt class="spec type" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span class="keyword">type</span> exp</code></dt><dd><p>the type of expressions of the target language</p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">val</span> error : <a href="index.html#type-t">t</a></code></dt><dd><p>an ill-formed term.</p></dd></dl><dl><dt class="spec value" id="val-store"><a href="#val-store" class="anchor"></a><code><span class="keyword">val</span> store : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>store s k x</code> is <code>store (mem s) (bitv k) (bitv x)</code></p></dd></dl><dl><dt class="spec value" id="val-store_word"><a href="#val-store_word" class="anchor"></a><code><span class="keyword">val</span> store_word : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>store_word d s k x</code> is <code>storew (bool d) (mem s) (bitv k) (bitv x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-var"><a href="#val-var" class="anchor"></a><code><span class="keyword">val</span> var : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>var s m n</code> is <code>var (ctxt s) (mems (bits m) (bits n))</code></p></dd></dl><dl><dt class="spec value" id="val-unknown"><a href="#val-unknown" class="anchor"></a><code><span class="keyword">val</span> unknown : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unknown m n</code> is <code>unk (mems (bits m) (bits n))</code></p></dd></dl><dl><dt class="spec value" id="val-ite"><a href="#val-ite" class="anchor"></a><code><span class="keyword">val</span> ite : <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>ite c x y</code> is <code>ite (bool c) (mem x) (mem y)</code></p></dd></dl><dl><dt class="spec value" id="val-let_bit"><a href="#val-let_bit" class="anchor"></a><code><span class="keyword">val</span> let_bit : string <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>let_bit s x y</code> is <code>scoped @@ fun v -&gt; (bool x) (mem [y|s-&gt;v])</code>.</p><p>Note, the <code>let_bit</code> rule is not mapped to the <code>let_</code> term, but instead a scoped fresh variable <code>v</code> is created and <code>s</code> is substituted with <code>v</code> in <code>y</code>.</p></dd></dl><dl><dt class="spec value" id="val-let_reg"><a href="#val-let_reg" class="anchor"></a><code><span class="keyword">val</span> let_reg : string <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>let_reg s x y</code> is <code>scoped @@ fun v -&gt; (bitv x) (mem [y|s-&gt;v])</code>.</p><p>Note, the <code>let_reg</code> rule is not mapped to the <code>let_</code> term, but instead a scoped fresh variable <code>v</code> is created and <code>s</code> is substituted with <code>v</code> in <code>y</code>.</p></dd></dl><dl><dt class="spec value" id="val-let_mem"><a href="#val-let_mem" class="anchor"></a><code><span class="keyword">val</span> let_mem : string <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>let_mem s x y</code> is <code>scoped @@ fun v -&gt; (mem x) (mem [y|s-&gt;v])</code>.</p><p>Note, the <code>let_mem</code> rule is not mapped to the <code>let_</code> term, but instead a scoped fresh variable <code>v</code> is created and <code>s</code> is substituted with <code>v</code> in <code>y</code>.</p></dd></dl><dl><dt class="spec value" id="val-let_float"><a href="#val-let_float" class="anchor"></a><code><span class="keyword">val</span> let_float : string <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>let_float s x y</code> is <code>scoped @@ fun v -&gt; (float x) (mem [y|s-&gt;v])</code>.</p><p>Note, the <code>let_float</code> rule is not mapped to the <code>let_</code> term, but instead a scoped fresh variable <code>v</code> is created and <code>s</code> is substituted with <code>v</code> in <code>y</code>.</p></dd></dl></div></body></html>