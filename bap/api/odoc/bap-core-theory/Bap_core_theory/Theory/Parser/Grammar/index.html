<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Grammar (bap-core-theory.Bap_core_theory.Theory.Parser.Grammar)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap-core-theory</a> &#x00BB; <a href="../../../index.html">Bap_core_theory</a> &#x00BB; <a href="../../index.html">Theory</a> &#x00BB; <a href="../index.html">Parser</a> &#x00BB; Grammar</nav><h1>Module <code>Parser.Grammar</code></h1><p>An untyped grammar for a subset of Core Theory languages.</p><p>This module defines grammars for six sub-languages for each sort of Core Theory terms.</p><h4 id="notation"><a href="#notation" class="anchor"></a>Notation</h4><p>Each rule in the grammar <code>S</code> returns a value of type <code>S.t</code>, which is a semantic action that will eventually build a Core Theory term of a corresponding to the rule type. This type is abstract and is totally co-inductive (i.e., it could also produced, there are no grammar rules (functions) that consume values of this type.</p><p>Since each grammar rule will eventually build a Core Theory term, we will describe rules using the Core Theory denotations. The parser generator will invoke recursively the top-level rules on each non-terminal. Those rules are referenced using the following names:</p><ul><li><code>bitv</code> - parses the language of bitvectors;</li><li><code>bool</code> - parses the language of booleans;</li><li><code>mem</code> - parses the language of memories;</li><li><code>stmt</code> - parses the language of statements;</li><li><code>float</code> - parses the language of floats;</li><li><code>rmode</code> - parses the language of rounding modes.</li></ul><p>The parsing rules occasionally need to refer to the sorts of therms, we use the following short-hand notation for sorts:</p><ul><li><code>bits m = Bitv.define m</code> - a sort of bitvectors with <code>m</code> bits;</li><li><code>Bool.t</code> - the sort of booleans;</li><li><code>mems k v = Mem.define k v</code> - a sort of memories;</li></ul><p>Finally, the width associated with the sort <code>s</code> is denoted with <code>size s = Bitv.size s</code>.</p><p>Example,</p><pre><code class="ml">(** [add x y] is [add (bitv x) (bitv y)].  *)
val add : exp -&gt; exp -&gt; t</code></pre><p>says that the grammar rule <code>add</code> interprets its arguments in the <code>bitv</code> context (recursively calls the <code>bitv</code> function) and have the denotation of the <code>add p q</code> term of the Core Theory, where <code>p = bitv x</code> and <code>q = bitv y</code>.</p><h5 id="contexts"><a href="#contexts" class="anchor"></a>Contexts</h5><p>To ensure the freshness of generated variables and to enable a higher-order abstract syntax style (a generalization of the De Bruijn notation) we wrap each semantic action in a context that holds the binding rules.</p><p>The <code>var</code> family of grammar rules rename the passed names if they are bound in the renaming context, which is denoted with <code>context s</code> which is a function that returns the name bound to <code>s</code> in the context or <code>s</code> if it is unbound.</p><p>The <code>let_&lt;T&gt; n ...</code> and <code>tmp_&lt;T&gt; n ...</code> take the old name <code>n</code>, create a fresh variable <code>n'</code> and append the <code>n,n'</code> binding to the context in which the grammar rule is invoked, denoted with <code>rule [&lt;non-term&gt;|n-&gt;n']</code>, e.g.,</p><pre><code class="ml">[let_reg s x y] is [scoped @@ fun v -&gt; (bitv x) (bitv [y|s-&gt;v])]</code></pre><p>As a result of the <code>let_reg</code> rule applications any free occurrence of the variable <code>s</code> will be substituted with the freshly generated variable <code>v</code>. This will ensure alpha-equivalence of expressions that use the <code>let_&lt;T&gt;</code> forms.</p><p>The <code>tmp_&lt;T&gt;</code> rules are basically the same as <code>let_&lt;T&gt;</code> except that the scope of the freshly created variable is indefinite, so these forms could be used to create hygienic symbol generators.</p></header><dl><dt class="spec type" id="type-ieee754"><a href="#type-ieee754" class="anchor"></a><code><span class="keyword">type</span> ieee754</code><code> = <a href="../../IEEE754/index.html#type-parameters">IEEE754.parameters</a></code></dt></dl><dl><dt class="spec module-type" id="module-type-Bitv"><a href="#module-type-Bitv" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Bitv/index.html">Bitv</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Bitvectors.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Bool"><a href="#module-type-Bool" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Bool/index.html">Bool</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Booleans.</p></dd></dl><div class="spec module-type" id="module-type-Mem"><a href="#module-type-Mem" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Mem/index.html">Mem</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-Stmt"><a href="#module-type-Stmt" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Stmt/index.html">Stmt</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Statements.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Float"><a href="#module-type-Float" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Float/index.html">Float</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Floating point expressions.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Rmode"><a href="#module-type-Rmode" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Rmode/index.html">Rmode</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Rounding modes.</p></dd></dl></div></body></html>