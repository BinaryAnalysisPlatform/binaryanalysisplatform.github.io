<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser (bap-core-theory.Bap_core_theory.Theory.Parser)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">bap-core-theory</a> &#x00BB; <a href="../../index.html">Bap_core_theory</a> &#x00BB; <a href="../index.html">Theory</a> &#x00BB; Parser</nav><header class="odoc-preamble"><h1>Module <code><span>Theory.Parser</span></code></h1><p>Generates parsers of untyped ASTs into type Core Theory terms.</p><p>The <code>Parser.Make</code> functor produces a recursive-descent parser for a family of untyped BIL-style languages.</p><p>In general, the problem of parsing an untyped representation into richly-typed term, such as the Core Theory term is convoluted if not tedious. This module along with the signatures in the Grammar module facilitates this task, at least for typical intermediate languages such as BIL and its variants.</p><p>The recursive-descent parser has six top-level rules, for each supported term sort:</p><ul><li><code>bitv</code> - produces terms of type <code>'a bitv</code>;</li><li><code>bool</code> - produces terms of type <code>bool</code>;</li><li><code>mem</code> - produces terms of type <code>('k,'v) mem</code>;</li><li><code>stmt</code> - produces terms of type <code>'a effect</code>;</li><li><code>float</code> - produces terms of type <code>('f,'s) float</code>;</li><li><code>rmode</code> - produces terms of type <code>rmode</code>.</li></ul><p>The target language is not required to represent all those terms or to distinguish types in the same way as this parser do.</p><p>To implement a parser for a target language all five rules must be provided, but they could be incomplete or empty.</p><p>Each rule is a function, that takes a parser that recognizes a sub-language of a term that is parsed by the function, and the expression or statement of the target language. The function has to map each non-terminal of the target language to a rule in the provided subgrammar, i.e.,</p><pre>        let bitv : type t r. (t,exp,r) bitv_parser =
          fun (module S) -&gt; function
          | symbol .. symbol -&gt; S.rule1 symbol .. symbol
          | ..
          | symbol .. symbol -&gt; S.ruleN symbol .. symbol</pre><p>Let's take the BIL parser as a concrete example,</p><pre><code>let bitv : type t r. (t,exp,r) bitv_parser =
  fun (module S) -&gt; function
    | Cast (HIGH,n,x) -&gt; S.high n x
    | .. -&gt; ..
    | Cast (SIGNED,n,x) -&gt; S.signed n x
    | BinOp(PLUS,x,y) -&gt; S.add x y
    | .. -&gt; ..
    | BinOp(XOR,x,y) -&gt; S.logxor x y
    | Let (v,y,z) when is_bit v -&gt; S.let_bit (Var.name v) y z
    | .. -&gt; ..
    | Let (v,y,z) when is_mem v -&gt; S.let_mem (Var.name v) y z
    | .. -&gt; ..
      (* ill-formed expressions *)
    | Let _
    | Store (_, _, _, _, _)
    | Unknown (_, (Mem _|Unk)) as exp -&gt; fail exp `Bitv; S.error</code></pre><p>We omitted most of the rules for brevity, see the full definition in the BIL plugin. The mapping is pretty straightforward. As this example highlights, the parser is also playing the role of a type checker. Expressions that are not valid in the given context has to be mapped to the <code>error</code> term. The term itself doesn't have any payload and works as an abort symbol for the parser. Since parser are expected to be implemented in a plugin code, they can utilize to full extend the interface with the user to provide fancy error messages.</p><p>The context of the expression is automatically inferred by the parser generator with the help of the top-level syntactic rules provided by the user. In the example above, the context of the let-bound expression is determined from the type of the variable. For some languages, it might be necessary to write a type-inference algorithm.</p><p>Note, that the parser must return a value of type <code>S.t</code> which is abstract and couldn't be unified with the type of the Core Theory term. Therefore, the rule implementer is limited to the language that is defined by the transitive closure of the sub-grammar that is passed to the function that implements the rule. That basically makes this parser infrastructure non-extensible, which is alleviated by the fact that provided sub-grammars are very rich. The task of writing an extensible parser is still a research question.</p></header><nav class="odoc-toc"><ul><li><a href="#notes-on-future-extensions">Notes on future extensions</a></li></ul></nav><div class="odoc-content"><h4 id="notes-on-future-extensions"><a href="#notes-on-future-extensions" class="anchor"></a>Notes on future extensions</h4><p>We're reserving the right to extend the grammar signatures in the <code>Parser.Grammar</code> module without changing the major version of the library, since those modules are designed to be used co-inductively (as types of modules that are provided by the library, not required), therefore adding more definitions to the grammars which could be used by the library user makes the library strictly more powerful (stronger). To prevent any issues, it is recommended not to open the provided module (i.e., always use the grammar rules via the dot notation, e.g., S.add), since adding a new rule may hide the existing functions in the scope if the module is opened. For alternative implementations of this parser generator it is recommended not to reuse these module types literally but to copy them (or define your own rules).</p><div class="odoc-spec"><div class="spec module" id="module-Grammar" class="anchored"><a href="#module-Grammar" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Grammar/index.html">Grammar</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An untyped grammar for a subset of Core Theory languages.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-bitv_parser" class="anchored"><a href="#type-bitv_parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e, 'r) bitv_parser</span></span><span> = <span><span>(<span class="keyword">module</span> <a href="Grammar/module-type-Bitv/index.html">Grammar.Bitv</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Grammar/module-type-Bitv/index.html#type-exp">exp</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Bitv/index.html#type-rmode">rmode</a> = <span class="type-var">'r</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Bitv/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>bitv grammar exp</code> parses <code>exp</code> using <code>grammar</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-bool_parser" class="anchored"><a href="#type-bool_parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e, 'r) bool_parser</span></span><span> = <span><span>(<span class="keyword">module</span> <a href="Grammar/module-type-Bool/index.html">Grammar.Bool</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Grammar/module-type-Bool/index.html#type-exp">exp</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Bool/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>bool grammar exp</code> parses <code>exp</code> using <code>grammar</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-mem_parser" class="anchored"><a href="#type-mem_parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e) mem_parser</span></span><span> = <span><span>(<span class="keyword">module</span> <a href="Grammar/module-type-Mem/index.html">Grammar.Mem</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Grammar/module-type-Mem/index.html#type-exp">exp</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Mem/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>mem grammar exp</code> parses <code>exp</code> using <code>grammar</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-stmt_parser" class="anchored"><a href="#type-stmt_parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e, 'r, 's) stmt_parser</span></span><span> = <span><span>(<span class="keyword">module</span> <a href="Grammar/module-type-Stmt/index.html">Grammar.Stmt</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Grammar/module-type-Stmt/index.html#type-exp">exp</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Stmt/index.html#type-rmode">rmode</a> = <span class="type-var">'r</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Stmt/index.html#type-stmt">stmt</a> = <span class="type-var">'s</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Stmt/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>stmt grammar stmt</code> parses <code>stmt</code> using <code>grammar</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-float_parser" class="anchored"><a href="#type-float_parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e, 'r) float_parser</span></span><span> = <span><span>(<span class="keyword">module</span> <a href="Grammar/module-type-Float/index.html">Grammar.Float</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Grammar/module-type-Float/index.html#type-exp">exp</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Float/index.html#type-rmode">rmode</a> = <span class="type-var">'r</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Float/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>float grammar exp</code> parses <code>exp</code> using <code>grammar</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-rmode_parser" class="anchored"><a href="#type-rmode_parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'e) rmode_parser</span></span><span> = <span><span>(<span class="keyword">module</span> <a href="Grammar/module-type-Rmode/index.html">Grammar.Rmode</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Grammar/module-type-Rmode/index.html#type-exp">exp</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Grammar/module-type-Rmode/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>rmode grammar exp</code> parses <code>exp</code> using <code>grammar</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('e, 'r, 's) t</span></span><span> = </span><span>{</span></code><table><tr id="type-t.bitv" class="anchored"><td class="def record field"><a href="#type-t.bitv" class="anchor"></a><code><span>bitv : a. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>, <span class="type-var">'r</span>)</span> <a href="#type-bitv_parser">bitv_parser</a></span>;</span></code></td></tr><tr id="type-t.bool" class="anchored"><td class="def record field"><a href="#type-t.bool" class="anchor"></a><code><span>bool : a. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>, <span class="type-var">'r</span>)</span> <a href="#type-bool_parser">bool_parser</a></span>;</span></code></td></tr><tr id="type-t.mem" class="anchored"><td class="def record field"><a href="#type-t.mem" class="anchor"></a><code><span>mem : a. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="#type-mem_parser">mem_parser</a></span>;</span></code></td></tr><tr id="type-t.stmt" class="anchored"><td class="def record field"><a href="#type-t.stmt" class="anchor"></a><code><span>stmt : a. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>, <span class="type-var">'r</span>, <span class="type-var">'s</span>)</span> <a href="#type-stmt_parser">stmt_parser</a></span>;</span></code></td></tr><tr id="type-t.float" class="anchored"><td class="def record field"><a href="#type-t.float" class="anchor"></a><code><span>float : a. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>, <span class="type-var">'r</span>)</span> <a href="#type-float_parser">float_parser</a></span>;</span></code></td></tr><tr id="type-t.rmode" class="anchored"><td class="def record field"><a href="#type-t.rmode" class="anchor"></a><code><span>rmode : a. <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-rmode_parser">rmode_parser</a></span>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-parser" class="anchored"><a href="#type-parser" class="anchor"></a><code><span><span class="keyword">type</span> <span>('e, 'r, 's) parser</span></span><span> = <span><span>(<span class="type-var">'e</span>, <span class="type-var">'r</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>parser</code> is a tuple of top-level parsing routines.</p><p>Parser defines a Core Theory denotation of an untyped AST with expressions of type <code>'e</code>, statements of type <code>'s</code> and rounding modes represented with type <code>'r</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-S/index.html">S</a> : <a href="../module-type-Core/index.html">Core</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Make(Theory)</code> parses AST to the specified <code>Theory</code> terms.</p></div></div></div></body></html>