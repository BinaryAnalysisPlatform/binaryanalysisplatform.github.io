<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (graphlib.Graphlib.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">graphlib</a> &#x00BB; <a href="../index.html">Graphlib</a> &#x00BB; Std</nav><header class="odoc-preamble"><h1>Module <code><span>Graphlib.Std</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#graph-library">Graph library</a><ul><li><a href="#auxiliary-graph-data-structures">Auxiliary graph data structures</a></li><li><a href="#visual-attributes-for-graph-vizualization.">Visual attributes for graph vizualization.</a></li></ul></li></ul></nav><div class="odoc-content"><h4 id="graph-library"><a href="#graph-library" class="anchor"></a>Graph library</h4><p><a href="../index.html"><code>Graphlib</code></a> is a generic library that extends a OCamlGraph library.<a href="../index.html"><code>Graphlib</code></a> uses its own and richer <code>Graph</code> interface that is isomorphic to OCamlGraph's <code>Sigs.P</code> signature for persistent graphs. Two functors witnesses isomorphism of the interfaces: <code>Graphlib</code>.To_ocamlgraph and <code>Graphlib</code>.Of_ocamlgraph. Thanks to these functors, any algorithm written for OCamlGraph can be used on <code>Graphlibs</code> graph and vice versa.</p><p>The <code>Graph</code> interface provides a richer interface in a Core style. Nodes and Edges implements the <code>Opaque</code> interface, i.e., they come with Maps, Sets, Hashtbls, etc, (e.g., <code>G.Node.Set</code> is a set of node for graph implementation, provided by a module named <code>G</code>). Graphs also implement <code>Printable</code> interface, that makes them much easier to debug.</p><p>Along with graphs, auxiliary data structures are provided, like <span class="xref-unresolved">path</span> to represent paths in graph, <span class="xref-unresolved">tree</span> for representing different graph spannings, <span class="xref-unresolved">partition</span> for graph partitioning, and more.</p><p>The <a href="../index.html"><code>Graphlib</code></a> module provides a set of generic graph algorithms. Contrary to OCamlGraph, each <a href="../index.html"><code>Graphlib</code></a> interface is provided using functions rather than functors. Which makes the interface easier to use, at least in simple cases. Also, <a href="../index.html"><code>Graphlib</code></a> heavily uses optional and keyword parameters. For die-hards, many algorithms still have a functor interface.</p><p>All <a href="../index.html"><code>Graphlib</code></a> algorithms accept a first-class module with graph implementation as a first argument. You can think of this parameter as an explicit type class.</p><p>A recommended way to work with <a href="../index.html"><code>Graphlib</code></a> is to bind the chosen implementation to some short name, usually <code>G</code> would be a good choice:</p><pre><code>module G = Graphlib.Make(String)(Bool)</code></pre><p>This will bind <code>G</code> to a graph implementation that has <code>string</code> nodes with edges labeled by values of type <code>bool</code>.</p><p>Graphs of type <code>G.t</code> could be created using the generic <code>Graphlib</code>.create function:</p><pre><code>let g = Graphlib.create (module G) ~edges:[
    &quot;entry&quot;, &quot;loop&quot;, true;
    &quot;loop&quot;, &quot;exit&quot;, true;
    &quot;loop&quot;, &quot;loop&quot;, false;
  ] ()</code></pre><p>This will create an instance of type <code>G.t</code>. Of course, it is still possible to use non-generic <code>G.empty</code>, <code>G.Node.insert</code>, <code>G.Edge.insert</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-Node" class="anchored"><a href="#module-type-Node" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Node/index.html">Node</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><a href="module-type-Graph/index.html"><code>Graph</code></a> nodes. Semantics of operations is denoted using mathematical model, described in <a href="module-type-Graph/index.html"><code>Graph</code></a> interface.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Edge" class="anchored"><a href="#module-type-Edge" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Edge/index.html">Edge</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Interface that every Graph edge should provide</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Graph" class="anchored"><a href="#module-type-Graph" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html">Graph</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Graph signature.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-graph" class="anchored"><a href="#type-graph" class="anchor"></a><code><span><span class="keyword">type</span> <span>('c, 'n, 'e) graph</span></span><span> =
  <span>(<span class="keyword">module</span> <a href="module-type-Graph/index.html">Graph</a>
  <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span>
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span>
   <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span></span></code></div><div class="spec-doc"><p>a type abbreviation for a packed module, implementing graph interface. Note: this type prenexes only 3 out of 8 type variables, so, sometimes it is not enough.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-edge_kind" class="anchored"><a href="#type-edge_kind" class="anchor"></a><code><span><span class="keyword">type</span> edge_kind</span><span> = </span><span>[ </span></code><table><tr id="type-edge_kind.Tree" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Tree" class="anchor"></a><code><span>| </span></code><code><span>`Tree</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>edge is a part of a tree</p><span class="comment-delim">*)</span></td></tr><tr id="type-edge_kind.Back" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Back" class="anchor"></a><code><span>| </span></code><code><span>`Back</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>back edge</p><span class="comment-delim">*)</span></td></tr><tr id="type-edge_kind.Cross" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Cross" class="anchor"></a><code><span>| </span></code><code><span>`Cross</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>cross edge</p><span class="comment-delim">*)</span></td></tr><tr id="type-edge_kind.Forward" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Forward" class="anchor"></a><code><span>| </span></code><code><span>`Forward</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>forward edge</p><span class="comment-delim">*)</span></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Graph edges classification. For explanations see <a href="Graphlib/index.html#val-depth_first_search">DFS</a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-tree" class="anchored"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tree</span></span></code></div><div class="spec-doc"><p>a <a href="Tree/index.html"><code>Tree</code></a> representation.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-frontier" class="anchored"><a href="#type-frontier" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a frontier</span></span></code></div><div class="spec-doc"><p>a type representing <a href="Frontier/index.html"><code>Frontier</code></a>s</p></div></div><div class="odoc-spec"><div class="spec type" id="type-partition" class="anchored"><a href="#type-partition" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a partition</span></span></code></div><div class="spec-doc"><p>a <a href="Partition/index.html">result</a> of partitioning algorithms</p></div></div><div class="odoc-spec"><div class="spec type" id="type-group" class="anchored"><a href="#type-group" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a group</span></span></code></div><div class="spec-doc"><p>a partition <a href="Group/index.html">Cell</a></p></div></div><div class="odoc-spec"><div class="spec type" id="type-path" class="anchored"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a path</span></span></code></div><div class="spec-doc"><p>walk without a repetition of edges and inner nodes</p></div></div><div class="odoc-spec"><div class="spec type" id="type-equiv" class="anchored"><a href="#type-equiv" class="anchor"></a><code><span><span class="keyword">type</span> equiv</span></code></div><div class="spec-doc"><p>runtime witness of the <a href="Equiv/index.html">equivalence class</a></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Tree" class="anchored"><a href="#module-Tree" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Tree/index.html">Tree</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Tree is a particular subtype of a graph for which each node has only one predecessor, and there is only one path between tree root and any other node. Here is an example of a tree:</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Frontier" class="anchored"><a href="#module-Frontier" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Frontier/index.html">Frontier</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Frontier maps each node into a possibly empty set of nodes. This is used for representing dominance and post-dominance frontiers.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Path" class="anchored"><a href="#module-Path" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Path/index.html">Path</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Path between two nodes.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Partition" class="anchored"><a href="#module-Partition" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Partition/index.html">Partition</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Result of a set partitioning.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Group" class="anchored"><a href="#module-Group" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Group/index.html">Group</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Group is a non-empty set that is a result of partitioning of an underlying set <code>S</code> into a set of non-intersecting and non-empty subsets that cover set <code>S</code>. See <a href="Partition/index.html"><code>Partition</code></a> for more information.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Equiv" class="anchored"><a href="#module-Equiv" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Equiv/index.html">Equiv</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Ordinal for representing equivalence. Useful, for indexing elements based on their equivalence.</p></div></div><h6 id="auxiliary-graph-data-structures"><a href="#auxiliary-graph-data-structures" class="anchor"></a>Auxiliary graph data structures</h6><div class="odoc-spec"><div class="spec module-type" id="module-type-Predicate" class="anchored"><a href="#module-type-Predicate" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Predicate/index.html">Predicate</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A type of modules for filtering graphs. See <a href="Graphlib/index.html#val-filtered"><code>Graphlib.filtered</code></a> or <a href="Graphlib/Filtered/index.html"><code>Graphlib.Filtered</code></a></p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Isomorphism" class="anchored"><a href="#module-type-Isomorphism" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Isomorphism/index.html">Isomorphism</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Isomorphism</code> is a bijection between type <code>s</code> and <code>t</code>. Useful for creating graph views and mapping graphs. See <a href="Graphlib/index.html#val-view"><code>Graphlib.view</code></a> and <a href="Graphlib/Mapper/index.html"><code>Graphlib.Mapper</code></a>.</p></div></div><div class="odoc-spec"><div class="spec class-type" id="class-type-dfs_visitor" class="anchored"><a href="#class-type-dfs_visitor" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">type</span> ['n, 'e, 's] </span><span><a href="class-type-dfs_visitor/index.html">dfs_visitor</a></span><span> = <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><h5 id="visual-attributes-for-graph-vizualization."><a href="#visual-attributes-for-graph-vizualization." class="anchor"></a>Visual attributes for graph vizualization.</h5><p>Consult OCamlGraph library for more information.</p><div class="odoc-spec"><div class="spec type" id="type-node_attr" class="anchored"><a href="#type-node_attr" class="anchor"></a><code><span><span class="keyword">type</span> node_attr</span><span> = <span class="xref-unresolved">Graph</span>.Graphviz.DotAttributes.vertex</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-edge_attr" class="anchored"><a href="#type-edge_attr" class="anchor"></a><code><span><span class="keyword">type</span> edge_attr</span><span> = <span class="xref-unresolved">Graph</span>.Graphviz.DotAttributes.edge</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-graph_attr" class="anchored"><a href="#type-graph_attr" class="anchor"></a><code><span><span class="keyword">type</span> graph_attr</span><span> = <span class="xref-unresolved">Graph</span>.Graphviz.DotAttributes.graph</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-labeled" class="anchored"><a href="#type-labeled" class="anchor"></a><code><span><span class="keyword">type</span> <span>('n, 'a) labeled</span></span><span> = </span><span>{</span></code><table><tr id="type-labeled.node" class="anchored"><td class="def record field"><a href="#type-labeled.node" class="anchor"></a><code><span>node : <span class="type-var">'n</span>;</span></code></td></tr><tr id="type-labeled.node_label" class="anchored"><td class="def record field"><a href="#type-labeled.node_label" class="anchor"></a><code><span>node_label : <span class="type-var">'a</span>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Solution" class="anchored"><a href="#module-Solution" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Solution/index.html">Solution</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A solution to a system of fixed-point equations.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Graphlib" class="anchored"><a href="#module-Graphlib" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Graphlib/index.html">Graphlib</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Generic Graph Library</p></div></div></div></body></html>