<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (graphlib.Graphlib.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">graphlib</a> &#x00BB; <a href="../index.html">Graphlib</a> &#x00BB; Std</nav><h1>Module <code>Graphlib.Std</code></h1><h4 id="graph-library"><a href="#graph-library" class="anchor"></a>Graph library</h4><p><a href="Graphlib/index.html"><code>Graphlib</code></a> is a generic library that extends a well known OCamlGraph library. <a href="Graphlib/index.html"><code>Graphlib</code></a> uses its own and richer <a href="module-type-Graph/index.html"><code>Graph</code></a> interface that is isomorphic to OCamlGraph's <code>Sigs.P</code> signature for persistent graphs. Two functors witnesses isomorphism of the interfaces: <a href="Graphlib/To_ocamlgraph/index.html"><code>Graphlib.To_ocamlgraph</code></a> and <a href="Graphlib/Of_ocamlgraph/index.html"><code>Graphlib.Of_ocamlgraph</code></a>. Thanks to these functors, any algorithm written for OCamlGraph can be used on <code>Graphlibs</code> graph and vice verse.</p><p>The <a href="module-type-Graph/index.html"><code>Graph</code></a> interface provides a richer interface in a Core style. Nodes and Edges implements the <code>Opaque</code> interface, i.e., they come with Maps, Sets, Hashtbls, etc, (e.g., <code>G.Node.Set</code> is a set of node for graph implementation, provided by a module named <code>G</code>). Graphs also implement <code>Printable</code> interface, that makes them much easier to debug.</p><p>Along with graphs, auxiliary data structures are provided, like <a href="Path/index.html"><span>path</span></a> to represent paths in graph, <a href="Tree/index.html"><span>tree</span></a> for representing different graph spannings, <a href="Partition/index.html"><span>partition</span></a> for graph partitioning, and more.</p><p>The <a href="Graphlib/index.html"><code>Graphlib</code></a> module provides a set of generic graph algorithms. Contrary to OCamlGraph, each <a href="Graphlib/index.html"><code>Graphlib</code></a> interface is provided using functions rather than functors. Which makes the interface easier to use, at least in simple cases. Also, <a href="Graphlib/index.html"><code>Graphlib</code></a> heavily uses optional and keyword parameters. For die-hards, many algorithms still have a functor interface.</p><p>All <a href="Graphlib/index.html"><code>Graphlib</code></a> algorithms accept a first-class module with graph implementation as a first argument. You can think of this parameter as an explicit type class.</p><p>A recommended way to work with <a href="Graphlib/index.html"><code>Graphlib</code></a> is to bind the chosen implementation to some short name, usually <code>G</code> would be a good choice:</p><pre><code class="ml">module G = Graphlib.Make(String)(Bool)</code></pre><p>This will bind <code>G</code> to a graph implementation that has <code>string</code> nodes with edges labeled by values of type <code>bool</code>.</p><p>Graphs of type <code>G.t</code> could be created using the generic <a href="Graphlib/index.html#val-create"><code>Graphlib.create</code></a> function:</p><pre><code class="ml">let g = Graphlib.create (module G) ~edges:[
    &quot;entry&quot;, &quot;loop&quot;, true;
    &quot;loop&quot;, &quot;exit&quot;, true;
    &quot;loop&quot;, &quot;loop&quot;, false;
  ] ()</code></pre><p>This will create an instance of type <code>G.t</code>. Of course, it is still possible to use non-generic <code>G.empty</code>, <code>G.Node.insert</code>, <code>G.Edge.insert</code>.</p><nav class="toc"><ul><li><a href="#auxiliary-graph-data-structures">Auxiliary graph data structures</a></li><li><a href="#visual-attributes-for-graph-vizualization.">Visual attributes for graph vizualization.</a></li></ul></nav></header><dl><dt class="spec module-type" id="module-type-Node"><a href="#module-type-Node" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Node/index.html">Node</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><a href="module-type-Graph/index.html"><code>Graph</code></a> nodes.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Edge"><a href="#module-type-Edge" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Edge/index.html">Edge</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interface that every Graph edge should provide</p></dd></dl><dl><dt class="spec module-type" id="module-type-Graph"><a href="#module-type-Graph" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html">Graph</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Graph signature.</p></dd></dl><dl><dt class="spec type" id="type-graph"><a href="#type-graph" class="anchor"></a><code><span class="keyword">type</span> <span>('c, 'n, 'e) graph</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span></code></dt><dd><p>a type abbreviation for a packed module, implementing graph interface. Note: this type prenexes only 3 out of 8 type variables, so, sometimes it is not enough.</p></dd></dl><dl><dt class="spec type" id="type-edge_kind"><a href="#type-edge_kind" class="anchor"></a><code><span class="keyword">type</span> edge_kind</code> = <code>[ </code><table class="variant"><tr id="type-edge_kind.Tree" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Tree" class="anchor"></a><code>| </code><code>`Tree</code></td><td class="doc"><p>edge is a part of a tree</p></td></tr><tr id="type-edge_kind.Back" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Back" class="anchor"></a><code>| </code><code>`Back</code></td><td class="doc"><p>back edge</p></td></tr><tr id="type-edge_kind.Cross" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Cross" class="anchor"></a><code>| </code><code>`Cross</code></td><td class="doc"><p>cross edge</p></td></tr><tr id="type-edge_kind.Forward" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Forward" class="anchor"></a><code>| </code><code>`Forward</code></td><td class="doc"><p>forward edge</p></td></tr></table><code> ]</code></dt><dd><p>Graph edges classification. For explanations see <a href="Graphlib/index.html#val-depth_first_search"><span>DFS</span></a>.</p></dd></dl><dl><dt class="spec type" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span class="keyword">type</span> <span>'a tree</span></code></dt><dd><p>a <a href="Tree/index.html"><code>Tree</code></a> representation.</p></dd></dl><dl><dt class="spec type" id="type-frontier"><a href="#type-frontier" class="anchor"></a><code><span class="keyword">type</span> <span>'a frontier</span></code></dt><dd><p>a type representing <a href="Frontier/index.html"><code>Frontier</code></a>s</p></dd></dl><dl><dt class="spec type" id="type-partition"><a href="#type-partition" class="anchor"></a><code><span class="keyword">type</span> <span>'a partition</span></code></dt><dd><p>a <a href="Partition/index.html"><span>result</span></a> of partitioning algorithms</p></dd></dl><dl><dt class="spec type" id="type-group"><a href="#type-group" class="anchor"></a><code><span class="keyword">type</span> <span>'a group</span></code></dt><dd><p>a partition <a href="Group/index.html"><span>Cell</span></a></p></dd></dl><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> <span>'a path</span></code></dt><dd><p>walk without a repetition of edges and inner nodes</p></dd></dl><dl><dt class="spec type" id="type-equiv"><a href="#type-equiv" class="anchor"></a><code><span class="keyword">type</span> equiv</code></dt><dd><p>runtime witness of the <a href="Equiv/index.html"><span>equivalence class</span></a></p></dd></dl><dl><dt class="spec module" id="module-Tree"><a href="#module-Tree" class="anchor"></a><code><span class="keyword">module</span> <a href="Tree/index.html">Tree</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Tree is a particular subtype of a graph for which each node has only one predecessor, and there is only one path between tree root and any other node. Here is an example of a tree:</p></dd></dl><dl><dt class="spec module" id="module-Frontier"><a href="#module-Frontier" class="anchor"></a><code><span class="keyword">module</span> <a href="Frontier/index.html">Frontier</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Frontier maps each node into a possibly empty set of nodes. This is used for representing dominance and post-dominance frontiers.</p></dd></dl><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module</span> <a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Path between two nodes.</p></dd></dl><dl><dt class="spec module" id="module-Partition"><a href="#module-Partition" class="anchor"></a><code><span class="keyword">module</span> <a href="Partition/index.html">Partition</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Result of a set partitioning.</p></dd></dl><dl><dt class="spec module" id="module-Group"><a href="#module-Group" class="anchor"></a><code><span class="keyword">module</span> <a href="Group/index.html">Group</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Group is a non-empty set that is a result of partitioning of an underlying set <code>S</code> into a set of non-intersecting and non-empty subsets that cover set <code>S</code>. See <a href="Partition/index.html"><code>Partition</code></a> for more information.</p></dd></dl><dl><dt class="spec module" id="module-Equiv"><a href="#module-Equiv" class="anchor"></a><code><span class="keyword">module</span> <a href="Equiv/index.html">Equiv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Ordinal for representing equivalence. Useful, for indexing elements based on their equivalence.</p></dd></dl><section><header><h6 id="auxiliary-graph-data-structures"><a href="#auxiliary-graph-data-structures" class="anchor"></a>Auxiliary graph data structures</h6></header><dl><dt class="spec module-type" id="module-type-Predicate"><a href="#module-type-Predicate" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Predicate/index.html">Predicate</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A type of modules for filtering graphs. See <a href="Graphlib/index.html#val-filtered"><code>Graphlib.filtered</code></a> or <a href="Graphlib/Filtered/index.html"><code>Graphlib.Filtered</code></a></p></dd></dl><dl><dt class="spec module-type" id="module-type-Isomorphism"><a href="#module-type-Isomorphism" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Isomorphism/index.html">Isomorphism</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Isomorphism</code> is a bijection between type <code>s</code> and <code>t</code>. Useful for creating graph views and mapping graphs. See <a href="Graphlib/index.html#val-view"><code>Graphlib.view</code></a> and <a href="Graphlib/Mapper/index.html"><code>Graphlib.Mapper</code></a>.</p></dd></dl><div class="spec class-type" id="class-type-dfs_visitor"><a href="#class-type-dfs_visitor" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span> ['n, 'e, 's] <a href="class-type-dfs_visitor/index.html">dfs_visitor</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></div></section><section><header><h5 id="visual-attributes-for-graph-vizualization."><a href="#visual-attributes-for-graph-vizualization." class="anchor"></a>Visual attributes for graph vizualization.</h5><p>Consult OCamlGraph library for more information.</p></header><dl><dt class="spec type" id="type-node_attr"><a href="#type-node_attr" class="anchor"></a><code><span class="keyword">type</span> node_attr</code><code> = <a href="../../../ocamlgraph/Graph/Graphviz/DotAttributes/index.html#type-vertex">Graph.Graphviz.DotAttributes.vertex</a></code></dt><dt class="spec type" id="type-edge_attr"><a href="#type-edge_attr" class="anchor"></a><code><span class="keyword">type</span> edge_attr</code><code> = <a href="../../../ocamlgraph/Graph/Graphviz/DotAttributes/index.html#type-edge">Graph.Graphviz.DotAttributes.edge</a></code></dt><dt class="spec type" id="type-graph_attr"><a href="#type-graph_attr" class="anchor"></a><code><span class="keyword">type</span> graph_attr</code><code> = <a href="../../../ocamlgraph/Graph/Graphviz/DotAttributes/index.html#type-graph">Graph.Graphviz.DotAttributes.graph</a></code></dt><dt class="spec type" id="type-labeled"><a href="#type-labeled" class="anchor"></a><code><span class="keyword">type</span> <span>('n, 'a) labeled</span></code><code> = </code><code>{</code><table class="record"><tr id="type-labeled.node" class="anchored"><td class="def field"><a href="#type-labeled.node" class="anchor"></a><code>node : <span class="type-var">'n</span>;</code></td></tr><tr id="type-labeled.node_label" class="anchored"><td class="def field"><a href="#type-labeled.node_label" class="anchor"></a><code>node_label : <span class="type-var">'a</span>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec module" id="module-Solution"><a href="#module-Solution" class="anchor"></a><code><span class="keyword">module</span> <a href="Solution/index.html">Solution</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A solution to a system of fixed-point equations.</p></dd></dl><dl><dt class="spec module" id="module-Graphlib"><a href="#module-Graphlib" class="anchor"></a><code><span class="keyword">module</span> <a href="Graphlib/index.html">Graphlib</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Generic Graph Library</p></dd></dl></section></div></body></html>