<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (graphlib.Graphlib.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">graphlib</a> &#x00BB; <a href="../index.html">Graphlib</a> &#x00BB; Std</nav><h1>Module <code>Graphlib.Std</code></h1><h4 id="graph-library"><a href="#graph-library" class="anchor"></a>Graph library</h4><p><a href="Graphlib/index.html"><code>Graphlib</code></a> is a generic library that extends a well known OCamlGraph library. <a href="Graphlib/index.html"><code>Graphlib</code></a> uses its own, more reach, <a href="module-type-Graph/index.html"><code>Graph</code></a> interface that is isomorphic to OCamlGraph's <code>Sigs.P</code> signature for persistant graphs. Two functors witness the isomorphism of the interfaces: <a href="Graphlib/To_ocamlgraph/index.html"><code>Graphlib.To_ocamlgraph</code></a> and <a href="Graphlib/Of_ocamlgraph/index.html"><code>Graphlib.Of_ocamlgraph</code></a>. Thanks to these functors, any algorithm written for OCamlGraph can be used on <code>Graphlibs</code> graph and vice verse.</p><p>The <a href="module-type-Graph/index.html"><code>Graph</code></a> interface provides a richer interface in a Core style. Nodes and Edges implements <code>Opaque</code> data structure, i.e., they come with Maps, Sets, Hashtbls, etc, preloaded (e.g., <code>G.Node.Set</code> is a set of node for graph implementation, provided by a module named <code>G</code>). Graphs also implement <code>Printable</code> interface, that makes them much easier to debug.</p><p>Along with graphs, auxiliary data structures are provided, like <a href="Path/index.html"><span>path</span></a> to represent paths in graph, <a href="Tree/index.html"><span>tree</span></a> for representing different graph spannings, <a href="Partition/index.html"><span>partition</span></a> for graph partitioning, and more.</p><p><a href="Graphlib/index.html"><code>Graphlib</code></a> is a library that provides a set of generic algorithms, as well as implementations of a <a href="module-type-Graph/index.html"><code>Graph</code></a> interface, and a suite of preinstantiated graphs.</p><p>Contrary to OCamlGraph, each <a href="Graphlib/index.html"><code>Graphlib</code></a> interface is provided as a function, not a functor. Thus making there use syntactically easier. Also, <a href="Graphlib/index.html"><code>Graphlib</code></a> heavily uses optional and keyword parameters. For die-hards, many algorithms still have functor a interface.</p><p>All <a href="Graphlib/index.html"><code>Graphlib</code></a> algorithms accept a first-class module with graph implementation as a first argument. You can think of this parameter as an explicit type class. Later, when modular implicits will be accepted in OCaml, this parameter can be omitted. But for now, we need to pass them.</p><p>A recommended way to work with <a href="Graphlib/index.html"><code>Graphlib</code></a> is to bind the chosen implementation with some short name, usually <code>G</code> would be a good choice:</p><pre><code class="ml">module G = Graphlib.Make(String)(Bool)</code></pre><p>This will bind name <code>G</code> with a graph implementation that has <code>string</code> nodes, with edges labeled by values of type <code>bool</code>.</p><p>To create a graph of type <code>G.t</code> one can use a generic <a href="Graphlib/index.html#val-create"><code>Graphlib.create</code></a> function:</p><pre><code class="ml">let g = Graphlib.create (module G) ~edges:[
       &quot;entry&quot;, &quot;loop&quot;, true;
       &quot;loop&quot;, &quot;exit&quot;, true;
       &quot;loop&quot;, &quot;loop&quot;, false;
     ] ()</code></pre><p>This will create an instance of type <code>G.t</code>. Of course, it is still possible to use non-generic <code>G.empty</code>, <code>G.Node.insert</code>, <code>G.Edge.insert</code>.</p><nav class="toc"><ul><li><a href="#auxiliary-graph-data-structures">Auxiliary graph data structures</a></li><li><a href="#visual-attributes-for-graph-vizualization.">Visual attributes for graph vizualization.</a></li></ul></nav></header><dl><dt class="spec module-type" id="module-type-Node"><a href="#module-type-Node" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Node/index.html">Node</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><a href="module-type-Graph/index.html"><code>Graph</code></a> nodes.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Edge"><a href="#module-type-Edge" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Edge/index.html">Edge</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interface that every Graph edge should provide</p></dd></dl><dl><dt class="spec module-type" id="module-type-Graph"><a href="#module-type-Graph" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html">Graph</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Graph signature.</p></dd></dl><dl><dt class="spec type" id="type-graph"><a href="#type-graph" class="anchor"></a><code><span class="keyword">type</span> ('c, 'n, 'e) graph</code><code> = (<span class="keyword">module</span> <a href="module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</code></dt><dd><p>a type abbreviation for a packed module, implementing graph interface. Note: this type prenexes only 3 out of 8 type variables, so, sometimes it is not enough.</p></dd></dl><dl><dt class="spec type" id="type-edge_kind"><a href="#type-edge_kind" class="anchor"></a><code><span class="keyword">type</span> edge_kind</code> = <code>[ </code><table class="variant"><tr id="type-edge_kind.Tree" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Tree" class="anchor"></a><code>| </code><code>`Tree</code></td><td class="doc"><p>edge is a part of a tree</p></td></tr><tr id="type-edge_kind.Back" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Back" class="anchor"></a><code>| </code><code>`Back</code></td><td class="doc"><p>back edge</p></td></tr><tr id="type-edge_kind.Cross" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Cross" class="anchor"></a><code>| </code><code>`Cross</code></td><td class="doc"><p>cross edge</p></td></tr><tr id="type-edge_kind.Forward" class="anchored"><td class="def constructor"><a href="#type-edge_kind.Forward" class="anchor"></a><code>| </code><code>`Forward</code></td><td class="doc"><p>forward edge</p></td></tr></table><code> ]</code></dt><dd><p>Graph edges classification. For explanations see <a href="Graphlib/index.html#val-depth_first_search"><span>DFS</span></a>.</p></dd></dl><dl><dt class="spec type" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span class="keyword">type</span> 'a tree</code></dt><dd><p>a <a href="Tree/index.html"><code>Tree</code></a> representation.</p></dd></dl><dl><dt class="spec type" id="type-frontier"><a href="#type-frontier" class="anchor"></a><code><span class="keyword">type</span> 'a frontier</code></dt><dd><p>a type representing <a href="Frontier/index.html"><code>Frontier</code></a>s</p></dd></dl><dl><dt class="spec type" id="type-partition"><a href="#type-partition" class="anchor"></a><code><span class="keyword">type</span> 'a partition</code></dt><dd><p>a <a href="Partition/index.html"><span>result</span></a> of partitioning algorithms</p></dd></dl><dl><dt class="spec type" id="type-group"><a href="#type-group" class="anchor"></a><code><span class="keyword">type</span> 'a group</code></dt><dd><p>a partition <a href="Group/index.html"><span>Cell</span></a></p></dd></dl><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> 'a path</code></dt><dd><p>walk without a repetition of edges and inner nodes</p></dd></dl><dl><dt class="spec type" id="type-equiv"><a href="#type-equiv" class="anchor"></a><code><span class="keyword">type</span> equiv</code></dt><dd><p>runtime witness of the <a href="Equiv/index.html"><span>equivalence class</span></a></p></dd></dl><dl><dt class="spec module" id="module-Tree"><a href="#module-Tree" class="anchor"></a><code><span class="keyword">module</span> <a href="Tree/index.html">Tree</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Tree is a particular subtype of a graph for which each node has only one predecessor, and there is only one path between tree root and any other node. Here is an example of a tree:</p></dd></dl><dl><dt class="spec module" id="module-Frontier"><a href="#module-Frontier" class="anchor"></a><code><span class="keyword">module</span> <a href="Frontier/index.html">Frontier</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Frontier maps each node into a possibly empty set of nodes. This is used for representing dominance and post-dominance frontiers.</p></dd></dl><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module</span> <a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Path between two nodes.</p></dd></dl><dl><dt class="spec module" id="module-Partition"><a href="#module-Partition" class="anchor"></a><code><span class="keyword">module</span> <a href="Partition/index.html">Partition</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Result of a set partitioning.</p></dd></dl><dl><dt class="spec module" id="module-Group"><a href="#module-Group" class="anchor"></a><code><span class="keyword">module</span> <a href="Group/index.html">Group</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Group is a non-empty set that is a result of partitioning of an underlying set <code>S</code> into a set of non-intersecting and non-empty subsets that cover set <code>S</code>. See <a href="Partition/index.html"><code>Partition</code></a> for more information.</p></dd></dl><dl><dt class="spec module" id="module-Equiv"><a href="#module-Equiv" class="anchor"></a><code><span class="keyword">module</span> <a href="Equiv/index.html">Equiv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Ordinal for representing equivalence. Useful, for indexing elements based on their equivalence.</p></dd></dl><section><header><h6 id="auxiliary-graph-data-structures"><a href="#auxiliary-graph-data-structures" class="anchor"></a>Auxiliary graph data structures</h6></header><dl><dt class="spec module-type" id="module-type-Predicate"><a href="#module-type-Predicate" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Predicate/index.html">Predicate</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A type of modules for filtering graphs. See <a href="Graphlib/index.html#val-filtered"><code>Graphlib.filtered</code></a> or <a href="Graphlib/Filtered/index.html"><code>Graphlib.Filtered</code></a></p></dd></dl><dl><dt class="spec module-type" id="module-type-Isomorphism"><a href="#module-type-Isomorphism" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Isomorphism/index.html">Isomorphism</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Isomorphism</code> is a bijection between type <code>s</code> and <code>t</code>. Usefull for creating graph views and mapping graphs. See <a href="Graphlib/index.html#val-view"><code>Graphlib.view</code></a> and <a href="Graphlib/Mapper/index.html"><code>Graphlib.Mapper</code></a>.</p></dd></dl><div class="spec class-type" id="class-type-dfs_visitor"><a href="#class-type-dfs_visitor" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span> ['n, 'e, 's]<a href="class-type-dfs_visitor/index.html">dfs_visitor</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></div></section><section><header><h5 id="visual-attributes-for-graph-vizualization."><a href="#visual-attributes-for-graph-vizualization." class="anchor"></a>Visual attributes for graph vizualization.</h5><p>Consult OCamlGraph library for more information.</p></header><dl><dt class="spec type" id="type-node_attr"><a href="#type-node_attr" class="anchor"></a><code><span class="keyword">type</span> node_attr</code><code> = <a href="../../../ocamlgraph/Graph/Graphviz/DotAttributes/index.html#type-vertex">Graph.Graphviz.DotAttributes.vertex</a></code></dt><dt class="spec type" id="type-edge_attr"><a href="#type-edge_attr" class="anchor"></a><code><span class="keyword">type</span> edge_attr</code><code> = <a href="../../../ocamlgraph/Graph/Graphviz/DotAttributes/index.html#type-edge">Graph.Graphviz.DotAttributes.edge</a></code></dt><dt class="spec type" id="type-graph_attr"><a href="#type-graph_attr" class="anchor"></a><code><span class="keyword">type</span> graph_attr</code><code> = <a href="../../../ocamlgraph/Graph/Graphviz/DotAttributes/index.html#type-graph">Graph.Graphviz.DotAttributes.graph</a></code></dt><dt class="spec type" id="type-labeled"><a href="#type-labeled" class="anchor"></a><code><span class="keyword">type</span> ('n, 'a) labeled</code><code> = </code><code>{</code><table class="record"><tr id="type-labeled.node" class="anchored"><td class="def field"><a href="#type-labeled.node" class="anchor"></a><code>node : <span class="type-var">'n</span>;</code></td></tr><tr id="type-labeled.node_label" class="anchored"><td class="def field"><a href="#type-labeled.node_label" class="anchor"></a><code>node_label : <span class="type-var">'a</span>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec module" id="module-Solution"><a href="#module-Solution" class="anchor"></a><code><span class="keyword">module</span> <a href="Solution/index.html">Solution</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A solution to a system of fixed-point equations.</p></dd></dl><dl><dt class="spec module" id="module-Graphlib"><a href="#module-Graphlib" class="anchor"></a><code><span class="keyword">module</span> <a href="Graphlib/index.html">Graphlib</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Generic Graph Library</p></dd></dl></section></div></body></html>