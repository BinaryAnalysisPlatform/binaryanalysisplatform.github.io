<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Graphlib (graphlib.Graphlib.Std.Graphlib)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">graphlib</a> &#x00BB; <a href="../../index.html">Graphlib</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Graphlib</nav><h1>Module <code>Std.Graphlib</code></h1><p>Generic Graph Library</p></header><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Node/index.html">Node</a> : <a href="../../../../regular/Regular/Std/Opaque/index.html#module-type-S">Regular.Std.Opaque.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-Edge/index.html">Edge</a> : <a href="../../../../core_kernel/Core_kernel/index.html#module-type-T">Core_kernel.T</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Graph">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-node">node</a> = <a href="Make/argument-1-Node/index.html#type-t">Node.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/Node/index.html#type-label">Node.label</a> = <a href="Make/argument-1-Node/index.html#type-t">Node.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/Edge/index.html#type-label">Edge.label</a> = <a href="Make/argument-2-Edge/index.html#type-t">Edge.t</a></code></dt><dd><p><code>Make(Node)(Edge)</code> creates a module that implements <code>Graph</code> interface and has unlabeled nodes of type <code>Node.t</code> and edges labeled with <code>Edge.t</code></p></dd></dl><dl><dt class="spec module" id="module-Labeled"><a href="#module-Labeled" class="anchor"></a><code><span class="keyword">module</span> <a href="Labeled/index.html">Labeled</a> : <span class="keyword">functor</span> (<a href="Labeled/argument-1-Node/index.html">Node</a> : <a href="../../../../regular/Regular/Std/Opaque/index.html#module-type-S">Regular.Std.Opaque.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Labeled/argument-2-NL/index.html">NL</a> : <a href="../../../../core_kernel/Core_kernel/index.html#module-type-T">Core_kernel.T</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Labeled/argument-3-EL/index.html">EL</a> : <a href="../../../../core_kernel/Core_kernel/index.html#module-type-T">Core_kernel.T</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Graph">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Labeled/index.html#type-node">node</a> = <span><span>(<a href="Labeled/argument-1-Node/index.html#type-t">Node.t</a>, <a href="Labeled/argument-2-NL/index.html#type-t">NL.t</a>)</span> <a href="../index.html#type-labeled">labeled</a></span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Labeled/Node/index.html#type-label">Node.label</a> = <span><span>(<a href="Labeled/argument-1-Node/index.html#type-t">Node.t</a>, <a href="Labeled/argument-2-NL/index.html#type-t">NL.t</a>)</span> <a href="../index.html#type-labeled">labeled</a></span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Labeled/Edge/index.html#type-label">Edge.label</a> = <a href="Labeled/argument-3-EL/index.html#type-t">EL.t</a></code></dt><dd><p><code>Labeled(Node)(Node_label)(Edge_label)</code> creates a graph structure with both nodes and edges labeled with abitrary types.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/Edge/index.html#type-label">Edge.label</a> = <span class="type-var">'b</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/Node/index.html#type-label">Node.label</a> = <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;nodes:<span><span class="type-var">'a</span> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;edges:<span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>create (module G) ~nodes ~edges ()</code> creates a graph using implementation provided by <code>module G</code>. Example:</p><pre><code class="ml">module G = Graphlib.String.Bool;;
let g = Graphlib.create (module G) ~edges:[
    &quot;entry&quot;, &quot;loop&quot;, true;
    &quot;loop&quot;, &quot;exit&quot;, false;
    &quot;loop&quot;, &quot;loop&quot;, true] ()</code></pre></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>union (module G) g1 g2</code> returns a graph <code>g</code> that is a union of graphs <code>g1</code> and <code>g2</code>, i.e., contains all nodes and edges from this graphs.</p><p>Postcondition: </p><pre>          - N(g) = N(g1) ∪ N(g2).
          - E(g) = E(g1) ∪ E(g2).</pre></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>inter (module G) g1 g2</code> returns a graph <code>g</code> that is an intersection of graphs <code>g1</code> and <code>g2</code>, i.e., it contain and edges from this graphs.</p><p>Postcondition: </p><pre>          - N(g) = N(g1) ∩ N(g2).
          - E(g) = E(g1) ∩ E(g2).</pre></dd></dl><dl><dt class="spec value" id="val-to_dot"><a href="#val-to_dot" class="anchor"></a><code><span class="keyword">val</span> to_dot : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;graph_attrs:<span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span><a href="../index.html#type-graph_attr">graph_attr</a> list</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;node_attrs:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> <span><a href="../index.html#type-node_attr">node_attr</a> list</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;edge_attrs:<span>(<span class="type-var">'e</span> <span>&#45;&gt;</span> <span><a href="../index.html#type-edge_attr">edge_attr</a> list</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;string_of_node:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>?&#8288;string_of_edge:<span>(<span class="type-var">'e</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>?&#8288;channel:<a href="../../../../stdio/Stdio/Out_channel/index.html#type-t">Core_kernel.Out_channel.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;formatter:<a href="../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a></span> <span>&#45;&gt;</span> <span>?&#8288;filename:string</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>to_dot (module G) ~filename:&quot;graph.dot&quot; g</code> dumps graph <code>g</code> using <code>dot</code> format. This is a customizable version of printing function. For most cases it will be enough to use <code>G.pp</code> or <code>G.to_string</code> function. Use this function, if you really need to customize your output.</p><dl><dt>parameter graph_attrs</dt><dd><p>a list of global graph attributes;</p></dd></dl><dl><dt>parameter node_attrs</dt><dd><p>a list of node specific attributes;</p></dd></dl><dl><dt>parameter edge_attrs</dt><dd><p>a list of edge specific attributes;</p></dd></dl><dl><dt>parameter string_of_node</dt><dd><p>used to print nodes;</p></dd></dl><dl><dt>parameter string_of_edge</dt><dd><p>used to print edges;</p></dd></dl><dl><dt>parameter channel</dt><dd><p>where to output the graph;</p></dd></dl><dl><dt>parameter formatter</dt><dd><p>where to output the graph;</p></dd></dl><dl><dt>parameter filename</dt><dd><p>where to output the graph;</p><p>Note: if no output parameter is provided, the graph will not be outputted. More than one output targets is OK. For example, <code>to_dot (module G) ~filename:&quot;graph.dot&quot; ~channel:stdout g</code> will output graph <code>g</code> into both file named <code>&quot;graph.dot&quot;</code> and standard output.</p><p>Note: if <code>string_of_node</code> function is not provided, then graph nodes will be labeled with the reverse post order number.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-depth_first_search"><a href="#val-depth_first_search" class="anchor"></a><code><span class="keyword">val</span> depth_first_search : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;start:<span class="type-var">'n</span></span> <span>&#45;&gt;</span> <span>?&#8288;start_tree:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;enter_node:<span>(int <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;leave_node:<span>(int <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;enter_edge:<span>(<a href="../index.html#type-edge_kind">edge_kind</a> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;leave_edge:<span>(<a href="../index.html#type-edge_kind">edge_kind</a> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'s</span></span> <span>&#45;&gt;</span> <span class="type-var">'s</span></code></dt><dd><p><code>depth_first_search (module G) ~init g</code>. It is the most important algorithm of the Graphlib. It builds a forest of spanning trees of a graph, classifies graph edges and numbers nodes. It is a Swiss-army knife, that is very useful in implementing many other algorithms. You can think of this function as <code>fold</code> on steroids. But unlike <code>fold</code>, that accepts only one function, the <code>depth_first_search</code> accepts 5 different functions, that will be called on different situations, allowing you to «fill in the blanks» of your algorithm.</p><p>Although <code>depth_first_search</code> doesn't allow you to drive the walk itself, there're still ways to do this, using <a href="index.html#val-filtered"><code>filtered</code></a> function. That allows you to hide nodes or edges from the walker, thus effectively erasing them from a graph, without even touching it.</p><dl><dt>parameter rev</dt><dd><p>if true, then the graph <code>g</code> is traversed in a reverse direction. This is essentially the same, as reversing the graph, but make sure, that you've adjusted the start node.</p></dd></dl><dl><dt>parameter start</dt><dd><p>if specified, then the traverse will be started from the node that is equal to node <code>start</code>. Otherwise the traverse is started from the first node of a graph as returned by <code>G.nodes</code>, i.e., usually it is an arbitrary node.</p></dd></dl><dl><dt>parameter start_tree</dt><dd><p><code>node</code> <code>state</code> is called on each new spanning tree started by the algorithm. If all nodes are reachable from the start node, then this function will be called only once. If all nodes of a graph are connected, then this function, will be called only once.</p></dd></dl><dl><dt>parameter enter_node</dt><dd><p><code>pre</code> <code>node</code> <code>state</code> is called when a node is first discovered by the traversal. The number is a preorder number, also known as depth-first number or <code>dfnum</code>. All nodes are entered in a pre-order.</p></dd></dl><dl><dt>parameter leave_node</dt><dd><p><code>rpost</code> <code>node</code> <code>state</code> is called when all successors of a <code>node</code> are left (finished). The provided number is a reverse post order number, that also defines a topological sorting order of a graph. All nodes, are left in a post order.</p></dd></dl><dl><dt>parameter enter_edge</dt><dd><p><code>kind</code> <code>edge</code> <code>state</code> is called when and <code>edge</code> is first discovered. Edge kinds are described below. The destination of the edge may not be discovered (i.e., entered) yet. But the source is already entered (but not finished).</p></dd></dl><dl><dt>parameter leave_edge</dt><dd><p><code>kind</code> <code>edge</code> <code>state</code> is called when the edge destination is at least started.</p><p>Edges classification</p><p>An edge in a spanning tree, produced by a depth first walk, can belong to one of the following category (kind):</p><ul><li>Tree edges constitutes a spanning tree <code>T</code> of a graph;</li><li>Forward edges go from an ancestor to a descendants in a tree <code>T</code>;</li><li>Back edges go from descendants to ancestors in <code>T</code>, including node itself (they are also known as cycle edges).</li><li>Cross edges - all other edges, i.e., such edges for which doesn't go from ancestors to descendants or vice verse. They are possible since, tree defines only partial ordering.</li></ul><p>With respect to a pre-order and reverse post-ordering numbering the source <code>x</code> and a destination <code>y</code> of an edge with a given <code>kind</code> satisfy to the following inequalities:</p><pre>            +---------+-----------------+---------------------+
            | Tree    | pre[x] &lt; pre[y] | rpost[x] &lt; rpost[y] |
            | Forward | pre[x] &lt; pre[y] | rpost[x] &lt; rpost[y] |
            | Back    | pre[x] ≥ pre[y] | rpost[x] ≥ rpost[y] |
            | Cross   | pre[x] &gt; pre[y] | rpost[x] &lt; rpost[y] |
            +---------+-----------------+---------------------+</pre><p>Note: since there can be more than one valid order of traversal of the same graph, (and thus more than one valid spanning tree), depending on a traversal the same edges can be classified differently. With the only exception, that a back edge will be always a back edge, disregarding the particular order.</p><p>Complexity</p><p>The algorithm is linear in time. It uses constant stack space. In fact, for small graphs it uses stack, but for large graphs dynamically switches to a heap storage. The space complexity is bounded by linear function of the graph depth.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-depth_first_visit"><a href="#val-depth_first_visit" class="anchor"></a><code><span class="keyword">val</span> depth_first_visit : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;start:<span class="type-var">'n</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'s</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'n</span>, <span class="type-var">'e</span>, <span class="type-var">'s</span>)</span> <a href="../class-type-dfs_visitor/index.html">dfs_visitor</a></span> <span>&#45;&gt;</span> <span class="type-var">'s</span></code></dt><dd><p><code>depth_first_visit (module G) ~init visitor g</code> allows to specify visiting functions using object. That opens space for re-usability and using open recursion.</p></dd></dl><dl><dt class="spec class" id="class-dfs_identity_visitor"><a href="#class-dfs_identity_visitor" class="anchor"></a><code><span class="keyword">class</span> ['n, 'e, 's] <a href="class-dfs_identity_visitor/index.html">dfs_identity_visitor</a> : <span><span>[<span class="type-var">'n</span>, <span class="type-var">'e</span>, <span class="type-var">'s</span>]</span> <a href="../class-type-dfs_visitor/index.html">dfs_visitor</a></span></code></dt><dd><p>base class with all methods defaults to nothing.</p></dd></dl><dl><dt class="spec value" id="val-reverse_postorder_traverse"><a href="#val-reverse_postorder_traverse" class="anchor"></a><code><span class="keyword">val</span> reverse_postorder_traverse : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;start:<span class="type-var">'n</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../../../../regular/Regular/Std/index.html#type-seq">Regular.Std.seq</a></span></code></dt><dd><p>returns a sequence of nodes in reverse post order.</p></dd></dl><dl><dt class="spec value" id="val-postorder_traverse"><a href="#val-postorder_traverse" class="anchor"></a><code><span class="keyword">val</span> postorder_traverse : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;start:<span class="type-var">'n</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../../../../regular/Regular/Std/index.html#type-seq">Regular.Std.seq</a></span></code></dt><dd><p>returns a sequence of nodes in post order</p></dd></dl><dl><dt class="spec value" id="val-dominators"><a href="#val-dominators" class="anchor"></a><code><span class="keyword">val</span> dominators : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../index.html#type-tree">tree</a></span></code></dt><dd><p><code>dominators (module G) g entry</code> builds a dominators tree for a given graph.</p><p>Definition: a <b>walk</b> is a sequence of alternating nodes and edges, where each edge's endpoints are the preceding and following nodes in the sequence.</p><p>Definition: a node <code>v</code> is <b>reachable</b> if there exists a walk starting from <code>entry</code> and ending with <code>v</code>.</p><p>Definition: node <code>u</code> <b>dominates</b> <code>v</code> if <code>u = v</code> or if all walks from <code>entry</code> to <code>v</code> contains <code>u</code>.</p><p>Definition: node <code>u</code> <b>strictly dominates</b> <code>v</code> if it dominates <code>v</code> and <code>u &lt;&gt; v</code>.</p><p>Definition: node <code>u</code> <b>immediately dominates</b> <code>v</code> if it strictly dominates <code>v</code> and there is no other node that strictly dominates <code>v</code> and is dominated by <code>u</code>.</p><p>Algorithm computes a dominator tree <code>t</code> that has the following properties:</p><ol><li>Sets of graph nodes and tree nodes are equal;</li><li>if node <code>u</code> is a parent of node <code>v</code>, then node <code>u</code> immediately dominates node <code>v</code>;</li><li>if node <code>u</code> is an ancestors of node <code>v</code>, then node <code>u</code> strictly dominates node <code>v</code>;</li><li>if node <code>v</code> is a child of node <code>u</code>, then node <code>u</code> immediately dominates node <code>v</code>;</li><li>if node <code>v</code> is a descendant of node <code>u</code>, then node <code>u</code> strictly dominates node <code>v</code>.</li></ol><p>If every node of graph <code>g</code> is reachable from a provided <code>entry</code> node, then properties (2) - (5) are reversible, i.e., an <code>if</code> statement can be read as <code>iff</code>, and the tree is unique.</p><p>To get a post-dominator tree, reverse the graph by passing <code>true</code> to <code>rev</code> and pass exit node as a starting node.</p><p>Note: although it is not imposed by the algotihm, but it is a good idea to have an entry node, that doesn't have any predecessors. Usually, this is what is silently assumed in many program analysis textbooks, but is not true in general for control-flow graphs that are reconstructed from binaries.</p><p>Note: all nodes that are not reachable from the specified <code>entry</code> node are parented by the <code>entry</code> node.</p></dd></dl><dl><dt class="spec value" id="val-dom_frontier"><a href="#val-dom_frontier" class="anchor"></a><code><span class="keyword">val</span> dom_frontier : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../index.html#type-tree">tree</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../index.html#type-frontier">frontier</a></span></code></dt><dd><p><code>dom_frontier (module G) g dom_tree</code> calculates dominance frontiers for all nodes in a graph <code>g</code>.</p><p>The dominance frontier of a node <code>d</code> is the set of all nodes <code>n</code> such that <code>d</code> dominates an immediate predecessor of <code>n</code>, but <code>d</code> does not strictly dominate <code>n</code>. It is the set of nodes where <code>d</code>'s dominance stops.</p></dd></dl><dl><dt class="spec value" id="val-strong_components"><a href="#val-strong_components" class="anchor"></a><code><span class="keyword">val</span> strong_components : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../index.html#type-partition">partition</a></span></code></dt><dd><p><code>strong_components (module G) g</code> partition graph into strongly connected components. The top of each component is a root node, i.e., a node that has the least pre-order number.</p></dd></dl><dl><dt class="spec value" id="val-shortest_path"><a href="#val-shortest_path" class="anchor"></a><code><span class="keyword">val</span> shortest_path : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;weight:<span>(<span class="type-var">'e</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'e</span> <a href="../index.html#type-path">path</a></span> option</span></code></dt><dd><p><code>shortest_path (module G) ?weight ?rev g u v</code> Find a shortest path from node <code>u</code> to node <code>v</code>.</p><dl><dt>parameter weight</dt><dd><p>defines a weight of each edge. It defaults to 1.</p></dd></dl><dl><dt>parameter rev</dt><dd><p>allows to reverse graph.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_reachable"><a href="#val-is_reachable" class="anchor"></a><code><span class="keyword">val</span> is_reachable : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_reachable (module G) ?rev g u v</code> is true if node <code>v</code> is reachable from node <code>u</code> in graph <code>g</code>. If rev is true, then it will solve the same problem but on a reversed graph.</p></dd></dl><dl><dt class="spec value" id="val-fold_reachable"><a href="#val-fold_reachable" class="anchor"></a><code><span class="keyword">val</span> fold_reachable : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_reachable (module G) ?rev ~init ~f g n</code> applies function <code>f</code> to all nodes reachable from node <code>g</code> in graph <code>g</code>. If <code>rev</code> is true, then the graph is reversed.</p><p>For example, the following will build a set of reachable nodes: <code>fold_reachable (module G) ~init:G.Node.Set.empty ~f:Set.add</code></p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare (module G1) (module G2) g1 g2</code> compares two graphs, with different implementation but the same node type.</p></dd></dl><dl><dt class="spec value" id="val-filtered"><a href="#val-filtered" class="anchor"></a><code><span class="keyword">val</span> filtered : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;skip_node:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;skip_edge:<span>(<span class="type-var">'e</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span></code></dt><dd><p><code>let module G' = filtered (module G) ?skip_node ?skip_edge ()</code> creates a new module <code>G'</code> that can be used at any place instead of <code>G</code>, but that will hide nodes and edges, for which functions <code>skip_node</code> and <code>skip_edge</code> return true.</p><p>Example:</p><pre><code class="ml">let killed_edges = G.Edge.Hash_set.create () in
let module G = Graphlib.filtered (module G)
    ~skip_edge:(Hash_set.mem killed_edges) () in
let rec loop g () =
  (* use (module G) as normal *)
  Hash_set.add killed_edges some_edge;
  (* all edges added to [killed_edges] will no be visible *)</code></pre></dd></dl><dl><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val</span> view : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'e</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/Edge/index.html#type-label">Edge.label</a> = <span class="type-var">'b</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/Node/index.html#type-label">Node.label</a> = <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>node:<span>(<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'f</span>)</span> * <span>(<span class="type-var">'f</span> <span>&#45;&gt;</span> <span class="type-var">'n</span>)</span>)</span></span> <span>&#45;&gt;</span> <span>edge:<span>(<span>(<span class="type-var">'e</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> * <span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'e</span>)</span>)</span></span> <span>&#45;&gt;</span> <span>node_label:<span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'p</span>)</span> * <span>(<span class="type-var">'p</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span>)</span></span> <span>&#45;&gt;</span> <span>edge_label:<span>(<span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> * <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span>)</span></span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-edge">edge</a> = <span class="type-var">'d</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'f</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/Edge/index.html#type-label">Edge.label</a> = <span class="type-var">'r</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/Node/index.html#type-label">Node.label</a> = <span class="type-var">'p</span>)</span></code></dt><dd><p><code>view (module G) ~node ~edge ~node_label ~edge_label</code> creates a proxy module, that will transform back and forward elements of graph, using corresponding functions.</p></dd></dl><dl><dt class="spec module" id="module-To_ocamlgraph"><a href="#module-To_ocamlgraph" class="anchor"></a><code><span class="keyword">module</span> <a href="To_ocamlgraph/index.html">To_ocamlgraph</a> : <span class="keyword">functor</span> (<a href="To_ocamlgraph/argument-1-G/index.html">G</a> : <a href="../index.html#module-type-Graph">Graph</a>) <span>&#45;&gt;</span> <a href="../../../../ocamlgraph/Graph/Sig/index.html#module-type-P">Graph.Sig.P</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="To_ocamlgraph/index.html#type-t">t</a> = <a href="To_ocamlgraph/argument-1-G/index.html#type-t">G.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="To_ocamlgraph/V/index.html#type-t">V.t</a> = <a href="To_ocamlgraph/argument-1-G/index.html#type-node">G.node</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="To_ocamlgraph/E/index.html#type-t">E.t</a> = <a href="To_ocamlgraph/argument-1-G/index.html#type-edge">G.edge</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="To_ocamlgraph/V/index.html#type-label">V.label</a> = <a href="To_ocamlgraph/argument-1-G/Node/index.html#type-label">G.Node.label</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="To_ocamlgraph/E/index.html#type-label">E.label</a> = <a href="To_ocamlgraph/argument-1-G/Edge/index.html#type-label">G.Edge.label</a></code></dt><dd><p><code>To_ocamlgraph(G)</code> returns a module that implements OCamlGraph interface for a persistent graph.</p></dd></dl><dl><dt class="spec module" id="module-Of_ocamlgraph"><a href="#module-Of_ocamlgraph" class="anchor"></a><code><span class="keyword">module</span> <a href="Of_ocamlgraph/index.html">Of_ocamlgraph</a> : <span class="keyword">functor</span> (<a href="Of_ocamlgraph/argument-1-G/index.html">G</a> : <a href="../../../../ocamlgraph/Graph/Sig/index.html#module-type-P">Graph.Sig.P</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Graph">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Of_ocamlgraph/index.html#type-t">t</a> = <a href="Of_ocamlgraph/argument-1-G/index.html#type-t">G.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_ocamlgraph/index.html#type-node">node</a> = <a href="Of_ocamlgraph/argument-1-G/V/index.html#type-t">G.V.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_ocamlgraph/index.html#type-edge">edge</a> = <a href="Of_ocamlgraph/argument-1-G/E/index.html#type-t">G.E.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_ocamlgraph/Node/index.html#type-label">Node.label</a> = <a href="Of_ocamlgraph/argument-1-G/V/index.html#type-label">G.V.label</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_ocamlgraph/Edge/index.html#type-label">Edge.label</a> = <a href="Of_ocamlgraph/argument-1-G/E/index.html#type-label">G.E.label</a></code></dt><dd><p><code>Of_ocamlgraph(O)</code> creates an adapter module, that implements <code>Graphlib</code> interface on top of the module implementing <code>OCamlGraph</code> interface.</p></dd></dl><dl><dt class="spec module" id="module-Filtered"><a href="#module-Filtered" class="anchor"></a><code><span class="keyword">module</span> <a href="Filtered/index.html">Filtered</a> : <span class="keyword">functor</span> (<a href="Filtered/argument-1-G/index.html">G</a> : <a href="../index.html#module-type-Graph">Graph</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Filtered/argument-2-P/index.html">P</a> : <a href="../index.html#module-type-Predicate">Predicate</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Filtered/index.html#type-node">node</a> = <a href="Filtered/argument-1-G/index.html#type-node">G.node</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Filtered/index.html#type-edge">edge</a> = <a href="Filtered/argument-1-G/index.html#type-edge">G.edge</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Graph">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Filtered/index.html#type-t">t</a> = <a href="Filtered/argument-1-G/index.html#type-t">G.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Filtered/index.html#type-node">node</a> = <a href="Filtered/argument-1-G/index.html#type-node">G.node</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Filtered/index.html#type-edge">edge</a> = <a href="Filtered/argument-1-G/index.html#type-edge">G.edge</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="Filtered/Node/index.html">Node</a> = <a href="Filtered/argument-1-G/index.html#module-Node">G.Node</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="Filtered/Edge/index.html">Edge</a> = <a href="Filtered/argument-1-G/index.html#module-Edge">G.Edge</a></code></dt><dd><p>functorized version of a <code>filter</code> function.</p></dd></dl><dl><dt class="spec module" id="module-Mapper"><a href="#module-Mapper" class="anchor"></a><code><span class="keyword">module</span> <a href="Mapper/index.html">Mapper</a> : <span class="keyword">functor</span> (<a href="Mapper/argument-1-G/index.html">G</a> : <a href="../index.html#module-type-Graph">Graph</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Mapper/argument-2-N/index.html">N</a> : <a href="../index.html#module-type-Isomorphism">Isomorphism</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-s">s</a> = <a href="Mapper/argument-1-G/index.html#type-node">G.node</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Mapper/argument-3-E/index.html">E</a> : <a href="../index.html#module-type-Isomorphism">Isomorphism</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-s">s</a> = <a href="Mapper/argument-1-G/index.html#type-edge">G.edge</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Mapper/argument-4-NL/index.html">NL</a> : <a href="../index.html#module-type-Isomorphism">Isomorphism</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-s">s</a> = <a href="Mapper/argument-1-G/Node/index.html#type-label">G.Node.label</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Mapper/argument-5-EL/index.html">EL</a> : <a href="../index.html#module-type-Isomorphism">Isomorphism</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-s">s</a> = <a href="Mapper/argument-1-G/Edge/index.html#type-label">G.Edge.label</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Graph">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-t">t</a> = <a href="Mapper/argument-1-G/index.html#type-t">G.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-node">node</a> = <a href="Mapper/argument-2-N/index.html#type-t">N.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Mapper/index.html#type-edge">edge</a> = <a href="Mapper/argument-3-E/index.html#type-t">E.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Mapper/Node/index.html#type-label">Node.label</a> = <a href="Mapper/argument-4-NL/index.html#type-t">NL.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Mapper/Edge/index.html#type-label">Edge.label</a> = <a href="Mapper/argument-5-EL/index.html#type-t">EL.t</a></code></dt><dd><p>functorized version of <a href="index.html#val-view"><code>Graphlib.view</code></a> function.</p></dd></dl><dl><dt class="spec value" id="val-fixpoint"><a href="#val-fixpoint" class="anchor"></a><code><span class="keyword">val</span> fixpoint : <span>(<span class="keyword">module</span> <a href="../module-type-Graph/index.html">Graph</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-node">node</a> = <span class="type-var">'n</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-Graph/index.html#type-t">t</a> = <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;steps:int</span> <span>&#45;&gt;</span> <span>?&#8288;start:<span class="type-var">'n</span></span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>?&#8288;step:<span>(int <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span>init:<span><span>(<span class="type-var">'n</span>, <span class="type-var">'d</span>)</span> <a href="../Solution/index.html#type-t">Solution.t</a></span></span> <span>&#45;&gt;</span> <span>equal:<span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>merge:<span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'n</span>, <span class="type-var">'d</span>)</span> <a href="../Solution/index.html#type-t">Solution.t</a></span></code></dt><dd><p><code>fixpoint ~equal ~init ~merge ~f g</code> computes a solution for a system of equations denoted by graph <code>g</code>, using the initial approximation <code>init</code> (obtained either with <code>Solution.create</code> or from the previous calls to <code>fixpoint</code>).</p><p>The general representation of the fixpoint equation is</p><pre>          x(i) = f(i) (a(1,i) x(1) %  ... % a(n,i) x(n)),</pre><p>where</p><ul><li><code>x(i)</code> is the value of the <code>i</code>'th variable (node);</li><li><code>a(s,d)</code> is <code>1</code> if there is an edge from the node <code>s</code> to the node <code>d</code> and <code>0</code> otherwise;</li><li><code>%</code> the merge operator;</li><li><code>f(i)</code> is the transfer function for the node <code>i</code>.</li></ul><p>A solution is obtained through a series of iterations until the fixed point is reached, i.e., until the system stabilizes. The total number of iterations could be bound by an arbitrary number. If the maximum number of iterations is reached before the system stabilizes then the solution is not complete. An incomplete solution could be resumed later, or used as it is (for example, in case of ascending chain the solution is always a lower approximation of a real solution, so it is always safe to use it).</p><dl><dt>parameter the</dt><dd><p>upper bound to the number of iterations the solver can make.</p></dd></dl><dl><dt>parameter start</dt><dd><p>the entry node of the graph</p></dd></dl><dl><dt>parameter rev</dt><dd><p>if <code>true</code> then graph is visited in the reverse order, defaults to <code>false</code>.</p></dd></dl><dl><dt>parameter step</dt><dd><p>a function that is called every time a new value of a variable is obtained (an extension point for narrowing/widening).</p></dd></dl><dl><dt>parameter equal</dt><dd><p>compares two approximations for equivalence</p></dd></dl><dl><dt>parameter init</dt><dd><p>initial approximation</p></dd></dl><dl><dt>parameter merge</dt><dd><p>the operator for path merging (usually meet/join depending on a starting point).</p></dd></dl><dl><dt>parameter f</dt><dd><p>the transfer function</p><p>Data Flow Analysis and Abstract Interpretation</p><p>The <code>fixpoint</code> function implements a general fixed pointed iterative solver, that is suitable for implementing data-flow analysis or abstract interpreters. This section will provide some insight on how a particular choice of parameters affects the result of computation. We will start with a small introduction to the theory of Data Flow Analysis and Abstract Interpretation, with respect to the solution of a system of fixed point equations.</p><p>Introduction</p><p>The data domain is a set of values equipped with a partial ordering operation <code>(L,&lt;=)</code>, also know as a poset. We assume, that the poset is bounded complete, i.e., there are two special elements of the set that are called <code>top</code> and <code>bot</code> (the bottom value). The top element is the greatest element of the set L, i.e., for all <code>x</code> in <code>L</code>, <code>x &lt;= top</code>. Correspondingly, the bottom element is the least element of the set <code>L</code>, i.e., for all <code>x</code> in <code>L</code>, <code>bot &lt;= x</code>. It is not required by the framework that the poset has both or any of them, however their presence makes the explanation easier, and since any lattice could be artificially extended with these two elements, their introduction will not introduce a loss of generality. Since values of the lattice <code>L</code> represent information, the partial ordering between two pieces of information <code>a</code> and <code>b</code>, e.g., <code>a &lt;= b</code>, tells us that <code>a</code> contains no more information than <code>b</code>. Therefore the <code>top</code> value contains all the information, representable in the lattice, correspondingly the <code>bot</code> value represents an absence of information. Thus, we will consider the bottom value as an over approximation (or a lower approximation in terms of the lattice ordering relation), as an absence of information cannot contain false statements (vacuous truth). Assuming, that there is some value <code>t</code>, <code>bot &lt;= t &lt;= top</code> that represents a ground truth (that is usually unobtainable), we say that all values that are less than or equal <code>t</code> are over-approximations of the truth, and the rest of the values, are under-approximations. Under-approximations under estimate a behavior of a system, and usually represent information about a system that is not true, hence an under approximate solution, is usually unsafe to use. In general, our task is to find an over approximation that is as close as possible to the ground truth <code>t</code>.</p><p>A solution to a fixed point equation (i.e., an equation of the form <code>x = f(x)</code>) could be obtainted by starting from some initial approximation <code>x0</code> and repeatedly applying <code>f</code> to it, until the solution is found, i.e., <code>x = f(... f(f(x0)) ...)</code>. In general, a function may have multiple (or no at all) fixed points. If a function has several fixed points, then we can distinguish two extremums - the least fixed point <code>lfp</code> and the greatest fixed point <code>gfp</code> w.r.t the ordering of lattice <code>L</code>. Assuming that function <code>f</code> is positive monotonic function (i.e., <code>x &lt;= y</code> implies that <code>f(x) &lt;= f(y)</code>), thechoice of the initial value <code>x0</code> denotes which of the two fixed points is computed. When we start with the bot value, we are ascending from it until the least fixed point is obtained. Dually, if we will start with the top value, we will descend until the maximal fixpoint is reached. Assuming that both fixpoints are lower approximations of the ground truth, we can easily see, that the maximal fixpoint solution is more attractive, as it bears more information than the minimal (unless both are the same). However, the ascending search, bears a nice property, that any intermediate solution is an over-approximation of the ground truth (i.e., we are monotonically aggregating facts).</p><p>In general, a function may not have a solution at all, or the solution may not be computable in practice, i.e., when the chain of function applications <code>x = f(... f(x0) ...)</code> is either infinite or effectively infinite (e.g., 2^64 applications). The Tarksi theorem states that if <code>L</code> is complete and <code>f</code> is monotone, then it has a fixed point. If a lattice has a limited height (maximum length of chain of elements, such that x0 &lt; x1 &lt; .. &lt; xM) then we will obtain a solution in no more than <code>M</code> steps. However, if <code>M</code> is very big, or infinite, then the solution won't be find in general, and the computation may not terminate.</p><p>This brings us to the main distinction between Abstract Interpretation and Data Flow Analysis. The latter usually deals with lattice that have finite heights, while the former deals with very big and infinite lattices. To accelerate the convergence of a chain of approximations, a special technique called <code>widening</code> is used. Widening can be seen as an operation that jumps over several applications of the function <code>f</code>, hence it actually accelerates the convergence. Given, that widening jumps forward in the chain, it is possible to overshoot the fixed point solution. This can potential involve a lossage of precision (in case of the descending chain) or to an incorrect solution (in case of the ascending chain).</p><p>So far, we were considering only one equation. However, we need to solve a system of equations, denoted by a graph (as graph denotes a boolean adjacency matrix <code>A = {a(i,j)}</code>, such that <code>a(i,j)</code> is <code>1</code> if there is an edge from <code>i</code> to <code>j</code>, and <code>0</code> otherwise). To solve the system of equations, we need to find such vector <code>x1,..,xM</code> that solves all equations. In general, a system may not have a solution (an over-constrainted system), may have one solution, and may have many solutions (under constrained system). In our case, the system is not linear, as each equation is function of type <code>L -&gt; L</code> not <code>L^M -&gt; N</code>, since all input variables are merged with some operator, usually <code>meet</code> or <code>join</code>. A correct choice of the merge opeator ensures correctness and convergence of the solution.</p><p>The <code>meet</code> operator is a commutative, associative, and idempotent operator, such that if <code>z = meet x y</code>, then <code>z &lt;= x
        &amp;&amp; z &lt;= y</code> and for all <code>w</code> in <code>L</code>, <code>w &lt;= x &amp;&amp; w &lt;= y</code> implies <code>w &lt;=
        z</code>. The <code>z</code> value is called the greatest lower bound (<code>glb</code>, or <code>inf</code>) of <code>x</code> and <code>y</code>. Intuitively, the <code>meet</code> operator takes two pieces of information and removes all contradictions. Thus <code>z</code> is the maximal consensus between <code>x</code> and <code>y</code>. The <code>top</code> element is the neutral element with respect to the <code>meet</code> operation, e.g., <code>meet x top = x</code>. A consequent application of the <code>meet</code> operation builds a <i>descending chain</i> of approximations, i.e., the amount of information is reduced on each step.</p><p>The <code>join</code> operator is dual to <code>meet</code> and is defined correspondingly (with the flipped order). A join of <code>x</code> and <code>y</code> is called the least upper bound (<code>lub</code>, <code>sup</code>) of <code>x</code> and <code>y</code>. Intuitively, the <code>join</code> operator takes two non-contradictory pieces information and returns their concatenation. The <code>bot</code> element is the neutral element with respect to the <code>join</code> operation, e.g., <code>join x bot = x</code>. A consequent application of the <code>join</code> operation builds an ascending chain of approximations, i.e., the amount of information is increased on each step.</p><p>Using the <code>fixpoint</code> function</p><p>The <code>fixpoint</code> interface is trying to be as general as possible, but at the same time easy to use. The interface, allows a user to choose the direction of approximation (ascending vs. descending) and how to accelerate the convergence in case of tall lattices by applying narrowing and widening. The implementation fixes the iteration strategy (by always using the topological ordering). In case if you need a fixed point solver, that allows you to use different iteration strategies, the <code>fixpoint</code><code>1</code> library provides a descent alternative.</p><p><code>1</code>: http://pop-art.inrialpes.fr/people/bjeannet/bjeannet-forge/fixpoint/</p><p>Using <code>fixpoint</code> for Classical Data Flow analysis</p><p>The classical Data Flow analysis uses the descending chain of approximations in a complete lattice with finite (usually very small) height. Thus, the <code>fixpoint</code> solution is the greatest (maximal) fixed point (a maximal set of facts on which all equations agree). If the transfer function <code>f</code> is monotone and distributive, then it is the meet-over-paths (mop) solution, in a more general case <code>gfp &lt;= mop</code> and <code>mop &lt;= t</code> (where <code>t</code> is the ground truth). (Note, <code>gfp</code> is of course the best solution to the system of equations, as it is the maximal of all solutions. Both <code>mop</code> and <code>t</code> are not solutions to the given system, but define the true properties of a system under test, that we are trying to model with the system of fixed point equations. The fact that <code>gfp</code> is smaller, indicates that our model looses the precision (i.e., it is overconstrained). For example, the meet-over-path solution is a meet of all possible paths, even those that are infeasible, thus the system is overconstrained as we are taking into account system behaviors that will never happen, this is however safe, to overconstraint a system, as it will give us an over-approximation of a real system behavior).</p><p>The <code>fixpoint</code> function could be easily applied to both forward and backward data flow problem, as backward problem could be seen as a forward problem on a reversed graph. To effectively reverse a graph, set the <code>rev</code> flag to <code>true</code> and set the <code>enter</code> parameter to the <code>exit</code> node.</p><p>Using <code>fixpoint</code> for Abstract Interpretation</p><p>Abstract Interpretation usually deals with complex and large lattices, and applies different heuristics to ensure termination with the minimum loss of precision. This usually ends up in applying widening and narrowing operations. Since widening accelerates by jumping forward in the chain of approximations, it can easily overshoot a fixed point, and in case of the ascending chain this may lead to a solution that is an under approximation of the ground truth. Thus, abstract interpretation is usually applied in the descending order. In this case the <code>widen</code> operation may still overshot the maximal fixpoint, that will lead to an over-approximation of the ground truth, that is safe, but still looses precision. Therefore, it is necessary to apply widening as rarely as possible. Unfortunately, a question where and when to apply widening is undecidable by itself, that's why heuristics are used. The <code>fixpoint</code> function, provides a limited capabilities to control widening via the <code>step i n x
        x'</code> function that is called every time a new <code>i</code>'th approximation <code>x'</code> for variable <code>n</code> is computed. The <code>step</code> function must return an upper bound (not necessary the least one) of the previous approximation <code>x</code> and the new approximation <code>x'</code>. The default, implementation just returns <code>x'</code>. An alternative implementation may widen <code>x'</code> if the number of steps <code>i</code> in the chain is higher than some threshold, and/or if <code>x</code> is a widening point (e.g., the loop header).</p><p>Note: terms widening and narrowing comes from the interval analysis where they were first introduced, and correspond to the widening of an interval (usually up to infinitiy) and narrowing a widened interval based on some heurisitic.</p><p>Using <code>fixpoint</code> for general iterative approximation</p><p>In a general case, the <code>fixpoint</code> function could be used to compute successive approximations of a solution to a system of (in)equations, even if <code>f</code> is not monotone, and the lattice is not finite. The termination could be guaranteed by limiting the maximum number of iterations. And the correctness could be ensured by starting from the bottom element, and using the ascending chain of approximations. In that case, even a partially complete solution would be an over-approximation of a real solution. The obtained partial solution could be later resumed (and possibly extended with newly obtained facts).</p><p>Implementation</p><p>The <code>fixpoint</code> uses the Kildall iterative algorithm. And applies equations in reverse postorder (topological order). The solution is represented as an abstract finite mapping, that is also used to specify the initial set of constraints and the initial value of unconstrained variables. It is possible to specify more than one constraint to the system of equation (as opposed to the classical approach where the constraint denotes only the input for the entry node).</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-scheme"><a href="#type-scheme" class="anchor"></a><code><span class="keyword">type</span> scheme</code></dt><dd><p>name generation scheme</p></dd></dl><dl><dt class="spec type" id="type-symbolizer"><a href="#type-symbolizer" class="anchor"></a><code><span class="keyword">type</span> <span>'a symbolizer</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p>a function that gives a name for a value of type <code>'a</code></p></dd></dl><dl><dt class="spec value" id="val-create_scheme"><a href="#val-create_scheme" class="anchor"></a><code><span class="keyword">val</span> create_scheme : <span>next:<span>(string <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-scheme">scheme</a></code></dt><dd><p><code>create_scheme ~next init</code> create a name generator, that will start with <code>init</code> and apply <code>next</code> on it infinitly.</p></dd></dl><dl><dt class="spec value" id="val-symbols"><a href="#val-symbols" class="anchor"></a><code><span class="keyword">val</span> symbols : <a href="index.html#type-scheme">scheme</a></code></dt><dd><p>lower case symbols, starting from 'a' and moving up to 'z'. As 'z' is reached, all foregoing symbols will have a form of 'node_N' where 'N' is an increasing natural number.</p></dd></dl><dl><dt class="spec value" id="val-numbers"><a href="#val-numbers" class="anchor"></a><code><span class="keyword">val</span> numbers : <a href="index.html#type-scheme">scheme</a></code></dt><dd><p>numbers from zero to inifinity (<code>Sys.max_int</code> in fact)</p><p>empty string</p></dd></dl><dl><dt class="spec value" id="val-nothing"><a href="#val-nothing" class="anchor"></a><code><span class="keyword">val</span> nothing : <a href="index.html#type-scheme">scheme</a></code></dt><dd><p>empty string</p></dd></dl><dl><dt class="spec value" id="val-by_given_order"><a href="#val-by_given_order" class="anchor"></a><code><span class="keyword">val</span> by_given_order : <a href="index.html#type-scheme">scheme</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbolizer">symbolizer</a></span></code></dt><dt class="spec value" id="val-by_natural_order"><a href="#val-by_natural_order" class="anchor"></a><code><span class="keyword">val</span> by_natural_order : <a href="index.html#type-scheme">scheme</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-symbolizer">symbolizer</a></span></code></dt></dl><dl><dt class="spec module" id="module-Dot"><a href="#module-Dot" class="anchor"></a><code><span class="keyword">module</span> <a href="Dot/index.html">Dot</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Generic dot printer.</p></dd></dl></div></body></html>