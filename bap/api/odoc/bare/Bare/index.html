<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bare (bare.Bare)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bare</a> &#x00BB; Bare</nav><h1>Module <code>Bare</code></h1><nav class="toc"><ul><li><a href="#example">Example</a></li><li><a href="#syntax">Syntax</a><ul><li><a href="#concrete-syntax">Concrete Syntax</a></li><li><a href="#abstract-syntax">Abstract Syntax</a></li></ul></li><li><a href="#semantics">Semantics</a></li></ul></nav></header><aside><p>Binary Analysis Rule Engine (BARE).</p><p>The Binary Analysis Rule Engine is a production system (a forward chaining rule system) that is used in the Binary Analysis Platform, and features non-linear pattern matching and a stream based approach to the state of the world.</p><p>BARE defines the syntax and semantics of a rule specification language, and provides a simple pattern matching engine. The semantics of facts, as well as the semantics of the evaluation loop are left to concrete implementations of interpreters.</p><p>A BARE specification consists of a sequence of rules. Each rule is a pair. The first element, called the left hand side, is a list of tuples that represents patterns that should be matched with facts. The second element, called the right hand side, is a list of tuples that represents the list of facts that should be produced once all patterns on the left hand side match with the provided facts. A rule is applied to a stream of facts, if all patterns in a rule matches with some facts, then a rule is triggered and produces facts from the right hand side. A rule may have variables on the left hand side, that will bind to elements of a fact tuple that matched with a pattern. The same variable may occur in different patterns of the same rule, i.e., a pattern is not required to be linear. When the same variable occurs in two patterns of the same rule, then a constraint is imposed that this variable should be bound to the same term in both patterns. The order of the patterns in the left hand side doesn't matter, thus the semantics of rule doesn't change with the permutation of its patterns. The order of facts may matter, depending on a concrete interpretation of fact. If a rule is applied to different permutations of a list of facts it may produce different sequences of facts, though all derivable facts will be produced.</p><p>BARE represents tuples with S-expressions and variables with atoms that start with the question mark (?). A single question mark character represents a wild card variable that matches with everything but cannot be used on the right hand side of a rule. Since the right hand side of a rule may contain more than one pattern the engine will perform the join operation on a stream of events. Given that any join operation generates a number of matches that is in general a polynomial function of the number of patterns, a caution should be used by an expert who builds a system with complex rules that contains many patterns in the same rule. BARE can't apply any query optimization techniques on a rule, given the open and extensible notion of a fact. Thus BARE should be considered as a base representation for the pattern/action forward chanining systems, that shall perform all the necessary optimizations on their level.</p></aside><section><header><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>Suppose we want to process a stream of events that represent the behavior of some memory allocator. We expect the following kinds of events:</p><ul><li><code>(acquire SITE PTR LEN)</code> represents an allocation event, where SITE is an allocation site (i.e., an address of a program instruction that performs an allocation), <code>PTR</code> is a pointer to the allocated data, and <code>LEN</code> is the data size;</li></ul><ul><li><code>(release SITE PTR LEN)</code> represents a memory deallocation event;</li></ul><ul><li><code>(violate SITE PTR KIND)</code> represents a violation of a memory allocator invariants of the specified KIND.</li></ul><p>Suppose we want to build a rule, that will report each violation as a tuple that contains a kind of the violation and all three sites, that are involved in the incident.</p><pre>    (((acquire ?asite ?ptr ?)
      (release ?rsite ?ptr ?)
      (violate ?vsite ?ptr ?kind)

     ((?kind ?asite ?rsite ?vsite)))</pre><p>This rule can be read as, for all acquire, release, and violate events that have the same <code>PTR</code> produce a fact of a violation of the specified kind that contains the program locations of these three events. For example, given the following sequence of events:</p><pre>      (acquire L10 0xBAD 10)
      (release L20 0XBAD 10)
      (violate L30 0XBAD use-after-free)
      (violate L40 0xBAD double-free)
      (violate L50 0XBAD use-after-free)</pre><p>The following facts will be produced if the rule is sequentially applied to the above sequence:</p><pre>      (use-after-free L10 L20 L30)
      (double-free L10 L20 L40)
      (use-after-free L10 L20 L50)</pre></header></section><section><header><h3 id="syntax"><a href="#syntax" class="anchor"></a>Syntax</h3></header><section><header><h4 id="concrete-syntax"><a href="#concrete-syntax" class="anchor"></a>Concrete Syntax</h4><p>A tuple is represented by an arbitrary S-expression. A variable is an atom that starts with the question mark. A special variable <code>?</code> (one question mark symbol) may occur on the left hand side of a rule, and represents a freshly created variable. Every occurrence of the <code>?</code> symbol represents a different variable. Both sides of a rule may be empty (represented by the 0-tuple <code>()</code>).</p><pre>    rule,r  ::= ((p1 .. pM) (f1 .. fN))
    sexp,s  ::= atom | (s1 .. sM)
    patt,p  ::= sexp
    fact,f  ::= sexp
    atom,a  ::= ?sequence-of-chars?</pre><p>Example:</p><pre>    (((duck ?name) (does ?action)) ((looks like ?name did ?action)))</pre><p>This rule contains two patterns <code>(duck ?name)</code> and <code>(does ?action)</code> and one production fact <code>(looks like ?name did ?action)</code>.</p></header></section><section><header><h4 id="abstract-syntax"><a href="#abstract-syntax" class="anchor"></a>Abstract Syntax</h4><p>A rule r is a tuple (P,F) where P is a sequence of patterns p1,...,pM, F is a sequence of facts f1,...,fN, and M,N are non-negative numbers. A pattern p and fact f are arbitrary n-tuples (terms) t, that contain atoms, other tuples, and free variables.</p><pre>    rule,r ::= (B,P,F)
    P ::= p1,...
    F ::= f1,...
    B ::= v1-&gt;f,...
    V ::= v1,...
    T ::= t1,...
    term,p,f,s,t ::= v | a | (t,..,tM)
    atom,x,y,z ::= ?atom?
    v ::= ?variable?</pre></header></section></section><section><header><h3 id="semantics"><a href="#semantics" class="anchor"></a>Semantics</h3><p>We use a regular sequent calculus (with all structural rules) to represent semantics. A rule with a sequence of patterns P matches with a sequence of facts with the given valuations, denoted as <code>B,T |- P</code>, if it can be proved using the rules below (plus regular rules of the sequent calculus). The (match-rule) rule, expands rules (eliminating tuples on the top level). The (match-tuple) rule further expands patterns until each pattern is either an atom, in that case it is proved by the axiom of identity, or to a variable, in that case a match can be proved with the (match-var) rule, that says that a variable matches a term only if it is bound to that term.</p><p>Note, that exchange and weakening rules of sequent calculus allows us to drop and rearrange facts. The latter makes the order of rules irrelevant. If for a sequence of facts, there are several valuations of variables that will lead to a match, then all these matches are provided. In other words, the engine will generate all derivable facts in an unspecified but consistent order.</p><pre>     B,T |- p1 .. B,T |- pM
     ----------------------- (match-rule)
     B,T |- (p1,..,pM)


     B,t1,T |- s1 .. B,tM,T |- sM
     ---------------------------- (match-tuple)
     B,(t1,..,tM),T |- (s1,..,sM)


     B,T |- v-&gt;t
     ---------- (match-var)
     B,t,T |- v</pre></header><dl><dt class="spec type" id="type-tuple"><a href="#type-tuple" class="anchor"></a><code><span class="keyword">type</span> tuple</code><code> = <a href="../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core_kernel.Sexp.t</a></code></dt><dd><p>representation of a tuple</p></dd></dl><dl><dt class="spec type" id="type-fact"><a href="#type-fact" class="anchor"></a><code><span class="keyword">type</span> fact</code><code> = <a href="index.html#type-tuple">tuple</a></code></dt><dd><p>representation of a fact</p></dd></dl><dl><dt class="spec module" id="module-Rule"><a href="#module-Rule" class="anchor"></a><code><span class="keyword">module</span> <a href="Rule/index.html">Rule</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Matching rule specification.</p></dd></dl></section></div></body></html>