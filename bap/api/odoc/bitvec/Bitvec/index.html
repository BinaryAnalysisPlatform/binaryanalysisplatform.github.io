<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bitvec (bitvec.Bitvec)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">bitvec</a> &#x00BB; Bitvec</nav><header class="odoc-preamble"><h1>Module <code><span>Bitvec</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>abstract representation of a fixed size bitvector</p></div></div><div class="odoc-spec"><div class="spec type" id="type-m" class="anchored"><a href="#type-m" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a m</span></span></code></div><div class="spec-doc"><p>a computation in some modulo</p></div></div><div class="odoc-spec"><div class="spec type" id="type-modulus" class="anchored"><a href="#type-modulus" class="anchor"></a><code><span><span class="keyword">type</span> modulus</span></code></div><div class="spec-doc"><p>type denoting the arithmetic modulus</p></div></div><div class="odoc-spec"><div class="spec value" id="val-modulus" class="anchored"><a href="#val-modulus" class="anchor"></a><code><span><span class="keyword">val</span> modulus : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-modulus">modulus</a></span></code></div><div class="spec-doc"><p><code>modulus s</code> is the modulus of bitvectors with size <code>s</code>.</p><p>This is a number $2^s-1$, also known as a Mersenne number.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-m1" class="anchored"><a href="#val-m1" class="anchor"></a><code><span><span class="keyword">val</span> m1 : <a href="#type-modulus">modulus</a></span></code></div><div class="spec-doc"><p><code>m1 = modulus 1</code> = $1$ is the modulus of bitvectors with size <code>1</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-m8" class="anchored"><a href="#val-m8" class="anchor"></a><code><span><span class="keyword">val</span> m8 : <a href="#type-modulus">modulus</a></span></code></div><div class="spec-doc"><p><code>m8 = modulus 8</code> = $255$ is the modulus of bitvectors with size <code>8</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-m16" class="anchored"><a href="#val-m16" class="anchor"></a><code><span><span class="keyword">val</span> m16 : <a href="#type-modulus">modulus</a></span></code></div><div class="spec-doc"><p><code>m16 = modulus 16</code> = $65535$ is the modulus of bitvectors with size <code>16</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.5.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-m32" class="anchored"><a href="#val-m32" class="anchor"></a><code><span><span class="keyword">val</span> m32 : <a href="#type-modulus">modulus</a></span></code></div><div class="spec-doc"><p><code>m32 = modulus 32</code> = $2^32-1$ is the modulus of bitvectors with size <code>32</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-m64" class="anchored"><a href="#val-m64" class="anchor"></a><code><span><span class="keyword">val</span> m64 : <a href="#type-modulus">modulus</a></span></code></div><div class="spec-doc"><p><code>m64 = modulus 64</code> = $2^64-1$ is the modulus of bitvectors with size <code>64</code></p></div></div><div class="odoc-spec"><div class="spec value external" id="val-(mod)" class="anchored"><a href="#val-(mod)" class="anchor"></a><code><span><span class="keyword">val</span> (mod) : <span><span><span class="type-var">'a</span> <a href="#type-m">m</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-modulus">modulus</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>(x &lt;op&gt; y) mod m</code> applies operation <code>&lt;op&gt;</code> modulo <code>m</code>.</p><p>Example: <code>(x + y) mod m</code> returns the sum of <code>x</code> and <code>y</code> modulo <code>m</code>.</p><p>Note: the <code>mod</code> function is declared as a primitive to enable support for inlining in non flambda versions of OCaml. Indeed, underneath the hood the <code>'a m</code> type is defined as the reader monad <code>modulus -&gt; 'a</code>, however we don't want to create a closure every time we compute an operation over bitvectors. With this trick, all versions of OCaml no matter the optimization options will inline <code>(x+y) mod m</code> and won't create any closures, even if <code>m</code> is not known at compile time.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare x y</code> compares <code>x</code> and <code>y</code> as unsigned integers, i.e., <code>compare x y</code> = <code>compare (to_nat x) (to_nat y)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal x y</code> is true if <code>x</code> and <code>y</code> represent the same integers</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;)" class="anchored"><a href="#val-(&lt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>x &lt; y</code> iff <code>compare x y = -1</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;)" class="anchored"><a href="#val-(&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>x &lt; y</code> iff <code>compare x y = -1</code></p><p><code>x &gt; y</code> iff <code>compare x y =  1</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(=)" class="anchored"><a href="#val-(=)" class="anchor"></a><code><span><span class="keyword">val</span> (=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>x &gt; y</code> iff <code>compare x y =  1</code></p><p><code>x = y</code> iff <code>compare x y =  0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;&gt;)" class="anchored"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&gt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>x = y</code> iff <code>compare x y =  0</code></p><p><code>x &lt;&gt; y</code> iff <code>compare x y &lt;&gt; 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;=)" class="anchored"><a href="#val-(&lt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>x &lt;&gt; y</code> iff <code>compare x y &lt;&gt; 0</code></p><p><code>x &lt;= y</code> iff <code>compare x y &lt;= 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;=)" class="anchored"><a href="#val-(&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>x &lt;= y</code> iff <code>compare x y &lt;= 0</code></p><p><code>x &gt;= y</code> iff <code>compare x y &gt;= 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash x</code> returns such <code>z</code> that forall <code>y</code> s.t. <code>x=y</code>, <code>hash y = z</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp ppf x</code> is a pretty printer for the bitvectors.</p><p>Could be used standalone or as an argument to the <code>%a</code> format specificator, e.g.,</p><pre><code>Format.fprintf &quot;0xBEEF != %a&quot; Bitvec.pp !$&quot;0xBEAF&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-to_binary" class="anchored"><a href="#val-to_binary" class="anchor"></a><code><span><span class="keyword">val</span> to_binary : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_binary x</code> returns a canonical binary representation of <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_binary" class="anchored"><a href="#val-of_binary" class="anchor"></a><code><span><span class="keyword">val</span> of_binary : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_binary s</code> returns a bitvector <code>x</code> s.t. <code>to_binary x = s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string x</code> returns a textual (human readable) representation of the bitvector <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string s</code> returns a bitvector that corresponds to <code>s</code>.</p><p>The set of accepted strings is defined by the following EBNF grammar:</p><pre>       valid-numbers ::=
        | &quot;0b&quot;, bin-digit, {bin-digit}
        | &quot;0o&quot;, oct-digit, {oct-digit}
        | &quot;0x&quot;, hex-digit, {hex-digit}
        | dec-digit, {dec-digit}

      bin-digit ::= '0' | '1'
      oct-digit ::= '0'-'7'
      dec-digit ::= '0'-'9'
      hex-digit ::= '0'-'9' |'a'-'f'|'A'-'F'</pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the string <code>s</code> is not recognized as <code>valid-numbers</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-bigint_unsafe" class="anchored"><a href="#val-bigint_unsafe" class="anchor"></a><code><span><span class="keyword">val</span> bigint_unsafe : <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>bigint_unsafe x</code> directly interprets a zarith value as bitvector.</p><p>The function is safe only if <code>x</code> is the result of <code>to_bigint</code>, otherwise the resulting value is unpredictable.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.5.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_substring" class="anchored"><a href="#val-of_substring" class="anchor"></a><code><span><span class="keyword">val</span> of_substring : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_substring ~pos ~len s</code> is a bitvector that corresponds to a substring of <code>s</code> designated by the start position <code>pos</code> and length <code>len</code>.</p><p>The result is the same as <code>of_string (String.sub s pos len)</code>, except that no intermediate substring is created.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>is the starting position of the substring (defaults to <code>0</code>)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>is the length of the substring (defaults to the length of <code>s</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>pos</code> and <code>len</code> together do not define a valid substring of <code>s</code> or if the substring is not a sequence of numbers of the base <code>b</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string_base" class="anchored"><a href="#val-of_string_base" class="anchor"></a><code><span><span class="keyword">val</span> of_string_base : <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string_base b x</code> is a bitvector that corresponds to <code>s</code> represented in base <code>b</code>.</p><p>The base <code>b</code> must be between <code>2</code> and <code>16</code>. The textual representation shall not contain a prefix that designates the base and must be a sequence of digits that are less than <code>b</code>.</p><p>Examples</p><p>Valid inputs:</p><ul><li><code>of_string_base 16 &quot;DEADBEEF&quot;</code>;</li><li><code>of_string_base 2 &quot;010110&quot;</code>;</li><li><code>of_string_base 11 &quot;AAAAAA&quot;</code>.</li></ul><p>Invalid inputs:</p><ul><li><code>of_string_base 16 &quot;0xDEADBEEF&quot;</code>;</li><li><code>of_string_base 2  &quot;-010100&quot;</code>;</li><li><code>of_string_base 10 &quot;AAAAA&quot;</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_substring_base" class="anchored"><a href="#val-of_substring_base" class="anchor"></a><code><span><span class="keyword">val</span> of_substring_base : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_substring_base b x</code> is a bitvector that corresponds to a substring of <code>s</code> designated by the start position <code>pos</code> and length <code>len</code> that is a sequence of digits in base <code>b</code>.</p><p>The result is the same as <code>of_string_base b x (String.sub s pos
    len)</code>, except that no intermediate substring is created.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>is the starting position of the substring (default to <code>0</code>)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>is the length of the substring (defaults to the length of <code>s</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>pos</code> and <code>len</code> together do not define a valid substring of <code>s</code> or if the substring is not a sequence of numbers of the base <code>b</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fits_int" class="anchored"><a href="#val-fits_int" class="anchor"></a><code><span><span class="keyword">val</span> fits_int : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>fits_int x</code> is <code>true</code> if <code>x</code> could be represented with the OCaml <code>int</code> type.</p><p>Note: it is not always true that <code>fits_int (int x mod m)</code>, since depending on <code>m</code> a negative number might not fit into the OCaml representation. For positive numbers it is true, however.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int" class="anchored"><a href="#val-to_int" class="anchor"></a><code><span><span class="keyword">val</span> to_int : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>to_int x</code> returns an OCaml integer that has the same representation as <code>x</code>.</p><p>The function is undefined if <code>not (fits_int x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fits_int32" class="anchored"><a href="#val-fits_int32" class="anchor"></a><code><span><span class="keyword">val</span> fits_int32 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>fits_int32 x</code> is <code>true</code> if <code>x</code> could be represented with the OCaml <code>int</code> type.</p><p>Note: it is not always true that <code>fits_int32 (int32 x mod m)</code>, since depending on <code>m</code> the negative <code>x</code> may not fit back into the <code>int32</code> representation. For positive numbers it is true, however.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int32" class="anchored"><a href="#val-to_int32" class="anchor"></a><code><span><span class="keyword">val</span> to_int32 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>to_int32 x</code> returns an OCaml integer that has the same representation as <code>x</code>.</p><p>The function is undefined if <code>not (fits_int32 x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fits_int64" class="anchored"><a href="#val-fits_int64" class="anchor"></a><code><span><span class="keyword">val</span> fits_int64 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>fits_int64 x</code> is <code>true</code> if <code>x</code> could be represented with the OCaml <code>int</code> type.</p><p>Note: it is not always true that <code>fits_int64 (int64 x mod m)</code>, since depending on <code>m</code> the negative <code>x</code> might not fit back into the <code>int64</code> representation. For positive numbers it is true, however.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int64" class="anchored"><a href="#val-to_int64" class="anchor"></a><code><span><span class="keyword">val</span> to_int64 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>to_int64 x</code> returns an OCaml integer that has the same representation as <code>x</code>.</p><p>The function is undefined if <code>not (fits_int64 x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_bigint" class="anchored"><a href="#val-to_bigint" class="anchor"></a><code><span><span class="keyword">val</span> to_bigint : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Z</span>.t</span></code></div><div class="spec-doc"><p><code>to_bigint x</code> returns a natural number that corresponds to <code>x</code>.</p><p>The returned value is always positive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extract" class="anchored"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : <span>hi:int <span class="arrow">&#45;&gt;</span></span> <span>lo:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extract ~hi ~lo x</code> extracts bits from <code>lo</code> to <code>hi</code>.</p><p>The operation is effectively equivalent to <code>(x lsr lo) mod (hi-lo+1)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-select" class="anchored"><a href="#val-select" class="anchor"></a><code><span><span class="keyword">val</span> select : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>select bits x</code> builds a bitvector from <code>bits</code> of <code>x</code>.</p><p>Returns a bitvector <code>y</code> such that <code>nth</code> bit of it is equal to <code>List.nth bits n</code> bit of <code>x</code>.</p><p>Returns <code>zero</code> if <code>bits</code> are empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>append m n x y</code> takes <code>m</code> bits of <code>x</code> and <code>n</code> bits of <code>y</code> and returns their concatenation. The result has <code>m+n</code> bits.</p><p>Examples:</p><ul><li><code>append 16 16 !$&quot;0xdead&quot; !$&quot;0xbeef&quot; = !$&quot;0xdeadbeef&quot;</code>;</li><li><code>append 12 20 !$&quot;0xbadadd&quot; !$&quot;0xbadbeef&quot; = !$&quot;0xadddbeef&quot;</code>;;</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span>int <span class="arrow">&#45;&gt;</span></span> <span>times:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>repeat m ~times:n x</code> repeats <code>m</code> bits of <code>x</code> <code>n</code> times.</p><p>The result has <code>m*n</code> bits.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>concat m xs</code> concatenates <code>m</code> bits of each <code>x</code> in <code>xs</code>.</p><p>The operation is the reduction of the <code>append</code> operation with <code>m=n</code>. The result has <code>m * List.length xs</code> bits and is equal to <code>0</code> if <code>xs</code> is empty.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> := <span><span class="type-var">'a</span> <a href="#type-m">m</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-bool" class="anchored"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>bool x</code> returns <code>one</code> if <code>x</code> and <code>zero</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int" class="anchored"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>int n mod m</code> is <code>n</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int32" class="anchored"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>int32 n mod m</code> is <code>n</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int64" class="anchored"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <span>int64 <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>int64 n mod m</code> is <code>n</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bigint" class="anchored"><a href="#val-bigint" class="anchor"></a><code><span><span class="keyword">val</span> bigint : <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>bigint n mod m</code> is <code>n</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zero" class="anchored"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>zero</code> is <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-one" class="anchored"><a href="#val-one" class="anchor"></a><code><span><span class="keyword">val</span> one : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>one</code> is <code>1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ones" class="anchored"><a href="#val-ones" class="anchor"></a><code><span><span class="keyword">val</span> ones : <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>ones mod m</code> is a bitvector of size <code>m</code> with all bits set</p></div></div><div class="odoc-spec"><div class="spec value" id="val-succ" class="anchored"><a href="#val-succ" class="anchor"></a><code><span><span class="keyword">val</span> succ : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>succ x mod m</code> is the successor of <code>x</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-nsucc" class="anchored"><a href="#val-nsucc" class="anchor"></a><code><span><span class="keyword">val</span> nsucc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>nsucc x n mod m</code> is the <code>n</code>th successor of <code>x</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pred" class="anchored"><a href="#val-pred" class="anchor"></a><code><span><span class="keyword">val</span> pred : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>pred x mod m</code> is the predecessor of <code>x</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-npred" class="anchored"><a href="#val-npred" class="anchor"></a><code><span><span class="keyword">val</span> npred : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>npred x n mod m</code> is the <code>n</code>th predecessor of <code>x</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-neg" class="anchored"><a href="#val-neg" class="anchor"></a><code><span><span class="keyword">val</span> neg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>neg x mod m</code> is the 2-complement of <code>x</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lnot" class="anchored"><a href="#val-lnot" class="anchor"></a><code><span><span class="keyword">val</span> lnot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>lnot x</code> is the 1-complement of <code>x</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-abs" class="anchored"><a href="#val-abs" class="anchor"></a><code><span><span class="keyword">val</span> abs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>abs x mod m</code> absolute value of <code>x</code> modulo <code>m</code>.</p><p>The absolute value of <code>x</code> is equal to <code>neg x</code> if <code>msb x</code> and to <code>x</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>add x y mod m</code> is <code>x + y</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>sub x y mod m</code> is <code>x - y</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mul" class="anchored"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>mul x y mod m</code> is <code>x * y</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-div" class="anchored"><a href="#val-div" class="anchor"></a><code><span><span class="keyword">val</span> div : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>div x y mod m</code> is <code>x / y</code> modulo <code>m</code>,</p><p>where <code>/</code> is the truncating towards zero division, that returns <code>ones m</code> if <code>y = 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sdiv" class="anchored"><a href="#val-sdiv" class="anchor"></a><code><span><span class="keyword">val</span> sdiv : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>sdiv x y mod m</code> is signed division of <code>x</code> by <code>y</code> modulo <code>m</code>,</p><p>The signed division operator is defined in terms of the <code>div</code> operator as follows:</p><pre>                        /
                        | div x y mod m : if not mx /\ not my
                        | neg (div (neg x) y) mod m if mx /\ not my
      x sdiv y mod m = &lt;
                        | neg (div x (neg y)) mod m if not mx /\ my
                        | div (neg x) (neg y) mod m if mx /\ my
                        \

      where mx = msb x mod m,
        and my = msb y mod m.</pre></div></div><div class="odoc-spec"><div class="spec value" id="val-rem" class="anchored"><a href="#val-rem" class="anchor"></a><code><span><span class="keyword">val</span> rem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>rem x y mod m</code> is the remainder of <code>x / y</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-srem" class="anchored"><a href="#val-srem" class="anchor"></a><code><span><span class="keyword">val</span> srem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>srem x y mod m</code> is the signed remainder <code>x / y</code> modulo <code>m</code>.</p><p>This version of the signed remainder where the sign follows the dividend, and is defined via the <code>rem</code> operation as follows</p><pre>                        /
                        | rem x y mod m : if not mx /\ not my
                        | neg (rem (neg x) y) mod m if mx /\ not my
      x srem y mod m = &lt;
                        | neg (rem x (neg y)) mod m if not mx /\ my
                        | neg (rem (neg x) (neg y)) mod m if mx /\ my
                        \

      where mx = msb x mod m,
        and my = msb y mod m.</pre></div></div><div class="odoc-spec"><div class="spec value" id="val-smod" class="anchored"><a href="#val-smod" class="anchor"></a><code><span><span class="keyword">val</span> smod : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>smod x y mod m</code> is the signed remainder of <code>x / y</code> modulo <code>m</code>.</p><p>This version of the signed remainder where the sign follows the divisor, and is defined in terms of the <code>rem</code> operation as follows:</p><pre>                        /
                        | u if u = 0
      x smod y mod m = &lt;
                        | v if u &lt;&gt; 0
                        \

                        /
                        | u if not mx /\ not my
                        | add (neg u) y mod m if mx /\ not my
                   v = &lt;
                        | add u x mod m if not mx /\ my
                        | neg u mod m if mx /\ my
                        \

      where mx = msb x mod m,
        and my = msb y mod m,
        and u = rem s t mod m.</pre></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>nth x n mod m</code> is <code>true</code> if <code>n</code>th bit of <code>x</code> is <code>set</code>.</p><p>Returns <code>msb x mod m</code> if <code>n &gt;= m</code> and <code>lsb x mod m</code> if <code>n &lt; 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-msb" class="anchored"><a href="#val-msb" class="anchor"></a><code><span><span class="keyword">val</span> msb : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>msb x mod m</code> returns the most significand bit of <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lsb" class="anchored"><a href="#val-lsb" class="anchor"></a><code><span><span class="keyword">val</span> lsb : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>lsb x mod m</code> returns the least significand bit of <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-logand" class="anchored"><a href="#val-logand" class="anchor"></a><code><span><span class="keyword">val</span> logand : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>logand x y mod m</code> is a bitwise logical and of <code>x</code> and <code>y</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-logor" class="anchored"><a href="#val-logor" class="anchor"></a><code><span><span class="keyword">val</span> logor : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>logor x y mod m</code> is a bitwise logical or of <code>x</code> and <code>y</code> modulo <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-logxor" class="anchored"><a href="#val-logxor" class="anchor"></a><code><span><span class="keyword">val</span> logxor : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>logxor x y mod m</code> is exclusive <code>or</code> between <code>x</code> and <code>y</code> modulo <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-lshift" class="anchored"><a href="#val-lshift" class="anchor"></a><code><span><span class="keyword">val</span> lshift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>lshift x y mod m</code> shifts <code>x</code> to left by <code>y</code>. Returns <code>0</code> is <code>y &gt;= m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rshift" class="anchored"><a href="#val-rshift" class="anchor"></a><code><span><span class="keyword">val</span> rshift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>rshift x y mod m</code> shifts <code>x</code> right by <code>y</code> bits. Returns <code>0</code> if <code>y &gt;= m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-arshift" class="anchored"><a href="#val-arshift" class="anchor"></a><code><span><span class="keyword">val</span> arshift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>arshift x y mod m</code> shifts <code>x</code> right by <code>y</code> with <code>msb x</code> filling.</p><p>Returns <code>ones mod m</code> if <code>y &gt;= m /\ msb x mod m</code> and <code>zero</code> if <code>y &gt;= m /\ msb x mod m = 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-gcd" class="anchored"><a href="#val-gcd" class="anchor"></a><code><span><span class="keyword">val</span> gcd : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>gcd x y mod m</code> returns the greatest common divisor modulo <code>m</code></p><p><code>gcd x y</code> is the meet operation of the divisibility lattice, with <code>0</code> being the top of the lattice and <code>1</code> being the bottom, therefore <code>gcd x 0 = gcd x 0 = x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lcm" class="anchored"><a href="#val-lcm" class="anchor"></a><code><span><span class="keyword">val</span> lcm : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>lcm x y mod</code> returns the least common multiplier modulo <code>m</code>.</p><p><code>lcm x y</code> is the meet operation of the divisibility lattice, with <code>0</code> being the top of the lattice and <code>1</code> being the bottom, therefore <code>lcm x 0 = lcm 0 x = 0</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-gcdext" class="anchored"><a href="#val-gcdext" class="anchor"></a><code><span><span class="keyword">val</span> gcdext : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(g,a,b) = gcdext x y mod m</code>, where</p><ul><li><code>g = gcd x y mod m</code>,</li><li><code>g = (a * x + b * y) mod m</code>.</li></ul><p>The operation is well defined if one or both operands are equal to <code>0</code>, in particular:</p><ul><li><code>(x,1,0) = gcdext(x,0)</code>,</li><li><code>(x,0,1) = gcdext(0,x)</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(!$)" class="anchored"><a href="#val-(!$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$) : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>!$x</code> is <code>of_string x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!!)" class="anchored"><a href="#val-(!!)" class="anchor"></a><code><span><span class="keyword">val</span> (!!) : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>!!x mod m</code> is <code>int x mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(~-)" class="anchored"><a href="#val-(~-)" class="anchor"></a><code><span><span class="keyword">val</span> (~-) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>~-x mod m</code> is <code>neg x mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(~~)" class="anchored"><a href="#val-(~~)" class="anchor"></a><code><span><span class="keyword">val</span> (~~) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>~~x mod m</code> is <code>lnot x mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(+)" class="anchored"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x + y) mod m</code> is <code>add x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(-)" class="anchored"><a href="#val-(-)" class="anchor"></a><code><span><span class="keyword">val</span> (-) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x - y) mod m</code> is <code>sub x y mod m </code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(*)" class="anchored"><a href="#val-(*)" class="anchor"></a><code><span><span class="keyword">val</span> (*) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x * y) mod m</code> is <code>mul x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(/)" class="anchored"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x / y) mod m</code> is <code>div x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(/$)" class="anchored"><a href="#val-(/$)" class="anchor"></a><code><span><span class="keyword">val</span> (/$) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>x /$ y mod m</code> is <code>sdiv x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(%)" class="anchored"><a href="#val-(%)" class="anchor"></a><code><span><span class="keyword">val</span> (%) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x % y) mod m</code> is <code>rem x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(%$)" class="anchored"><a href="#val-(%$)" class="anchor"></a><code><span><span class="keyword">val</span> (%$) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x %$ y) mod m</code> is <code>smod x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(%^)" class="anchored"><a href="#val-(%^)" class="anchor"></a><code><span><span class="keyword">val</span> (%^) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x %^ y) mod m</code> is <code>srem x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(land)" class="anchored"><a href="#val-(land)" class="anchor"></a><code><span><span class="keyword">val</span> (land) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x land y) mod m</code> is <code>logand x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lor)" class="anchored"><a href="#val-(lor)" class="anchor"></a><code><span><span class="keyword">val</span> (lor) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x lor y) mod m</code> is <code>logor x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lxor)" class="anchored"><a href="#val-(lxor)" class="anchor"></a><code><span><span class="keyword">val</span> (lxor) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x lxor y) mod m</code> is <code>logxor x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lsl)" class="anchored"><a href="#val-(lsl)" class="anchor"></a><code><span><span class="keyword">val</span> (lsl) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x lsl y) mod m</code> <code>lshift x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lsr)" class="anchored"><a href="#val-(lsr)" class="anchor"></a><code><span><span class="keyword">val</span> (lsr) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x lsr y) mod m</code> is <code>rshift x y mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(asr)" class="anchored"><a href="#val-(asr)" class="anchor"></a><code><span><span class="keyword">val</span> (asr) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x asr y) = arshift x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(++)" class="anchored"><a href="#val-(++)" class="anchor"></a><code><span><span class="keyword">val</span> (++) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x ++ n) mod m</code> is <code>nsucc x n mod m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>(x -- n) mod m</code>is <code>npred x n mod m</code></p></div></div></details></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Modulus" class="anchored"><a href="#module-type-Modulus" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-Modulus/index.html">Modulus</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-M/index.html">M</a> : <a href="module-type-Modulus/index.html">Modulus</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>module Mx = Make(Modulus)</code> produces a module <code>Mx</code> which implements all operation in <code>S</code> modulo <code>Modulus.modulus</code>, so that all operations return a bitvector directly.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-D" class="anchored"><a href="#module-type-D" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-D/index.html">D</a></span><span> = <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-M1" class="anchored"><a href="#module-M1" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="M1/index.html">M1</a></span><span> : <a href="module-type-D/index.html">D</a></span></code></div><div class="spec-doc"><p><code>M1</code> specializes <code>Make(struct let modulus = m1 end)</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-M8" class="anchored"><a href="#module-M8" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="M8/index.html">M8</a></span><span> : <a href="module-type-D/index.html">D</a></span></code></div><div class="spec-doc"><p><code>M8</code> specializes <code>Make(struct let modulus = m8 end)</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-M16" class="anchored"><a href="#module-M16" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="M16/index.html">M16</a></span><span> : <a href="module-type-D/index.html">D</a></span></code></div><div class="spec-doc"><p><code>M16</code> specializes <code>Make(struct let modulus = m16 end)</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-M32" class="anchored"><a href="#module-M32" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="M32/index.html">M32</a></span><span> : <a href="module-type-D/index.html">D</a></span></code></div><div class="spec-doc"><p><code>M32</code> specializes <code>Make(struct let modulus = m32 end)</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-M64" class="anchored"><a href="#module-M64" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="M64/index.html">M64</a></span><span> : <a href="module-type-D/index.html">D</a></span></code></div><div class="spec-doc"><p><code>M64</code> specializes <code>Make(struct let modulus = m64 end)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-modular" class="anchored"><a href="#val-modular" class="anchor"></a><code><span><span class="keyword">val</span> modular : <span>int <span class="arrow">&#45;&gt;</span></span> <span>(<span class="keyword">module</span> <a href="module-type-D/index.html">D</a>)</span></span></code></div><div class="spec-doc"><p><code>modular n</code> returns a module <code>M</code>, which implements all operations in <code>S</code> modulo the bitwidth <code>n</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.5.0</li></ul></div></div></div></body></html>