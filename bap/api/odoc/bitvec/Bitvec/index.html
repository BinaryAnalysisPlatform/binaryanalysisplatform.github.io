<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bitvec (bitvec.Bitvec)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bitvec</a> &#x00BB; Bitvec</nav><h1>Module <code>Bitvec</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>abstract representation of a fixed size bitvector</p></dd></dl><dl><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> <span>'a m</span></code></dt><dd><p>a computation in some modulo</p></dd></dl><dl><dt class="spec type" id="type-modulus"><a href="#type-modulus" class="anchor"></a><code><span class="keyword">type</span> modulus</code></dt><dd><p>type denoting the arithmetic modulus</p></dd></dl><dl><dt class="spec value" id="val-modulus"><a href="#val-modulus" class="anchor"></a><code><span class="keyword">val</span> modulus : int <span>&#45;&gt;</span> <a href="index.html#type-modulus">modulus</a></code></dt><dd><p><code>modulus s</code> is the modulus of bitvectors with size <code>s</code>.</p><p>This is a number $2^s-1$, also known as a Mersenne number.</p></dd></dl><dl><dt class="spec value" id="val-m1"><a href="#val-m1" class="anchor"></a><code><span class="keyword">val</span> m1 : <a href="index.html#type-modulus">modulus</a></code></dt><dd><p><code>m1 = modulus 1</code> = $1$ is the modulus of bitvectors with size <code>1</code></p></dd></dl><dl><dt class="spec value" id="val-m8"><a href="#val-m8" class="anchor"></a><code><span class="keyword">val</span> m8 : <a href="index.html#type-modulus">modulus</a></code></dt><dd><p><code>m8 = modulus 8</code> = $255$ is the modulus of bitvectors with size <code>8</code></p></dd></dl><dl><dt class="spec value" id="val-m32"><a href="#val-m32" class="anchor"></a><code><span class="keyword">val</span> m32 : <a href="index.html#type-modulus">modulus</a></code></dt><dd><p><code>m32 = modulus 32</code> = $2^32-1$ is the modulus of bitvectors with size <code>32</code></p></dd></dl><dl><dt class="spec value" id="val-m64"><a href="#val-m64" class="anchor"></a><code><span class="keyword">val</span> m64 : <a href="index.html#type-modulus">modulus</a></code></dt><dd><p><code>m64 = modulus 64</code> = $2^64-1$ is the modulus of bitvectors with size <code>64</code></p></dd></dl><dl><dt class="spec external" id="val-(mod)"><a href="#val-(mod)" class="anchor"></a><code><span class="keyword">val</span> (mod) : <span><span class="type-var">'a</span> <a href="index.html#type-m">m</a></span> <span>&#45;&gt;</span> <a href="index.html#type-modulus">modulus</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>(x &lt;op&gt; y) mod m</code> applies operation <code>&lt;op&gt;</code> modulo <code>m</code>.</p><p>Example: <code>(x + y) mod m</code> returns the sum of <code>x</code> and <code>y</code> modulo <code>m</code>.</p><p>Note: the <code>mod</code> function is declared as a primitive to enable support for inlining in non flambda versions of OCaml. Indeed, underneath the hood the <code>'a m</code> type is defined as the reader monad <code>modulus -&gt; 'a</code>, however we don't want to create a closure every time we compute an operation over bitvectors. With this trick, all versions of OCaml no matter the optimization options will inline <code>(x+y) mod m</code> and won't create any closures, even if <code>m</code> is not known at compile time.</p></dd></dl><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare x y</code> compares <code>x</code> and <code>y</code> as unsigned integers, i.e., <code>compare x y</code> = <code>compare (to_nat x) (to_nat y)</code></p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal x y</code> is true if <code>x</code> and <code>y</code> represent the same integers</p></dd></dl><dl><dt class="spec value" id="val-(&lt;)"><a href="#val-(&lt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>x &lt; y</code> iff <code>compare x y = -1</code></p></dd></dl><dl><dt class="spec value" id="val-(&gt;)"><a href="#val-(&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>x &lt; y</code> iff <code>compare x y = -1</code></p><p><code>x &gt; y</code> iff <code>compare x y =  1</code></p></dd></dl><dl><dt class="spec value" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span class="keyword">val</span> (=) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>x &gt; y</code> iff <code>compare x y =  1</code></p><p><code>x = y</code> iff <code>compare x y =  0</code></p></dd></dl><dl><dt class="spec value" id="val-(&lt;&gt;)"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&gt;) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>x = y</code> iff <code>compare x y =  0</code></p><p><code>x &lt;&gt; y</code> iff <code>compare x y &lt;&gt; 0</code></p></dd></dl><dl><dt class="spec value" id="val-(&lt;=)"><a href="#val-(&lt;=)" class="anchor"></a><code><span class="keyword">val</span> (&lt;=) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>x &lt;&gt; y</code> iff <code>compare x y &lt;&gt; 0</code></p><p><code>x &lt;= y</code> iff <code>compare x y &lt;= 0</code></p></dd></dl><dl><dt class="spec value" id="val-(&gt;=)"><a href="#val-(&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;=) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>x &lt;= y</code> iff <code>compare x y &lt;= 0</code></p><p><code>x &gt;= y</code> iff <code>compare x y &gt;= 0</code></p></dd></dl><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>hash x</code> returns such <code>z</code> that forall <code>y</code> s.t. <code>x=y</code>, <code>hash y = z</code></p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf x</code> is a pretty printer for the bitvectors.</p><p>Could be used standalone or as an argument to the <code>%a</code> format specificator, e.g.,</p><pre><code class="ml">Format.fprintf &quot;0xBEEF != %a&quot; Bitvec.pp !$&quot;0xBEAF&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-to_binary"><a href="#val-to_binary" class="anchor"></a><code><span class="keyword">val</span> to_binary : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_binary x</code> returns a canonical binary representation of <code>x</code></p></dd></dl><dl><dt class="spec value" id="val-of_binary"><a href="#val-of_binary" class="anchor"></a><code><span class="keyword">val</span> of_binary : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_binary s</code> returns a bitvector <code>x</code> s.t. <code>to_binary x = s</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string x</code> returns a textual (human readable) representation of the bitvector <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_string s</code> returns a bitvector that corresponds to <code>s</code>.</p><p>The set of accepted strings is defined by the following EBNF grammar:</p><pre>       valid-numbers ::=
        | &quot;0b&quot;, bin-digit, {bin-digit}
        | &quot;0o&quot;, oct-digit, {oct-digit}
        | &quot;0x&quot;, hex-digit, {hex-digit}
        | dec-digit, {dec-digit}

      bin-digit ::= '0' | '1'
      oct-digit ::= '0'-'7'
      dec-digit ::= '0'-'9'
      hex-digit ::= '0'-'9' |'a'-'f'|'A'-'F'</pre><p>The function is not defined if <code>s</code> is not in <code>valid-numbers</code>.</p></dd></dl><dl><dt class="spec value" id="val-fits_int"><a href="#val-fits_int" class="anchor"></a><code><span class="keyword">val</span> fits_int : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>fits_int x</code> is <code>true</code> if <code>x</code> could be represented with the OCaml <code>int</code> type.</p><p>Note: it is not always true that <code>fits_int (int x mod m)</code>, since depending on <code>m</code> a negative number might not fit into the OCaml representation. For positive numbers it is true, however.</p></dd></dl><dl><dt class="spec value" id="val-to_int"><a href="#val-to_int" class="anchor"></a><code><span class="keyword">val</span> to_int : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>to_int x</code> returns an OCaml integer that has the same representation as <code>x</code>.</p><p>The function is undefined if <code>not (fits_int x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fits_int32"><a href="#val-fits_int32" class="anchor"></a><code><span class="keyword">val</span> fits_int32 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>fits_int32 x</code> is <code>true</code> if <code>x</code> could be represented with the OCaml <code>int</code> type.</p><p>Note: it is not always true that <code>fits_int32 (int32 x mod m)</code>, since depending on <code>m</code> the negative <code>x</code> may not fit back into the <code>int32</code> representation. For positive numbers it is true, however.</p></dd></dl><dl><dt class="spec value" id="val-to_int32"><a href="#val-to_int32" class="anchor"></a><code><span class="keyword">val</span> to_int32 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int32</code></dt><dd><p><code>to_int32 x</code> returns an OCaml integer that has the same representation as <code>x</code>.</p><p>The function is undefined if <code>not (fits_int32 x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-fits_int64"><a href="#val-fits_int64" class="anchor"></a><code><span class="keyword">val</span> fits_int64 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>fits_int64 x</code> is <code>true</code> if <code>x</code> could be represented with the OCaml <code>int</code> type.</p><p>Note: it is not always true that <code>fits_int64 (int64 x mod m)</code>, since depending on <code>m</code> the negative <code>x</code> might not fit back into the <code>int64</code> representation. For positive numbers it is true, however.</p></dd></dl><dl><dt class="spec value" id="val-to_int64"><a href="#val-to_int64" class="anchor"></a><code><span class="keyword">val</span> to_int64 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int64</code></dt><dd><p><code>to_int64 x</code> returns an OCaml integer that has the same representation as <code>x</code>.</p><p>The function is undefined if <code>not (fits_int64 x)</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_bigint"><a href="#val-to_bigint" class="anchor"></a><code><span class="keyword">val</span> to_bigint : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../zarith/Z/index.html#type-t">Z.t</a></code></dt><dd><p><code>to_bigint x</code> returns a natural number that corresponds to <code>x</code>.</p><p>The returned value is always positive.</p></dd></dl><dl><dt class="spec value" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span class="keyword">val</span> extract : <span>hi:int</span> <span>&#45;&gt;</span> <span>lo:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>extract ~hi ~lo x</code> extracts bits from <code>lo</code> to <code>hi</code>.</p><p>The operation is effectively equivalent to <code>(x lsr lo) mod (hi-lo+1)</code></p></dd></dl><dl><dt class="spec value" id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val</span> select : <span>int list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>select bits x</code> builds a bitvector from <code>bits</code> of <code>x</code>.</p><p>Returns a bitvector <code>y</code> such that <code>nth</code> bit of it is equal to <code>List.nth bits n</code> bit of <code>x</code>.</p><p>Returns <code>zero</code> if <code>bits</code> are empty.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append m n x y</code> takes <code>m</code> bits of <code>x</code> and <code>n</code> bits of <code>y</code> and returns their concatenation. The result has <code>m+n</code> bits.</p><p>Examples:</p><ul><li><code>append 16 16 !$&quot;0xdead&quot; !$&quot;0xbeef&quot; = !$&quot;0xdeadbeef&quot;</code>;</li><li><code>append 12 20 !$&quot;0xbadadd&quot; !$&quot;0xbadbeef&quot; = !$&quot;0xadddbeef&quot;</code>;;</li></ul></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : int <span>&#45;&gt;</span> <span>times:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>repeat m ~times:n x</code> repeats <code>m</code> bits of <code>x</code> <code>n</code> times.</p><p>The result has <code>m*n</code> bits.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat m xs</code> concatenates <code>m</code> bits of each <code>x</code> in <code>xs</code>.</p><p>The operation is the reduction of the <code>append</code> operation with <code>m=n</code>. The result has <code>m * List.length xs</code> bits and is equal to <code>0</code> if <code>xs</code> is empty.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="index.html#module-type-S">S</a>.m</span> := <span><span class="type-var">'a</span> <a href="index.html#type-m">m</a></span></code></span></summary><dl><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> <span>'a m</span></code></dt><dd><p>an abstract representation of an operation modulo some number.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>bool x</code> returns <code>one</code> if <code>x</code> and <code>zero</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>int n mod m</code> is <code>n</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : int32 <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>int32 n mod m</code> is <code>n</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : int64 <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>int64 n mod m</code> is <code>n</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-bigint"><a href="#val-bigint" class="anchor"></a><code><span class="keyword">val</span> bigint : <a href="../../zarith/Z/index.html#type-t">Z.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>bigint n mod m</code> is <code>n</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : <a href="index.html#type-t">t</a></code></dt><dd><p><code>zero</code> is <code>0</code>.</p></dd></dl><dl><dt class="spec value" id="val-one"><a href="#val-one" class="anchor"></a><code><span class="keyword">val</span> one : <a href="index.html#type-t">t</a></code></dt><dd><p><code>one</code> is <code>1</code>.</p></dd></dl><dl><dt class="spec value" id="val-ones"><a href="#val-ones" class="anchor"></a><code><span class="keyword">val</span> ones : <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>ones mod m</code> is a bitvector of size <code>m</code> with all bits set</p></dd></dl><dl><dt class="spec value" id="val-succ"><a href="#val-succ" class="anchor"></a><code><span class="keyword">val</span> succ : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>succ x mod m</code> is the successor of <code>x</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-nsucc"><a href="#val-nsucc" class="anchor"></a><code><span class="keyword">val</span> nsucc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>nsucc x n mod m</code> is the <code>n</code>th successor of <code>x</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-pred"><a href="#val-pred" class="anchor"></a><code><span class="keyword">val</span> pred : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>pred x mod m</code> is the predecessor of <code>x</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-npred"><a href="#val-npred" class="anchor"></a><code><span class="keyword">val</span> npred : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>npred x n mod m</code> is the <code>n</code>th predecessor of <code>x</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span class="keyword">val</span> neg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>neg x mod m</code> is the 2-complement of <code>x</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-(lnot)"><a href="#val-(lnot)" class="anchor"></a><code><span class="keyword">val</span> (lnot) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>lnot x</code> is the 1-complement of <code>x</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-abs"><a href="#val-abs" class="anchor"></a><code><span class="keyword">val</span> abs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>abs x mod m</code> absolute value of <code>x</code> modulo <code>m</code>.</p><p>The absolute value of <code>x</code> is equal to <code>neg x</code> if <code>msb x</code> and to <code>x</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>add x y mod m</code> is <code>x + y</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>sub x y mod m</code> is <code>x - y</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span class="keyword">val</span> mul : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>mul x y mod m</code> is <code>x * y</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val</span> div : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>div x y mod m</code> is <code>x / y</code> modulo <code>m</code>,</p><p>where <code>/</code> is the truncating towards zero division, that returns <code>ones m</code> if <code>y = 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-sdiv"><a href="#val-sdiv" class="anchor"></a><code><span class="keyword">val</span> sdiv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>sdiv x y mod m</code> is signed division of <code>x</code> by <code>y</code> modulo <code>m</code>,</p><p>The signed division operator is defined in terms of the <code>div</code> operator as follows:</p><pre>                        /
                        | div x y mod m : if not mx /\ not my
                        | neg (div (neg x) y) mod m if mx /\ not my
      x sdiv y mod m = &lt;
                        | neg (div x (neg y)) mod m if not mx /\ my
                        | div (neg x) (neg y) mod m if mx /\ my
                        \

      where mx = msb x mod m,
        and my = msb y mod m.</pre></dd></dl><dl><dt class="spec value" id="val-rem"><a href="#val-rem" class="anchor"></a><code><span class="keyword">val</span> rem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>rem x y mod m</code> is the remainder of <code>x / y</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-srem"><a href="#val-srem" class="anchor"></a><code><span class="keyword">val</span> srem : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>srem x y mod m</code> is the signed remainder <code>x / y</code> modulo <code>m</code>.</p><p>This version of the signed remainder where the sign follows the dividend, and is defined via the <code>rem</code> operation as follows</p><pre>                        /
                        | rem x y mod m : if not mx /\ not my
                        | neg (rem (neg x) y) mod m if mx /\ not my
      x srem y mod m = &lt;
                        | neg (rem x (neg y)) mod m if not mx /\ my
                        | neg (rem (neg x) (neg y)) mod m if mx /\ my
                        \

      where mx = msb x mod m,
        and my = msb y mod m.</pre></dd></dl><dl><dt class="spec value" id="val-smod"><a href="#val-smod" class="anchor"></a><code><span class="keyword">val</span> smod : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>smod x y mod m</code> is the signed remainder of <code>x / y</code> modulo <code>m</code>.</p><p>This version of the signed remainder where the sign follows the divisor, and is defined in terms of the <code>rem</code> operation as follows:</p><pre>                        /
                        | u if u = 0
      x smod y mod m = &lt;
                        | v if u &lt;&gt; 0
                        \

                        /
                        | u if not mx /\ not my
                        | add (neg u) y mod m if mx /\ not my
                   v = &lt;
                        | add u x mod m if not mx /\ my
                        | neg u mod m if mx /\ my
                        \

      where mx = msb x mod m,
        and my = msb y mod m,
        and u = rem s t mod m.</pre></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>nth x n mod m</code> is <code>true</code> if <code>n</code>th bit of <code>x</code> is <code>set</code>.</p><p>Returns <code>msb x mod m</code> if <code>n &gt;= m</code> and <code>lsb x mod m</code> if <code>n &lt; 0</code></p></dd></dl><dl><dt class="spec value" id="val-msb"><a href="#val-msb" class="anchor"></a><code><span class="keyword">val</span> msb : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>msb x mod m</code> returns the most significand bit of <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-lsb"><a href="#val-lsb" class="anchor"></a><code><span class="keyword">val</span> lsb : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>lsb x mod m</code> returns the least significand bit of <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-logand"><a href="#val-logand" class="anchor"></a><code><span class="keyword">val</span> logand : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>logand x y mod m</code> is a bitwise logical and of <code>x</code> and <code>y</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-logor"><a href="#val-logor" class="anchor"></a><code><span class="keyword">val</span> logor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>logor x y mod m</code> is a bitwise logical or of <code>x</code> and <code>y</code> modulo <code>m</code>.</p></dd></dl><dl><dt class="spec value" id="val-logxor"><a href="#val-logxor" class="anchor"></a><code><span class="keyword">val</span> logxor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>logxor x y mod m</code> is exclusive <code>or</code> between <code>x</code> and <code>y</code> modulo <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-lshift"><a href="#val-lshift" class="anchor"></a><code><span class="keyword">val</span> lshift : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>lshift x y mod m</code> shifts <code>x</code> to left by <code>y</code>. Returns <code>0</code> is <code>y &gt;= m</code>.</p></dd></dl><dl><dt class="spec value" id="val-rshift"><a href="#val-rshift" class="anchor"></a><code><span class="keyword">val</span> rshift : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>rshift x y mod m</code> shifts <code>x</code> right by <code>y</code> bits. Returns <code>0</code> if <code>y &gt;= m</code></p></dd></dl><dl><dt class="spec value" id="val-arshift"><a href="#val-arshift" class="anchor"></a><code><span class="keyword">val</span> arshift : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>arshift x y mod m</code> shifts <code>x</code> right by <code>y</code> with <code>msb x</code> filling.</p><p>Returns <code>ones mod m</code> if <code>y &gt;= m /\ msb x mod m</code> and <code>zero</code> if <code>y &gt;= m /\ msb x mod m = 0</code></p></dd></dl><dl><dt class="spec value" id="val-gcd"><a href="#val-gcd" class="anchor"></a><code><span class="keyword">val</span> gcd : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>gcd x y mod m</code> returns the greatest common divisor modulo <code>m</code></p><p><code>gcd x y</code> is the meet operation of the divisibility lattice, with <code>0</code> being the top of the lattice and <code>1</code> being the bottom, therefore <code>gcd x 0 = gcd x 0 = x</code>.</p></dd></dl><dl><dt class="spec value" id="val-lcm"><a href="#val-lcm" class="anchor"></a><code><span class="keyword">val</span> lcm : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>lcm x y mod</code> returns the least common multiplier modulo <code>m</code>.</p><p><code>lcm x y</code> is the meet operation of the divisibility lattice, with <code>0</code> being the top of the lattice and <code>1</code> being the bottom, therefore <code>lcm x 0 = lcm 0 x = 0</code></p></dd></dl><dl><dt class="spec value" id="val-gcdext"><a href="#val-gcdext" class="anchor"></a><code><span class="keyword">val</span> gcdext : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a>)</span> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(g,a,b) = gcdext x y mod m</code>, where</p><ul><li><code>g = gcd x y mod m</code>,</li><li><code>g = (a * x + b * y) mod m</code>.</li></ul><p>The operation is well defined if one or both operands are equal to <code>0</code>, in particular:</p><ul><li><code>(x,1,0) = gcdext(x,0)</code>,</li><li><code>(x,0,1) = gcdext(0,x)</code>.</li></ul></dd></dl><dl><dt class="spec value" id="val-(!$)"><a href="#val-(!$)" class="anchor"></a><code><span class="keyword">val</span> (!$) : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>!$x</code> is <code>of_string x</code></p></dd></dl><dl><dt class="spec value" id="val-(!!)"><a href="#val-(!!)" class="anchor"></a><code><span class="keyword">val</span> (!!) : int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>!!x mod m</code> is <code>int x mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(~-)"><a href="#val-(~-)" class="anchor"></a><code><span class="keyword">val</span> (~-) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>~-x mod m</code> is <code>neg x mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(~~)"><a href="#val-(~~)" class="anchor"></a><code><span class="keyword">val</span> (~~) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>~~x mod m</code> is <code>lnot x mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span class="keyword">val</span> (+) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x + y) mod m</code> is <code>add x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span class="keyword">val</span> (-) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x - y) mod m</code> is <code>sub x y mod m </code></p></dd></dl><dl><dt class="spec value" id="val-(*)"><a href="#val-(*)" class="anchor"></a><code><span class="keyword">val</span> (*) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x * y) mod m</code> is <code>mul x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span class="keyword">val</span> (/) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x / y) mod m</code> is <code>div x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(/$)"><a href="#val-(/$)" class="anchor"></a><code><span class="keyword">val</span> (/$) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>x /$ y mod m</code> is <code>sdiv x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(%)"><a href="#val-(%)" class="anchor"></a><code><span class="keyword">val</span> (%) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x % y) mod m</code> is <code>rem x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(%$)"><a href="#val-(%$)" class="anchor"></a><code><span class="keyword">val</span> (%$) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x %$ y) mod m</code> is <code>smod x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(%^)"><a href="#val-(%^)" class="anchor"></a><code><span class="keyword">val</span> (%^) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x %^ y) mod m</code> is <code>srem x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(land)"><a href="#val-(land)" class="anchor"></a><code><span class="keyword">val</span> (land) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x land y) mod m</code> is <code>logand x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(lor)"><a href="#val-(lor)" class="anchor"></a><code><span class="keyword">val</span> (lor) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x lor y) mod m</code> is <code>logor x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(lxor)"><a href="#val-(lxor)" class="anchor"></a><code><span class="keyword">val</span> (lxor) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x lxor y) mod m</code> is <code>logxor x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(lsl)"><a href="#val-(lsl)" class="anchor"></a><code><span class="keyword">val</span> (lsl) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x lsl y) mod m</code> <code>lshift x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(lsr)"><a href="#val-(lsr)" class="anchor"></a><code><span class="keyword">val</span> (lsr) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x lsr y) mod m</code> is <code>rshift x y mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(asr)"><a href="#val-(asr)" class="anchor"></a><code><span class="keyword">val</span> (asr) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x asr y) = arshift x y</code></p></dd></dl><dl><dt class="spec value" id="val-(++)"><a href="#val-(++)" class="anchor"></a><code><span class="keyword">val</span> (++) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x ++ n) mod m</code> is <code>nsucc x n mod m</code></p></dd></dl><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>(x -- n) mod m</code>is <code>npred x n mod m</code></p></dd></dl></details></div></div></div><div class="spec module-type" id="module-type-Modulus"><a href="#module-type-Modulus" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Modulus/index.html">Modulus</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-M/index.html">M</a> : <a href="index.html#module-type-Modulus">Modulus</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>module Mx = Make(Modulus)</code> produces a module <code>Mx</code> which implements all operation in <code>S</code> modulo <code>Modulus.modulus</code>, so that all operations return a bitvector directly.</p></dd></dl><dl><dt class="spec module" id="module-M1"><a href="#module-M1" class="anchor"></a><code><span class="keyword">module</span> <a href="M1/index.html">M1</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></code></dt><dd><p><code>M1</code> specializes <code>Make(struct let modulus = m1 end)</code></p></dd></dl><dl><dt class="spec module" id="module-M8"><a href="#module-M8" class="anchor"></a><code><span class="keyword">module</span> <a href="M8/index.html">M8</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></code></dt><dd><p><code>M8</code> specializes <code>Make(struct let modulus = m8 end)</code></p></dd></dl><dl><dt class="spec module" id="module-M32"><a href="#module-M32" class="anchor"></a><code><span class="keyword">module</span> <a href="M32/index.html">M32</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></code></dt><dd><p><code>M32</code> specializes <code>Make(struct let modulus = m32 end)</code></p></dd></dl><dl><dt class="spec module" id="module-M64"><a href="#module-M64" class="anchor"></a><code><span class="keyword">module</span> <a href="M64/index.html">M64</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="module-type-S/index.html#type-m">m</a></span> = <span class="type-var">'a</span></code></dt><dd><p><code>M64</code> specializes <code>Make(struct let modulus = m64 end)</code></p></dd></dl></div></body></html>