<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Word (bap.Bap.Std.Word)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Word</nav><header class="odoc-preamble"><h1>Module <code><span>Std.Word</span></code></h1><p>Shortcut for bitvectors that represent words</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#clarification-on-size-morphism">Clarification on size-morphism</a></li><li><a href="#clarification-on-signs">Clarification on signs</a></li><li><a href="#bv_string">Clarification on string representation</a></li><li><a href="#constructors">Constructors</a></li><li><a href="#some-predefined-constant-constructors">Some predefined constant constructors</a></li><li><a href="#helpful-shortcuts">Helpful shortcuts</a></li><li><a href="#conversions-to-ocaml-built-in-integer-types">Conversions to OCaml built in integer types</a></li><li><a href="#iteration-over-bitvector-components">Iteration over bitvector components</a><ul><li><a href="#comparison-with-zero">Comparison with zero</a></li></ul></li></ul></nav><div class="odoc-content"><p>Bitvector -- an integer with modular arithmentics.</p><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>A numeric value with the 2-complement binary representation. It is good for representing addresses, offsets and other arithmetic values.</p><p>Each value is attributed by a bitwidth and signedness. All arithmetic operations over values are done modulo their widths. It is an error to apply arithmetic operation to values with different widths. Default implementations will raise a an exception, however there exists a family of modules that provide arithmetic operations lifted to an <code>Or_error.t</code> monad. It is suggested to use them, if you know what kind of operands you're expecting.</p><h3 id="clarification-on-size-morphism"><a href="#clarification-on-size-morphism" class="anchor"></a>Clarification on size-morphism</h3><p>Size-monomorphic operations (as opposed to size-polymorphic comparison) doesn't allow to compare two operands with different sizes, and either raise an exception or return <code>Error</code>. If we would have a type safe interface, with type <code>t</code> defined as <code>type 'a t</code>, where <code>'a</code> stands for size, then size-monomorphic operations will have type <code>'a t -&gt; 'a t -&gt; _</code>, and size-polymorphic <code>'a t -&gt; 'b t -&gt; _</code>.</p><p>By default, size-polymorphic comparison is used. To understand the ordering relation one can think that a lexical ordering is specified on a tuple <code>(x,n)</code>, where <code>x</code> is the number and <code>n</code> is the size. For example, the following sequence is in an ascending order:</p><pre><code>0x0:1, 0x0:32, 0x0:64, 0x1:1, 0x1:32, 0xD:4, 0xDEADBEEF:32</code></pre><p>.</p><p>A size-monomorphic interfaced is exposed in a <code>Mono</code> submodule. So if you want a monomorphic map, then just use <code>Mono.Map</code> module. Note, <code>Mono</code> submodule doesn't provide <code>Table</code>, since we cannot guarantee that all keys in a hash-table have equal size.</p><h3 id="clarification-on-signs"><a href="#clarification-on-signs" class="anchor"></a>Clarification on signs</h3><p>By default all numbers represented by a bitvector are considered unsigned. This includes comparisons, e.g., <code>of_int (-1)
      ~width:32</code> is greater than zero. If you need to perform a signed operation, you can use the <code>signed</code> operator to temporary cast your value to the signed kind. We use word &quot;temporary&quot; to emphasize that, the signedness property won't propagate to the result of the operation, e.g. result of the following expression: <code>Int_exn.(signed x / y)</code> will not be signed. In other words each new value is created unsigned.</p><p>If any operand of a binary operation is signed, then a signed version of an operation is used, i.e., the other operand is upcasted to the signed kind.</p><p>Remember to use explicit casts, whenever you really need a signed representation. Examples:</p><pre><code>let x = of_int ~-6 ~width:8
let y = to_int x          (* y = 250 *)
let z = to_int (signed x) (* z = ~-6 *)
let zero = of_int 0 ~width:8
let p = x &lt; zero          (* p = false *)
let q = signed x &lt; zero   (* p = true *)</code></pre><h3 id="bv_string"><a href="#bv_string" class="anchor"></a>Clarification on string representation</h3><p>As a part of <code>Identifiable</code> interface bitvector provides a pair of complement functions: <code>to_string</code> and <code>of_string</code>, that provides facilities to store bitvector as a human readable string, and to restore it from string. The format of the representation is the following (in EBNF):</p><pre><code>repr  = [sign], [base], digit, {digit}, &quot;:&quot;, size, [kind]
  sign  = &quot;+&quot; | &quot;-&quot;;
base  = &quot;0x&quot; | &quot;0b&quot; | &quot;0o&quot;;
size  = dec, {dec};
digit = dec | oct | hex;
dec   = ?decimal digit?;
oct   = ?octal digit?;
hex   = ?hexadecimal digit?;
kind  = u | s</code></pre><p>Examples: <code>0x5D:32s, 0b0101:16u, 5:64, +5:8, +0x5D:16</code>.</p><p>If <code>base</code> is omitted base-10 is assumed. If the kind is omitted, then the usigned kind is assumed. The output format is always in a hex representation with a full prefix. .</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../index.html#type-word">word</a></span></code></div><div class="spec-doc"><p><code>word</code> is an abbreviation to <code>Bitvector.t</code></p></div></div><div class="odoc-include"><div class="spec-doc"><p>Common Interfaces</p><p>A bitvector is a value, first of all, so it supports a common set of a value interface: it can be stored, compared, it can be a key in a dictionary, etc. Moreover, being a number it can be compared with zero and applied to a common set of integer operations.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../../regular/Regular/Std/Regular/module-type-S/index.html">Regular.Std.Regular.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../../regular/Regular/Std/Regular/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../../regular/Regular/Std/Regular/module-type-S/index.html#type-comparator_witness">comparator_witness</a> = <a href="../Bitvector/index.html#type-comparator_witness">Bitvector.comparator_witness</a></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Binable.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-bin_size_t" class="anchored"><a href="#val-bin_size_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_size_t : <span><a href="#type-t">t</a> <span class="xref-unresolved">Bin_prot</span>.Size.sizer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_write_t" class="anchored"><a href="#val-bin_write_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_write_t : <span><a href="#type-t">t</a> <span class="xref-unresolved">Bin_prot</span>.Write.writer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_read_t" class="anchored"><a href="#val-bin_read_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_read_t : <span><a href="#type-t">t</a> <span class="xref-unresolved">Bin_prot</span>.Read.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-__bin_read_t__" class="anchored"><a href="#val-__bin_read_t__" class="anchor"></a><code><span><span class="keyword">val</span> __bin_read_t__ : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="xref-unresolved">Bin_prot</span>.Read.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_shape_t" class="anchored"><a href="#val-bin_shape_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_shape_t : <span class="xref-unresolved">Bin_prot</span>.Shape.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_writer_t" class="anchored"><a href="#val-bin_writer_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_writer_t : <span><a href="#type-t">t</a> <span class="xref-unresolved">Bin_prot</span>.Type_class.writer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_reader_t" class="anchored"><a href="#val-bin_reader_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_reader_t : <span><a href="#type-t">t</a> <span class="xref-unresolved">Bin_prot</span>.Type_class.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_t" class="anchored"><a href="#val-bin_t" class="anchor"></a><code><span><span class="keyword">val</span> bin_t : <span><a href="#type-t">t</a> <span class="xref-unresolved">Bin_prot</span>.Type_class.t</span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexpable.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-t_of_sexp" class="anchored"><a href="#val-t_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> t_of_sexp : <span><span class="xref-unresolved">Sexplib0__</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0__</span>.Sexp.t</span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../../regular/Regular/Std/Printable/module-type-S/index.html">Regular.Std.Printable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../../regular/Regular/Std/Printable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string x</code> returns a human-readable representation of <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-str" class="anchored"><a href="#val-str" class="anchor"></a><code><span><span class="keyword">val</span> str : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>str () t</code> is formatted output function that matches &quot;%a&quot; conversion format specifier in functions, that prints to string, e.g., <code>sprintf</code>, <code>failwithf</code>, <code>errorf</code> and, surprisingly all <code>Lwt</code> printing function, including <code>Lwt_io.printf</code> and logging (or any other function with type ('a,unit,string,...) formatN`. Example:</p><pre><code>Or_error.errorf &quot;type %a is not valid for %a&quot;
  Type.str ty Exp.str exp</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-pps" class="anchored"><a href="#val-pps" class="anchor"></a><code><span><span class="keyword">val</span> pps : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>synonym for <code>str</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-ppo" class="anchored"><a href="#val-ppo" class="anchor"></a><code><span><span class="keyword">val</span> ppo : <span><span class="xref-unresolved">Core_kernel</span>.Out_channel.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>will print to a standard <code>output_channel</code>, useful for using in <code>printf</code>, <code>fprintf</code>, etc.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_seq" class="anchored"><a href="#val-pp_seq" class="anchor"></a><code><span><span class="keyword">val</span> pp_seq : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>prints a sequence of values of type <code>t</code></p></div></div><div class="odoc-include"><div class="spec-doc"><p>this will include <code>pp</code> function from <code>Core</code> that has type <span class="xref-unresolved"><code>t printer</code></span>, and can be used in <code>Format.printf</code> family of functions</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Pretty_printer.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary></details></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Comparable.S_binable <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span> <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">comparator_witness</span> = <span class="xref-unresolved">Bitvector</span>.comparator_witness</span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-(&gt;=)" class="anchored"><a href="#val-(&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;=)" class="anchored"><a href="#val-(&lt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(=)" class="anchored"><a href="#val-(=)" class="anchor"></a><code><span><span class="keyword">val</span> (=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;)" class="anchored"><a href="#val-(&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;)" class="anchored"><a href="#val-(&lt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;&gt;)" class="anchored"><a href="#val-(&lt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&gt;) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ascending" class="anchored"><a href="#val-ascending" class="anchor"></a><code><span><span class="keyword">val</span> ascending : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-descending" class="anchored"><a href="#val-descending" class="anchor"></a><code><span><span class="keyword">val</span> descending : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-between" class="anchored"><a href="#val-between" class="anchor"></a><code><span><span class="keyword">val</span> between : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>low:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>high:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-clamp_exn" class="anchored"><a href="#val-clamp_exn" class="anchor"></a><code><span><span class="keyword">val</span> clamp_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>min:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>max:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-clamp" class="anchored"><a href="#val-clamp" class="anchor"></a><code><span><span class="keyword">val</span> clamp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>min:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>max:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Or_error.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-comparator_witness" class="anchored"><a href="#type-comparator_witness" class="anchor"></a><code><span><span class="keyword">type</span> comparator_witness</span><span> = <a href="../Bitvector/index.html#type-comparator_witness">Bitvector.comparator_witness</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_lbound" class="anchored"><a href="#val-validate_lbound" class="anchor"></a><code><span><span class="keyword">val</span> validate_lbound : <span>min:<span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Maybe_bound.t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Validate.check</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_ubound" class="anchored"><a href="#val-validate_ubound" class="anchor"></a><code><span><span class="keyword">val</span> validate_ubound : <span>max:<span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Maybe_bound.t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Validate.check</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_bound" class="anchored"><a href="#val-validate_bound" class="anchor"></a><code><span><span class="keyword">val</span> validate_bound : <span>min:<span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Maybe_bound.t</span> <span class="arrow">&#45;&gt;</span></span> <span>max:<span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Maybe_bound.t</span> <span class="arrow">&#45;&gt;</span></span>
<span><a href="#type-t">t</a> <span class="xref-unresolved">Base__</span>.Validate.check</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Replace_polymorphic_compare" class="anchored"><a href="#module-Replace_polymorphic_compare" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Replace_polymorphic_compare/index.html">Replace_polymorphic_compare</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-comparator" class="anchored"><a href="#val-comparator" class="anchor"></a><code><span><span class="keyword">val</span> comparator : <span><span>(<a href="#type-t">t</a>, <a href="#type-comparator_witness">comparator_witness</a>)</span> <span class="xref-unresolved">Core_kernel__</span>.Comparator.comparator</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Hashable.S_binable <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-hash_fold_t" class="anchored"><a href="#val-hash_fold_t" class="anchor"></a><code><span><span class="keyword">val</span> hash_fold_t : <span><span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.state <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.state</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.hash_value</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-hashable" class="anchored"><a href="#val-hashable" class="anchor"></a><code><span><span class="keyword">val</span> hashable : <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel__</span>.Hashtbl.Hashable.t</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Table" class="anchored"><a href="#module-Table" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Table/index.html">Table</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Hash_set" class="anchored"><a href="#module-Hash_set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Hash_set/index.html">Hash_set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Hash_queue" class="anchored"><a href="#module-Hash_queue" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Hash_queue/index.html">Hash_queue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../../regular/Regular/Std/Data/module-type-S/index.html">Regular.Std.Data.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../../regular/Regular/Std/Data/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-info" class="anchored"><a href="#type-info" class="anchor"></a><code><span><span class="keyword">type</span> info</span><span> = string * <span>[ <span>`Ver of string</span> ]</span> * <span>string option</span></span></code></div><div class="spec-doc"><p><code>name,Ver v,desc</code> information attached to a particular reader or writer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-version" class="anchored"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : string</span></code></div><div class="spec-doc"><p>Data representation version. After any change in data representation the version should be increased.</p><p>Serializers that are derived from a data representation must have the same version as a version of the data structure, from which it is derived. This kind of serializers can only read and write data of the same version.</p><p>Other serializers can actually read and write data independent on its representation version. A serializer, that can't store data of current version simply shouldn't be added to a set of serializers.</p><p>It is assumed, that if a reader and a writer has the same name and version, then whatever was written by the writer should be readable by the reader. The round-trip equality is not required, thus it is acceptable if some information is lost.</p><p>It is also possible, that a reader and a writer that has the same name are compatible. In that case it is recommended to use semantic versioning.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-size_in_bytes" class="anchored"><a href="#val-size_in_bytes" class="anchor"></a><code><span><span class="keyword">val</span> size_in_bytes : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>size_in_bytes ?ver ?fmt datum</code> returns the amount of bytes that is needed to represent <code>datum</code> in the given format and version</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bytes" class="anchored"><a href="#val-of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../regular/Regular/Std/index.html#type-bytes">Regular.Std.bytes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bytes ?ver ?fmt bytes</code> deserializes a value from bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_bytes" class="anchored"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../regular/Regular/Std/index.html#type-bytes">Regular.Std.bytes</a></span></code></div><div class="spec-doc"><p><code>to_bytes ?ver ?fmt datum</code> serializes a <code>datum</code> to a sequence of bytes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_to_bytes" class="anchored"><a href="#val-blit_to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> blit_to_bytes : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../regular/Regular/Std/index.html#type-bytes">Regular.Std.bytes</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit_to_bytes ?ver ?fmt buffer datum offset</code> copies a serialized representation of datum into a <code>buffer</code>, starting from the <code>offset</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bigstring" class="anchored"><a href="#val-of_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> of_bigstring : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Core_kernel</span>.bigstring <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bigstring ?ver ?fmt buf</code> deserializes a datum from bigstring</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_bigstring" class="anchored"><a href="#val-to_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> to_bigstring : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Core_kernel</span>.bigstring</span></code></div><div class="spec-doc"><p><code>of_bigstring ?ver ?fmt datum</code> serializes a datum to a sequence of bytes represented as bigstring</p></div></div><div class="odoc-spec"><div class="spec value" id="val-blit_to_bigstring" class="anchored"><a href="#val-blit_to_bigstring" class="anchor"></a><code><span><span class="keyword">val</span> blit_to_bigstring : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>?fmt:string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Core_kernel</span>.bigstring <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit_to_bigstring ?ver ?fmt buffer datum offset</code> copies a serialized representation of datum into a <code>buffer</code>, starting from <code>offset</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Io" class="anchored"><a href="#module-Io" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Io/index.html">Io</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Input/Output functions for the given datum.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Cache" class="anchored"><a href="#module-Cache" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Cache/index.html">Cache</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Data cache.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_reader" class="anchored"><a href="#val-add_reader" class="anchor"></a><code><span><span class="keyword">val</span> add_reader : <span>?desc:string <span class="arrow">&#45;&gt;</span></span> <span>ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> <a href="../../../../regular/Regular/Std/index.html#type-reader">Regular.Std.reader</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_reader ?desc ~ver name reader</code> registers a new <code>reader</code> with a provided <code>name</code>, version <code>ver</code> and optional description <code>desc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_writer" class="anchored"><a href="#val-add_writer" class="anchor"></a><code><span><span class="keyword">val</span> add_writer : <span>?desc:string <span class="arrow">&#45;&gt;</span></span> <span>ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> <a href="../../../../regular/Regular/Std/index.html#type-writer">Regular.Std.writer</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_writer ?desc ~ver name writer</code> registers a new <code>writer</code> with a provided <code>name</code>, version <code>ver</code> and optional description <code>desc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-available_readers" class="anchored"><a href="#val-available_readers" class="anchor"></a><code><span><span class="keyword">val</span> available_readers : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-info">info</a> list</span></span></code></div><div class="spec-doc"><p><code>available_reader ()</code> lists available readers for the data type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_reader" class="anchored"><a href="#val-default_reader" class="anchor"></a><code><span><span class="keyword">val</span> default_reader : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-info">info</a></span></code></div><div class="spec-doc"><p><code>default_reader</code> returns information about default reader</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_default_reader" class="anchored"><a href="#val-set_default_reader" class="anchor"></a><code><span><span class="keyword">val</span> set_default_reader : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_default_reader ?ver name</code> sets new default reader. If version is not specified then the latest available version is used. Raises an exception if a reader with a given name doesn't exist.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_reader" class="anchored"><a href="#val-with_reader" class="anchor"></a><code><span><span class="keyword">val</span> with_reader : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_reader ?ver name operation</code> temporary sets a default reader to a reader with a specified name and version. The default reader is restored after <code>operation</code> is finished.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-available_writers" class="anchored"><a href="#val-available_writers" class="anchor"></a><code><span><span class="keyword">val</span> available_writers : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-info">info</a> list</span></span></code></div><div class="spec-doc"><p><code>available_writer ()</code> lists available writers for the data type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_writer" class="anchored"><a href="#val-default_writer" class="anchor"></a><code><span><span class="keyword">val</span> default_writer : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-info">info</a></span></code></div><div class="spec-doc"><p><code>default_writer</code> returns information about the default writer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_default_writer" class="anchored"><a href="#val-set_default_writer" class="anchor"></a><code><span><span class="keyword">val</span> set_default_writer : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_default_writer ?ver name</code> sets new default writer. If version is not specified then the latest available version is used. Raises an exception if a writer with a given name doesn't exist.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_writer" class="anchored"><a href="#val-with_writer" class="anchor"></a><code><span><span class="keyword">val</span> with_writer : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_writer ?ver name operation</code> temporary sets a default writer to a writer with a specified name and version. The default writer is restored after <code>operation</code> is finished.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-default_printer" class="anchored"><a href="#val-default_printer" class="anchor"></a><code><span><span class="keyword">val</span> default_printer : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-info">info</a> option</span></span></code></div><div class="spec-doc"><p><code>default_writer</code> optionally returns an information about default printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_default_printer" class="anchored"><a href="#val-set_default_printer" class="anchor"></a><code><span><span class="keyword">val</span> set_default_printer : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_default_printer ?ver name</code> sets new default printer. If version is not specified then the latest available version is used. Raises an exception if a printer with a given name doesn't exist.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_printer" class="anchored"><a href="#val-with_printer" class="anchor"></a><code><span><span class="keyword">val</span> with_printer : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_printer ?ver name operation</code> temporary sets a default printer to a printer with a specified name and version. The default printer is restored after <code>operation</code> is finished.</p></div></div><h3 id="low-level-access-to-serializers"><a href="#low-level-access-to-serializers" class="anchor"></a>Low level access to serializers</h3><div class="odoc-spec"><div class="spec value" id="val-find_reader" class="anchored"><a href="#val-find_reader" class="anchor"></a><code><span><span class="keyword">val</span> find_reader : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> <a href="../../../../regular/Regular/Std/index.html#type-reader">Regular.Std.reader</a></span> option</span></span></code></div><div class="spec-doc"><p><code>find_reader ?ver name</code> lookups a reader with a given name. If version is not specified, then a reader with maximum version is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_writer" class="anchored"><a href="#val-find_writer" class="anchor"></a><code><span><span class="keyword">val</span> find_writer : <span>?ver:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> <a href="../../../../regular/Regular/Std/index.html#type-writer">Regular.Std.writer</a></span> option</span></span></code></div><div class="spec-doc"><p><code>find_writer ?ver name</code> lookups a writer with a given name. If version is not specified, then a writer with maximum version is returned.</p></div></div></details></div></details></div><div class="odoc-include"><div class="spec-doc"><p>Bitvector implements a common set of operations that are expected from integral values.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Integer/module-type-S/index.html">Integer.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Integer/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Integer/module-type-Base/index.html">Integer.Base</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Integer/module-type-Base/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-abs" class="anchored"><a href="#val-abs" class="anchor"></a><code><span><span class="keyword">val</span> abs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>abs x</code> absolute value of <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-neg" class="anchored"><a href="#val-neg" class="anchor"></a><code><span><span class="keyword">val</span> neg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>neg x</code> = <code>-x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add x y</code> is <code>x + y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub x y</code> is <code>x - y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mul" class="anchored"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mul x y</code> is <code>x * y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-div" class="anchored"><a href="#val-div" class="anchor"></a><code><span><span class="keyword">val</span> div : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>div x y</code> is <code>x / y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-modulo" class="anchored"><a href="#val-modulo" class="anchor"></a><code><span><span class="keyword">val</span> modulo : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>modulo  x y</code> is <code>x mod y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-lnot" class="anchored"><a href="#val-lnot" class="anchor"></a><code><span><span class="keyword">val</span> lnot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lnot x</code> is a logical negation of <code>x</code> (1-complement)</p><p><code>logand x y</code> is a conjunction of <code>x</code> and <code>y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-logand" class="anchored"><a href="#val-logand" class="anchor"></a><code><span><span class="keyword">val</span> logand : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>logand x y</code> is a conjunction of <code>x</code> and <code>y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-logor" class="anchored"><a href="#val-logor" class="anchor"></a><code><span><span class="keyword">val</span> logor : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>logor x y</code> is a disjunction of <code>x</code> and <code>y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-logxor" class="anchored"><a href="#val-logxor" class="anchor"></a><code><span><span class="keyword">val</span> logxor : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>logxor x y</code> is exclusive or between <code>x</code> and <code>y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-lshift" class="anchored"><a href="#val-lshift" class="anchor"></a><code><span><span class="keyword">val</span> lshift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lshift x y</code> shift <code>x</code> by <code>y</code> bits left</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rshift" class="anchored"><a href="#val-rshift" class="anchor"></a><code><span><span class="keyword">val</span> rshift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rshift x y</code> shift <code>x</code> by <code>y</code> bits to the right</p></div></div><div class="odoc-spec"><div class="spec value" id="val-arshift" class="anchored"><a href="#val-arshift" class="anchor"></a><code><span><span class="keyword">val</span> arshift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arshift x y</code> shift <code>x</code> by <code>y</code> bits to the right and fill with the sign bit.</p></div></div></details></div><h4 id="a-common-set-of-infix-operators"><a href="#a-common-set-of-infix-operators" class="anchor"></a>A common set of infix operators</h4><div class="odoc-spec"><div class="spec value" id="val-(~-)" class="anchored"><a href="#val-(~-)" class="anchor"></a><code><span><span class="keyword">val</span> (~-) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>~-x = neg x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(+)" class="anchored"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x + y = add x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(-)" class="anchored"><a href="#val-(-)" class="anchor"></a><code><span><span class="keyword">val</span> (-) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x - y = sub x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(*)" class="anchored"><a href="#val-(*)" class="anchor"></a><code><span><span class="keyword">val</span> (*) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x * y = mul x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(/)" class="anchored"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x / y = div x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(mod)" class="anchored"><a href="#val-(mod)" class="anchor"></a><code><span><span class="keyword">val</span> (mod) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x mod y = modulo x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(land)" class="anchored"><a href="#val-(land)" class="anchor"></a><code><span><span class="keyword">val</span> (land) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x land y = logand x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lor)" class="anchored"><a href="#val-(lor)" class="anchor"></a><code><span><span class="keyword">val</span> (lor) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x lor y = logor x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lxor)" class="anchored"><a href="#val-(lxor)" class="anchor"></a><code><span><span class="keyword">val</span> (lxor) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lxor x y = logxor x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lsl)" class="anchored"><a href="#val-(lsl)" class="anchor"></a><code><span><span class="keyword">val</span> (lsl) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x lsl y = lshift x y</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(lsr)" class="anchored"><a href="#val-(lsr)" class="anchor"></a><code><span><span class="keyword">val</span> (lsr) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x lsr y</code> = rshift x y</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(asr)" class="anchored"><a href="#val-(asr)" class="anchor"></a><code><span><span class="keyword">val</span> (asr) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>x asr y = arshift x y</code></p></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-Mono" class="anchored"><a href="#module-Mono" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Mono</span><span> : <span class="xref-unresolved">Core_kernel</span>.Comparable <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></div><div class="spec-doc"><p>A comparable interface with size-monomorphic comparison.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-endian" class="anchored"><a href="#type-endian" class="anchor"></a><code><span><span class="keyword">type</span> endian</span><span> = <a href="../index.html#type-endian">endian</a></span><span> = </span></code><table><tr id="type-endian.LittleEndian" class="anchored"><td class="def variant constructor"><a href="#type-endian.LittleEndian" class="anchor"></a><code><span>| </span><span><span class="constructor">LittleEndian</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>least significant byte comes first</p><span class="comment-delim">*)</span></td></tr><tr id="type-endian.BigEndian" class="anchored"><td class="def variant constructor"><a href="#type-endian.BigEndian" class="anchor"></a><code><span>| </span><span><span class="constructor">BigEndian</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>most significant byte comes first</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Specifies the order of bytes in a word.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_shape_endian" class="anchored"><a href="#val-bin_shape_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_shape_endian : <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Shape.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_size_endian" class="anchored"><a href="#val-bin_size_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_size_endian : <span><a href="#type-endian">endian</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Size.sizer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_write_endian" class="anchored"><a href="#val-bin_write_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_write_endian : <span><a href="#type-endian">endian</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Write.writer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_writer_endian" class="anchored"><a href="#val-bin_writer_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_writer_endian : <span><a href="#type-endian">endian</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Type_class.writer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_read_endian" class="anchored"><a href="#val-bin_read_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_read_endian : <span><a href="#type-endian">endian</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Read.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-__bin_read_endian__" class="anchored"><a href="#val-__bin_read_endian__" class="anchor"></a><code><span><span class="keyword">val</span> __bin_read_endian__ : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-endian">endian</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Read.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_reader_endian" class="anchored"><a href="#val-bin_reader_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_reader_endian : <span><a href="#type-endian">endian</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Type_class.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_endian" class="anchored"><a href="#val-bin_endian" class="anchor"></a><code><span><span class="keyword">val</span> bin_endian : <span><a href="#type-endian">endian</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Type_class.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_endian" class="anchored"><a href="#val-compare_endian" class="anchor"></a><code><span><span class="keyword">val</span> compare_endian : <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_endian" class="anchored"><a href="#val-sexp_of_endian" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_endian : <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-endian_of_sexp" class="anchored"><a href="#val-endian_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> endian_of_sexp : <span><span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-endian">endian</a></span></code></div></div><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><a href="../../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create v w</code> creates a word from bitvector <code>v</code> of width <code>w</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-code_addr" class="anchored"><a href="#val-code_addr" class="anchor"></a><code><span><span class="keyword">val</span> code_addr : <span><a href="../../../../bap-core-theory/Bap_core_theory/Theory/Target/index.html#type-t">Bap_core_theory.Theory.Target.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>code_addr t x</code> uses target's address size to create a word.</p><p>Same as <code>create x (Theory.Target.code_addr_size t)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-data_addr" class="anchored"><a href="#val-data_addr" class="anchor"></a><code><span><span class="keyword">val</span> data_addr : <span><a href="../../../../bap-core-theory/Bap_core_theory/Theory/Target/index.html#type-t">Bap_core_theory.Theory.Target.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>data_addr t x</code> uses target's code address size to create a word.</p><p>Same as <code>create x (Theory.Target.data_addr_size t)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-data_word" class="anchored"><a href="#val-data_word" class="anchor"></a><code><span><span class="keyword">val</span> data_word : <span><a href="../../../../bap-core-theory/Bap_core_theory/Theory/Target/index.html#type-t">Bap_core_theory.Theory.Target.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>data_word t x</code> uses target's word size to create a word.</p><p>Same as <code>create x (Theory.Target.bits t)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string s</code> parses a bitvector from a string representation defined in section <a href="#bv_string">Clarification on string representation</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_bool" class="anchored"><a href="#val-of_bool" class="anchor"></a><code><span><span class="keyword">val</span> of_bool : <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bool x</code> is a bitvector with length <code>1</code> and value <code>b0</code> if <code>x</code> is false and <code>b1</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_int" class="anchored"><a href="#val-of_int" class="anchor"></a><code><span><span class="keyword">val</span> of_int : <span>width:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_int ~width n</code> creates a bitvector of the specified bit-<code>width</code> with the value equal to <code>n</code>. If bits of the <code>n</code> that doesn't fit into <code>width</code> are ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_int32" class="anchored"><a href="#val-of_int32" class="anchor"></a><code><span><span class="keyword">val</span> of_int32 : <span>?width:int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_int32 ?width n</code> creates a bitvector of the specified bit-<code>width</code> with the value equal to <code>n</code>. If bits of the <code>n</code> that doesn't fit into <code>width</code> are ignored. Parameter <code>width</code> defaults to <code>32</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_int64" class="anchored"><a href="#val-of_int64" class="anchor"></a><code><span><span class="keyword">val</span> of_int64 : <span>?width:int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_int32 ?width n</code> creates a bitvector of the specified bit-<code>width</code> with the value equal to <code>n</code>. If bits of the <code>n</code> that doesn't fit into <code>width</code> are ignored. Parameter <code>width</code> defaults to <code>32</code>.</p></div></div><h3 id="some-predefined-constant-constructors"><a href="#some-predefined-constant-constructors" class="anchor"></a>Some predefined constant constructors</h3><div class="odoc-spec"><div class="spec value" id="val-b0" class="anchored"><a href="#val-b0" class="anchor"></a><code><span><span class="keyword">val</span> b0 : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>b0 = of_bool false</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-b1" class="anchored"><a href="#val-b1" class="anchor"></a><code><span><span class="keyword">val</span> b1 : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>b1 = of_bool true</code></p></div></div><h3 id="helpful-shortcuts"><a href="#helpful-shortcuts" class="anchor"></a>Helpful shortcuts</h3><div class="odoc-spec"><div class="spec value" id="val-one" class="anchored"><a href="#val-one" class="anchor"></a><code><span><span class="keyword">val</span> one : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>one width</code> number one with a specified <code>width</code>, is a shortcut for <code>of_int 1 ~width</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-zero" class="anchored"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>zero width</code> zero with a specified <code>width</code>, is a shortcut for <code>of_int 0 ~width</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-ones" class="anchored"><a href="#val-ones" class="anchor"></a><code><span><span class="keyword">val</span> ones : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ones width</code> is a number with a specified <code>width</code>, and all bits set to 1. It is a shortcut for <code>lnot (zero width)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_binary" class="anchored"><a href="#val-of_binary" class="anchor"></a><code><span><span class="keyword">val</span> of_binary : <span>?width:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_binary ?width endian num</code> creates a bitvector from a string interpreted as a sequence of bytes in a specified order.</p><p>The result is always positive and unsigned. The <code>num</code> argument is not shared. <code>width</code> defaults to the length of <code>num</code> in bits, i.e. <code>8 * String.length num</code>.</p></div></div><h3 id="conversions-to-ocaml-built-in-integer-types"><a href="#conversions-to-ocaml-built-in-integer-types" class="anchor"></a>Conversions to OCaml built in integer types</h3><div class="odoc-spec"><div class="spec value" id="val-to_bitvec" class="anchored"><a href="#val-to_bitvec" class="anchor"></a><code><span><span class="keyword">val</span> to_bitvec : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a></span></code></div><div class="spec-doc"><p><code>to_bitvec x</code> returns a Bitvec represenation of <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int" class="anchored"><a href="#val-to_int" class="anchor"></a><code><span><span class="keyword">val</span> to_int : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>to_int x</code> projects <code>x</code> in to OCaml <code>int</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int32" class="anchored"><a href="#val-to_int32" class="anchor"></a><code><span><span class="keyword">val</span> to_int32 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>to_int32 x</code> projects <code>x</code> in to <code>int32</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int64" class="anchored"><a href="#val-to_int64" class="anchor"></a><code><span><span class="keyword">val</span> to_int64 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>to_int64 x</code> projects <code>x</code> in to <code>int64</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int_exn" class="anchored"><a href="#val-to_int_exn" class="anchor"></a><code><span><span class="keyword">val</span> to_int_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>to_int_exn x</code> projects <code>x</code> in to OCaml <code>int</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int32_exn" class="anchored"><a href="#val-to_int32_exn" class="anchor"></a><code><span><span class="keyword">val</span> to_int32_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div><div class="spec-doc"><p><code>to_int32_exn x</code> projects <code>x</code> in to <code>int32</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_int64_exn" class="anchored"><a href="#val-to_int64_exn" class="anchor"></a><code><span><span class="keyword">val</span> to_int64_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>to_int64_exn x</code> projects <code>x</code> in to <code>int64</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp x</code> prints <code>x</code> into a formatter. This is a default printer, controlled by <code>set_default_printer</code>. Multiple formats are available, see the <code>available_writers</code> for the actual list of formats and a format description. Out of box it defaults to <code>pp_hex_full</code>. Note, the <code>printf</code> function from examples refers to the <code>Format.printf</code>, thus it is assumed that the <code>Format</code> module is open in the scope.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_hex" class="anchored"><a href="#val-pp_hex" class="anchor"></a><code><span><span class="keyword">val</span> pp_hex : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_hex x</code> prints <code>x</code> in the hexadecimal format omitting suffixes, and the prefix if it is not necessary. Example,</p><pre><code># printf &quot;%a\n&quot; pp_hex (Word.of_int32 0xDEADBEEFl);;
0xDEADBEEF
# printf &quot;%a\n&quot; pp_hex (Word.of_int32 0x1);;
1</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dec" class="anchored"><a href="#val-pp_dec" class="anchor"></a><code><span><span class="keyword">val</span> pp_dec : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_dec x</code> prints <code>x</code> in the decimal format omitting suffixes and prefixes. Example,</p><pre><code># printf &quot;%a\n&quot; pp_dec (Word.of_int32 0xDEADBEEFl);;
3735928559
# printf &quot;%a\n&quot; pp_dec (Word.of_int32 0x1);;
1</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_oct" class="anchored"><a href="#val-pp_oct" class="anchor"></a><code><span><span class="keyword">val</span> pp_oct : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_oct x</code> prints <code>x</code> in the octal format omitting suffixes, and the prefix if it is not necessary. Example,</p><pre><code># printf &quot;%a\n&quot; pp_oct (Word.of_int32 0xDEADBEEFl);;
0o33653337357
# printf &quot;%a\n&quot; pp_oct (Word.of_int32 0x1);;
1</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_bin" class="anchored"><a href="#val-pp_bin" class="anchor"></a><code><span><span class="keyword">val</span> pp_bin : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_bin x</code> prints <code>x</code> in the binary (0 and 1) format omitting suffixes, and the prefix if it is not necessary. Example,</p><pre><code># printf &quot;%a\n&quot; pp_bin (Word.of_int32 0xDEADBEEFl);;
0b11011110101011011011111011101111
# printf &quot;%a\n&quot; pp_bin (Word.of_int32 0x1);;
1</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_hex_full" class="anchored"><a href="#val-pp_hex_full" class="anchor"></a><code><span><span class="keyword">val</span> pp_hex_full : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_hex_full x</code> prints <code>x</code> in the hexadecimal format with suffixes, and the prefix if it is necessary. Example,</p><pre><code># printf &quot;%a\n&quot; pp_hex_full (Word.of_int32 0xDEADBEEFl);;
0xDEADBEEF:32u
             # printf &quot;%a\n&quot; pp_hex_full (Word.of_int32 0x1);;
1:32u</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dec_full" class="anchored"><a href="#val-pp_dec_full" class="anchor"></a><code><span><span class="keyword">val</span> pp_dec_full : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_dec_full x</code> prints <code>x</code> in the decimal format with suffixes and prefixes. Example,</p><pre><code># printf &quot;%a\n&quot; pp_dec_full (Word.of_int32 0xDEADBEEFl);;
3735928559:32u
             # printf &quot;%a\n&quot; pp_dec_full (Word.of_int32 0x1);;
1:32u</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_oct_full" class="anchored"><a href="#val-pp_oct_full" class="anchor"></a><code><span><span class="keyword">val</span> pp_oct_full : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_oct_full x</code> prints <code>x</code> in the octal format with suffixes, and the prefix if it is necessary. Example,</p><pre><code># printf &quot;%a\n&quot; pp_oct_full (Word.of_int32 0xDEADBEEFl);;
0o33653337357:32u
                # printf &quot;%a\n&quot; pp_oct_full (Word.of_int32 0x1);;
1:32u</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_bin_full" class="anchored"><a href="#val-pp_bin_full" class="anchor"></a><code><span><span class="keyword">val</span> pp_bin_full : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>printf &quot;%a&quot; pp_bin_full x</code> prints <code>x</code> in the binary (0 and 1) format omitting suffixes, and the prefix if it is necessary. Example,</p><pre>          # printf &quot;%a\n&quot; pp_bin_full (Word.of_int32 0xDEADBEEFl);;
          0b11011110101011011011111011101111:32u
          # printf &quot;%a\n&quot; pp_bin_full (Word.of_int32 0x1);;
          1:32u</pre></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_generic" class="anchored"><a href="#val-pp_generic" class="anchor"></a><code><span><span class="keyword">val</span> pp_generic : <span>?case:<span>[ `upper <span>| `lower</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
<span>?prefix:<span>[ `auto <span>| `base</span> <span>| `none</span> <span><span>| `this</span> of string</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
<span>?suffix:<span>[ `none <span>| `full</span> <span>| `size</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span>?format:<span>[ `hex <span>| `dec</span> <span>| `oct</span> <span>| `bin</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_generic ?case ?prefix ?suffix ?format ppf x</code> - a printer to suit all tastes.</p><p>Note: this is a generic printer factory that should be used if none of the nine preinstantiated suits you.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>defines whether or not a number is prefixed:</p><ul><li><code>`auto</code> (default) - a prefix that corresponds to the chosen format is printed if it is necessary to disambiguate a number from a decimal representation;</li><li><code>`base</code> - a corresponding prefix is always printed;</li><li><code>`none</code> - the prefix is never printed;</li><li><code>`this p</code> - the user specified prefix <code>p</code> is always printed;</li></ul></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">suffix</span> <p>defines how the suffix should be printed:</p><ul><li><code>`none</code> (default) - the suffix is never printed;</li><li><code>`full</code> - a full suffix that denotes size and signedness is printed, e.g., <code>0xDE:32s</code> is a signed integer modulo <code>32</code>.</li><li><code>`size</code> - only the modulo is printed, e.g., <code>0xDE:32s</code> is printed as <code>0xDE:32</code></li></ul></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">format</span> <p>defines the textual representation format:</p><ul><li><code>hex</code> (default) - hexadecimal</li><li><code>dec</code> - decimal</li><li><code>oct</code> - octal</li><li><code>bin</code> - binary (0 and 1).</li></ul></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">case</span> <p>defines the case of hexadecimal letters</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_value" class="anchored"><a href="#val-string_of_value" class="anchor"></a><code><span><span class="keyword">val</span> string_of_value : <span>?hex:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_of_value ?hex x</code> returns a textual representation of the <code>x</code> value, i.e., ignores size and signedness. If <code>hex</code> is <code>true</code> (default), then it is in the hexadecimal representation, otherwise the decimal representation is used. The returned value is not prefixed. No leading zeros are printed. If a value is signed and negative, then a leading negative sign is printed. Hexadecimal letter literals are printed in a lowercase format.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-signed" class="anchored"><a href="#val-signed" class="anchor"></a><code><span><span class="keyword">val</span> signed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>signed t</code> casts t to a signed type, so that any operations applied on <code>t</code> will be signed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsigned" class="anchored"><a href="#val-unsigned" class="anchor"></a><code><span><span class="keyword">val</span> unsigned : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>unsigned t</code> casts <code>t</code> to an unsigned type, so that any operations applied to it will interpret <code>t</code> as an unsigned word. </p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.3</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_zero" class="anchored"><a href="#val-is_zero" class="anchor"></a><code><span><span class="keyword">val</span> is_zero : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_zero bv</code> is true iff all bits are set to zero.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_one" class="anchored"><a href="#val-is_one" class="anchor"></a><code><span><span class="keyword">val</span> is_one : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_ones bv</code> is true if the least significant bit is equal to one</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bitwidth" class="anchored"><a href="#val-bitwidth" class="anchor"></a><code><span><span class="keyword">val</span> bitwidth : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>bitwidth bv</code> return a bit-width, i.e., the amount of bits</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extract" class="anchored"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : <span>?hi:int <span class="arrow">&#45;&gt;</span></span> <span>?lo:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>extract bv ~hi ~lo</code> extracts a subvector from <code>bv</code>, starting from bit <code>hi</code> and ending with <code>lo</code>. Bits are enumerated from right to left (from least significant to most), starting from zero. <code>hi</code> maybe greater than <code>size</code>.</p><p><code>hi</code> defaults to <code>width bv - 1</code> <code>lo</code> defaults to <code>0</code>.</p><p>Example:</p><p><code>extract (of_int 17 ~width:8) ~hi:4 ~lo:3</code> will result in a two bit vector consisting of the forth and third bits, i.e., equal to a number <code>2</code>.</p><p><code>lo</code> and <code>hi</code> should be non-negative numbers. <code>lo</code> must be less then a <code>width bv</code> and <code>hi &gt;= lo</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extract_exn" class="anchored"><a href="#val-extract_exn" class="anchor"></a><code><span><span class="keyword">val</span> extract_exn : <span>?hi:int <span class="arrow">&#45;&gt;</span></span> <span>?lo:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extract_exn bv ~hi ~lo</code> is the same as <code>extract</code>, but will raise an exception on error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>concat b1 b2</code> concatenates two bitvectors</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(@.)" class="anchored"><a href="#val-(@.)" class="anchor"></a><code><span><span class="keyword">val</span> (@.) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>b1 @. b2</code> is <code>concat b1 b2</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-succ" class="anchored"><a href="#val-succ" class="anchor"></a><code><span><span class="keyword">val</span> succ : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>succ n</code> returns next value after <code>n</code>. It is not guaranteed that <code>signed (succ n) &gt; signed n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pred" class="anchored"><a href="#val-pred" class="anchor"></a><code><span><span class="keyword">val</span> pred : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pred n</code> returns a value preceding <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nsucc" class="anchored"><a href="#val-nsucc" class="anchor"></a><code><span><span class="keyword">val</span> nsucc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>nsucc m n</code> is <code>Fn.apply_n_times ~n succ m</code>, but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-npred" class="anchored"><a href="#val-npred" class="anchor"></a><code><span><span class="keyword">val</span> npred : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>npred m n</code> is <code>Fn.apply_n_times ~n pred addr</code>, but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(++)" class="anchored"><a href="#val-(++)" class="anchor"></a><code><span><span class="keyword">val</span> (++) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>a ++ n</code> is <code>nsucc a n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>a -- n</code> is <code>npred a n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-gcd" class="anchored"><a href="#val-gcd" class="anchor"></a><code><span><span class="keyword">val</span> gcd : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>gcd x y</code> is the greatest common divisor of <code>x</code> and <code>y</code> in the integers. Note that this is not always the greatest common divisor in the bitvectors of fixed length. For example, in the 32-bit unsigned integers, <code>2 = 2 + 2^32 = 2(1 + 2^31)</code>. Thus, <code>1 + 2^31</code> is a divisor of <code>2</code>, even though <code>gcd 2 2 = 2</code>. Two properties that still hold are: 1. Both <code>x</code> and <code>y</code> are multiples of <code>gcd x y</code>, and 2. <code>gcd x y &lt;= min (abs x) (abs y)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-lcm" class="anchored"><a href="#val-lcm" class="anchor"></a><code><span><span class="keyword">val</span> lcm : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>lcm x y</code> is the least common multiple of <code>x</code> and <code>y</code> in the integers. Note that, like <code>gcd x y</code>, this is not always the least common multiple of <code>x</code> and <code>y</code> in the fixed- length bitvectors. See the <code>gcd</code> documentation for an example. The result of this function will always be some common multiple of the inputs, even in the fixed-width bitvectors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gcdext" class="anchored"><a href="#val-gcdext" class="anchor"></a><code><span><span class="keyword">val</span> gcdext : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>gcdext x y</code> returns <code>(g, s, t)</code> where <code>g = gcd x y</code> and <code>g = s*x + t*y</code>. See the documentation for <code>gcd x y</code> for why this function is tricky to use.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gcd_exn" class="anchored"><a href="#val-gcd_exn" class="anchor"></a><code><span><span class="keyword">val</span> gcd_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>gcd_exn x y</code> is the same as <code>gcd</code>, but will raise an exception on error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lcm_exn" class="anchored"><a href="#val-lcm_exn" class="anchor"></a><code><span><span class="keyword">val</span> lcm_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lcm_exn x y</code> is the same as <code>lcm</code>, but will raise an exception on error.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gcdext_exn" class="anchored"><a href="#val-gcdext_exn" class="anchor"></a><code><span><span class="keyword">val</span> gcdext_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>gcdext_exn x y</code> is the same as <code>gcdext</code>, but will raise an exception on error.</p></div></div><h3 id="iteration-over-bitvector-components"><a href="#iteration-over-bitvector-components" class="anchor"></a>Iteration over bitvector components</h3><div class="odoc-spec"><div class="spec value" id="val-enum_bytes" class="anchored"><a href="#val-enum_bytes" class="anchor"></a><code><span><span class="keyword">val</span> enum_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../index.html#type-seq">seq</a></span></span></code></div><div class="spec-doc"><p><code>enum_bytes x order</code> returns a sequence of bytes of <code>x</code> in a specified <code>order</code>. Each byte is represented as a <code>bitvector</code> itself.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum_chars" class="anchored"><a href="#val-enum_chars" class="anchor"></a><code><span><span class="keyword">val</span> enum_chars : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span>char <a href="../index.html#type-seq">seq</a></span></span></code></div><div class="spec-doc"><p><code>enum_bytes x order</code> returns bytes of <code>x</code> in a specified <code>order</code>, with bytes represented by <code>char</code> type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-enum_bits" class="anchored"><a href="#val-enum_bits" class="anchor"></a><code><span><span class="keyword">val</span> enum_bits : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="../index.html#type-seq">seq</a></span></span></code></div><div class="spec-doc"><p><code>enum_bits x order</code> returns bits of <code>x</code> in a specified <code>order</code>. <code>order</code> defines only the ordering of words in a bitvector, bits will always be in MSB first order. The length of the sequence is always a power of <code>8</code>.</p></div></div><h4 id="comparison-with-zero"><a href="#comparison-with-zero" class="anchor"></a>Comparison with zero</h4><p>Note, we're not including <code>With_zero</code> interface, since it refers to the `Sign` module, that is available only in core_kernel &gt;= 113.33.00.</p><div class="odoc-spec"><div class="spec value" id="val-validate_positive" class="anchored"><a href="#val-validate_positive" class="anchor"></a><code><span><span class="keyword">val</span> validate_positive : <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Validate.check</span></span></code></div><div class="spec-doc"><p><code>validate_positive</code> validates that a value is positive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_non_negative" class="anchored"><a href="#val-validate_non_negative" class="anchor"></a><code><span><span class="keyword">val</span> validate_non_negative : <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Validate.check</span></span></code></div><div class="spec-doc"><p><code>validate_non_negative</code> validates that a value is non negative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_negative" class="anchored"><a href="#val-validate_negative" class="anchor"></a><code><span><span class="keyword">val</span> validate_negative : <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Validate.check</span></span></code></div><div class="spec-doc"><p><code>validate_negative</code> validates that a value is negative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-validate_non_positive" class="anchored"><a href="#val-validate_non_positive" class="anchor"></a><code><span><span class="keyword">val</span> validate_non_positive : <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Validate.check</span></span></code></div><div class="spec-doc"><p><code>validate_non_positive</code> validates that a value is not positive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_positive" class="anchored"><a href="#val-is_positive" class="anchor"></a><code><span><span class="keyword">val</span> is_positive : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_positive x</code> is true if <code>x</code> is greater than zero. Always true if <code>x</code> is unsigned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_non_negative" class="anchored"><a href="#val-is_non_negative" class="anchor"></a><code><span><span class="keyword">val</span> is_non_negative : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_non_negative x</code> is true if <code>x</code> is greater than or equal to zero. Tautology if <code>x</code> is unsigned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_negative" class="anchored"><a href="#val-is_negative" class="anchor"></a><code><span><span class="keyword">val</span> is_negative : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_negative x</code> is true if <code>x</code> is strictly less than zero. It is a contradiction if <code>x</code> is not signed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_non_positive" class="anchored"><a href="#val-is_non_positive" class="anchor"></a><code><span><span class="keyword">val</span> is_non_positive : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_non_positive x</code> is true if <code>x</code> is less than zero. It is a contradiction if <code>x</code> is not signed.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Int_err" class="anchored"><a href="#module-Int_err" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Int_err/index.html">Int_err</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Int_exn" class="anchored"><a href="#module-Int_exn" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Int_exn/index.html">Int_exn</a></span><span> : <a href="../Integer/module-type-S/index.html">Integer.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Integer/module-type-S/index.html#type-t">t</a> = <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Arithmetic that raises exceptions.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Unsafe" class="anchored"><a href="#module-Unsafe" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Unsafe/index.html">Unsafe</a></span><span> : <a href="../Integer/module-type-S/index.html">Integer.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Integer/module-type-S/index.html#type-t">t</a> = <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Arithmetic operations that doesn't check the widths.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Stable" class="anchored"><a href="#module-Stable" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Stable/index.html">Stable</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Stable marshaling interface.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Trie" class="anchored"><a href="#module-Trie" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Trie/index.html">Trie</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Prefix trees for bitvectors.</p></div></div></div></body></html>