<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cache (bap.Bap.Std.Label.Cache)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap</a> &#x00BB; <a href="../../../index.html">Bap</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Label</a> &#x00BB; Cache</nav><h1>Module <code>Label.Cache</code></h1><p>Data cache.</p><p>Store and retrieve data from cache. The cache can seen as a persistant weak key-value storage. Data stored here can disappear at any time, but can survive for a long time (outliving the program). The library by itself doesn't provide a caching service for any type, only the interface. The caching service can be added externally (e.g., via a plugin).</p><p>The caching infrastructure provides only facilities for storing and loading data. In fact this is just a weak key-value storage. A weak, because storage is allowed to to loose data.</p><p>As a key, we use <code>digest</code> that is underneath the hood is and md5 sum of arguments used to build the cached data.</p><p>Let's take for example a function that builds some control flow graphs. It has three parameters, one is an optional <code>debug</code>, that doesn't affect the algorithm, and the rest two has type <code>string</code> and <code>int</code> correspondingly. The following code will try to load result from a cache, using a digest of the arguments, and if is not available, the the graph will be computed and stored in the cache. This function will work even if there is no caching service. Of course, there will be no benefits, since the <code>save</code> function will just immediately forget its argument.</p><pre><code class="ml">let compute_graph ?(debug=false) x y : Graphs.Cfg.t =
  let digest =
    Data.Cache.digest ~namespace:&quot;example&quot; &quot;%s%d&quot; x y in
  match Graphs.Cfg.Cache.load digest with
  | Some g -&gt; g
  | None -&gt;
    let g = build_graph ?debug x y in
    Graphs.Cfg.Cache.save digest g;
    g</code></pre><p>Note: it is only reasonable to use caching for data types, that take significant amount of time to create.</p></header><dl><dt class="spec value" id="val-load"><a href="#val-load" class="anchor"></a><code><span class="keyword">val</span> load : <a href="../../../../../regular/Regular/Std/index.html#type-digest">Regular.Std.digest</a> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> option</code></dt><dd><p><code>load id</code> load data previously stored under give <code>id</code></p></dd></dl><dl><dt class="spec value" id="val-save"><a href="#val-save" class="anchor"></a><code><span class="keyword">val</span> save : <a href="../../../../../regular/Regular/Std/index.html#type-digest">Regular.Std.digest</a> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>save id data</code> store data under given <code>id</code>. If something is already stored, then it will be overwritten.</p></dd></dl></div></body></html>