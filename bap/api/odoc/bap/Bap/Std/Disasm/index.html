<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Disasm (bap.Bap.Std.Disasm)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Disasm</nav><header class="odoc-preamble"><h1>Module <code><span>Std.Disasm</span></code></h1><p>The interface to the disassembler level.</p><p>The following definitions are used in documentation of modules and functions in this interface.</p><p>An <i>instruction</i> is a sequence of consecutive bytes that has known decoding in the given instruction set architecture (ISA). The following semantic properties of an instruction, as provided by ISA specification. In the definitions below the following properties play an important role (see <a href="../Insn/index.html#type-property"><code>Insn.property</code></a> for more details about the properties):</p><ul><li><code>call</code>;</li><li><code>jump</code>.</li></ul><p>An <i>instruction address</i> is the address of the first byte of the instruction.</p><p>A <code>jump</code> instruction <i>destination</i> is an address defined by ISA specification to which the control flow should transfer if the jump is taken. Potentially, it is possible that the destination of a jump instruction follows the instruction, but otherwise, the instruction that follows the instruction is not the destination, only destinations of the <i>taken</i> jump are considered to be in the set of destinations of an instruction.</p><p>An instruction is a <i>conditional</i> <code>jump</code> if it is a <code>jump</code> instruction that is not always taken, as defined by the ISA specification.</p><p>An instruction is a <i>barrier</i> if it a <code>jump</code> that is not a <code>call</code> and is not conditional.</p><p>An <i>execution order</i>, is an order in which CPU executes instructions.</p><p>The <i>linear order</i> of a sequence of instructions is the ascending order of their addresses.</p><p>An instruction is <i>delayed</i> by <code>m &gt; 0</code> instructions if it takes effect not immediately but after <code>m</code> other instructions are executed.</p><p>An instruction <code>i(k)</code> <i>follows</i> the instruction <code>i(j)</code> if <code>i(j)</code> is not a barrier and either the address of <code>i(k)</code> is the successor of the address of the last byte of <code>i(j)</code> or if either <code>i(k+m)</code> or <code>i(k)</code> is an instruction that is delayed by <code>m &gt; 0</code> instructions.</p><p>A <i>chain of instructions</i> is a sequence of instruction <code>{i(0); ...; i(k),i(k+1),i(n)}</code> so that i(k+1) is either a resolved destination of <code>i(k)</code> or follows it. An instruction can belong to more than one chain.</p><p>A <i>valid chain of instructions</i> is a chain where the last instruction is a <code>jump</code> instruction that is either indirect or its destinations belong to some previous jump in the same chain.</p><p>An instruction is <i>valid</i> if it belongs to a valid chain of instructions.</p><p>A byte is <i>data</i> if one the following is true: 1) its address is an address of an instruction that is not valid; 2) it was classified in the knowledge base as data; 3) it is not an instruction.</p><p>A <i>basic block</i> is an non-empty instruction chain <code>{i(1); ... i(n)}</code> such that for each <code>1 &lt; i &lt;= n</code>,</p><ul><li><code>i(i)</code> follows <code>i(i-1)</code>;</li><li>there is no valid instruction in the knowledge base that has <code>i(i)</code> as a known destination;</li><li><code>i(i)</code> is not a jump when <code>i &lt; n</code>.</li></ul><p>A <i>subroutine</i> is a non-empty finite set of basic blocks <code>{b(1); ..; b(n)}</code> such that <code>b(1)</code> dominates each block in <code>{b(2); ..; b(n)}</code> (which also implies that they are reachable) and <code>b(1)</code> is called the <i>entry</i> block (or point).</p></header><nav class="odoc-toc"><ul><li><a href="#tags">Tags</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Driver" class="anchored"><a href="#module-Driver" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Driver/index.html">Driver</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Disassembler Driver.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Subroutines" class="anchored"><a href="#module-Subroutines" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Subroutines/index.html">Subroutines</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A set of subroutines.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../index.html#type-disasm">disasm</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><a href="../index.html#type-cfg">cfg</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create cfg</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_mem" class="anchored"><a href="#val-of_mem" class="anchor"></a><code><span><span class="keyword">val</span> of_mem : <span>?backend:string <span class="arrow">&#45;&gt;</span></span> <span>?brancher:<a href="../index.html#type-brancher">brancher</a> <span class="arrow">&#45;&gt;</span></span> <span>?rooter:<a href="../index.html#type-rooter">rooter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-arch">arch</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>disassemble ?roots arch mem</code> disassemble provided memory region <code>mem</code> using best available algorithm and backend for the specified <code>arch</code>. Roots, if provided, should point to memory regions, that are believed to contain code. At best, this should be a list of function starts. If no roots are provided, then the starting address of the provided memory <code>mem</code> will be used as a root.</p><p>The returned value will contain all memory reachable from the a given set of roots, at our best knowledge.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_image" class="anchored"><a href="#val-of_image" class="anchor"></a><code><span><span class="keyword">val</span> of_image : <span>?backend:string <span class="arrow">&#45;&gt;</span></span> <span>?brancher:<a href="../index.html#type-brancher">brancher</a> <span class="arrow">&#45;&gt;</span></span> <span>?rooter:<a href="../index.html#type-rooter">rooter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-image">image</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>disassemble_image image</code> disassemble a given image. Will take executable segments of the image and disassemble it, applying <code>disassemble</code> function. If no roots are specified, then symbol table will be used as a source of roots. If file doesn't contain one, then entry point will be used.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_file" class="anchored"><a href="#val-of_file" class="anchor"></a><code><span><span class="keyword">val</span> of_file : <span>?backend:string <span class="arrow">&#45;&gt;</span></span> <span>?brancher:<a href="../index.html#type-brancher">brancher</a> <span class="arrow">&#45;&gt;</span></span> <span>?rooter:<a href="../index.html#type-rooter">rooter</a> <span class="arrow">&#45;&gt;</span></span> <span>?loader:string <span class="arrow">&#45;&gt;</span></span>
<span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>disassemble_file ?roots path</code> takes a path to a binary and disassembles it</p></div></div><div class="odoc-spec"><div class="spec module" id="module-With_exn" class="anchored"><a href="#module-With_exn" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="With_exn/index.html">With_exn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>With_exn.f</code> is the same as <code>f</code> except that it throws an exception instead of returning <code>Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>merge d1 d2</code> is a union of control flow graphs and erros of the two disassemblers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insns" class="anchored"><a href="#val-insns" class="anchor"></a><code><span><span class="keyword">val</span> insns : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <a href="../index.html#type-insn">insn</a>)</span> <a href="../index.html#type-seq">seq</a></span></span></code></div><div class="spec-doc"><p>returns all instructions that was successfully decoded in an ascending order of their addresses. Each instruction is accompanied with its block of memory.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cfg" class="anchored"><a href="#val-cfg" class="anchor"></a><code><span><span class="keyword">val</span> cfg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-cfg">cfg</a></span></code></div><div class="spec-doc"><p>A whole program CFG.</p></div></div><h3 id="tags"><a href="#tags" class="anchor"></a>Tags</h3><div class="odoc-spec"><div class="spec value" id="val-insn" class="anchored"><a href="#val-insn" class="anchor"></a><code><span><span class="keyword">val</span> insn : <span><a href="../index.html#type-insn">insn</a> <a href="../index.html#type-tag">tag</a></span></span></code></div><div class="spec-doc"><p>machine instruction.</p></div></div></div></body></html>