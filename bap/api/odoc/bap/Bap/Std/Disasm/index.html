<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Disasm (bap.Bap.Std.Disasm)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Disasm</nav><h1>Module <code>Std.Disasm</code></h1><p>The interface to the disassembler level.</p><p>The following definitions are used in documentation of modules and functions in this interface.</p><p>An <i>instruction</i> is a sequence of consecutive bytes that has known decoding in the given instruction set architecture (ISA). The following semantic properties of an instruction, as provided by ISA specification. In the definitions below the following properties play an important role (see <a href="../Insn/index.html#type-property"><code>Insn.property</code></a> for more details about the properties):</p><ul><li><code>call</code>;</li><li><code>jump</code>.</li></ul><p>An <i>instruction address</i> is the address of the first byte of the instruction.</p><p>A <code>jump</code> instruction <i>destination</i> is an address defined by ISA specification to which the control flow should transfer if the jump is taken. Potentially, it is possible that the destination of a jump instruction follows the instruction, but otherwise, the instruction that follows the instruction is not the destination, only destinations of the <i>taken</i> jump are considered to be in the set of destinations of an instruction.</p><p>An instruction is a <i>conditional</i> <code>jump</code> if it is a <code>jump</code> instruction that is not always taken, as defined by the ISA specification.</p><p>An instruction is a <i>barrier</i> if it a <code>jump</code> that is not a <code>call</code> and is not conditional.</p><p>An <i>execution order</i>, is an order in which CPU executes instructions.</p><p>The <i>linear order</i> of a sequence of instructions is the ascending order of their addresses.</p><p>An instruction is <i>delayed</i> by <code>m &gt; 0</code> instructions if it takes effect not immediately but after <code>m</code> other instructions are executed.</p><p>An instruction <code>i(k)</code> <i>follows</i> the instruction <code>i(j)</code> if <code>i(j)</code> is not a barrier and either the address of <code>i(k)</code> is the successor of the address of the last byte of <code>i(j)</code> or if either <code>i(k+m)</code> or <code>i(k)</code> is an instruction that is delayed by <code>m &gt; 0</code> instructions.</p><p>A <i>chain of instructions</i> is a sequence of instruction <code>{i(0); ...; i(k),i(k+1),i(n)}</code> so that i(k+1) is either a resolved destination of <code>i(k)</code> or follows it. An instruction can belong to more than one chain.</p><p>A <i>valid chain of instructions</i> is a chain where the last instruction is a <code>jump</code> instruction that is either indirect or its destinations belong to some previous jump in the same chain.</p><p>An instruction is <i>valid</i> if it belongs to a valid chain of instructions.</p><p>A byte is <i>data</i> if one the following is true: 1) its address is an address of an instruction that is not valid; 2) it was classified in the knowledge base as data; 3) it is not an instruction.</p><p>A <i>basic block</i> is an non-empty instruction chain <code>{i(1); ... i(n)}</code> such that for each <code>1 &lt; i &lt;= n</code>,</p><ul><li><code>i(i)</code> follows <code>i(i-1)</code>;</li><li>there is no valid instruction in the knowledge base that has <code>i(i)</code> as a known destination;</li><li><code>i(i)</code> is not a jump when <code>i &lt; n</code>.</li></ul><p>A <i>subroutine</i> is a non-empty finite set of basic blocks <code>{b(1); ..; b(n)}</code> such that <code>b(1)</code> dominates each block in <code>{b(2); ..; b(n)}</code> (which also implies that they are reachable) and <code>b(1)</code> is called the <i>entry</i> block (or point).</p><nav class="toc"><ul><li><a href="#tags">Tags</a></li></ul></nav></header><dl><dt class="spec module" id="module-Driver"><a href="#module-Driver" class="anchor"></a><code><span class="keyword">module</span> <a href="Driver/index.html">Driver</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Disassembler Driver.</p></dd></dl><dl><dt class="spec module" id="module-Subroutines"><a href="#module-Subroutines" class="anchor"></a><code><span class="keyword">module</span> <a href="Subroutines/index.html">Subroutines</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A set of subroutines.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../index.html#type-disasm">disasm</a></code></dt></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <a href="../index.html#type-cfg">cfg</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create cfg</code></p></dd></dl><dl><dt class="spec value" id="val-of_mem"><a href="#val-of_mem" class="anchor"></a><code><span class="keyword">val</span> of_mem : <span>?&#8288;backend:string</span> <span>&#45;&gt;</span> <span>?&#8288;brancher:<a href="../index.html#type-brancher">brancher</a></span> <span>&#45;&gt;</span> <span>?&#8288;rooter:<a href="../index.html#type-rooter">rooter</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-arch">arch</a> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>disassemble ?roots arch mem</code> disassemble provided memory region <code>mem</code> using best available algorithm and backend for the specified <code>arch</code>. Roots, if provided, should point to memory regions, that are believed to contain code. At best, this should be a list of function starts. If no roots are provided, then the starting address of the provided memory <code>mem</code> will be used as a root.</p><p>The returned value will contain all memory reachable from the a given set of roots, at our best knowledge.</p></dd></dl><dl><dt class="spec value" id="val-of_image"><a href="#val-of_image" class="anchor"></a><code><span class="keyword">val</span> of_image : <span>?&#8288;backend:string</span> <span>&#45;&gt;</span> <span>?&#8288;brancher:<a href="../index.html#type-brancher">brancher</a></span> <span>&#45;&gt;</span> <span>?&#8288;rooter:<a href="../index.html#type-rooter">rooter</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-image">image</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>disassemble_image image</code> disassemble a given image. Will take executable segments of the image and disassemble it, applying <code>disassemble</code> function. If no roots are specified, then symbol table will be used as a source of roots. If file doesn't contain one, then entry point will be used.</p></dd></dl><dl><dt class="spec value" id="val-of_file"><a href="#val-of_file" class="anchor"></a><code><span class="keyword">val</span> of_file : <span>?&#8288;backend:string</span> <span>&#45;&gt;</span> <span>?&#8288;brancher:<a href="../index.html#type-brancher">brancher</a></span> <span>&#45;&gt;</span> <span>?&#8288;rooter:<a href="../index.html#type-rooter">rooter</a></span> <span>&#45;&gt;</span> <span>?&#8288;loader:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>disassemble_file ?roots path</code> takes a path to a binary and disassembles it</p></dd></dl><dl><dt class="spec module" id="module-With_exn"><a href="#module-With_exn" class="anchor"></a><code><span class="keyword">module</span> <a href="With_exn/index.html">With_exn</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>With_exn.f</code> is the same as <code>f</code> except that it throws an exception instead of returning <code>Error</code>.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge d1 d2</code> is a union of control flow graphs and erros of the two disassemblers.</p></dd></dl><dl><dt class="spec value" id="val-insns"><a href="#val-insns" class="anchor"></a><code><span class="keyword">val</span> insns : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <a href="../index.html#type-insn">insn</a>)</span> <a href="../index.html#type-seq">seq</a></span></code></dt><dd><p>returns all instructions that was successfully decoded in an ascending order of their addresses. Each instruction is accompanied with its block of memory.</p></dd></dl><dl><dt class="spec value" id="val-cfg"><a href="#val-cfg" class="anchor"></a><code><span class="keyword">val</span> cfg : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-cfg">cfg</a></code></dt><dd><p>A whole program CFG.</p></dd></dl><section><header><h3 id="tags"><a href="#tags" class="anchor"></a>Tags</h3></header><dl><dt class="spec value" id="val-insn"><a href="#val-insn" class="anchor"></a><code><span class="keyword">val</span> insn : <span><a href="../index.html#type-insn">insn</a> <a href="../index.html#type-tag">tag</a></span></code></dt><dd><p>machine instruction.</p></dd></dl></section></div></body></html>