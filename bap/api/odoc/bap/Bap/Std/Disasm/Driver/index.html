<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Driver (bap.Bap.Std.Disasm.Driver)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap</a> &#x00BB; <a href="../../../index.html">Bap</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Disasm</a> &#x00BB; Driver</nav><header class="odoc-preamble"><h1>Module <code><span>Disasm.Driver</span></code></h1><p>Disassembler Driver.</p><p>This is a low-level interface to the CFG reconstruction and disassembling engine. It is used by BAP's high-level components, such as the recursive-descent disassembler, so there is in general no need to use it directly, unless you're devising a custom disassembly pipe-line.</p><p>The disassembler is driven and controlled by the knowledge base, so it is possible to modify the behavior of the BAP disassembler layer through the knowledge base and turn the default recursive-descent mode into something more conservative, e.g., speculative, superset, shingled, or even probabilistic disassembler.</p></header><nav class="odoc-toc"><ul><li><a href="#algorithm">Algorithm</a><ul><li><a href="#memory-classification">Memory Classification</a></li><li><a href="#disassembling">Disassembling</a></li><li><a href="#backtracking">Backtracking</a></li><li><a href="#delay-slots">Delay slots</a></li></ul></li><li><a href="#low-level-interface">Low-level interface</a></li></ul></nav><div class="odoc-content"><h4 id="algorithm"><a href="#algorithm" class="anchor"></a>Algorithm</h4><h5 id="memory-classification"><a href="#memory-classification" class="anchor"></a>Memory Classification</h5><p>When the driver is fed with a new memory region (using the <a href="#val-scan"><code>Driver.scan</code></a> function), it uses the knowledge base to initially classify addresses that belong to this region.</p><p>For each byte in the region, it creates a temporary <code>core-theory:program</code> object and sets is <code>label-address</code> property to the address of that byte. It then queries if it is a function start (<code>core-theory:is-function</code>) and if it is known to be code or data (if the <code>core-theory:is-valid</code> property is <code>(true)</code> then it is classified as code and if it <code>(false)</code> then it is data, otherwise, it is undetermined). All objects created during classification are deleted immediately after the query and never committed to the knowledge base (they are scoped objects). Therefore it is fine to speculate and assume that all bytes are code by providing <code>(true)</code> to the <code>is-valid</code> property of each byte.</p><h5 id="disassembling"><a href="#disassembling" class="anchor"></a>Disassembling</h5><p>The disassembling starts from each function start (as identified by the previous step) and continues until there is no more unprocessed function starts and all addresses, which were classified as code, are either successfully disassembled or proved to be data.</p><p>During disassembling the driver will discover more jump destinations and add them to the worklist. The default mode is speculative, i.e., when we meet a barrier, we continue disassembling beyond it. If the worklist is empty, but the set of addresses that were classified as code (in the first step) is still not empty, which means that these addresses are not reachable from the initially provided starting points (function starts) then the minimal address is extracted from the set and is assumed to be a start of a basic block and added to the worklist.</p><p>The process continues until both the worklist and the set of code addresses are empty. When the process converges the knowledge base will contain all disassembled instructions (though some of them might be invalid). The result of the disassembly is the value that contains information sufficient to reconstruct the control-flow graph of the program. It could be queried directly, using various accessors or folded over with the <code>explore</code> function, which is a generalized control-flow graph building function.</p><h5 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h5><p>The disassembler has a backtracking mechanism that enables it to track each disassembled byte back to the memory byte that was initially marked as code or a function start. When we identify an instruction chain that is invalid, i.e., when data follow a machine instruction or when its destination is some data, we retract the whole chain of instructions. This ensures that all valid instructions belong to at least one valid instruction chain. The justification for not including invalid instructions chains into the disassembly is that such chains will unconditionally switch the CPU into the invalid instruction state which will terminate the program. Since such a chain can't include system calls or CPU exceptions (both are not barriers) it can't have any side-effects visible outside of the process so it could be safely ignored.</p><h5 id="delay-slots"><a href="#delay-slots" class="anchor"></a>Delay slots</h5><p>Any instruction could have a delay (<code>core-theory:delay</code>) that is greater than zero. In that case the execution order of the instructions will not be equal to the linear order of the instructions addresses and <code>m</code> instructions that follow the delayed instruction will be executed before that instruction (put in the basic block before it), where <code>m</code> is the size of the delay slot, expressed in instructions.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0</li></ul><div class="odoc-spec"><div class="spec type" id="type-state" class="anchored"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div><div class="spec-doc"><p>information necessary to build the control-flow graph.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0 implements [bin_io]</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_shape_state" class="anchored"><a href="#val-bin_shape_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_shape_state : <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Shape.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_size_state" class="anchored"><a href="#val-bin_size_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_size_state : <span><a href="#type-state">state</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Size.sizer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_write_state" class="anchored"><a href="#val-bin_write_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_write_state : <span><a href="#type-state">state</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Write.writer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_writer_state" class="anchored"><a href="#val-bin_writer_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_writer_state : <span><a href="#type-state">state</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Type_class.writer</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_read_state" class="anchored"><a href="#val-bin_read_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_read_state : <span><a href="#type-state">state</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Read.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-__bin_read_state__" class="anchored"><a href="#val-__bin_read_state__" class="anchor"></a><code><span><span class="keyword">val</span> __bin_read_state__ : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a>)</span> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Read.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_reader_state" class="anchored"><a href="#val-bin_reader_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_reader_state : <span><a href="#type-state">state</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Type_class.reader</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bin_state" class="anchored"><a href="#val-bin_state" class="anchor"></a><code><span><span class="keyword">val</span> bin_state : <span><a href="#type-state">state</a> <span class="xref-unresolved">Core_kernel</span>.Bin_prot.Type_class.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-insns" class="anchored"><a href="#type-insns" class="anchor"></a><code><span><span class="keyword">type</span> insns</span></code></div><div class="spec-doc"><p>abstract type for a sequence of instructions.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-jump" class="anchored"><a href="#type-jump" class="anchor"></a><code><span><span class="keyword">type</span> jump</span></code></div><div class="spec-doc"><p>abstract representation of a jump instruction.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <a href="#type-state">state</a></span></code></div><div class="spec-doc"><p><code>init</code> the initial disassembler state.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-state">state</a></span></code></div><div class="spec-doc"><p><code>merge x y</code> is a sum of information in states <code>x</code> and <code>y</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal x y</code> is <code>true</code> if <code>x</code> and <code>y</code> denote equal graphs.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></span></code></div><div class="spec-doc"><p><code>scan mem state</code> updates the state.</p><p>If bytes in <code>mem</code> were already scanned then returns <code>state</code> without changes. Nothing is stored in the knowledge base.</p><p>If it is a new memory region then classifies and disassembles the whole region. For each disassembled address <code>p</code> an object <code>Theory.Label.for_addr p</code> is stored in the knowledge base. It will contain a fully disassembled and lifted instruction. All instructions that are subroutine entry points will have <code>is-subroutine</code> property set to <code>(true)</code>.</p><p>See <code> sec:Algorithm</code> for the detailed description of the algorithm.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-explore" class="anchored"><a href="#val-explore" class="anchor"></a><code><span><span class="keyword">val</span> explore : <span>?entries:<span><a href="../../index.html#type-addr">addr</a> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span> <span class="arrow">&#45;&gt;</span></span> <span>?entry:<a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span>?follow:<span>(<span><a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>block:<span>(<span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-insns">insns</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'n</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>node:<span>(<span><span class="type-var">'n</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>edge:<span>(<span><span class="type-var">'n</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'n</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></span></code></div><div class="spec-doc"><p><code>explore ~block ~node ~edge ~init state</code> builds a control-flow graph from the <code>state</code>.</p><p>This function is a generalized fold function that calls the user provided functions to construct the graph, which has abstract type <code>'g</code>.</p><ul><li><code>block mem insns</code> creates a basic block of type <code>'n</code> which covers memory <code>mem</code>; <code>insns</code> is the sequence of instructions that constitute that memory, use <code>list_insns insns</code> to get instructions in the linear order of their addresses, or <code>execution_order</code> to get the execution order (which might be different from linear in the presence of delayed and speculative instructions).</li></ul><ul><li><code>node x g</code> inserts the node <code>x</code> into graph <code>g</code>;</li><li><code>edge x y g</code> inserts an edge between nodes <code>x</code> and <code>y</code>;</li><li><code>init</code> is the initial graph;</li><li><code>follow x</code> if it returns <code>true</code> then the function will follow this destination. Defaults to a function that always evaluates to <code>true</code>.</li></ul><ul><li><code>entry</code> is the entry point from which to build the graph, if absent, then all basic blocks will be consecuitively, in the order of ascending addresses, used as the entry points.</li></ul><ul><li><code>entries</code> is the sequence of entry points, if both <code>entry</code> and <code>entries</code> are specified then <code>entry</code> is consed with <code>entries</code>.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0 the optional [entries] parameter was added.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-list_insns" class="anchored"><a href="#val-list_insns" class="anchor"></a><code><span><span class="keyword">val</span> list_insns : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-insns">insns</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/Label/index.html#type-t">Bap_core_theory.Theory.Label.t</a> list</span></span></code></div><div class="spec-doc"><p><code>list_insns xs</code> returns the list of instructions in the ascending order of their addresses (or descending if <code>rev</code> is <code>true</code> (defaults to <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-execution_order" class="anchored"><a href="#val-execution_order" class="anchor"></a><code><span><span class="keyword">val</span> execution_order : <span><a href="#type-insns">insns</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/Label/index.html#type-t">Bap_core_theory.Theory.Label.t</a> list</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></span></code></div><div class="spec-doc"><p><code>execution_order xs</code> reruns a list of instructions in the order in which they will be executed by the target CPU, which could be different when instructions are delayed or speculatively executed.</p></div></div><h4 id="low-level-interface"><a href="#low-level-interface" class="anchor"></a>Low-level interface</h4><p>All functions in this interface were made availabe in BAP 2.2.0 unless stated otherwise.</p><div class="odoc-spec"><div class="spec value" id="val-subroutines" class="anchored"><a href="#val-subroutines" class="anchor"></a><code><span><span class="keyword">val</span> subroutines : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Core_kernel</span>.Set.M(<span class="xref-unresolved">Addr</span>).t</span></code></div><div class="spec-doc"><p><code>subroutines state</code> is a set of subroutine entry points that either were provided through the knowledge base or later discovered as destinations of call instructions.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-blocks" class="anchored"><a href="#val-blocks" class="anchor"></a><code><span><span class="keyword">val</span> blocks : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Core_kernel</span>.Set.M(<span class="xref-unresolved">Addr</span>).t</span></code></div><div class="spec-doc"><p><code>blocks state</code> is the set of addresses of instructions that start basic blocks.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_data" class="anchored"><a href="#val-is_data" class="anchor"></a><code><span><span class="keyword">val</span> is_data : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_data state x</code> is <code>true</code> if <code>x</code> was classified as data.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_subroutine" class="anchored"><a href="#val-is_subroutine" class="anchor"></a><code><span><span class="keyword">val</span> is_subroutine : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_subroutine s x</code> is <code>Set.mem (subroutines s) x</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_block" class="anchored"><a href="#val-is_block" class="anchor"></a><code><span><span class="keyword">val</span> is_block : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_block s x</code> is <code>Set.mem (blocks s) x</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_jump" class="anchored"><a href="#val-is_jump" class="anchor"></a><code><span><span class="keyword">val</span> is_jump : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_jump s x</code> is <code>true</code> if <code>x</code> is the maximal address of an instruction in the basic block that terminates with a jump.</p><p>Note, that when jumps are delayed, the linear order of instructions differs from the execution order, so the address of the last instruction is not the maximal address in the basic block.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-jump" class="anchored"><a href="#val-jump" class="anchor"></a><code><span><span class="keyword">val</span> jump : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-jump">jump</a> option</span></span></code></div><div class="spec-doc"><p><code>jump state src</code> if <code>src</code> is the last in the linear order instruction of a basic block that terminates with a jump instruction then returns the descrption of that jump instruction.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-destinations" class="anchored"><a href="#val-destinations" class="anchor"></a><code><span><span class="keyword">val</span> destinations : <span><a href="#type-jump">jump</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Core_kernel</span>.Set.M(<span class="xref-unresolved">Addr</span>).t</span></code></div><div class="spec-doc"><p><code>destinations jump</code> returns the set of resolved destinations.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_call" class="anchored"><a href="#val-is_call" class="anchor"></a><code><span><span class="keyword">val</span> is_call : <span><a href="#type-jump">jump</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_call jump</code> is <code>true</code> if jump is <code>call</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-is_barrier" class="anchored"><a href="#val-is_barrier" class="anchor"></a><code><span><span class="keyword">val</span> is_barrier : <span><a href="#type-jump">jump</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_barrier jump</code> is <code>true</code> if jump is <code>barrier</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div></div></body></html>