<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Driver (bap.Bap.Std.Disasm.Driver)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap</a> &#x00BB; <a href="../../../index.html">Bap</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Disasm</a> &#x00BB; Driver</nav><h1>Module <code>Disasm.Driver</code></h1><p>Disassembler Driver.</p><p>This is a low-level interface to the CFG reconstruction and disassembling engine. It is used by BAP's high-level components, such as the recursive-descent disassembler, so there is in general no need to use it directly, unless you're devising a custom disassembly pipe-line.</p><p>The disassembler is driven and controlled by the knowledge base, so it is possible to modify the behavior of the BAP disassembler layer through the knowledge base and turn the default recursive-descent mode into something more conservative, e.g., speculative, superset, shingled, or even probabilistic disassembler.</p><h4 id="algorithm"><a href="#algorithm" class="anchor"></a>Algorithm</h4><h5 id="memory-classification"><a href="#memory-classification" class="anchor"></a>Memory Classification</h5><p>When the driver is fed with a new memory region (using the <a href="index.html#val-scan"><code>Driver.scan</code></a> function), it uses the knowledge base to initially classify addresses that belong to this region.</p><p>For each byte in the region, it creates a temporary <code>core-theory:program</code> object and sets is <code>label-address</code> property to the address of that byte. It then queries if it is a function start (<code>core-theory:is-function</code>) and if it is known to be code or data (if the <code>core-theory:is-valid</code> property is <code>(true)</code> then it is classified as code and if it <code>(false)</code> then it is data, otherwise, it is undetermined). All objects created during classification are deleted immediately after the query and never committed to the knowledge base (they are scoped objects). Therefore it is fine to speculate and assume that all bytes are code by providing <code>(true)</code> to the <code>is-valid</code> property of each byte.</p><h5 id="disassembling"><a href="#disassembling" class="anchor"></a>Disassembling</h5><p>The disassembling starts from each function start (as identified by the previous step) and continues until there is no more unprocessed function starts and all addresses, which were classified as code, are either successfully disassembled or proved to be data.</p><p>During disassembling the driver will discover more jump destinations and add them to the worklist. The default mode is speculative, i.e., when we meet a barrier, we continue disassembling beyond it. If the worklist is empty, but the set of addresses that were classified as code (in the first step) is still not empty, which means that these addresses are not reachable from the initially provided starting points (function starts) then the minimal address is extracted from the set and is assumed to be a start of a basic block and added to the worklist.</p><p>The process continues until both the worklist and the set of code addresses are empty. When the process converges the knowledge base will contain all disassembled instructions (though some of them might be invalid). The result of the disassembly is the value that contains information sufficient to reconstruct the control-flow graph of the program. It could be queried directly, using various accessors or folded over with the <code>explore</code> function, which is a generalized control-flow graph building function.</p><h5 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h5><p>The disassembler has a backtracking mechanism that enables it to track each disassembled byte back to the memory byte that was initially marked as code or a function start. When we identify an instruction chain that is invalid, i.e., when data follow a machine instruction or when its destination is some data, we retract the whole chain of instructions. This ensures that all valid instructions belong to at least one valid instruction chain. The justification for not including invalid instructions chains into the disassembly is that such chains will unconditionally switch the CPU into the invalid instruction state which will terminate the program. Since such a chain can't include system calls or CPU exceptions (both are not barriers) it can't have any side-effects visible outside of the process so it could be safely ignored.</p><h5 id="delay-slots"><a href="#delay-slots" class="anchor"></a>Delay slots</h5><p>Any instruction could have a delay (<code>core-theory:delay</code>) that is greater than zero. In that case the execution order of the instructions will not be equal to the linear order of the instructions addresses and <code>m</code> instructions that follow the delayed instruction will be executed before that instruction (put in the basic block before it), where <code>m</code> is the size of the delay slot, expressed in instructions.</p><dl><dt>since</dt><dd>2.0.0</dd></dl><nav class="toc"><ul><li><a href="#low-level-interface">Low-level interface</a></li></ul></nav></header><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code></dt><dd><p>information necessary to build the control-flow graph.</p><dl><dt>since</dt><dd>2.2.0 implements [bin_io]</dd></dl></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-bin_shape_state"><a href="#val-bin_shape_state" class="anchor"></a><code><span class="keyword">val</span> bin_shape_state : <a href="../../../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt><dt class="spec value" id="val-bin_size_state"><a href="#val-bin_size_state" class="anchor"></a><code><span class="keyword">val</span> bin_size_state : <span><a href="index.html#type-state">state</a> <a href="../../../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></span></code></dt><dt class="spec value" id="val-bin_write_state"><a href="#val-bin_write_state" class="anchor"></a><code><span class="keyword">val</span> bin_write_state : <span><a href="index.html#type-state">state</a> <a href="../../../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></span></code></dt><dt class="spec value" id="val-bin_writer_state"><a href="#val-bin_writer_state" class="anchor"></a><code><span class="keyword">val</span> bin_writer_state : <span><a href="index.html#type-state">state</a> <a href="../../../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></span></code></dt><dt class="spec value" id="val-bin_read_state"><a href="#val-bin_read_state" class="anchor"></a><code><span class="keyword">val</span> bin_read_state : <span><a href="index.html#type-state">state</a> <a href="../../../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></code></dt><dt class="spec value" id="val-__bin_read_state__"><a href="#val-__bin_read_state__" class="anchor"></a><code><span class="keyword">val</span> __bin_read_state__ : <span><span>(int <span>&#45;&gt;</span> <a href="index.html#type-state">state</a>)</span> <a href="../../../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></code></dt><dt class="spec value" id="val-bin_reader_state"><a href="#val-bin_reader_state" class="anchor"></a><code><span class="keyword">val</span> bin_reader_state : <span><a href="index.html#type-state">state</a> <a href="../../../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span></code></dt><dt class="spec value" id="val-bin_state"><a href="#val-bin_state" class="anchor"></a><code><span class="keyword">val</span> bin_state : <span><a href="index.html#type-state">state</a> <a href="../../../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></span></code></dt></dl></div></div></div><dl><dt class="spec type" id="type-insns"><a href="#type-insns" class="anchor"></a><code><span class="keyword">type</span> insns</code></dt><dd><p>abstract type for a sequence of instructions.</p></dd></dl><dl><dt class="spec type" id="type-jump"><a href="#type-jump" class="anchor"></a><code><span class="keyword">type</span> jump</code></dt><dd><p>abstract representation of a jump instruction.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <a href="index.html#type-state">state</a></code></dt><dd><p><code>init</code> the initial disassembler state.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a></code></dt><dd><p><code>merge x y</code> is a sum of information in states <code>x</code> and <code>y</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal x y</code> is <code>true</code> if <code>x</code> and <code>y</code> denote equal graphs.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">val</span> scan : <a href="../../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <span><a href="index.html#type-state">state</a> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dd><p><code>scan mem state</code> updates the state.</p><p>If bytes in <code>mem</code> were already scanned then returns <code>state</code> without changes. Nothing is stored in the knowledge base.</p><p>If it is a new memory region then classifies and disassembles the whole region. For each disassembled address <code>p</code> an object <code>Theory.Label.for_addr p</code> is stored in the knowledge base. It will contain a fully disassembled and lifted instruction. All instructions that are subroutine entry points will have <code>is-subroutine</code> property set to <code>(true)</code>.</p><p>See <code> sec:Algorithm</code> for the detailed description of the algorithm.</p></dd></dl><dl><dt class="spec value" id="val-explore"><a href="#val-explore" class="anchor"></a><code><span class="keyword">val</span> explore : <span>?&#8288;entries:<span><a href="../../index.html#type-addr">addr</a> <a href="../../../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;entry:<a href="../../index.html#type-addr">addr</a></span> <span>&#45;&gt;</span> <span>?&#8288;follow:<span>(<a href="../../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span>bool <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span></span> <span>&#45;&gt;</span> <span>block:<span>(<a href="../../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <a href="index.html#type-insns">insns</a> <span>&#45;&gt;</span> <span><span class="type-var">'n</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span></span> <span>&#45;&gt;</span> <span>node:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span></span> <span>&#45;&gt;</span> <span>edge:<span>(<span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'n</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'c</span></span> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dd><p><code>explore ~block ~node ~edge ~init state</code> builds a control-flow graph from the <code>state</code>.</p><p>This function is a generalized fold function that calls the user provided functions to construct the graph, which has abstract type <code>'g</code>.</p><ul><li><code>block mem insns</code> creates a basic block of type <code>'n</code> which covers memory <code>mem</code>; <code>insns</code> is the sequence of instructions that constitute that memory, use <code>list_insns insns</code> to get instructions in the linear order of their addresses, or <code>execution_order</code> to get the execution order (which might be different from linear in the presence of delayed and speculative instructions).</li></ul><ul><li><code>node x g</code> inserts the node <code>x</code> into graph <code>g</code>;</li><li><code>edge x y g</code> inserts an edge between nodes <code>x</code> and <code>y</code>;</li><li><code>init</code> is the initial graph;</li><li><code>follow x</code> if it returns <code>true</code> then the function will follow this destination. Defaults to a function that always evaluates to <code>true</code>.</li></ul><ul><li><code>entry</code> is the entry point from which to build the graph, if absent, then all basic blocks will be consecuitively, in the order of ascending addresses, used as the entry points.</li></ul><ul><li><code>entries</code> is the sequence of entry points, if both <code>entry</code> and <code>entries</code> are specified then <code>entry</code> is consed with <code>entries</code>.</li></ul><dl><dt>since</dt><dd>2.2.0 the optional [entries] parameter was added.</dd></dl></dd></dl><dl><dt class="spec value" id="val-list_insns"><a href="#val-list_insns" class="anchor"></a><code><span class="keyword">val</span> list_insns : <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-insns">insns</a> <span>&#45;&gt;</span> <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/Label/index.html#type-t">Bap_core_theory.Theory.Label.t</a> list</span></code></dt><dd><p><code>list_insns xs</code> returns the list of instructions in the ascending order of their addresses (or descending if <code>rev</code> is <code>true</code> (defaults to <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-execution_order"><a href="#val-execution_order" class="anchor"></a><code><span class="keyword">val</span> execution_order : <a href="index.html#type-insns">insns</a> <span>&#45;&gt;</span> <span><span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/Label/index.html#type-t">Bap_core_theory.Theory.Label.t</a> list</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dd><p><code>execution_order xs</code> reruns a list of instructions in the order in which they will be executed by the target CPU, which could be different when instructions are delayed or speculatively executed.</p></dd></dl><section><header><h4 id="low-level-interface"><a href="#low-level-interface" class="anchor"></a>Low-level interface</h4><p>All functions in this interface were made availabe in BAP 2.2.0 unless stated otherwise.</p></header><dl><dt class="spec value" id="val-subroutines"><a href="#val-subroutines" class="anchor"></a><code><span class="keyword">val</span> subroutines : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../../../../core_kernel/Core_kernel__Set/M/index.html#type-t">Core_kernel.Set.M(Addr).t</a></code></dt><dd><p><code>subroutines state</code> is a set of subroutine entry points that either were provided through the knowledge base or later discovered as destinations of call instructions.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-blocks"><a href="#val-blocks" class="anchor"></a><code><span class="keyword">val</span> blocks : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../../../../core_kernel/Core_kernel__Set/M/index.html#type-t">Core_kernel.Set.M(Addr).t</a></code></dt><dd><p><code>blocks state</code> is the set of addresses of instructions that start basic blocks.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_data"><a href="#val-is_data" class="anchor"></a><code><span class="keyword">val</span> is_data : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../index.html#type-addr">addr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_data state x</code> is <code>true</code> if <code>x</code> was classified as data.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_subroutine"><a href="#val-is_subroutine" class="anchor"></a><code><span class="keyword">val</span> is_subroutine : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../index.html#type-addr">addr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_subroutine s x</code> is <code>Set.mem (subroutines s) x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_block"><a href="#val-is_block" class="anchor"></a><code><span class="keyword">val</span> is_block : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../index.html#type-addr">addr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_block s x</code> is <code>Set.mem (blocks s) x</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_jump"><a href="#val-is_jump" class="anchor"></a><code><span class="keyword">val</span> is_jump : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../index.html#type-addr">addr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_jump s x</code> is <code>true</code> if <code>x</code> is the maximal address of an instruction in the basic block that terminates with a jump.</p><p>Note, that when jumps are delayed, the linear order of instructions differs from the execution order, so the address of the last instruction is not the maximal address in the basic block.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-jump"><a href="#val-jump" class="anchor"></a><code><span class="keyword">val</span> jump : <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span><a href="index.html#type-jump">jump</a> option</span></code></dt><dd><p><code>jump state src</code> if <code>src</code> is the last in the linear order instruction of a basic block that terminates with a jump instruction then returns the descrption of that jump instruction.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-destinations"><a href="#val-destinations" class="anchor"></a><code><span class="keyword">val</span> destinations : <a href="index.html#type-jump">jump</a> <span>&#45;&gt;</span> <a href="../../../../../core_kernel/Core_kernel__Set/M/index.html#type-t">Core_kernel.Set.M(Addr).t</a></code></dt><dd><p><code>destinations jump</code> returns the set of resolved destinations.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_call"><a href="#val-is_call" class="anchor"></a><code><span class="keyword">val</span> is_call : <a href="index.html#type-jump">jump</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_call jump</code> is <code>true</code> if jump is <code>call</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_barrier"><a href="#val-is_barrier" class="anchor"></a><code><span class="keyword">val</span> is_barrier : <a href="index.html#type-jump">jump</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_barrier jump</code> is <code>true</code> if jump is <code>barrier</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl></section></div></body></html>