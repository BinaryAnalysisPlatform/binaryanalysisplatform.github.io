<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Basic (bap.Bap.Std.Disasm_expert.Basic)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../index.html">bap</a> &#x00BB; <a href="../../../index.html">Bap</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Disasm_expert</a> &#x00BB; Basic</nav><header class="odoc-preamble"><h1>Module <code><span>Disasm_expert.Basic</span></code></h1><p>Basic disassembler.</p><p>This is a target agnostic basic low-level machine code disassembler.</p></header><nav class="odoc-toc"><ul><li><a href="#basic-types">Basic types</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-pred" class="anchored"><a href="#type-pred" class="anchor"></a><code><span><span class="keyword">type</span> pred</span><span> = </span><span>[ </span></code><table><tr id="type-pred.Valid" class="anchored"><td class="def constructor"><a href="#type-pred.Valid" class="anchor"></a><code><span>| </span></code><code><span>`Valid</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>stop on first valid insn</p><span class="comment-delim">*)</span></td></tr><tr id="type-pred.Kind.t" class="anchored"><td class="def type"><a href="#type-pred.Kind.t" class="anchor"></a><code><span>| </span></code><code><span><a href="../../Kind/index.html#type-t">Kind.t</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>predicate to drive the disassembler</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_pred" class="anchored"><a href="#val-sexp_of_pred" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_pred : <span><a href="#type-pred">pred</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pred_of_sexp" class="anchored"><a href="#val-pred_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> pred_of_sexp : <span><span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-pred">pred</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-__pred_of_sexp__" class="anchored"><a href="#val-__pred_of_sexp__" class="anchor"></a><code><span><span class="keyword">val</span> __pred_of_sexp__ : <span><span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-pred">pred</a></span></code></div></div><h3 id="basic-types"><a href="#basic-types" class="anchor"></a>Basic types</h3><div class="odoc-spec"><div class="spec type" id="type-insn" class="anchored"><a href="#type-insn" class="anchor"></a><code><span><span class="keyword">type</span> <span>(+'a, +'k) insn</span></span></code></div><div class="spec-doc"><p><code>insn</code> basic instruction.</p><p>See <a href="Insn/index.html"><code>Insn</code></a> module for a more detailed description.</p><p>@typevar 'a = <a href="#type-asm">asm</a> | <a href="#type-empty">empty</a>, denotes whether assembly representation is available for the given instruction.</p><p>@typevar 'k = <a href="../../index.html#type-kind">kind</a> | <a href="#type-empty">empty</a>, denotes whether semantics kinds are available for the given instruction.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-insns" class="anchored"><a href="#type-insns" class="anchor"></a><code><span><span class="keyword">type</span> <span>(+'a, +'k) insns</span></span><span> = <span><span>(<a href="../../index.html#type-mem">mem</a> * <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-insn">insn</a></span> option</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>insns</code> is a list of pairs, where each pair consists of a memory region occupied by an instruction, and the instruction itself.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-empty" class="anchored"><a href="#type-empty" class="anchor"></a><code><span><span class="keyword">type</span> empty</span></code></div><div class="spec-doc"><p>witnesses the absence of the information</p></div></div><div class="odoc-spec"><div class="spec type" id="type-asm" class="anchored"><a href="#type-asm" class="anchor"></a><code><span><span class="keyword">type</span> asm</span></code></div><div class="spec-doc"><p>witnesses a presence of the assembly string</p></div></div><div class="odoc-spec"><div class="spec type" id="type-kinds" class="anchored"><a href="#type-kinds" class="anchor"></a><code><span><span class="keyword">type</span> kinds</span></code></div><div class="spec-doc"><p>witnesses a presence of the semantic kinds</p></div></div><div class="odoc-spec"><div class="spec type" id="type-full_insn" class="anchored"><a href="#type-full_insn" class="anchor"></a><code><span><span class="keyword">type</span> full_insn</span><span> = <span><span>(<a href="#type-asm">asm</a>, <a href="#type-kinds">kinds</a>)</span> <a href="#type-insn">insn</a></span></span></code></div><div class="spec-doc"><p>abbreviate an instruction with full information.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_full_insn" class="anchored"><a href="#val-compare_full_insn" class="anchor"></a><code><span><span class="keyword">val</span> compare_full_insn : <span><a href="#type-full_insn">full_insn</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-full_insn">full_insn</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_full_insn" class="anchored"><a href="#val-sexp_of_full_insn" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_full_insn : <span><a href="#type-full_insn">full_insn</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'k) t</span></span></code></div><div class="spec-doc"><p>Disassembler.</p><p>The <code>'a</code> and <code>'k</code> type variables specify disassembler modes of operation. In a process of disassembly it can store extra information that might be useful. Although, since storing it takes extra time and space, it is disabled by default.</p><p>The first type variable specifies whether storing assembly strings is enabled. It can be switched using <code>store_asm</code>, <code>drop_asm</code> functions. When it is enabled, then this type variable will be set to <code>asm</code>, and it will give an access to functions that returns this information. Otherwise, this type variable will be set to <code>empty</code>, thus stopping you from accessing assembler information.</p><p>The second type variable stands for <code>kinds</code>, i.e. to store or not to store extra information about instruction kind.</p><p>Note: at some points you can have an access to this information even if you don't enable it explicitly.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-state" class="anchored"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> <span>(+'a, +'k, 's, 'r) state</span></span></code></div><div class="spec-doc"><p>Disassembler state.</p><p>Words of precaution: this state is valid only inside handlers functions of the <code>run</code> function. It shouldn't be stored anywhere. First two type variables are bound correspondingly to two variables of the disassmbler <code>('a,'k) t</code> type. The last pair of type variables are bounded to input and output types of user functions. They are made different, so that a function can be run in an arbitrary monad. For simple cases, the can be made the same.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-register" class="anchored"><a href="#val-register" class="anchor"></a><code><span><span class="keyword">val</span> register : <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-language">Bap_core_theory.Theory.language</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-target">Bap_core_theory.Theory.target</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-empty">empty</a>, <a href="#type-empty">empty</a>)</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>register encoding constructor</code> registers a disassembler <code>constructor</code> for the given <code>encoding</code>.</p><p>The constructor receives the <code>target</code> value that further specifies the details of the target system, e.g., a cpu model, limitiations on the instruction set, etc.</p><p>The constructor commonly uses <a href="#val-create"><code>create</code></a> and passes the backend and target specific options to it. It can also use the <a href="#val-custom"><code>custom</code></a> function to create its own backend. Alternatively, the <a href="#val-lookup"><code>lookup</code></a> function could be used to delegate the decoding to another encoder.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lookup" class="anchored"><a href="#val-lookup" class="anchor"></a><code><span><span class="keyword">val</span> lookup : <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-target">Bap_core_theory.Theory.target</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-language">Bap_core_theory.Theory.language</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-empty">empty</a>, <a href="#type-empty">empty</a>)</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>lookup target encoding</code> returns the disassembler for the specified <code>target</code> and <code>encoding</code>, creates one if necessary.</p><p>Returns an error if there is no constructor for the given encoding registered (via the <a href="#val-register"><code>register</code></a> function) or if the constructor itself fails to create a disassembler.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?debug_level:int <span class="arrow">&#45;&gt;</span></span> <span>?cpu:string <span class="arrow">&#45;&gt;</span></span> <span>?attrs:string <span class="arrow">&#45;&gt;</span></span> <span>?backend:string <span class="arrow">&#45;&gt;</span></span>
<span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-empty">empty</a>, <a href="#type-empty">empty</a>)</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>create ?debug_level ?cpu ~backend target</code> creates the disassmbler from one of the C-level backends.</p><p>The parameters are backend-specific and are commonly set by the target support plugins via the <a href="#val-register"><code>register</code></a> function, therefore the <code>create</code> function should only be used to register a new target. Use <a href="#val-lookup"><code>lookup</code></a> to get an appropriate disassembler for your target/encoding.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0 has the [attrs] parameter</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-custom" class="anchored"><a href="#val-custom" class="anchor"></a><code><span><span class="keyword">val</span> custom : <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-target">Bap_core_theory.Theory.target</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-language">Bap_core_theory.Theory.language</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="keyword">module</span> <a href="../Backend/module-type-S/index.html">Backend.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Backend/module-type-S/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-empty">empty</a>, <a href="#type-empty">empty</a>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>custom target encoding backend disassembler</code> creates a custom backend for the given <code>target</code> and <code>encoding</code>.</p><p>This function is commonly called by the constructor function registered with the <a href="#val-register"><code>register</code></a> function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_disasm" class="anchored"><a href="#val-with_disasm" class="anchor"></a><code><span><span class="keyword">val</span> with_disasm : <span>?debug_level:int <span class="arrow">&#45;&gt;</span></span> <span>?cpu:string <span class="arrow">&#45;&gt;</span></span> <span>?backend:string <span class="arrow">&#45;&gt;</span></span>
<span>string <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span><span>(<a href="#type-empty">empty</a>, <a href="#type-empty">empty</a>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>with_disasm ?debug_level ?cpu ~backend ~f target</code> creates a disassembler passing all options to <code>create</code> function and applies function <code>f</code> to it. Once <code>f</code> is evaluated the disassembler is closed with <code>close</code> function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close d</code> closes a disassembler <code>d</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-store_asm" class="anchored"><a href="#val-store_asm" class="anchor"></a><code><span><span class="keyword">val</span> store_asm : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">'k</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-asm">asm</a>, <span class="type-var">'k</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>enables storing assembler information</p></div></div><div class="odoc-spec"><div class="spec value" id="val-store_kinds" class="anchored"><a href="#val-store_kinds" class="anchor"></a><code><span><span class="keyword">val</span> store_kinds : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <a href="#type-kinds">kinds</a>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>enables storing instruction kinds information</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span>?backlog:int <span class="arrow">&#45;&gt;</span></span> <span>?stop_on:<span><a href="#type-pred">pred</a> list</span> <span class="arrow">&#45;&gt;</span></span>
<span>?invalid:<span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>?stopped:<span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>?hit:<span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-asm">asm</a>, <a href="#type-kinds">kinds</a>)</span> <a href="#type-insn">insn</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>return:<span>(<span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span>init:<span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p><code>run ?stop_on ?invalid ?stopped dis mem ~init ~return ~hit</code> performs the recursive disassembly of the specified chunk of memory <code>mem</code>. The process of disassembly can be driven using the <code>stop</code>, <code>step</code>, <code>back</code> and <code>jump</code> functions, described later.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">backlog</span> <p>defines a size of history of states, that can be used for backtracking. Defaults to some positive natural number.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">stop_on</span> <p>defines a set of predicates that will be checked on each step to decide whether a disassembler should stop here and call the user-provided <code>hit</code> function, or it should continue. The decision is made according to the rule: <code>if
          exists stop_on then stop</code>, i.e., it there exists such predicate in a set of predicates, that evaluates to true, then stop the disassembly and pass the control to the user function <code>hit</code>. A few notes: only valid instructions can match predicates, and if the set is empty, then it always evaluates to false.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">init</span> <p>initial value of user data, that can be passed through handlers (cf., <code>fold</code>)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">return</span> <p>a function that lifts user data type <code>'s</code> to type <code>'r</code>. It is useful when you need to perform disassembly in some monad, like <code>Or_error</code>, or <code>Lwt</code>. Otherwise, just use <code>ident</code> function and assume that <code>'s == 'r</code>.</p><p>The disassembler will invoke user provided callbacks. To each callback at least two parameters are passed: <code>state</code> and <code>user_data</code>. <code>user_data</code> is arbitrary data of type <code>'s</code> with which the folding over the memory is actually performed. <code>state</code> incapsulates the current state of the disassembler, and provides continuation functions, namely <code>stop</code>, <code>next</code> and <code>back</code>, that drives the process of disassembly. This functions are used to pass control back to the disassembler.</p><p><code>stopped state user_data</code> is called when there is no more data to disassemble. This handler is optional and defaults to <code>stop</code>.</p><p><code>invalid state user_data</code> is an optional handler that is called on each invalid instruction (i.e., a portion of data that is not a valid instruction), it defaults to <code>step</code>, i.e., to skipping.</p><p><code>hit state mem insn data</code> is called when one of the predicates specified by a user was hit. <code>insn</code> is actually the instruction that satisfies the predicate. <code>mem</code> is a memory region spanned by the instruction. <code>data</code> is a user data. <code>insn</code> can be queried for assembly string and kinds even if the corresponding modes are disabled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-insn_of_mem" class="anchored"><a href="#val-insn_of_mem" class="anchor"></a><code><span><span class="keyword">val</span> insn_of_mem : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../index.html#type-mem">mem</a> * <span><span><span>(<a href="#type-asm">asm</a>, <a href="#type-kinds">kinds</a>)</span> <a href="#type-insn">insn</a></span> option</span> * <span>[ <span>`left of <a href="../../index.html#type-mem">mem</a></span> <span>| `finished</span> ]</span>)</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>insn_of_mem dis mem</code> performs a disassembly of one instruction from the a given memory region <code>mem</code>. Returns a tuple <code>imem,insn,`left over</code> where <code>imem</code> stands for a piece of memory consumed in a process of disassembly, <code>insn</code> can be <code>Some ins</code> if disassembly was successful, and <code>None</code> otherwise. <code>`left over</code> complements <code>imem</code> to original <code>mem</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-addr" class="anchored"><a href="#val-addr" class="anchor"></a><code><span><span class="keyword">val</span> addr : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../../index.html#type-addr">addr</a></span></code></div><div class="spec-doc"><p>current position of the disassembler</p></div></div><div class="odoc-spec"><div class="spec value" id="val-preds" class="anchored"><a href="#val-preds" class="anchor"></a><code><span><span class="keyword">val</span> preds : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pred">pred</a> list</span></span></code></div><div class="spec-doc"><p>current set of predicates</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_preds" class="anchored"><a href="#val-with_preds" class="anchor"></a><code><span><span class="keyword">val</span> with_preds : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-pred">pred</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span></span></code></div><div class="spec-doc"><p>updates the set of predicates, that rules the stop condition.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insns" class="anchored"><a href="#val-insns" class="anchor"></a><code><span><span class="keyword">val</span> insns : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-insns">insns</a></span></span></code></div><div class="spec-doc"><p>a queue of instructions disassembled in this step</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last" class="anchored"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'k</span>)</span> <a href="#type-insns">insns</a></span></span></code></div><div class="spec-doc"><p><code>last s n</code> returns last <code>n</code> instructions disassembled in this step. If there are less then <code>n</code> instructions, then returns a smaller list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-memory" class="anchored"><a href="#val-memory" class="anchor"></a><code><span><span class="keyword">val</span> memory : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../../index.html#type-mem">mem</a></span></code></div><div class="spec-doc"><p>the memory region we're currently working on</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stop" class="anchored"><a href="#val-stop" class="anchor"></a><code><span><span class="keyword">val</span> stop : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p>stop the disassembly and return the provided value.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-step" class="anchored"><a href="#val-step" class="anchor"></a><code><span><span class="keyword">val</span> step : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p>continue disassembling from the current point. You can change a a set of predicates, before stepping next. If you want to continue from a different address, use <code>jump</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-jump" class="anchored"><a href="#val-jump" class="anchor"></a><code><span><span class="keyword">val</span> jump : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p>jump to the specified memory and continue disassembly in it.</p><p>For example, if you want to jump to a specified address, and you're working in a <code>Or_error</code> monad, then you can:</p><p><code>view ~from:addr (mem state) &gt;&gt;= fun mem -&gt; jump mem data</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-back" class="anchored"><a href="#val-back" class="anchor"></a><code><span><span class="keyword">val</span> back : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'s</span>, <span class="type-var">'r</span>)</span> <a href="#type-state">state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p>restarts last step.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Insn" class="anchored"><a href="#module-Insn" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Insn/index.html">Insn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Basic instruction aka machine-specific instruction.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Trie" class="anchored"><a href="#module-Trie" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Trie/index.html">Trie</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Trie maps over instructions</p></div></div><div class="odoc-spec"><div class="spec value" id="val-available_backends" class="anchored"><a href="#val-available_backends" class="anchor"></a><code><span><span class="keyword">val</span> available_backends : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>enumerates names of available disassembler backends.</p></div></div></div></body></html>