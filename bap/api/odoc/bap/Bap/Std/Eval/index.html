<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Eval (bap.Bap.Std.Eval)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Eval</nav><h1>Module <code>Std.Eval</code></h1><p>Basic and generic expression evaluator.</p><p>The module provides functors that derive base classes and class types for Expi, Bili, and Biri.</p><p>Note, this is a low-level interface that can be used if you want to build your own evaluators (interpreters). If you want to use already existing interpreter without drastically changing the semantics of BIL consider using the Primus Framework.</p><dl><dt>since</dt><dd>1.3</dd></dl></header><dl><dt class="spec module" id="module-T1"><a href="#module-T1" class="anchor"></a><code><span class="keyword">module</span> <a href="T1/index.html">T1</a> : <span class="keyword">functor</span> (<a href="T1/argument-1-M/index.html">M</a> : <a href="../../../../core_kernel/Core_kernel/index.html#module-type-T1">Core_kernel.T1</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An evaluator interface parametrized by a <code>T1</code> monad.</p></dd></dl><dl><dt class="spec module" id="module-T2"><a href="#module-T2" class="anchor"></a><code><span class="keyword">module</span> <a href="T2/index.html">T2</a> : <span class="keyword">functor</span> (<a href="T2/argument-1-M/index.html">M</a> : <a href="../../../../core_kernel/Core_kernel/index.html#module-type-T2">Core_kernel.T2</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An evaluator parametrized by a <code>T2</code> monad.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An interface of a basic evaluator in a <code>T1</code> monad</p></dd></dl><dl><dt class="spec module-type" id="module-type-S2"><a href="#module-type-S2" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S2/index.html">S2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An interface of a basic evaluator in a <code>T1</code> monad</p></dd></dl><dl><dt class="spec module" id="module-Make2"><a href="#module-Make2" class="anchor"></a><code><span class="keyword">module</span> <a href="Make2/index.html">Make2</a> : <span class="keyword">functor</span> (<a href="Make2/argument-1-M/index.html">M</a> : <a href="../../../../monads/Monads/Std/Monad/index.html#module-type-S2">Monads.Std.Monad.S2</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S2">S2</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>('a, 'e) <a href="Make2/index.html#type-m">m</a></span> := <span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <a href="Make2/argument-1-M/index.html#type-t">M.t</a></span> <span class="keyword">and</span> <span class="keyword">module</span> <a href="Make2/M/index.html">M</a> := <a href="Make2/index.html#argument-1-M">M</a></code></dt><dd><p><code>Make2(M)</code> provides an implementation of the <code>S2</code> interface lifted into the monad <code>M</code>.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-M/index.html">M</a> : <a href="../../../../monads/Monads/Std/Monad/index.html#module-type-S">Monads.Std.Monad.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="Make/index.html#type-m">m</a></span> := <span><span class="type-var">'a</span> <a href="Make/argument-1-M/index.html#type-t">M.t</a></span> <span class="keyword">and</span> <span class="keyword">module</span> <a href="Make/M/index.html">M</a> := <a href="Make/index.html#argument-1-M">M</a></code></dt><dd><p><code>Make(M)</code> provides an implementation of the <code>S2</code> interface lifted into the monad <code>M</code>.</p></dd></dl></div></body></html>