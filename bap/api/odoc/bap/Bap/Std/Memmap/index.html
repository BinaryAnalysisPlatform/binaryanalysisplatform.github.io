<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Memmap (bap.Bap.Std.Memmap)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Memmap</nav><h1>Module <code>Std.Memmap</code></h1><p>Memory maps. Memory map is an assosiative data structure that maps memory regions to values. Unlike in the Table, memory regions in the Memmap can intersect in an arbitrary ways. This data structure is also known as an Interval Tree.</p><p><code>Memmap</code> is an instance of the <code>Interval_tree</code> with the <code>Memory</code> serving as an interval.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-memmap">memmap</a></span></code></dt><dd><p>memory map, aka interval trees</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt></dl></div></div></div><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>empty</code> map</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>singleton</code> a memory map containing only one memory region</p></dd></dl><dl><dt class="spec value" id="val-min_addr"><a href="#val-min_addr" class="anchor"></a><code><span class="keyword">val</span> min_addr : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../index.html#type-addr">addr</a> option</span></code></dt><dd><p><code>min_addr map</code> is a minimum addr mapped in <code>map</code></p></dd></dl><dl><dt class="spec value" id="val-max_addr"><a href="#val-max_addr" class="anchor"></a><code><span class="keyword">val</span> max_addr : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../index.html#type-addr">addr</a> option</span></code></dt><dd><p><code>max_addr map</code> is a maximum addr mapped in <code>map</code></p></dd></dl><dl><dt class="spec value" id="val-min_binding"><a href="#val-min_binding" class="anchor"></a><code><span class="keyword">val</span> min_binding : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>min_binding map</code> is a minimum binding mapped in <code>map</code></p></dd></dl><dl><dt class="spec value" id="val-max_binding"><a href="#val-max_binding" class="anchor"></a><code><span class="keyword">val</span> max_binding : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>max_binding map</code> is a maximum binding mapped in <code>map</code></p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>add map mem tag</code> adds a new memory region <code>mem</code> tagged with <code>tag</code>. If the same region was already in the <code>map</code> it will be tagged with the <code>tag</code> again, even if it has had the same tag.</p></dd></dl><dl><dt class="spec value" id="val-dominators"><a href="#val-dominators" class="anchor"></a><code><span class="keyword">val</span> dominators : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span></code></dt><dd><p><code>dominators map mem</code> an ordered sequence of all memory regions, containing <code>mem</code>. A memory region <code>(x,y)</code> contains region <code>(p,q)</code>, iff <code>p &gt;= x &amp;&amp; q &lt;= y</code>, where memory regions are depicted using closed intervals.</p></dd></dl><dl><dt class="spec value" id="val-intersections"><a href="#val-intersections" class="anchor"></a><code><span class="keyword">val</span> intersections : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span></code></dt><dd><p><code>intersections map mem</code> an ordered sequence of all memory regions, that intersects with <code>mem</code>. Memory region <code>(x,y)</code> intersects with region <code>(p,q)</code> iff there exists such <code>z</code> that</p><p><code>z &gt;= p || z &lt;= q &amp;&amp; z &gt;= x &amp;&amp; z &lt;= y</code>.</p><p>In other words if there exists such byte that belongs to both memory regions.</p></dd></dl><dl><dt class="spec value" id="val-intersects"><a href="#val-intersects" class="anchor"></a><code><span class="keyword">val</span> intersects : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>intersects map mem</code> is true if <code>intersections map mem</code> is not empty</p></dd></dl><dl><dt class="spec value" id="val-dominates"><a href="#val-dominates" class="anchor"></a><code><span class="keyword">val</span> dominates : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>dominates map mem</code> if there is a non empty set of dominators</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains map addr</code> true if there exists such memory region <code>mem</code>, that <code>Memory.contains mem addr</code></p></dd></dl><dl><dt class="spec value" id="val-lookup"><a href="#val-lookup" class="anchor"></a><code><span class="keyword">val</span> lookup : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span></code></dt><dd><p><code>lookup map addr</code> returns an ordered sequence of all memory containing the <code>addr</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map m f</code> returns a new map with each tag mapped with function <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mapi m f</code> the same as <code>map</code>, but <code>f</code> is called with two arguments: <code>mem</code> and <code>tag</code>, where <code>mem</code> is a memory region, and <code>tag</code> is a <code>tag</code> associated with that region.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter map f</code> returns a map that contains only those elements for which <code>f</code> evaluated to <code>true</code></p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_map m f</code> creates a new map by applying a function <code>f</code> to each tag. If <code>f</code> returns <code>Some x</code> then this region will be mapped to <code>x</code> in a new map, otherwise it will be dropped.</p></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val</span> filter_mapi : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_mapi</code> is like <code>filter_map</code> but use function also accepts would associated memory region</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove map mem</code> removes all bindings to <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-remove_intersections"><a href="#val-remove_intersections" class="anchor"></a><code><span class="keyword">val</span> remove_intersections : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove_intersections map mem</code> removes all bindings that that intersects with <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-remove_dominators"><a href="#val-remove_dominators" class="anchor"></a><code><span class="keyword">val</span> remove_dominators : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove_dominators map mem</code> removes all bindings that are dominators to <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-to_sequence"><a href="#val-to_sequence" class="anchor"></a><code><span class="keyword">val</span> to_sequence : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span></code></dt><dd><p><code>to_sequence map</code> converts the memmap <code>'a t</code> to a sequence of key-value pairs</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../core_kernel/Core_kernel/Container/index.html#module-type-S1">Core_kernel.Container.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../../../../core_kernel/Core_kernel/Container/module-type-S1/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>equal:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Checks whether the provided element is there, using <code>equal</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'accum</span></code></dt><dd><p><code>fold t ~init ~f</code> returns <code>f (... f (f (f init e1) e2) e3 ...) en</code>, where <code>e1..en</code> are the elements of <code>t</code></p></dd></dl><dl><dt class="spec value" id="val-fold_result"><a href="#val-fold_result" class="anchor"></a><code><span class="keyword">val</span> fold_result : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'accum</span>,Â <span class="type-var">'e</span>)</span> <a href="../../../../base/Base/Result/index.html#type-t">Base.Result.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'accum</span>,Â <span class="type-var">'e</span>)</span> <a href="../../../../base/Base/Result/index.html#type-t">Base.Result.t</a></span></code></dt><dd><p><code>fold_result t ~init ~f</code> is a short-circuiting version of <code>fold</code> that runs in the <code>Result</code> monad. If <code>f</code> returns an <code>Error _</code>, that value is returned without any additional invocations of <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_until"><a href="#val-fold_until" class="anchor"></a><code><span class="keyword">val</span> fold_until : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'accum</span>,Â <span class="type-var">'final</span>)</span> <a href="../../../../base/Base__/Container_intf/Export/Continue_or_stop/index.html#type-t">Base__.Container_intf.Continue_or_stop.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>finish:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'final</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'final</span></code></dt><dd><p><code>fold_until t ~init ~f ~finish</code> is a short-circuiting version of <code>fold</code>. If <code>f</code> returns <code>Stop _</code> the computation ceases and results in that value. If <code>f</code> returns <code>Continue _</code>, the fold will proceed. If <code>f</code> never returns <code>Stop _</code>, the final result is computed by <code>finish</code>.</p><p>Example:</p><pre><code class="ml">type maybe_negative =
  | Found_negative of int
  | All_nonnegative of { sum : int }

(** [first_neg_or_sum list] returns the first negative number in [list], if any,
    otherwise returns the sum of the list. *)
let first_neg_or_sum =
  List.fold_until ~init:0
    ~f:(fun sum x -&gt;
      if x &lt; 0
      then Stop (Found_negative x)
      else Continue (sum + x))
    ~finish:(fun sum -&gt; All_nonnegative { sum })
;;

let x = first_neg_or_sum [1; 2; 3; 4; 5]
val x : maybe_negative = All_nonnegative {sum = 15}

let y = first_neg_or_sum [1; 2; -3; 4; 5]
val y : maybe_negative = Found_negative -3</code></pre></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns <code>true</code> if and only if there exists an element for which the provided function evaluates to <code>true</code>. This is a short-circuiting operation.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns <code>true</code> if and only if the provided function evaluates to <code>true</code> for all elements. This is a short-circuiting operation.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Returns the number of elements for which the provided function evaluates to true.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <span>(<span class="keyword">module</span> <a href="../../../../base/Base__/Container_intf/module-type-Summable/index.html">Base__.Container_intf.Summable</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../../base/Base__/Container_intf/module-type-Summable/index.html#type-t">t</a> = <span class="type-var">'sum</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'sum</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'sum</span></code></dt><dd><p>Returns the sum of <code>f i</code> for all <code>i</code> in the container.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Returns as an <code>option</code> the first element for which <code>f</code> evaluates to true.</p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p>Returns the first evaluation of <code>f</code> that returns <code>Some</code>, and returns <code>None</code> if there is no such element.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span></code></dt><dt class="spec value" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span class="keyword">val</span> min_elt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Returns a minimum (resp maximum) element from the collection using the provided <code>compare</code> function, or <code>None</code> if the collection is empty. In case of a tie, the first element encountered while traversing the collection is returned. The implementation uses <code>fold</code> so it has the same complexity as <code>fold</code>.</p></dd></dl><dl><dt class="spec value" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span class="keyword">val</span> max_elt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><span class="type-var">'a</span> <a href="../../../../regular/Regular/Std/index.html#type-printer">Regular.Std.printer</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="../../../../regular/Regular/Std/index.html#type-printer">Regular.Std.printer</a></span></code></dt><dd><p><code>pp pp_elem</code> constracts a printer for a memmap to the given element.</p></dd></dl></div></body></html>