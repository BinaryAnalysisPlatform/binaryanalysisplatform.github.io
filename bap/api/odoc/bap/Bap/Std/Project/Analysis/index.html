<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Analysis (bap.Bap.Std.Project.Analysis)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../../index.html">bap</a> &#x00BB; <a href="../../../index.html">Bap</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Project</a> &#x00BB; Analysis</nav><h1>Module <code>Project.Analysis</code></h1><p>Knowledge base analyses.</p><p>A registry of the knowledge base computations that could be used for exploring and refining the facts stored in the knowledge base.</p><p>An analysis could be parameterized by an arbitrary number of arguments, e.g., to register a function <code>print_subr</code> that has type</p><pre><code class="ml">tid -&gt; string -&gt; Bitvec.t -&gt; unit knowledge</code></pre><p>use the following code</p><pre><code class="ml">let open Project.Analysis in
register ~package &quot;subroutine&quot;
  (args @@ unit $ string $ bitvec)
  print_subr</code></pre><p>The registered analyses could be invoked directly, using the <code>Analysis.apply</code> function or via the <code>analysis</code> plugin that provides a REPL as well as an ability to call analysis from the command-line interface or from a script. To get the list of available analyses, run `bap analyze commands`.</p><nav class="toc"><ul><li><a href="#grammar-rules">Grammar Rules</a><ul><li><a href="#terminals">Terminals</a></li><li><a href="#non-terminals">Non-terminals</a></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>the type for analyses</p></dd></dl><dl><dt class="spec type" id="type-info"><a href="#type-info" class="anchor"></a><code><span class="keyword">type</span> info</code></dt><dd><p>information about an analysis</p></dd></dl><dl><dt class="spec type" id="type-grammar"><a href="#type-grammar" class="anchor"></a><code><span class="keyword">type</span> grammar</code></dt><dd><p>a description of the analysis application syntax</p></dd></dl><dl><dt class="spec type" id="type-arg"><a href="#type-arg" class="anchor"></a><code><span class="keyword">type</span> <span>'a arg</span></code></dt><dd><p>a description of an analysis argument</p></dd></dl><dl><dt class="spec type" id="type-args"><a href="#type-args" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'r) args</span></code></dt><dd><p>a signature of an analysis.</p><p>The <code>'r</code> type denotes the return type of an analysis, which is always <code>unit knowledge</code> and the <code>'a</code> type variable denotes the function type of the analysis, e.g., an analysis of type</p><pre><code class="ml">tid -&gt; Bitvec.t -&gt; unit knowledge</code></pre><p>will have the following args type</p><pre><code class="ml">(tid -&gt; Bitvec.t -&gt; unit knowledge, unit knowledge) args</code></pre></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span>unit <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span></code></dt><dd><p><code>apply analysis</code> is the computation performed by the analysis.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt><dd><p><code>find ?package string</code> searches the analysis with the given name in the registry.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="index.html#type-info">info</a> <span>&#45;&gt;</span> <a href="../../../../../bap-knowledge/Bap_knowledge/Knowledge/Name/index.html#type-t">Bap_knowledge.Knowledge.Name.t</a></code></dt><dd><p><code>name info</code> is the analysis unique name.</p></dd></dl><dl><dt class="spec value" id="val-desc"><a href="#val-desc" class="anchor"></a><code><span class="keyword">val</span> desc : <a href="index.html#type-info">info</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>desc info</code> is the short description of the analysis</p></dd></dl><dl><dt class="spec value" id="val-grammar"><a href="#val-grammar" class="anchor"></a><code><span class="keyword">val</span> grammar : <a href="index.html#type-info">info</a> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>grammar info</code> is the description of the rule grammar.</p></dd></dl><dl><dt class="spec value" id="val-register"><a href="#val-register" class="anchor"></a><code><span class="keyword">val</span> register : <span>?&#8288;desc:string</span> <span>&#45;&gt;</span> <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>unit <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span> <a href="index.html#type-args">args</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>register ?desc ?package name comp</code> registers the knowledge computation as an analysis. The <code>package:name</code> pair should be unique.</p></dd></dl><dl><dt class="spec value" id="val-registered"><a href="#val-registered" class="anchor"></a><code><span class="keyword">val</span> registered : unit <span>&#45;&gt;</span> <span><a href="index.html#type-info">info</a> list</span></code></dt><dd><p>information about currently registered analyses</p></dd></dl><dl><dt class="spec value" id="val-args"><a href="#val-args" class="anchor"></a><code><span class="keyword">val</span> args : <span><span class="type-var">'a</span> <a href="index.html#type-arg">arg</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-args">args</a></span></code></dt><dd><p><code>args x</code> a unary signature.</p><p>Creates a signature of a function that takes one argument. The type <code>'a</code> of the argument and its syntax are represented by the value of type <code>'a arg</code>.</p><p>Examples,</p><ul><li><pre><code class="ml">args empty</code></pre><p>-- a function of type <code>unit -&gt; 'r</code></p></li><li><pre><code class="ml">args string</code></pre><p>-- a function of type <code>string -&gt; 'r</code>.</p></li></ul><p>Note, while the <code>'r</code> type is kept as a variable it will be concretized to the <code>unit knowledge</code> when the function of this type will be registered using the <code>register</code> function.</p></dd></dl><dl><dt class="spec value" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val</span> ($) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-args">args</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-arg">arg</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-args">args</a></span></code></dt><dd><p><code>args $ arg</code> appends <code>arg</code> to <code>args</code>.</p><p>If <code>args</code> denote a signature of a function with type <code>x -&gt; y</code> and <code>arg</code> has type <code>z</code>, then <code>args $ arg</code> denote a signature of type <code>x -&gt; y -&gt; z</code>.</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><p><code>args string $ bitvec $ program</code> - denotes a function of type <code>string -&gt; Bitvec.t -&gt; Theory.Label.t -&gt; 'r</code>.</p><h4 id="a-note-on-the-type"><a href="#a-note-on-the-type" class="anchor"></a>A note on the type</h4><p>The type of the <code>$</code> makes a little bit more clear if we will consider the following example, <code>args string $ bitvec</code>, where</p><ul><li><code>args string</code> has type <code>(string -&gt; 'r,'r) args</code> and</li><li><code>bitvec</code> has type <code>Bitvec.t arg</code>.</li></ul><p>The type of <code>args string $ bitvec</code> is computed by unifying <code>string -&gt; 'r</code> with <code>'a</code> and <code>'r</code> with <code>'b -&gt; 'c</code>, where <code>'b</code> is <code>Bitvec.t</code>. A syntactic unification gives us the following values for the variables <code>'r</code> and <code>'a</code></p><ul><li><code>'r = Bitvec.t -&gt; 'c</code></li><li><code>'a = string -&gt; 'r = string -&gt; Bitvec.t -&gt; 'c</code></li></ul><p>Therefore the type of <code>args string $ bitvec</code> is</p><pre><code class="ml">('a,'c) args = (string -&gt; Bitvec.t -&gt; 'c,'c) args</code></pre></dd></dl><section><header><h3 id="grammar-rules"><a href="#grammar-rules" class="anchor"></a>Grammar Rules</h3></header><section><header><h4 id="terminals"><a href="#terminals" class="anchor"></a>Terminals</h4></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span>unit <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>empty</code> no arguments.</p><p>The syntax is an empty string and the signature is a unary function that takes an argument of type <code>unit</code>.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>string <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>string</code> a string argument.</p><p>The syntax is a string of characters that does not include whitespaces.</p></dd></dl><dl><dt class="spec value" id="val-bitvec"><a href="#val-bitvec" class="anchor"></a><code><span class="keyword">val</span> bitvec : <span><a href="../../../../../bitvec/Bitvec/index.html#type-t">Bitvec.t</a> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>bitvec</code> a bitvector.</p><p>The syntax is described in the <a href="../../../../../bitvec/Bitvec/index.html#val-of_string"><code>Bitvec.of_string</code></a> and is a non-negative binary, octal, hexadecimal, or decimal numeral.</p></dd></dl><dl><dt class="spec value" id="val-program"><a href="#val-program" class="anchor"></a><code><span class="keyword">val</span> program : <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/Label/index.html#type-t">Bap_core_theory.Theory.Label.t</a> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>program</code> a program label.</p><p>The syntax is a textual representation of the knowledge base symbol (<span class="xref-unresolved" title="unresolved reference to &quot;Knowledge.Symbol&quot;"><code>Knowledge</code>.Symbol</span>). Unqualified names are read in the current package.</p><p>Examples, <code>0x88f0</code> or <code>bin/arm-linux-gnueabi-echo:0x88f0</code>.</p></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span><a href="../../../../../bap-core-theory/Bap_core_theory/Theory/Unit/index.html#type-t">Bap_core_theory.Theory.Unit.t</a> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>unit</code> a program unit.</p><p>The syntax is a textual representation of the knowledge base symbol (<span class="xref-unresolved" title="unresolved reference to &quot;Knowledge.Symbol&quot;"><code>Knowledge</code>.Symbol</span>). Unqualified names are read in the current package.</p><p>Examples, <code>file:/bin/ls</code> or <code>my-unit</code>.</p></dd></dl><dl><dt class="spec value" id="val-argument"><a href="#val-argument" class="anchor"></a><code><span class="keyword">val</span> argument : <span>?&#8288;desc:string</span> <span>&#45;&gt;</span> <span>parse:<span>(<span>fail:<span>(string <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../../bap-knowledge/Bap_knowledge/index.html#type-knowledge">Bap_knowledge.knowledge</a></span>)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>argument ~parse name</code> defines a new terminal.</p><p>The <code>name</code> denotes the name of the rule as it will appear in the grammar definition. The <code>parse</code> function defines the grammar, it is called as <code>parse fail input</code> where <code>input</code> is the value of type <code>string</code>. The <code>parse</code> function should either produce a value of type <code>'a</code> if <code>input</code> is a valid representation or use <code>fail error</code> to indicate that it is invalid, where <code>error</code> is the error message.</p><p>The <code>parse</code> function is a knowledge computation so it can access the knowledge base to construct the value.</p></dd></dl></section><section><header><h4 id="non-terminals"><a href="#non-terminals" class="anchor"></a>Non-terminals</h4></header><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span><span class="type-var">'a</span> <a href="index.html#type-arg">arg</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>optional x</code> an optional argument <code>x</code>.</p><p>The syntax of <code>args xs $ optional x</code> is <code>&lt;xs&gt; [&lt;x&gt;]</code>, where <code>&lt;x&gt;</code> denotes the syntax of the argument <code>x</code>, <code>[]</code> indicates that it can be omitted, and <code>&lt;xs&gt;</code> is the grammar of the signature <code>xs</code>. An optional argument should be the last argument in the signature, otherwise the resulting grammar will be ambiguous.</p><p>Example, the grammar of</p><pre><code class="ml">  args string $ optional bitvec
}],

recognizes the following strings,
  - [&quot;hello&quot;]
  - [&quot;hello 0x42&quot;]  </code></pre></dd></dl><dl><dt class="spec value" id="val-keyword"><a href="#val-keyword" class="anchor"></a><code><span class="keyword">val</span> keyword : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-arg">arg</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>keyword s x</code> an optional keyworded argument <code>x</code>.</p><p>The syntax of <code>args xs $ keyword s x</code> is </p><pre><code class="ml">&lt;xs&gt; [:&lt;s&gt; &lt;x&gt;]</code></pre><p>, where <code>&lt;x&gt;</code> denotes the syntax of the argument <code>x</code>, <code>[]</code> indicates that it can be omitted, <code>:&lt;s&gt;</code> is the literal string <code>&quot;:&lt;s&gt;&quot;</code>, where <code>&lt;s&gt;</code> is equal to <code>s</code>, and <code>&lt;xs&gt;</code> is the grammar of the signature <code>xs</code>. If a grammar includes several keyworded arguments they may follow in an arbitrary order.</p><p>Example, the grammar of</p><pre><code class="ml">  args @@
  keyword &quot;foo&quot; string $
  keyword &quot;bar&quot; bitvec
}],

recognizes the following strings,

  - [&quot;&quot;]
  - [&quot;:foo hello&quot;]
  - [&quot;:bar 0x42&quot;]
  - [&quot;:foo hello :bar 0x42&quot;]
  - [&quot;:bar 0x42 :foo hello&quot;]</code></pre></dd></dl><dl><dt class="spec value" id="val-flag"><a href="#val-flag" class="anchor"></a><code><span class="keyword">val</span> flag : string <span>&#45;&gt;</span> <span>bool <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>flag x</code> a keyword <code>x</code> without arguments.</p><p>The syntax of <code>args xs $ flag s</code> is </p><pre><code class="ml">&lt;xs&gt; [:&lt;s&gt;]</code></pre><p>, where <code>[]</code> indicates that it can be omitted, <code>:s</code> is the literal string <code>&quot;:&lt;s&gt;&quot;</code>, where <code>&lt;s&gt;</code> is equal to <code>s</code>, and <code>&lt;xs&gt;</code> is the grammar of the signature <code>xs</code>. If a grammar includes several flags they may follow in an arbitrary order.</p><p>Example, the grammar of</p><pre><code class="ml">  args @@
  flag &quot;foo&quot; $
  flag &quot;bar&quot;
}],

recognizes the following strings,
  - [&quot;&quot;]
  - [&quot;:foo hello&quot;]
  - [&quot;:bar 0x42&quot;]
  - [&quot;:foo hello :bar 0x42&quot;]
  - [&quot;:bar 0x42 :foo hello&quot;]
  - and so on.</code></pre></dd></dl><dl><dt class="spec value" id="val-rest"><a href="#val-rest" class="anchor"></a><code><span class="keyword">val</span> rest : <span><span class="type-var">'a</span> <a href="index.html#type-arg">arg</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-arg">arg</a></span></code></dt><dd><p><code>rest x</code> a zero or more <code>x</code> arguments.</p><p>The syntax of <code>args xs $ rest x</code> is </p><pre><code class="ml">&lt;xs&gt; [&lt;x&gt;]...</code></pre><p>, where <code>[]...</code> indicates that an argument can be omitted or repeated an arbitrary number of times, <code>&lt;x&gt;</code> is syntax of the agument <code>x</code>, and <code>&lt;xs&gt;</code> is the grammar of the signature <code>xs</code>. The <code>rest x</code> argument should be the last argument in the signature, and any extensions of the resulting signature will lead to an ambiguous grammar.</p><p>Example, the grammar of</p><pre><code class="ml">  args string $ rest bitvec
}],

recognizes the following strings,
  - [&quot;hello&quot;]
  - [&quot;hello 0x42&quot;]
  - [&quot;hello 0x42 42&quot;]
  - and so on</code></pre></dd></dl><dl><dt class="spec module" id="module-Grammar"><a href="#module-Grammar" class="anchor"></a><code><span class="keyword">module</span> <a href="Grammar/index.html">Grammar</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Abstract Grammar descriptions.</p></dd></dl></section></section></div></body></html>