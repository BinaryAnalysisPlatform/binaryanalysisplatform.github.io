<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Eff (bap.Bap.Std.Eff)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Eff</nav><h1>Module <code>Std.Eff</code></h1><p>Effect analysis.</p><p>Effect analysis describes how an expression computation interacts with the outside world. By the outside world we understand the whole of the CPU state (including the hidden state) and the memory. We distinguish, so far, between the following sorts of effects:</p><ul><li>coeffects - a value of an expression depends on the outside world, that is further subdivided by the read effect, when an expression reads a CPU register, and the load effect, when an expression an expression accesses the memory.</li></ul><ul><li>effects - a value modifies the state of the world, by either storing a value in the memory, or by raising a CPU exception via the division by zero or accessing the memory.</li></ul><p>An expression that doesn't have effects or coeffects is idempotent and can be moved arbitrary in a tree, removed or substituted. An expression that has only <code>coeffects</code> is generative and can be reproduced without a significant change of semantics.</p><p>Examples:</p><ul><li><code>x ^ x</code>, <code>x+1</code>, <code>x</code> - have coeffects;</li><li><code>x[y]</code> - has both effects (may raise pagefault) and coeffects;</li><li><code>7 * 8</code>, <code>42</code> - have no effects.</li></ul><dl><dt>since</dt><dd>1.3</dd></dl></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>a set of expression effects</p></dd></dl><dl><dt class="spec value" id="val-none"><a href="#val-none" class="anchor"></a><code><span class="keyword">val</span> none : <a href="index.html#type-t">t</a></code></dt><dd><p>an expression doesn't have any effects</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-t">t</a></code></dt><dd><p>an expression reads a register (nonvirtual) variable.</p></dd></dl><dl><dt class="spec value" id="val-load"><a href="#val-load" class="anchor"></a><code><span class="keyword">val</span> load : <a href="index.html#type-t">t</a></code></dt><dd><p>an expression loads a value from a memory</p></dd></dl><dl><dt class="spec value" id="val-store"><a href="#val-store" class="anchor"></a><code><span class="keyword">val</span> store : <a href="index.html#type-t">t</a></code></dt><dd><p>an expression stores a value in a memory</p></dd></dl><dl><dt class="spec value" id="val-raise"><a href="#val-raise" class="anchor"></a><code><span class="keyword">val</span> raise : <a href="index.html#type-t">t</a></code></dt><dd><p>an expression raises a CPU exception</p></dd></dl><dl><dt class="spec value" id="val-reads"><a href="#val-reads" class="anchor"></a><code><span class="keyword">val</span> reads : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>reads eff</code> if <code>read</code> in <code>eff</code></p></dd></dl><dl><dt class="spec value" id="val-loads"><a href="#val-loads" class="anchor"></a><code><span class="keyword">val</span> loads : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>loads eff</code> if <code>load</code> in <code>eff</code></p></dd></dl><dl><dt class="spec value" id="val-stores"><a href="#val-stores" class="anchor"></a><code><span class="keyword">val</span> stores : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>stores eff</code> if <code>load</code> in <code>eff</code></p></dd></dl><dl><dt class="spec value" id="val-raises"><a href="#val-raises" class="anchor"></a><code><span class="keyword">val</span> raises : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>raises eff</code> if <code>raise</code> in <code>eff</code></p></dd></dl><dl><dt class="spec value" id="val-has_effects"><a href="#val-has_effects" class="anchor"></a><code><span class="keyword">val</span> has_effects : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_effects eff</code> if <code>stores eff</code> || <code>raises eff</code></p></dd></dl><dl><dt class="spec value" id="val-has_coeffects"><a href="#val-has_coeffects" class="anchor"></a><code><span class="keyword">val</span> has_coeffects : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_coeffects eff</code> if <code>loads eff</code> || <code>reads eff</code></p></dd></dl><aside><p><code>compute x</code> computes a set of effects produced by <code>x</code>. The result is a sound overapproximation of the real effects, i.e., if an effect is computed then it may really happen, but if it is not computed, then it is proved that it is not possible for the expression to have this effect.</p><p>The analysis applies a simple abstract interpretation to approximate arithmetic and prove an absence of the division by zero. The load/store/read analysis is more precise than the division by zero, as the only source of the imprecision is a presence of conditional expressions.</p><p>Requires: normalized and simplified expression.</p><p>Warning: the above should be either relaxed or expressed in the type system.</p></aside><dl><dt class="spec value" id="val-compute"><a href="#val-compute" class="anchor"></a><code><span class="keyword">val</span> compute : <a href="../index.html#type-exp">exp</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl></div></body></html>