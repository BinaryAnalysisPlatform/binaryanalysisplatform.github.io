<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Memory (bap.Bap.Std.Memory)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Memory</nav><h1>Module <code>Std.Memory</code></h1><p>Memory region</p><nav class="toc"><ul><li><a href="#interfacing-with-c">Interfacing with C</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../index.html#type-mem">mem</a></code></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;pos:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <a href="../index.html#type-endian">endian</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> Core_kernel.Bigstring.t <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>create ?pos ?len endian start data</code> creates a memory region.</p><p>Creates a memory view of the provided <code>data</code> using the specified byte order <code>endian</code> and mapping the first (<code>pos</code>) byte to the <code>start</code> address. The <code>pos</code> and <code>len</code> parameters can be used to narrow down the view, and default to <code>0</code> and the length of the provided string, correspondingly.</p><p>The <code>data</code> may not be copied and the returned memory view may reference the same bigstring object.</p></dd></dl><dl><dt class="spec value" id="val-rebase"><a href="#val-rebase" class="anchor"></a><code><span class="keyword">val</span> rebase : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>rebase mem addr</code> returns the same memory but with the new starting address <code>addr</code>.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-slot"><a href="#val-slot" class="anchor"></a><code><span class="keyword">val</span> slot : <span><span>(<a href="../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-program">Bap_core_theory.Theory.program</a>, <span><a href="../index.html#type-mem">mem</a> option</span>)</span> <a href="../../../../bap-knowledge/Bap_knowledge/Knowledge/index.html#type-slot">Bap_knowledge.Knowledge.slot</a></span></code></dt><dd><p>memory representation of a program</p></dd></dl><dl><dt class="spec value" id="val-of_file"><a href="#val-of_file" class="anchor"></a><code><span class="keyword">val</span> of_file : <a href="../index.html#type-endian">endian</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>of_file endian start name</code> creates a memory region from file. Takes data stored in a file with the given <code>name</code> and maps it to the memory region with the specified starting address <code>start</code> and using the <code>endian</code> for storing and reading words.</p></dd></dl><dl><dt class="spec value" id="val-view"><a href="#val-view" class="anchor"></a><code><span class="keyword">val</span> view : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <span>?&#8288;from:<a href="../index.html#type-addr">addr</a></span> <span>&#45;&gt;</span> <span>?&#8288;words:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>view word_size ~from ~words mem</code> returns a new memory that represents the specified region of memory <code>mem</code>. <code>copy</code> function performs deep copy.</p><dl><dt>parameter addr</dt><dd><p>defaults <code>min_addr mem</code></p></dd></dl><dl><dt>parameter words</dt><dd><p>defaults to the end of the memory region.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-view_exn"><a href="#val-view_exn" class="anchor"></a><code><span class="keyword">val</span> view_exn : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <span>?&#8288;from:<a href="../index.html#type-addr">addr</a></span> <span>&#45;&gt;</span> <span>?&#8288;words:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>view_exn mem</code> is the same as <code>ok_exn @@view_exn mem</code> but is slightly more efficient.</p><dl><dt>raises Invalid_arg</dt><dd><p>in case if the arguments are not fitting into the memory.</p></dd></dl><dl><dt>since</dt><dd>2.2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>range mem a0 a1</code> returns a view on <code>mem</code> starting from address <code>a0</code> and ending at <code>a1</code>, bounds inclusive</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>merge m1 m2</code> takes two memory regions, that either intersects or share edges (i.e., difference between <code>min_addr</code> of one of the blocks and <code>max_addr</code> of another is less then or equal to one, and returns memory blocks that spans memory starting from the address</p><pre><code class="ml">min (min_addr m1) (min_addr m2)</code></pre><p>and ending with address</p><pre><code class="ml">max (max_addr m1) (max_addr m2)</code></pre><p>.</p><p>Will return an error, if either the above state precondition doesn't hold, or if this two memory blocks doesn't share the same underlying memory (i.e., bases), or if they have different endianness.</p></dd></dl><dl><dt class="spec value" id="val-first_byte"><a href="#val-first_byte" class="anchor"></a><code><span class="keyword">val</span> first_byte : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>first_byte m</code> returns first byte of <code>m</code> as a memory</p></dd></dl><dl><dt class="spec value" id="val-last_byte"><a href="#val-last_byte" class="anchor"></a><code><span class="keyword">val</span> last_byte : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>last_byte m</code> returns last byte of <code>m</code> as a memory</p></dd></dl><dl><dt class="spec value" id="val-endian"><a href="#val-endian" class="anchor"></a><code><span class="keyword">val</span> endian : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-endian">endian</a></code></dt><dd><p>returns the order of bytes in a word</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span>?&#8288;disp:int</span> <span>&#45;&gt;</span> <span>?&#8288;index:int</span> <span>&#45;&gt;</span> <span>?&#8288;scale:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <span>?&#8288;addr:<a href="../index.html#type-addr">addr</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../index.html#type-word">word</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>get ?disp ?index ?scale ?addr mem</code> reads a <code>scale</code> sized word from <code>mem</code>.</p><p>Parameters mimic the reference syntax in the gas assembler, e.g., <code>dis(base,index,scale)</code> denotes address at <code>base + index * scale + dis</code>.</p><p>The size of the returned word is equal to <code>scale</code>, bytes are read in the <code>endian mem</code> order.</p><dl><dt>parameter disp</dt><dd><p>is the base offset and defaults to <code>0</code></p></dd></dl><dl><dt>parameter index</dt><dd><p>defaults to <code>0</code></p></dd></dl><dl><dt>parameter scale</dt><dd><p>defaults to <code>`r8</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-(^)"><a href="#val-(^)" class="anchor"></a><code><span class="keyword">val</span> (^) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span><a href="../index.html#type-word">word</a> Core_kernel.Or_error.t</span></code></dt><dd><p><code>m^n</code> dereferences a byte at address <code>n</code></p></dd></dl><dl><dt class="spec value" id="val-(^!)"><a href="#val-(^!)" class="anchor"></a><code><span class="keyword">val</span> (^!) : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a></code></dt><dd><p><code>m^.n</code> dereferences a byte at address <code>n</code></p></dd></dl><dl><dt class="spec value" id="val-max_addr"><a href="#val-max_addr" class="anchor"></a><code><span class="keyword">val</span> max_addr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a></code></dt><dd><p><code>max_addr m</code> is an address of the last byte of <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-min_addr"><a href="#val-min_addr" class="anchor"></a><code><span class="keyword">val</span> min_addr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a></code></dt><dd><p><code>min_addr m</code> is an address of the first byte of <code>m</code></p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length m</code> returns a number of bytes in m</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains mem addr</code> returns true if <code>mem</code> contains address <code>addr</code></p></dd></dl><dl><dt class="spec value" id="val-compare_with"><a href="#val-compare_with" class="anchor"></a><code><span class="keyword">val</span> compare_with : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span>[ `addr_is_inside <span>| `addr_is_below</span> <span>| `addr_is_above</span> ]</span></code></dt><dd><p><code>compare_with mem addr</code> compares memory with <code>addr</code></p></dd></dl><dl><dt class="spec module" id="module-Input"><a href="#module-Input" class="anchor"></a><code><span class="keyword">module</span> <a href="Input/index.html">Input</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A set of low level input operations. Note: it is more effective to use above head iterators, instead of this low level interface, since iterators do not need to check every memory access.</p></dd></dl><div><div class="spec include"><div class="doc"><h3 id="printing-and-outputting"><a href="#printing-and-outputting" class="anchor"></a>Printing and outputting</h3><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../regular/Regular/Std/Printable/index.html#module-type-S">Regular.Std.Printable.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../../regular/Regular/Std/Printable/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>type of printable</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string x</code> returns a human-readable representation of <code>x</code></p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>str () t</code> is formatted output function that matches &quot;%a&quot; conversion format specifier in functions, that prints to string, e.g., <code>sprintf</code>, <code>failwithf</code>, <code>errorf</code> and, surprisingly all <code>Lwt</code> printing function, including <code>Lwt_io.printf</code> and logging (or any other function with type ('a,unit,string,...) formatN`. Example:</p><pre><code class="ml">Or_error.errorf &quot;type %a is not valid for %a&quot;
  Type.str ty Exp.str exp</code></pre></dd></dl><dl><dt class="spec value" id="val-pps"><a href="#val-pps" class="anchor"></a><code><span class="keyword">val</span> pps : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>synonym for <code>str</code></p></dd></dl><dl><dt class="spec value" id="val-ppo"><a href="#val-ppo" class="anchor"></a><code><span class="keyword">val</span> ppo : Core_kernel.Out_channel.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>will print to a standard <code>output_channel</code>, useful for using in <code>printf</code>, <code>fprintf</code>, etc.</p></dd></dl><dl><dt class="spec value" id="val-pp_seq"><a href="#val-pp_seq" class="anchor"></a><code><span class="keyword">val</span> pp_seq : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Core_kernel.Sequence.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>prints a sequence of values of type <code>t</code></p></dd></dl><div><div class="spec include"><div class="doc"><p>this will include <code>pp</code> function from <code>Core</code> that has type <a href="../../../../regular/Regular/Std/index.html#type-printer"><span><code>t printer</code></span></a>, and can be used in <code>Format.printf</code> family of functions</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Core_kernel.Pretty_printer.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="../index.html#module-Memory">Memory</a>.t := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Base__.Formatter.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></details></div></div></div></details></div></div></div><dl><dt class="spec value" id="val-hexdump"><a href="#val-hexdump" class="anchor"></a><code><span class="keyword">val</span> hexdump : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>hexdump t out</code> outputs hexdump (as per <code>hexdump -C</code>) of the memory to formatter <code>out</code></p></dd></dl><div><div class="spec include"><div class="doc"><p>a set of iterators, with identity monad.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-type-Memory_iterators">Memory_iterators</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Memory_iterators/index.html#type-t">t</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>'a <a href="../module-type-Memory_iterators/index.html#type-m">m</a></span> = <span class="type-var">'a</span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-m"><a href="#type-m" class="anchor"></a><code><span class="keyword">type</span> <span>'a m</span></code><code> = <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>fold ~word_size ~init ~f t</code> folds over elements of <code>t</code>, so a result is <code>f (... (f (f a elt_1) elt_2) ...) elt_n</code></p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>iter ~word_size ~f t</code> applies <code>f</code> to elements of <code>t</code></p></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val</span> foldi : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>foldi ~word_size ~init ~f t</code> is like <a href="index.html#val-fold"><code>fold</code></a>, but also passes an address to the <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>iteri ~word_size ~f t</code> is like <a href="index.html#val-iter"><code>iter</code></a>, but also passes an address to the <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>exists ~word_size ~f t</code> checks if at least one element of <code>t</code> satisfies the predicate <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>for_all ~word_size ~f t</code> checks if all elements of <code>t</code> satisfies the predicate <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span>int <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>count ~word_size ~f t</code> is the number of elements in <code>t</code> that satisfies the predicate <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_if"><a href="#val-find_if" class="anchor"></a><code><span class="keyword">val</span> find_if : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span>bool <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span><span><a href="../index.html#type-word">word</a> option</span> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>find_if ~word_size ~f t</code> returns the first element of <code>t</code> that satisfies the predicate <code>p</code> or None if no elements satisfied</p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span>?&#8288;word_size:<a href="../index.html#type-size">size</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <a href="../index.html#type-word">word</a> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-m">m</a></span>)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-m">m</a></span></code></dt><dd><p><code>find_map ~word_size ~f t</code> returns the first evaluation of <code>f</code> that returns <code>Some</code> or None if <code>f</code> always returns <code>None</code></p></dd></dl></details></div></div></div><dl><dt class="spec module" id="module-With_error"><a href="#module-With_error" class="anchor"></a><code><span class="keyword">module</span> <a href="With_error/index.html">With_error</a> : <a href="../index.html#module-type-Memory_iterators">Memory_iterators</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-Memory_iterators/index.html#type-t">t</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>'a <a href="../module-type-Memory_iterators/index.html#type-m">m</a></span> = <span><span class="type-var">'a</span> Core_kernel.Or_error.t</span></code></dt><dd><p>iterators lifter to the Or_error monad</p></dd></dl><dl><dt class="spec module" id="module-Make_iterators"><a href="#module-Make_iterators" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_iterators/index.html">Make_iterators</a> : <span class="keyword">functor</span> (<a href="Make_iterators/index.html#argument-1-M">M</a> : <a href="../Legacy/Monad/index.html#module-type-S">Legacy.Monad.S</a>) <span>&#45;&gt;</span> <a href="../index.html#module-type-Memory_iterators">Memory_iterators</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_iterators/index.html#type-t">t</a> := <a href="index.html#type-t">t</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>'a <a href="Make_iterators/index.html#type-m">m</a></span> = <span><span class="type-var">'a</span> <a href="Make_iterators/index.html#argument-1-M">M</a>.t</span></code></dt><dd><p>lifts iterators to monad <code>M</code></p></dd></dl><section><header><h3 id="interfacing-with-c"><a href="#interfacing-with-c" class="anchor"></a>Interfacing with C</h3><p>The following interfaces is supposed to be used only for the purposes of exposing memory to c programs.</p></header><dl><dt class="spec value" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span class="keyword">val</span> to_buffer : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core_kernel.Bigsubstring.t</code></dt><dd><p><code>to_buffers mem</code> creates a buffer representing the memory <code>mem</code>. It is not specified whether the returned buffer has some sharing with underlying implementation. In other words the returned buffer shouldn't be modified.</p><p>Since it is not guaranteed that memory is contiguous, a sequence of buffers is returned, with each buffer representing a contiguous part of memory.</p></dd></dl><dl><dt class="spec module" id="module-Trie"><a href="#module-Trie" class="anchor"></a><code><span class="keyword">module</span> <a href="Trie/index.html">Trie</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Tries over memory</p></dd></dl></section></div></body></html>