<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Memory (bap.Bap.Std.Memory)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Memory</nav><header class="odoc-preamble"><h1>Module <code><span>Std.Memory</span></code></h1><p>Memory region</p></header><nav class="odoc-toc"><ul><li><a href="#interfacing-with-c">Interfacing with C</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="../index.html#type-mem">mem</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>?pos:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Core_kernel</span>.Bigstring.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>create ?pos ?len endian start data</code> creates a memory region.</p><p>Creates a memory view of the provided <code>data</code> using the specified byte order <code>endian</code> and mapping the first (<code>pos</code>) byte to the <code>start</code> address. The <code>pos</code> and <code>len</code> parameters can be used to narrow down the view, and default to <code>0</code> and the length of the provided string, correspondingly.</p><p>The <code>data</code> may not be copied and the returned memory view may reference the same bigstring object.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rebase" class="anchored"><a href="#val-rebase" class="anchor"></a><code><span><span class="keyword">val</span> rebase : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rebase mem addr</code> returns the same memory but with the new starting address <code>addr</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-slot" class="anchored"><a href="#val-slot" class="anchor"></a><code><span><span class="keyword">val</span> slot : <span><span>(<a href="../../../../bap-core-theory/Bap_core_theory/Theory/index.html#type-program">Bap_core_theory.Theory.program</a>, <span><a href="../index.html#type-mem">mem</a> option</span>)</span> <a href="../../../../bap-knowledge/Bap_knowledge/Knowledge/index.html#type-slot">Bap_knowledge.Knowledge.slot</a></span></span></code></div><div class="spec-doc"><p>memory representation of a program</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_file" class="anchored"><a href="#val-of_file" class="anchor"></a><code><span><span class="keyword">val</span> of_file : <span><a href="../index.html#type-endian">endian</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>of_file endian start name</code> creates a memory region from file. Takes data stored in a file with the given <code>name</code> and maps it to the memory region with the specified starting address <code>start</code> and using the <code>endian</code> for storing and reading words.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-view" class="anchored"><a href="#val-view" class="anchor"></a><code><span><span class="keyword">val</span> view : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span>?from:<a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span>?words:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>view word_size ~from ~words mem</code> returns a new memory that represents the specified region of memory <code>mem</code>. <code>copy</code> function performs deep copy.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">addr</span> <p>defaults <code>min_addr mem</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">words</span> <p>defaults to the end of the memory region.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-view_exn" class="anchored"><a href="#val-view_exn" class="anchor"></a><code><span><span class="keyword">val</span> view_exn : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span>?from:<a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span>?words:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>view_exn mem</code> is the same as <code>ok_exn @@view_exn mem</code> but is slightly more efficient.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_arg</span> <p>in case if the arguments are not fitting into the memory.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>range mem a0 a1</code> returns a view on <code>mem</code> starting from address <code>a0</code> and ending at <code>a1</code>, bounds inclusive</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>merge m1 m2</code> takes two memory regions, that either intersects or share edges (i.e., difference between <code>min_addr</code> of one of the blocks and <code>max_addr</code> of another is less then or equal to one, and returns memory blocks that spans memory starting from the address</p><pre><code>min (min_addr m1) (min_addr m2)</code></pre><p>and ending with address</p><pre><code>max (max_addr m1) (max_addr m2)</code></pre><p>.</p><p>Will return an error, if either the above state precondition doesn't hold, or if this two memory blocks doesn't share the same underlying memory (i.e., bases), or if they have different endianness.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first_byte" class="anchored"><a href="#val-first_byte" class="anchor"></a><code><span><span class="keyword">val</span> first_byte : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>first_byte m</code> returns first byte of <code>m</code> as a memory</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last_byte" class="anchored"><a href="#val-last_byte" class="anchor"></a><code><span><span class="keyword">val</span> last_byte : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>last_byte m</code> returns last byte of <code>m</code> as a memory</p></div></div><div class="odoc-spec"><div class="spec value" id="val-endian" class="anchored"><a href="#val-endian" class="anchor"></a><code><span><span class="keyword">val</span> endian : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-endian">endian</a></span></code></div><div class="spec-doc"><p>returns the order of bytes in a word</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>?disp:int <span class="arrow">&#45;&gt;</span></span> <span>?index:int <span class="arrow">&#45;&gt;</span></span> <span>?scale:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span>?addr:<a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>get ?disp ?index ?scale ?addr mem</code> reads a <code>scale</code> sized word from <code>mem</code>.</p><p>Parameters mimic the reference syntax in the gas assembler, e.g., <code>dis(base,index,scale)</code> denotes address at <code>base + index * scale + dis</code>.</p><p>The size of the returned word is equal to <code>scale</code>, bytes are read in the <code>endian mem</code> order.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">disp</span> <p>is the base offset and defaults to <code>0</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">index</span> <p>defaults to <code>0</code></p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">scale</span> <p>defaults to <code>`r8</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(^)" class="anchored"><a href="#val-(^)" class="anchor"></a><code><span><span class="keyword">val</span> (^) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>m^n</code> dereferences a byte at address <code>n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(^!)" class="anchored"><a href="#val-(^!)" class="anchor"></a><code><span><span class="keyword">val</span> (^!) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-word">word</a></span></code></div><div class="spec-doc"><p><code>m^.n</code> dereferences a byte at address <code>n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_addr" class="anchored"><a href="#val-max_addr" class="anchor"></a><code><span><span class="keyword">val</span> max_addr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-addr">addr</a></span></code></div><div class="spec-doc"><p><code>max_addr m</code> is an address of the last byte of <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-min_addr" class="anchored"><a href="#val-min_addr" class="anchor"></a><code><span><span class="keyword">val</span> min_addr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-addr">addr</a></span></code></div><div class="spec-doc"><p><code>min_addr m</code> is an address of the first byte of <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length m</code> returns a number of bytes in m</p></div></div><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>contains mem addr</code> returns true if <code>mem</code> contains address <code>addr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_with" class="anchored"><a href="#val-compare_with" class="anchor"></a><code><span><span class="keyword">val</span> compare_with : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `addr_is_inside <span>| `addr_is_below</span> <span>| `addr_is_above</span> ]</span></span></code></div><div class="spec-doc"><p><code>compare_with mem addr</code> compares memory with <code>addr</code></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Input" class="anchored"><a href="#module-Input" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Input/index.html">Input</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A set of low level input operations. Note: it is more effective to use above head iterators, instead of this low level interface, since iterators do not need to check every memory access.</p></div></div><div class="odoc-include"><div class="spec-doc"><p>Printing and outputting</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../../regular/Regular/Std/Printable/module-type-S/index.html">Regular.Std.Printable.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../../regular/Regular/Std/Printable/module-type-S/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string x</code> returns a human-readable representation of <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-str" class="anchored"><a href="#val-str" class="anchor"></a><code><span><span class="keyword">val</span> str : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>str () t</code> is formatted output function that matches &quot;%a&quot; conversion format specifier in functions, that prints to string, e.g., <code>sprintf</code>, <code>failwithf</code>, <code>errorf</code> and, surprisingly all <code>Lwt</code> printing function, including <code>Lwt_io.printf</code> and logging (or any other function with type ('a,unit,string,...) formatN`. Example:</p><pre><code>Or_error.errorf &quot;type %a is not valid for %a&quot;
  Type.str ty Exp.str exp</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-pps" class="anchored"><a href="#val-pps" class="anchor"></a><code><span><span class="keyword">val</span> pps : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>synonym for <code>str</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-ppo" class="anchored"><a href="#val-ppo" class="anchor"></a><code><span><span class="keyword">val</span> ppo : <span><span class="xref-unresolved">Core_kernel</span>.Out_channel.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>will print to a standard <code>output_channel</code>, useful for using in <code>printf</code>, <code>fprintf</code>, etc.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_seq" class="anchored"><a href="#val-pp_seq" class="anchor"></a><code><span><span class="keyword">val</span> pp_seq : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>prints a sequence of values of type <code>t</code></p></div></div><div class="odoc-include"><div class="spec-doc"><p>this will include <code>pp</code> function from <code>Core</code> that has type <span class="xref-unresolved"><code>t printer</code></span>, and can be used in <code>Format.printf</code> family of functions</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Pretty_printer.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Base__</span>.Formatter.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div></details></div><div class="odoc-spec"><div class="spec value" id="val-hexdump" class="anchored"><a href="#val-hexdump" class="anchor"></a><code><span><span class="keyword">val</span> hexdump : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>hexdump t out</code> outputs hexdump (as per <code>hexdump -C</code>) of the memory to formatter <code>out</code></p></div></div><div class="odoc-include"><div class="spec-doc"><p>a set of iterators, with identity monad.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../module-type-Memory_iterators/index.html">Memory_iterators</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../module-type-Memory_iterators/index.html#type-t">t</a> := <a href="#type-t">t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-Memory_iterators/index.html#type-m">m</a></span> = <span class="type-var">'a</span></span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-m" class="anchored"><a href="#type-m" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a m</span></span><span> = <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>fold ~word_size ~init ~f t</code> folds over elements of <code>t</code>, so a result is <code>f (... (f (f a elt_1) elt_2) ...) elt_n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>iter ~word_size ~f t</code> applies <code>f</code> to elements of <code>t</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>foldi ~word_size ~init ~f t</code> is like <a href="#val-fold"><code>fold</code></a>, but also passes an address to the <code>f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>iteri ~word_size ~f t</code> is like <a href="#val-iter"><code>iter</code></a>, but also passes an address to the <code>f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>exists ~word_size ~f t</code> checks if at least one element of <code>t</code> satisfies the predicate <code>f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>for_all ~word_size ~f t</code> checks if all elements of <code>t</code> satisfies the predicate <code>f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>count ~word_size ~f t</code> is the number of elements in <code>t</code> that satisfies the predicate <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_if" class="anchored"><a href="#val-find_if" class="anchor"></a><code><span><span class="keyword">val</span> find_if : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-word">word</a> option</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>find_if ~word_size ~f t</code> returns the first element of <code>t</code> that satisfies the predicate <code>p</code> or None if no elements satisfied</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span>?word_size:<a href="../index.html#type-size">size</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-word">word</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-m">m</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-m">m</a></span></span></code></div><div class="spec-doc"><p><code>find_map ~word_size ~f t</code> returns the first evaluation of <code>f</code> that returns <code>Some</code> or None if <code>f</code> always returns <code>None</code></p></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-With_error" class="anchored"><a href="#module-With_error" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="With_error/index.html">With_error</a></span><span> : <a href="../module-type-Memory_iterators/index.html">Memory_iterators</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../module-type-Memory_iterators/index.html#type-t">t</a> := <a href="#type-t">t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-Memory_iterators/index.html#type-m">m</a></span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></span></code></div><div class="spec-doc"><p>iterators lifter to the Or_error monad</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make_iterators" class="anchored"><a href="#module-Make_iterators" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make_iterators/index.html">Make_iterators</a></span><span> (<a href="Make_iterators/index.html#argument-1-M">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="../module-type-Memory_iterators/index.html">Memory_iterators</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../module-type-Memory_iterators/index.html#type-t">t</a> := <a href="#type-t">t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-Memory_iterators/index.html#type-m">m</a></span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">M</span>.t</span></span></span></code></div><div class="spec-doc"><p>lifts iterators to monad <code>M</code></p></div></div><h3 id="interfacing-with-c"><a href="#interfacing-with-c" class="anchor"></a>Interfacing with C</h3><p>The following interfaces is supposed to be used only for the purposes of exposing memory to c programs.</p><div class="odoc-spec"><div class="spec value" id="val-to_buffer" class="anchored"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Core_kernel</span>.Bigsubstring.t</span></code></div><div class="spec-doc"><p><code>to_buffers mem</code> creates a buffer representing the memory <code>mem</code>. It is not specified whether the returned buffer has some sharing with underlying implementation. In other words the returned buffer shouldn't be modified.</p><p>Since it is not guaranteed that memory is contiguous, a sequence of buffers is returned, with each buffer representing a contiguous part of memory.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Trie" class="anchored"><a href="#module-Trie" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Trie/index.html">Trie</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Tries over memory</p></div></div></div></body></html>