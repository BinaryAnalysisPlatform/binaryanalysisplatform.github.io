<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Table (bap.Bap.Std.Table)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Table</nav><h1>Module <code>Std.Table</code></h1><p>Table.</p><p>Tables are used to partition memory region into a set of non-intersecting areas. Each area is associated with arbitrary value of type <code>'a</code> bound to the type of the table.</p><p>All operations over tables are purely applicative, i.e. there is no observable side-effects. Although, they employ some kind of caching underneath the hood, so that they perform better if they're build once and used many times.</p><p>Tables can be also linked. For example, if you have two tables mapping the same memory region to a different sets of values, you can create a mapping from one set of values to another. See <code>link</code> function for mode details.</p><nav class="toc"><ul><li><a href="#table-relations">Table relations</a><ul><li><a href="#examples">Examples</a></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-table">table</a></span></code></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Ppx_sexp_conv_lib.Sexp.t</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-hashable"><a href="#type-hashable" class="anchor"></a><code><span class="keyword">type</span> <span>'a hashable</span></code><code> = <span><span class="type-var">'a</span> Core_kernel.Hashtbl.Hashable.t</span></code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>creates an empty table</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>creates a table containing one bindins</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> Core_kernel.Or_error.t</span></code></dt><dd><p><code>add table mem v</code> returns a new table with added mapping from a mem region <code>mem</code> to a data value <code>v</code></p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>returns a new table with all mappings from the mem region <code>mem</code> removed</p></dd></dl><dl><dt class="spec value" id="val-change"><a href="#val-change" class="anchor"></a><code><span class="keyword">val</span> change : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span>f:<span>(<span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span> <span>&#45;&gt;</span> <span>[ <span>`rebind of <a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span></span> <span><span>| `update</span> of <span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></span> <span>| `remove</span> <span>| `ignore</span> ]</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>change tab mem ~f</code> function <code>f</code> is applied to a set of all memory regions that intersects with <code>mem</code>. If function <code>f</code> evaluates to <code>`remap (new_mem,y)</code> then all memory regions that have had intersections with <code>mem</code> will be removed from the new map and memory region <code>new_mem</code> will be mapped to <code>y</code>. If <code>f</code> evaluates to <code>`remove</code>, then the regions will be removed, and nothing will be added. If it evaluates to <code>`skip</code> then the table will be returned unchanged. Intersections are passed sorted in an ascending order.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>length table</code> returns a number of entries in the table</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find table mem</code> finds an element mapped to the memory region <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-find_addr"><a href="#val-find_addr" class="anchor"></a><code><span class="keyword">val</span> find_addr : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-addr">addr</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>find_addr tab addr</code> finds a memory region that contains a specified <code>addr</code></p></dd></dl><dl><dt class="spec value" id="val-intersections"><a href="#val-intersections" class="anchor"></a><code><span class="keyword">val</span> intersections : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span></code></dt><dd><p><code>intersections table mem</code> returns all mappings in a <code>table</code> that have intersections with <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-fold_intersections"><a href="#val-fold_intersections" class="anchor"></a><code><span class="keyword">val</span> fold_intersections : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_intersections table mem</code> folds over all regions intersecting with <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-has_intersections"><a href="#val-has_intersections" class="anchor"></a><code><span class="keyword">val</span> has_intersections : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_intersections tab mem</code> is true iff some portion of <code>mem</code> is is already mapped in <code>tab</code>.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem table mem</code> is true if table contains mem region <code>mem</code></p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>next table elt</code> returns element next to <code>elt</code>, if any</p></dd></dl><dl><dt class="spec value" id="val-prev"><a href="#val-prev" class="anchor"></a><code><span class="keyword">val</span> prev : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>next table elt</code> returns element preceding to <code>elt</code>, if any</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>min tab</code> return the lowest binding</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>max tab</code> return the highest binding</p></dd></dl><dl><dt class="spec type" id="type-r"><a href="#type-r" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'm) r</span></code></dt><dd><p>Relation multiplicity. For a given type <code>'a</code> creates type <code>'m</code></p></dd></dl><section><header><h3 id="table-relations"><a href="#table-relations" class="anchor"></a>Table relations</h3></header><dl><dt class="spec value" id="val-many"><a href="#val-many" class="anchor"></a><code><span class="keyword">val</span> many : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="../index.html#type-seq">seq</a></span>)</span> <a href="index.html#type-r">r</a></span></code></dt><dd><p><code>0..*</code></p></dd></dl><dl><dt class="spec value" id="val-at_least_one"><a href="#val-at_least_one" class="anchor"></a><code><span class="keyword">val</span> at_least_one : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="../index.html#type-seq">seq</a></span>)</span> <a href="index.html#type-r">r</a></span></code></dt><dt class="spec value" id="val-one"><a href="#val-one" class="anchor"></a><code><span class="keyword">val</span> one : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-r">r</a></span></code></dt><dd><p><code>1..1</code></p></dd></dl><dl><dt class="spec value" id="val-maybe_one"><a href="#val-maybe_one" class="anchor"></a><code><span class="keyword">val</span> maybe_one : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-r">r</a></span></code></dt><dd><p><code>0..1</code></p></dd></dl><aside><p><code>link relation t t1 t2</code> takes two tables and returns a mapping from elements of one table to elements of other table.</p><p>Parameter <code>t</code> specifies a <code>hashable</code> typeclass of the type <code>'a</code>. If type <code>'a</code> implements <code>Hashable</code> interface, then you can obtain it with <code>hashable</code> function, e.g. <code>Int.hashable</code> with return the appropriate type class. If <code>'a</code> doesn't implement <code>Hashable</code>, then it can be implemented manually.</p><p>Relation specifies the multiplicity of the relation between entities from table <code>t1</code> to entities from table <code>t2</code>, and is summarized below:</p><ul><li><code>one_to_many</code> means that a particular region from table <code>t1</code> can span several memory regions from table <code>t2</code>. Example: segments to symbols relation.</li></ul><ul><li><code>one_to_one</code> means that for each value of type <code>'a</code> there is exactly one value of type <code>'b</code>. This relation should be used with caution, since it is quantified over _all_ values of type <code>'a</code>. Indeed, it should be used only for cases, when it can be guaranteed, that it is impossible to create such value of type <code>'b</code>, that has no correspondence in table <code>t2</code>. Otherwise, <code>one_to_maybe_one</code> relation should be used. Example: llvm machine code to assembly string relation.</li></ul><ul><li><code>one_to_maybe_one</code> means that for each value in table <code>t1</code> there exists at most one value in table <code>t2</code>. Example: function to symbol relation.</li></ul></aside><section><header><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><pre><code class="ml">let mc_of_insn  = link one_to:one Insn.hashable insns mcs
let syms_of_sec = link one_to:many Sec.hashable  secs syms</code></pre></header><dl><dt class="spec value" id="val-link"><a href="#val-link" class="anchor"></a><code><span class="keyword">val</span> link : <span>one_to:<span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-r">r</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-hashable">hashable</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : <span>one_to:<span><span>(<a href="../index.html#type-mem">mem</a>, <span class="type-var">'r</span>)</span> <a href="index.html#type-r">r</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-hashable">hashable</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> Core_kernel.Or_error.t</span></code></dt><dd><p><code>rev_map arity t tab</code> creates a reverse mapping from values of typeclass <code>t</code> stored in table <code>tab</code> to memory regions.</p><p>Note. not every mapping is reversible, for example, trying to obtain a reverse of surjective mapping as a one-to-one mapping will result in an error. But surjective mappings can be reversed using <code>~one_to:many</code> mapping. A particular example of surjective mapping is <code>symbol</code> tables, in a case when functions can occupy several non-contiguous regions of memory.</p><p>For example, to create a mapping from a function symbol to sequence of memory regions with it code:</p><pre><code class="ml">rev_map one_to:many Sym.hashable tab</code></pre></dd></dl><dl><dt class="spec type" id="type-ranged"><a href="#type-ranged" class="anchor"></a><code><span class="keyword">type</span> <span>'a ranged</span></code><code> = <span>?&#8288;start:<a href="../index.html#type-mem">mem</a></span> <span>&#45;&gt;</span> <span>?&#8288;until:<a href="../index.html#type-mem">mem</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><h3 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h3><p>This section provides a common set of iterators. Note: name iterator is used in a functional meaning, i.e., an iterator is a function that takes a data structure and another function, and applies it to all elements in some manner.</p><p>All iterators share some common part of interface that was lifted to a <code>'a ranged</code> type. When you see</p><p><code>('a t -&gt; f:('a -&gt; bool) -&gt; bool) ranged</code></p><p>just mentally substitute it with:</p><p><code>?start -&gt; ?until -&gt; 'a t -&gt; f:('a -&gt; bool) -&gt; bool</code>.</p><p>In other words <code>'f ranged</code> just prepends <code>?start -&gt; ?until -&gt;</code> to function with type <code>'f</code> (do not forget that <code>'f</code> can be an arrow type).</p><p><code>start</code> and <code>until</code> parameters narrows iteration to some subset of table. If they are unspecified then iteration would be performed on all table entries in an ascending order of addresses. If they are specified, then if <code>start &lt;= until</code>, then iteration will be performed in the same order but on a specified subset. In the case, when <code>start &gt; until</code>, iteration will be performed in a decreasing order.</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>exists ~start ~until ~f table</code> checks if at least one element of <code>table</code> satisfies the predicate <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>for_all ~start ~until ~f table</code> checks if all elements of <code>table</code> satisfies the predicate <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-existsi"><a href="#val-existsi" class="anchor"></a><code><span class="keyword">val</span> existsi : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>existsi ~start ~until ~f table</code> is like <a href="index.html#val-exists"><code>exists</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-for_alli"><a href="#val-for_alli" class="anchor"></a><code><span class="keyword">val</span> for_alli : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> bool)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>for_alli ~start ~until ~f table</code> is like <a href="index.html#val-for_all"><code>for_all</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> int)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>count ~start ~until ~f table</code> returns the number of elements <code>table</code> that satisfy the predicate <code>p</code></p></dd></dl><dl><dt class="spec value" id="val-find_if"><a href="#val-find_if" class="anchor"></a><code><span class="keyword">val</span> find_if : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>find_if ~start ~until ~f table</code> returns the first element of <code>table</code> that satisfies the predicate <code>p</code> or None if no elements satisfied</p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>find_map ~start ~until ~f table</code> returns the first evaluation of <code>f</code> that returns <code>Some</code> or None if <code>f</code> always returns <code>None</code></p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>fold ~start ~until ~init ~f table</code> returns a fold over <code>table</code> in form <code>f elt_n ( ... (f elt_2 (f (elt_1 acc))) ... )</code></p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>iter ~start ~until ~f table</code> applies function <code>f</code> in turn to elements of <code>table</code></p></dd></dl><dl><dt class="spec value" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span class="keyword">val</span> find_mapi : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>find_mapi ~start ~until ~f table</code> is like <a href="index.html#val-find_map"><code>find_map</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val</span> foldi : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>foldi ~start ~until ~f table</code> is like <a href="index.html#val-fold"><code>fold</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>ieri ~start ~until ~f table</code> is like <a href="index.html#val-iter"><code>iter</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>map ~start ~until ~f table</code> applies <code>f</code> to elements of <code>table</code> and builds new table with results returned by <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>mapi ~start ~until ~f table</code> is like <a href="index.html#val-map"><code>map</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>filter ~start ~until ~f table</code> removes all mappings from <code>table</code> that doesn't satisfies the predicate <code>f</code></p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>filter_map ~start ~until ~f table</code> return a subtable of <code>table</code> containing only elements for which <code>f</code> returns <code>Some</code></p></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val</span> filteri : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>filteri ~start ~until ~f table</code> is like <a href="index.html#val-filter"><code>filter</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val</span> filter_mapi : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../index.html#type-mem">mem</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>filter_mapi ~start ~until ~f table</code> is like <a href="index.html#val-filter_map"><code>filter_map</code></a>, but also passes the memory as an argument.</p></dd></dl><dl><dt class="spec value" id="val-to_sequence"><a href="#val-to_sequence" class="anchor"></a><code><span class="keyword">val</span> to_sequence : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>to_sequence ~start ~until table</code> converts the <code>table</code> to a sequence of key-value pairs.</p></dd></dl><dl><dt class="spec value" id="val-regions"><a href="#val-regions" class="anchor"></a><code><span class="keyword">val</span> regions : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../index.html#type-mem">mem</a> <a href="../index.html#type-seq">seq</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>regions table</code> returns in an ascending order of addresses all memory regions mapped in a <code>table</code></p></dd></dl><dl><dt class="spec value" id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val</span> elements : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-seq">seq</a></span>)</span> <a href="index.html#type-ranged">ranged</a></span></code></dt><dd><p><code>elements table</code> returns in an ascending order of addresses all elements mapped in a <code>table</code></p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp printer</code> - creates a printer for table from value printer</p></dd></dl></section></section></div></body></html>