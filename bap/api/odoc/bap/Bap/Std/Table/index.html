<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Table (bap.Bap.Std.Table)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap</a> &#x00BB; <a href="../../index.html">Bap</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Table</nav><header class="odoc-preamble"><h1>Module <code><span>Std.Table</span></code></h1><p>Table.</p><p>Tables are used to partition memory region into a set of non-intersecting areas. Each area is associated with arbitrary value of type <code>'a</code> bound to the type of the table.</p><p>All operations over tables are purely applicative, i.e. there is no observable side-effects. Although, they employ some kind of caching underneath the hood, so that they perform better if they're build once and used many times.</p><p>Tables can be also linked. For example, if you have two tables mapping the same memory region to a different sets of values, you can create a mapping from one set of values to another. See <code>link</code> function for mode details.</p></header><nav class="odoc-toc"><ul><li><a href="#table-relations">Table relations</a><ul><li><a href="#examples">Examples</a></li></ul></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../index.html#type-table">table</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_sexp_conv_lib</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-hashable" class="anchored"><a href="#type-hashable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a hashable</span></span><span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Hashtbl.Hashable.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>creates an empty table</p></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>creates a table containing one bindins</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>add table mem v</code> returns a new table with added mapping from a mem region <code>mem</code> to a data value <code>v</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>returns a new table with all mappings from the mem region <code>mem</code> removed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-change" class="anchored"><a href="#val-change" class="anchor"></a><code><span><span class="keyword">val</span> change : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span>
  <span>f:
    <span>( <span><span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span> <span class="arrow">&#45;&gt;</span></span>
      <span>[ <span>`rebind of <a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span></span> <span><span>| `update</span> of <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span> <span>| `remove</span> <span>| `ignore</span> ]</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>change tab mem ~f</code> function <code>f</code> is applied to a set of all memory regions that intersects with <code>mem</code>. If function <code>f</code> evaluates to <code>`remap (new_mem,y)</code> then all memory regions that have had intersections with <code>mem</code> will be removed from the new map and memory region <code>new_mem</code> will be mapped to <code>y</code>. If <code>f</code> evaluates to <code>`remove</code>, then the regions will be removed, and nothing will be added. If it evaluates to <code>`skip</code> then the table will be returned unchanged. Intersections are passed sorted in an ascending order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length table</code> returns a number of entries in the table</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find table mem</code> finds an element mapped to the memory region <code>mem</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_addr" class="anchored"><a href="#val-find_addr" class="anchor"></a><code><span><span class="keyword">val</span> find_addr : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_addr tab addr</code> finds a memory region that contains a specified <code>addr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-intersections" class="anchored"><a href="#val-intersections" class="anchor"></a><code><span><span class="keyword">val</span> intersections : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span></span></code></div><div class="spec-doc"><p><code>intersections table mem</code> returns all mappings in a <code>table</code> that have intersections with <code>mem</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_intersections" class="anchored"><a href="#val-fold_intersections" class="anchor"></a><code><span><span class="keyword">val</span> fold_intersections : 
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span>
  <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>fold_intersections table mem</code> folds over all regions intersecting with <code>mem</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-has_intersections" class="anchored"><a href="#val-has_intersections" class="anchor"></a><code><span><span class="keyword">val</span> has_intersections : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_intersections tab mem</code> is true iff some portion of <code>mem</code> is is already mapped in <code>tab</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem table mem</code> is true if table contains mem region <code>mem</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span><span class="keyword">val</span> next : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>next table elt</code> returns element next to <code>elt</code>, if any</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prev" class="anchored"><a href="#val-prev" class="anchor"></a><code><span><span class="keyword">val</span> prev : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>next table elt</code> returns element preceding to <code>elt</code>, if any</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>min tab</code> return the lowest binding</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>max tab</code> return the highest binding</p></div></div><div class="odoc-spec"><div class="spec type" id="type-r" class="anchored"><a href="#type-r" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'm) r</span></span></code></div><div class="spec-doc"><p>Relation multiplicity. For a given type <code>'a</code> creates type <code>'m</code></p></div></div><h3 id="table-relations"><a href="#table-relations" class="anchor"></a>Table relations</h3><div class="odoc-spec"><div class="spec value" id="val-many" class="anchored"><a href="#val-many" class="anchor"></a><code><span><span class="keyword">val</span> many : <span><span>( <span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="../index.html#type-seq">seq</a></span> )</span> <a href="#type-r">r</a></span></span></code></div><div class="spec-doc"><p><code>0..*</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-at_least_one" class="anchored"><a href="#val-at_least_one" class="anchor"></a><code><span><span class="keyword">val</span> at_least_one : <span><span>( <span class="type-var">'a</span>, <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="../index.html#type-seq">seq</a></span> )</span> <a href="#type-r">r</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-one" class="anchored"><a href="#val-one" class="anchor"></a><code><span><span class="keyword">val</span> one : <span><span>( <span class="type-var">'a</span>, <span class="type-var">'a</span> )</span> <a href="#type-r">r</a></span></span></code></div><div class="spec-doc"><p><code>1..1</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-maybe_one" class="anchored"><a href="#val-maybe_one" class="anchor"></a><code><span><span class="keyword">val</span> maybe_one : <span><span>( <span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span> )</span> <a href="#type-r">r</a></span></span></code></div><div class="spec-doc"><p><code>0..1</code></p></div></div><p><code>link relation t t1 t2</code> takes two tables and returns a mapping from elements of one table to elements of other table.</p><p>Parameter <code>t</code> specifies a <code>hashable</code> typeclass of the type <code>'a</code>. If type <code>'a</code> implements <code>Hashable</code> interface, then you can obtain it with <code>hashable</code> function, e.g. <code>Int.hashable</code> with return the appropriate type class. If <code>'a</code> doesn't implement <code>Hashable</code>, then it can be implemented manually.</p><p>Relation specifies the multiplicity of the relation between entities from table <code>t1</code> to entities from table <code>t2</code>, and is summarized below:</p><ul><li><code>one_to_many</code> means that a particular region from table <code>t1</code> can span several memory regions from table <code>t2</code>. Example: segments to symbols relation.</li></ul><ul><li><code>one_to_one</code> means that for each value of type <code>'a</code> there is exactly one value of type <code>'b</code>. This relation should be used with caution, since it is quantified over _all_ values of type <code>'a</code>. Indeed, it should be used only for cases, when it can be guaranteed, that it is impossible to create such value of type <code>'b</code>, that has no correspondence in table <code>t2</code>. Otherwise, <code>one_to_maybe_one</code> relation should be used. Example: llvm machine code to assembly string relation.</li></ul><ul><li><code>one_to_maybe_one</code> means that for each value in table <code>t1</code> there exists at most one value in table <code>t2</code>. Example: function to symbol relation.</li></ul><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><pre><code>let mc_of_insn  = link one_to:one Insn.hashable insns mcs
let syms_of_sec = link one_to:many Sec.hashable  secs syms</code></pre><div class="odoc-spec"><div class="spec value" id="val-link" class="anchored"><a href="#val-link" class="anchor"></a><code><span><span class="keyword">val</span> link : <span>one_to:<span><span>( <span class="type-var">'b</span>, <span class="type-var">'r</span> )</span> <a href="#type-r">r</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-hashable">hashable</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_map" class="anchored"><a href="#val-rev_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_map : 
  <span>one_to:<span><span>( <a href="../index.html#type-mem">mem</a>, <span class="type-var">'r</span> )</span> <a href="#type-r">r</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-hashable">hashable</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span> )</span> <span class="xref-unresolved">Core_kernel</span>.Or_error.t</span></span></code></div><div class="spec-doc"><p><code>rev_map arity t tab</code> creates a reverse mapping from values of typeclass <code>t</code> stored in table <code>tab</code> to memory regions.</p><p>Note. not every mapping is reversible, for example, trying to obtain a reverse of surjective mapping as a one-to-one mapping will result in an error. But surjective mappings can be reversed using <code>~one_to:many</code> mapping. A particular example of surjective mapping is <code>symbol</code> tables, in a case when functions can occupy several non-contiguous regions of memory.</p><p>For example, to create a mapping from a function symbol to sequence of memory regions with it code:</p><pre><code>rev_map one_to:many Sym.hashable tab</code></pre></div></div><div class="odoc-spec"><div class="spec type" id="type-ranged" class="anchored"><a href="#type-ranged" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ranged</span></span><span> = <span>?start:<a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span>?until:<a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Iterators</p><p>This section provides a common set of iterators. Note: name iterator is used in a functional meaning, i.e., an iterator is a function that takes a data structure and another function, and applies it to all elements in some manner.</p><p>All iterators share some common part of interface that was lifted to a <code>'a ranged</code> type. When you see</p><p><code>('a t -&gt; f:('a -&gt; bool) -&gt; bool) ranged</code></p><p>just mentally substitute it with:</p><p><code>?start -&gt; ?until -&gt; 'a t -&gt; f:('a -&gt; bool) -&gt; bool</code>.</p><p>In other words <code>'f ranged</code> just prepends <code>?start -&gt; ?until -&gt;</code> to function with type <code>'f</code> (do not forget that <code>'f</code> can be an arrow type).</p><p><code>start</code> and <code>until</code> parameters narrows iteration to some subset of table. If they are unspecified then iteration would be performed on all table entries in an ascending order of addresses. If they are specified, then if <code>start &lt;= until</code>, then iteration will be performed in the same order but on a specified subset. In the case, when <code>start &gt; until</code>, iteration will be performed in a decreasing order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>exists ~start ~until ~f table</code> checks if at least one element of <code>table</code> satisfies the predicate <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>for_all ~start ~until ~f table</code> checks if all elements of <code>table</code> satisfies the predicate <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-existsi" class="anchored"><a href="#val-existsi" class="anchor"></a><code><span><span class="keyword">val</span> existsi : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>existsi ~start ~until ~f table</code> is like <a href="#val-exists"><code>exists</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_alli" class="anchored"><a href="#val-for_alli" class="anchor"></a><code><span><span class="keyword">val</span> for_alli : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>for_alli ~start ~until ~f table</code> is like <a href="#val-for_all"><code>for_all</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>count ~start ~until ~f table</code> returns the number of elements <code>table</code> that satisfy the predicate <code>p</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_if" class="anchored"><a href="#val-find_if" class="anchor"></a><code><span><span class="keyword">val</span> find_if : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>find_if ~start ~until ~f table</code> returns the first element of <code>table</code> that satisfies the predicate <code>p</code> or None if no elements satisfied</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>find_map ~start ~until ~f table</code> returns the first evaluation of <code>f</code> that returns <code>Some</code> or None if <code>f</code> always returns <code>None</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>fold ~start ~until ~init ~f table</code> returns a fold over <code>table</code> in form <code>f elt_n ( ... (f elt_2 (f (elt_1 acc))) ... )</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>iter ~start ~until ~f table</code> applies function <code>f</code> in turn to elements of <code>table</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_mapi" class="anchored"><a href="#val-find_mapi" class="anchor"></a><code><span><span class="keyword">val</span> find_mapi : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>find_mapi ~start ~until ~f table</code> is like <a href="#val-find_map"><code>find_map</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>foldi ~start ~until ~f table</code> is like <a href="#val-fold"><code>fold</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>ieri ~start ~until ~f table</code> is like <a href="#val-iter"><code>iter</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>map ~start ~until ~f table</code> applies <code>f</code> to elements of <code>table</code> and builds new table with results returned by <code>f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>mapi ~start ~until ~f table</code> is like <a href="#val-map"><code>map</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>filter ~start ~until ~f table</code> removes all mappings from <code>table</code> that doesn't satisfies the predicate <code>f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>filter_map ~start ~until ~f table</code> return a subtable of <code>table</code> containing only elements for which <code>f</code> returns <code>Some</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filteri" class="anchored"><a href="#val-filteri" class="anchor"></a><code><span><span class="keyword">val</span> filteri : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>filteri ~start ~until ~f table</code> is like <a href="#val-filter"><code>filter</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_mapi" class="anchored"><a href="#val-filter_mapi" class="anchor"></a><code><span><span class="keyword">val</span> filter_mapi : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><a href="../index.html#type-mem">mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>filter_mapi ~start ~until ~f table</code> is like <a href="#val-filter_map"><code>filter_map</code></a>, but also passes the memory as an argument.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_sequence" class="anchored"><a href="#val-to_sequence" class="anchor"></a><code><span><span class="keyword">val</span> to_sequence : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-mem">mem</a> * <span class="type-var">'a</span>)</span> <a href="../index.html#type-seq">seq</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>to_sequence ~start ~until table</code> converts the <code>table</code> to a sequence of key-value pairs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-regions" class="anchored"><a href="#val-regions" class="anchor"></a><code><span><span class="keyword">val</span> regions : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-mem">mem</a> <a href="../index.html#type-seq">seq</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>regions table</code> returns in an ascending order of addresses all memory regions mapped in a <code>table</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-elements" class="anchored"><a href="#val-elements" class="anchor"></a><code><span><span class="keyword">val</span> elements : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-seq">seq</a></span> )</span> <a href="#type-ranged">ranged</a></span></span></code></div><div class="spec-doc"><p><code>elements table</code> returns in an ascending order of addresses all elements mapped in a <code>table</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : 
  <span><span>( <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp printer</code> - creates a printer for table from value printer</p></div></div></div></body></html>