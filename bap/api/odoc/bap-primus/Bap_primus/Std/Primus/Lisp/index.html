<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lisp (bap-primus.Bap_primus.Std.Primus.Lisp)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap-primus</a> &#x00BB; <a href="../../../index.html">Bap_primus</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Primus</a> &#x00BB; Lisp</nav><h1>Module <code>Primus.Lisp</code></h1><p>Lisp machine.</p><p>The Lisp Machine is an extensible Lisp Machine embedded into the Primus Machine. The Lisp machine is used to provide function stubs (summaries), as well as to control the Primus Machine using a dialect of Lisp.</p><h2 id="primus-lisp-language"><a href="#primus-lisp-language" class="anchor"></a>Primus Lisp Language</h2><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>Primus Lisp is a dialect of Lisp, that can be used to interact with a native program. Primus Lisp is close to Common Lisp and to the Emacs Lisp dialect.</p><p>Primus Lips is a low-level language that doesn't provide many abstractions, as it tries to be as close to the machine language as possible. In that sense Primus Lisp can be seen as an assembler, except that it can't really assemble binaries, as it operates over already existing and assembled program. Primus Lisp, however is still quite powerful, as the absence of suitable abstractions is compensated with powerful and versatile meta-programming system.</p><p>Primus Lisp is primarily used for the following tasks:</p><ul><li>writing function summaries (aka stubs);</li><li>setting up program environment;</li><li>exploring and observing program behavior.</li></ul><p>A Primus Lisp program is a file, that can contain the following entities:</p><ul><li>feature requests;</li><li>declarations;</li><li>constants</li><li>substitutions;</li><li>methods;</li><li>macros;</li><li>functions;</li></ul><p>The entities may be specified in any order, however the above order constitutes a good programming practice.</p><p>Each file provides (implements) a feature, that has the same name as the name of the file without an extension and directories. Thus the namespace of features is flat. A feature is usually a function, macro definition, or any other definition, or a collection of definition, gathered under the same theme. For example, the <code>getopt</code> feature implements C <code>getopt</code> function, and accompanying definitions. The features maybe very specific, i.e., providing an implementation for only one small function, or they can be a collection of other features. For example, the <code>posix</code> feature provides an implementation of all functions specified in the POSIX standard (not all at the time of writing).</p><p>A collection of files is called a library. To use features provided by another file, the file should be requested with the <code>(require &lt;ident&gt;)</code> form, where <code>&lt;ident&gt;</code> is the name of the feature. A file with the requested name is searched in the library, and loaded, making all its definitions available in the lexical scope, that follows the <code>require</code> form. If a feature is already provided, then nothing happens. Dependencies should not contain cycles.</p><p>Top-level declarations specify attributes that are shared by all definitions in a file. For example, a declaration</p><pre>(declare (context (arch armv7))</pre><p>makes all definitions visible only in the context of the ARMv7 architecture.</p><p>Constants and substitutions are primitive abstractions that give names to code fragments. Macros are program transformations. Functions add parameters to a code, and are basic building blocks. Scope of all definitions can be limited with the context declarations. Finally, a function can be advised with another function using the <code>advice-add</code> function.</p><h3 id="type-system"><a href="#type-system" class="anchor"></a>Type system</h3><p>A type defines all possible values of an expression. In Primus Lisp, expression values can be only scalar, i.e., machine words of different widths. The width is always specified in the number of bits. A maximum width of a word is equal to the width of the architecture machine word, thus a family of types is dependent on the context of evaluation. (Note, current implementation limits maximum width of the machine word to 64 bits). We denote a type of expression with a decimal number, e.g., <code>(exp : 16)</code> means that an expression ranges over all 16 bit words.</p><p>An expression can have a polymorphic type <code>t</code> that denotes a powerset of all types for the given architecture. For example, for ARMv7, <b>t = 32 \/ 31 \/ .. \/ 1</b>. Thus a value of any type, is a also a value of type <code>t</code>.</p><p>Side note -- the type system doesn't include the unit type, i.e., the <code>0</code> type. An expression <code>()</code> evaluates to the <code>0:1</code> value.</p><h3 id="functions-and-expressions"><a href="#functions-and-expressions" class="anchor"></a>Functions and expressions</h3><p>Functions are named abstractions of code, where a code is a sequence of expressions. Since a value of an expression is a machine word, functions are not first-class values in Primus Lisp. However, functions and types can be manipulated on the meta-programming level.</p><p>A function is defined with the <code>defun</code> form, that has the following syntax:</p><pre><code class="ml">(defun &lt;name&gt; (&lt;arg&gt; ...) &lt;exp&gt; ...)</code></pre><p>A list of arguments (that can be empty) defines function arity. Functions in Primus Lisp has fixed arity, unlike macros.</p><p>A function definition may optionally contain a documentation strings and a declaration section. For example,</p><pre>         (defun strlen (p)
           &quot;returns a length of the null-terminated string pointed by P&quot;
           (declare (external &quot;strlen&quot;))
           (msg &quot;strlen was called with $p&quot;)
           (let ((len 0))
             (while (not (points-to-null p))
               (incr len p))
             len))</pre><p>A function can be called (applied) using the function application form:</p><pre>(&lt;name&gt; &lt;exp&gt; ...)</pre><p>The first element of the function application form is not an expression and must be an identified. The rest arguments are expressions, that are evaluated from left to right. All arguments are passed by value.</p><p>The body of a function is a sequence of expressions, that is evaluated in the lexical order (i.e., from left to right). A value of the last expression is the result of the function evaluation. An expression is either a function application or or a special form. Primus Lisp defines only 5 special forms, the rest of the syntax is defined using the macro system.</p><h4 id="conditionals"><a href="#conditionals" class="anchor"></a>Conditionals</h4><p>The <b>(if &lt;test-expr&gt; &lt;then-expr&gt; &lt;else-expr&gt; ...)</b> form is a basic control flow structure. If <b>&lt;test-expr&gt;</b> evaluates to a non-zero word then the result of the <b>&lt;if&gt;</b> form is the result of evaluation of the <b>&lt;then-expr&gt;</b>, otherwise a sequence of <b>&lt;else-expr&gt;</b> ... is evaluated and the result of the form evaluation would be a result of the last expression in a form</p><p>For example,</p><pre>        (if (&lt; 4 3)
            (msg &quot;shouldn't happen&quot;)
          (msg &quot;that's right&quot;)
          (- 4 3))</pre><p>Note that the the <b>&lt;else-expr&gt;</b> sequence maybe empty.</p><p>Several derived forms are defined as macros, e.g.,</p><pre>          (when &lt;cond&gt; &lt;expr&gt; ...)
          (or &lt;expr&gt; ...)
          (and &lt;expr&gt; ...)</pre><h4 id="loops"><a href="#loops" class="anchor"></a>Loops</h4><p>Iterations can be implemented either using recursion or with the <code>while</code> special form. Since the interpreter doesn't provide the tail-call optimization it is better to use the latter (although the interpreter itself is using a constant stack size, as it uses the host language heap memory to represent the Primus Lisp call stack).</p><p>The <b>(while &lt;cond&gt; &lt;expr&gt; ...)</b> form, will evaluate the &lt;cond&gt; expression first, and if it is a non-zero value, then the sequence of expressions <b>&lt;expr&gt; ...</b> is evaluated, and the value of the last expression becomes the value of the <code>while</code> form. If the value of the <b>&lt;cond&gt;</b> expression is a false value, then this value becomes the value of the <code>while</code> form.</p><h4 id="variables"><a href="#variables" class="anchor"></a>Variables</h4><p>The <code>let</code> form binds values to names in the lexical scope.</p><pre>         (let (&lt;binding&gt; ...)  &lt;body-expr&gt; ...)
         binding ::= (&lt;var&gt; &lt;expr&gt;)</pre><p>Evaluates each <b>&lt;binding&gt;</b> in order binding the <b>&lt;var&gt;</b> identifier to a result of <b>&lt;expr&gt;</b>. The newly created binding is available in consequent bindings and in the &lt;body-expr&gt;, but is not visible outside of the scope of the let-form.</p><p>Example,</p><pre>        (let ((x 4)
              (y (+ x 2)))
          (+ x 3))</pre><p>The value of the <code>let</code> form is the value of the last expression <b>&lt;sN&gt;</b>.</p><h4 id="sequencing"><a href="#sequencing" class="anchor"></a>Sequencing</h4><p>The <b>(prog &lt;expr&gt; ...)</b> form combines a sequence of expressions into one expression, and is useful in the contexts where an expression is required. The expressions are evaluated from left to right, and the value of the <code>prog</code> form is the value of the last expression.</p><h4 id="messaging"><a href="#messaging" class="anchor"></a>Messaging</h4><p>The <b>(msg &lt;fmt&gt; &lt;expr&gt; ...)</b> form constructs logging/debugging messages using an embedded formatting language. The formed message will be sent to the logging facility, that was set up during the Primus Lisp library initialization.</p><p>The format language interprets all symbols literally, unless they start with the dollar sign ($).</p><p>A pair of characters of the form <b>$&lt;n&gt;</b>, where <b>&lt;n&gt;</b> is a decimal digit, will be substituted with the value of the n'th expression (counting from zero).</p><p>Example,</p><pre>(msg &quot;hello, $0 $0 world, (+ 7 8) = $1&quot; &quot;cruel&quot; (+ 7 8))</pre><p>will be rendered to a message:</p><pre>&quot;hello, cruel cruel world, (+ 7 8) = 15&quot;</pre><h3 id="metaprogramming"><a href="#metaprogramming" class="anchor"></a>Metaprogramming</h3><p>Ordinary Primus Lisp expressions are evaluated at the runtime in the Primus emulator, and are quite limited as they need to be evaluated directly on the CPU model. To mitigate this limitation, Primus Lisp provides a powerful metaprogramming system. The metaprogram is evaluated when the Primus Lisp program is read. A metaprogram generates a program, that will be evaluated by the CPU. The metaprogram itself is Turing complete, thus any transformation can be applied to a program. The Primus Lisp metaprogramming system use term-rewriting as a computational model, with Lisp code fragments as terms. Primus Lisp provides three facilities for metaprogramming:</p><ul><li>syntactic constants;</li><li>syntactic substitutions;</li><li>macro definitions.</li></ul><h4 id="constants"><a href="#constants" class="anchor"></a>Constants</h4><p>The syntactic constants is the simplest syntactic substitution, it just substitutes atoms for atoms. Constants are introduced with the <code>defconstant</code> form, that has the following syntax:</p><pre>         (defconstant &lt;name&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;docstring&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;declarations&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;docstring&gt; &lt;declarations&gt; &lt;atom&gt;)</pre><p>For example,</p><pre>(defconstant main-address 0xDEAD)</pre><p>During the program parsing, each occurrence of the <b>&lt;name&gt;</b> term will be rewritten with the <b>&lt;value&gt;</b> term, that should be an atom.</p><h4 id="substitutions"><a href="#substitutions" class="anchor"></a>Substitutions</h4><p>The syntactic substitution is a generalization of syntactic constant, and has quite a similar syntax:</p><pre>          | (defsubst &lt;name&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; &lt;declarations&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; :&lt;syntax&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; &lt;declarations&gt; :&lt;syntax&gt; &lt;value&gt; ...)</pre><p>During parsing, every occurrence of the term <b>&lt;name&gt;</b> (that should be an atom), will be rewritten with a sequence of values </p><pre><code class="ml">{&lt;value&gt;} </code></pre><p>.</p><p>Example,</p><pre>(defsubst ten-digits 0 1 2 3 4 5 6 7 8 9)</pre><p>A process of applying of the substitutions is called &quot;expansion&quot;. Since the expansion transforms an atom to a list of atoms, it can be applied only inside the macro or function application. For example,</p><pre>(+ ten-digits)</pre><p>will be expanded to</p><pre>(+ 0 1 2 3 4 5 6 7 8 9 )</pre><h5 id="special-syntax"><a href="#special-syntax" class="anchor"></a>Special syntax</h5><p>Expansions also provide a support for extensible value specification syntax, that enables domain-specific data specification languages. Currently, we support only two syntaxes: <code>:ascii</code> and <code>:hex</code>.</p><p>In the <code>:ascii</code> syntax the values should be atoms, possibly delimited with double quotes. Each character of each atom will be expanded to its corresponding ASCII code. Strings can contain special characters prefixed with a backslash. The special character can be one of the well-known ASCII special character, e.g., <code>\n</code>, <code>\r</code>, etc, or it can be a decimal or a hexadecimal code of a character.</p><p>Example, given the following substitution:</p><pre>(defsubst hello-cruel-world :ascii &quot;hello, cruel world\n\000&quot;)</pre><p>the following application:</p><pre>(write-block SP hello-cruel-world</pre><p>will be expanded with</p><pre><code class="ml">(write-block SP
   0x68 0x65 0x6c 0x6c 0x6f 0x2c 0x20 0x63
   0x72 0x75 0x65 0x6c 0x20 0x77 0x6f 0x72
   0x6c 0x64 0x0a 0x00)</code></pre><p>In the <code>:hex</code> syntax the sequence of atoms is split into two-characters subsequences each treated as a hex value. This syntax is useful for encoding memory dumps in a format that is close to the hexdump (without offsets). E.g., given the following substitution rule</p><pre><code class="ml">(defsubt example :hex 68656c 6c 6f2c2063)</code></pre><p>an application</p><pre><code class="ml">(write-block SP example)</code></pre><p>will be expanded into</p><pre><code class="ml">(write-block SP 0x68 0x65 0x6c 0x6c 0x6f 0x2c 0x20 0x63)</code></pre><h4 id="macro"><a href="#macro" class="anchor"></a>Macro</h4><p>The macros provide the most versatile and powerful way to specify arbitrary code transformations. The macro definitions introduce abstractions on the meta-programming level. I.e., it allows a programmer to write a function that operates on code terms, making the code a first class value.</p><p>The macro definition has the following syntax:</p><pre>          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;docstring&gt; &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;declarations&gt; &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;value&gt;)</pre><p>A macro definition adds a term rewriting rule, that rewrites each occurrence of <b>(&lt;name&gt; &lt;arg&gt; ...)</b>, where the number of arguments <code>N</code> is greater or equal then the number of parameters <code>M</code>, with the <b>&lt;value&gt;</b> in which occurrences of the <code>i</code>th parameter is substituted with the term <code>i</code>th argument. If <code>N</code> is bigger than <code>M</code>, then the last parameter is bound with the sequence of arguments <b>&lt;argM&gt;...&lt;argN&gt;</b>.</p><p>The macro subsystem doesn't provide any specific looping or control-flow facilities, however, the macro-overloading mechanism along with the recursion make it possible to encode arbitrary meta-transformations.</p><p>Other than a standard context-based ad-hoc overloading mechanism, the macro application uses the arity-based resolution. As it was described above, if a number of arguments is greater than the number of parameters, then the last parameter is bound to the rest of the arguments. When several macro definitions matches, then a definition that has fewer unmatched arguments is chosen. For example, suppose we have the following definitions:</p><pre>          (defmacro list-length (x) 1)
          (defmacro list-length (x xs) (+ 1 (list-length xs)))</pre><p>The the following term</p><pre>(list-length 1 2 3)</pre><p>will be normalized (after a series of transformations) with the following:</p><pre>(+ 1 (+ 1 1))</pre><pre>          1: (list-length 1 2 3) =&gt; (+ 1 (list-length 2 3))
          2: (+ 1 (list-length 2 3)) =&gt; (+ 1 (+ 1 (list-length 3)))
          3: (+ 1 (+ 1 (list-length 3))) =&gt; (+ 1 (+ 1 1))</pre><p>In the first step, both definition match. In the first definition <code>x</code> is bound to <code>1 2 3</code>, while in the second <code>x</code> is bound to <code>1</code> and <code>xs</code> is bound to <code>2 3</code>. Since the last parameter is bound to fewer arguments, the second definition is chosen as the most certain. In the second step the second definition is still more concrete. Finally at the last step, the second definition doesn't match at all, as it has more parameters than arguments.</p><p>A slightly more complex example, is a fold iterator, that applies a function to a sequence of arguments of arbitrary length, e.g.,</p><pre>          (defmacro fold (f a x) (f a x))
          (defmacro fold (f a x xs) (fold f (f a x) xs))</pre><p>Using this definition we can define a sum function (although it is not needed as the <code>+</code> function defined in the Primus Lisp standard library, already accepts arbitrary number of arguments), as:</p><pre>(defmacro sum (xs) (fold + 0 xs))</pre><p>The <b>(sum 1 2 3)</b> will be rewritten as follows:</p><pre>          1: (sum 1 2 3) =&gt; (fold + 0 1 2 3)
          2: (fold + 0 1 2 3) =&gt; (fold + (+ 0 1) 2 3)
          3: (fold + (+ 0 1) 2 3) =&gt; (fold + (+ (+ 0 1) 2) 3)
          4: (fold + (+ (+ 0 1) 2) 3) =&gt; (+ (+ (+ 0 1) 2) 3)</pre><p>A more real example is the <code>write-block</code> macro, that takes a sequence of bytes, and writes them starting from the given address:</p><pre>          (defmacro write-block (addr bytes)
             (fold memory-write addr bytes))</pre><p>The definition uses the <code>memory-write</code> primitive, that writes a byte at the given address and returns an address of the next byte.</p><h3 id="polymorphism"><a href="#polymorphism" class="anchor"></a>Polymorphism</h3><p>Primus Lisp provides both kinds of polymorphism: parametric and ad hoc.</p><p>Expressions in Primus Lisp have types, that are denoted with natural numbers starting with one. Each type defines a set of values that can be represented with the given number of bits. Values with different widths are different, even if they represent the same number. Expressions can be polymorphic, e.g., function</p><pre>(defun square (x) ( * x x))</pre><p>has type `forall n. n -&gt; n -&gt; n`. Thus it can be applied to values of different types, e.g., <code>(square 4:4)</code>, that will be evaluated to the <code>0:4</code> value, or <code>(square 4:8)</code>, that will be evaluated to <code>16:8</code>, etc. The parametric polymorphism doesn't require any special annotations or type specifications so we will not stop on it anymore.</p><p>The ad hoc polymorphism provides a facilities for overloading definitions. That is, the same entity may have multiple definitions, and depending on a context, only one definition should be chosen. Not only functions can have multiple definitions, but also macros, constants, and substitutions. Since the latter three entities operate on the syntactic level, the syntax of Primus Lisp itself is context-dependent.</p><h4 id="context"><a href="#context" class="anchor"></a>Context</h4><p>A context (from the perspective of the type system) is a set of type class instances. The context is fixed when a program is parsed. A Primus Lisp program may not change the context; neither in runtime, nor it the parse time, thus a program is parsed and evaluated at the specific context. However, a definition may declare that it makes sense only in some context. If more than one definition make sense under the given context, then the most specific one is chosen. If no definition is more specific than another, then an error occurs.</p><p>A type class defines a type as a set of features. The subset relation induces a subtyping relation over types - a type <code>t'</code> is a subtype of a type <code>t</code> if <code>t' &lt;= t</code> (i.e., if <code>t'</code> is a subset of <code>t</code>). Each feature is a textual tag, called a feature constructor.</p><p>The context declaration limits an associated definition to the specified type class(es), and has the following syntax:</p><pre>          (declare (context (&lt;type-class&gt; &lt;feature&gt; ...) ...))</pre><p>Let's use the following two definitions for a concrete example,</p><pre>          (defmacro get-arg-0 ()
             (declare (context (arch arm gnueabi)))
             R0)

          (defmacro get-arg-0 ()
             (declare (context (arch x86 cdecl)))
             (read-word word-width (+ SP (sizeof word-width))))</pre><p>We have two definitions of the same macro <code>get-arg-0</code>, that are applicable to different contexts. The first definition, is only applicable in the context of the ARM architecture and the gnueabi ABI. The second is applicable in the context of the x86 architecture and the cdecl ABI. More formally, a definition is considered only if its context is a subtype of the current type context.</p><h3 id="advice-mechanism"><a href="#advice-mechanism" class="anchor"></a>Advice mechanism</h3><p>Primus Lisp also provides a mechanism for non-intrusive extending existing function definitions. An existing definition maybe advised with another definition. A piece of advice maybe added to a function that will be called either before or after the evaluation of an advised function, e.g.,</p><pre>          (defun memory-written (a x)
            (declare (advice :before memory-write))
            (msg &quot;write $x to $a&quot;))</pre><p>This definition not only defines a new function called <code>memory-written</code>, but also proclaims it as advice function to the <code>memory-write</code> function that should before it is called.</p><p>If an advisor is attached before the advised function, then it the advisor will be called with the same arguments as the advised function. The return value of the advisor is ignored. The advisor function will be called as a normal Lisp function, with all expected overloading and name resolving. So it is possible to provide context specific advice. If there are several advice to the same function, then they will be called in the unspecified order.</p><p>An advisor that is attached after the advised function will be called with one extra argument - the result of evaluation of the advised function. The value returned by the advisor will override the result of the advised function. If there are several advisors attached after the same function, then they will be called in the unspecified order.</p><h3 id="signaling-mechanims"><a href="#signaling-mechanims" class="anchor"></a>Signaling Mechanims</h3><p>The Primus Observation system is reflected onto the Primus Lisp Machine Signals. Every time a reflected observation occurs the Lisp Machine receives a signal that is dispatched to handlers. A handler can be declared defined with the <code>defmethod</code> form, e.g.,</p><pre>        (defmethod call (name arg)
          (when (= name 'malloc)
            (msg &quot;malloc($0) was called&quot; arg)))</pre><p>The <code>defmethod</code> form follows the general definition template, i.e., it can contain a docstring and declaration section, and selection and resolution rules are applicable to methods. Methods of the same signal are invoked in an unspecified order.</p><h3 id="formal-syntax"><a href="#formal-syntax" class="anchor"></a>Formal syntax</h3><p>Each entity is an s-expression with the grammar, specified below.We use BNF-like syntax with the following conventions. Metavariables are denoted like <code>&lt;this&gt;</code>. The <code>&lt;this&gt; ...</code> stands of any number of <code>&lt;this&gt;</code> (possibly zero). Ordinary parentheses do not bear any notation, and should be read literally. Note, since the grammar is not context free, and is extensible, the following is an approximation of the language grammar. Grammar extension points are defined with the '?extensible?'comment in a production definition.</p><pre>module ::= &lt;entity&gt; ...

entity ::=
  | &lt;feature-request&gt;
  | &lt;declarations&gt;
  | &lt;constant-definition&gt;
  | &lt;substitution-definition&gt;
  | &lt;parameter-definition&gt;
  | &lt;macro-definition&gt;
  | &lt;function-definition&gt;
  | &lt;method-definition&gt;

feature-request ::= (require &lt;ident&gt;)

declarations ::= (declare &lt;attribute&gt; ...)

constant-definition ::=
  | (defconstant &lt;ident&gt; &lt;atom&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;docstring&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt; &lt;docstring&gt;)

parameter-definition ::=
  | (defparameter &lt;ident&gt; &lt;atom&gt;)
  | (defparameter &lt;ident&gt; &lt;atom&gt; &lt;docstring&gt;)
  | (defparameter &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt; &lt;docstring&gt;)

substitution-definition ::=
  | (defsubst &lt;ident&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; &lt;declarations&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; :&lt;syntax&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; &lt;declarations&gt; :&lt;syntax&gt; &lt;atom&gt; ...)

macro-definition ::=
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;docstring&gt; &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;declarations&gt; &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt;)

function-definition ::=
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;declarations&gt; &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt; ...)

method-definition ::=
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;declarations&gt; &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt; ...)


exp ::=
  | ()
  | &lt;var&gt;
  | &lt;word&gt;
  | &lt;sym&gt;
  | (if &lt;exp&gt; &lt;exp&gt; &lt;exp&gt; ...)
  | (let (&lt;binding&gt; ...) &lt;exp&gt; ...)
  | (set &lt;var&gt; &lt;exp&gt;)
  | (while &lt;exp&gt; &lt;exp&gt; &lt;exp&gt; ...)
  | (prog &lt;exp&gt; ...)
  | (msg &lt;format&gt; &lt;exp&gt; ...)
  | (&lt;ident&gt; &lt;exp&gt; ...)

binding ::= (&lt;var&gt; &lt;exp&gt;)

var ::= &lt;ident&gt; | &lt;ident&gt;:&lt;size&gt;

attribute ::=
  | (external &lt;ident&gt; ...)
  | (context (&lt;ident&gt; &lt;ident&gt; ...) ...)
  | (&lt;ident&gt; ?ident-specific-format?)

docstring ::= &lt;text&gt;

syntax ::= :hex | :ascii | ...

atom  ::= &lt;word&gt; | &lt;text&gt;

word  ::= ?ascii-char? | &lt;int&gt; | &lt;int&gt;:&lt;size&gt;

sym   ::= '&lt;atom&gt;

int   ::= ?decimal-octal-hex-or-bin format?

size  ::= ?decimal?

ident ::= ?any atom that is not recognized as a &lt;word&gt;?</pre></header><dl><dt class="spec type" id="type-program"><a href="#type-program" class="anchor"></a><code><span class="keyword">type</span> program</code></dt><dd><p>an abstract type representing a lisp program</p></dd></dl><dl><dt class="spec type" id="type-message"><a href="#type-message" class="anchor"></a><code><span class="keyword">type</span> message</code></dt><dd><p>an abstract type that represents messages send with the <code>msg</code> form.</p></dd></dl><dl><dt class="spec module" id="module-Load"><a href="#module-Load" class="anchor"></a><code><span class="keyword">module</span> <a href="Load/index.html">Load</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Primus Lisp program loader</p></dd></dl><div class="spec module" id="module-Doc"><a href="#module-Doc" class="anchor"></a><code><span class="keyword">module</span> <a href="Doc/index.html">Doc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span class="keyword">module</span> <a href="Type/index.html">Type</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Lisp Type System.</p></dd></dl><dl><dt class="spec module" id="module-Message"><a href="#module-Message" class="anchor"></a><code><span class="keyword">module</span> <a href="Message/index.html">Message</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Lisp Machine Message interface.</p></dd></dl><dl><dt class="spec module-type" id="module-type-Closure"><a href="#module-type-Closure" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Closure/index.html">Closure</a> = <span class="keyword">functor</span> (<a href="module-type-Closure/argument-1-Machine/index.html">Machine</a> : <a href="../Machine/index.html#module-type-S">Machine.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Machine independent closure.</p></dd></dl><dl><dt class="spec type" id="type-closure"><a href="#type-closure" class="anchor"></a><code><span class="keyword">type</span> closure</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-Closure/index.html">Closure</a>)</span></code></dt><dd><p>a closure packed as an OCaml value</p></dd></dl><div class="spec module" id="module-Primitive"><a href="#module-Primitive" class="anchor"></a><code><span class="keyword">module</span> <a href="Primitive/index.html">Primitive</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-Primitives"><a href="#module-type-Primitives" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Primitives/index.html">Primitives</a> = <span class="keyword">functor</span> (<a href="module-type-Primitives/argument-1-Machine/index.html">Machine</a> : <a href="../Machine/index.html#module-type-S">Machine.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-primitives"><a href="#type-primitives" class="anchor"></a><code><span class="keyword">type</span> primitives</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-Primitives/index.html">Primitives</a>)</span></code></dt><dd><p>a list of primitives.</p></dd></dl><dl><dt class="spec extension"><code><span class="keyword">type</span> <a href="../index.html#type-exn">exn</a> += </code><code><span class="extension">Runtime_error</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-message"><a href="#val-message" class="anchor"></a><code><span class="keyword">val</span> message : <span><a href="index.html#type-message">message</a> <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>message</code> observation occurs every time a message is sent from the Primus Machine.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Machine/index.html">Machine</a> : <a href="../Machine/index.html#module-type-S">Machine.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Make(Machine) creates a Lisp machine embedded into the Primus <code>Machine</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>?&#8288;log:<a href="../../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a></span> <span>&#45;&gt;</span> <span>?&#8288;paths:<span>string list</span></span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>