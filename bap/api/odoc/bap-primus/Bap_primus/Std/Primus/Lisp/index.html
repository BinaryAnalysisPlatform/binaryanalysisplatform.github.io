<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lisp (bap-primus.Bap_primus.Std.Primus.Lisp)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap-primus</a> &#x00BB; <a href="../../../index.html">Bap_primus</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Primus</a> &#x00BB; Lisp</nav><h1>Module <code>Primus.Lisp</code></h1><p>Lisp machine.</p><p>The Lisp Machine is an extensible Lisp Machine embedded into the Primus Machine. The Lisp machine is used to provide function stubs (summaries), as well as to control the Primus Machine using a dialect of Lisp.</p><h2 id="primus-lisp-language"><a href="#primus-lisp-language" class="anchor"></a>Primus Lisp Language</h2><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>Primus Lisp is a dialect of Lisp, that can be used to interact with a native program. Primus Lisp is close to the Common Lisp and Emacs Lisp dialects.</p><p>Primus Lips is a low-level language that doesn't provide many abstractions, as it tries to be as close to the machine language as possible. In that sense Primus Lisp can be seen as an assembler, except that it can't really assemble binaries, as it operates over already existing and assembled program. Primus Lisp, however is still quite powerful, as the absence of suitable abstractions is compensated with powerful and versatile meta-programming system.</p><p>Primus Lisp is primarily used for the following tasks:</p><ul><li>writing function summaries (aka stubs);</li><li>writing insturction semantics (aka lifters);</li><li>stubbing missing hardware;</li><li>setting up program environment;</li><li>exploring and observing program behavior.</li></ul><p>A Primus Lisp program is a set of files with each file consisting of:</p><ul><li>feature requests;</li><li>package definitions;</li><li>declarations;</li><li>constants</li><li>substitutions;</li><li>macros;</li><li>methods;</li><li>functions.</li></ul><p>The entities may be specified in any order, however the above order constitutes a good programming practice.</p><p>Each file provides (implements) a <i>feature</i> that has the same name as the name of the file without an extension and parent directories. Thus the namespace of features is flat. A feature is usually a function, macro definition, or any other definition, or a collection of definition, gathered under the same theme. For example, the <code>getopt</code> feature implements C <code>getopt</code> function, and accompanying definitions. The features maybe very specific, i.e., providing an implementation for only one small function, or they can be a collection of other features. For example, the <code>posix</code> feature provides an implementation of all functions specified in the POSIX standard (not all at the time of writing).</p><p>A collection of directories with lisp files is called a library. A feature (a lisp file) is loaded using the <code>(require &lt;feature&gt;)</code> form, where <code>&lt;feature&gt;</code> is the name of the feature. E.g., to load the <code>posix.lisp</code> file, use <code>(require posix)</code>. The loaded feature may, in turn load other features.</p><p>When all required features are loaded the Primus Lisp program is formed, which is a set of mutually recursive definitions. In Primus Lisp the same name can have multiple definitions and features may be mutually recursive, e.g., <code>foo</code> may <code>(require bar)</code> and <code>bar</code> may <code>(require foo)</code>. The order in which features are loaded is not important.</p><p>All definitions in Primus Lisp (since 2.3.0) are packaged in namespaces. A namespace (called <i>package</i> in Primus Lisp) is a collection of definitions. A package can <i>use</i> other packages, in that case all public definitions from the used package are copied to the destination package. The order in which packages are defined is irrelevant, e.g., it possible to use a package before it is defined as well as extend the set of used packages several times. It is even possible to form cycles in the use-package relation, e.g., a package <code>foo</code> may use package <code>bar</code> and <code>bar</code> can use <code>foo</code>. In that case definitions made in <code>foo</code> are always copied to <code>bar</code> and definitions made in <code>bar</code> are copied to <code>foo</code>, which effectively maintains equality between <code>foo</code> and <code>bar</code> as one is always a copy of another.</p><p>Names visibility as well as other attributes of definitions are controled with <i>declarations</i>. The top-level declarations specify attributes that are shared by all definitions in a feature (file). For example, a declaration</p><pre>(declare (context (arch armv7))</pre><p>makes all definitions <i>applicable</i> (existent) only in the context of the ARMv7 architecture.</p><p>Constants and substitutions are primitive abstractions that give names to code fragments. Macros are program transformations. Functions add parameters to a code, and are basic building blocks. Scope of all definitions can be limited with the context declarations. Finally, a function can be advised with another function using the <code>advice-add</code> function.</p><h3 id="package-system"><a href="#package-system" class="anchor"></a>Package System</h3><p>The Primus Lisp package system enables name clashes-free environment in the presence of mutually recursive definition of the whole program with type class-based names overloading. An important feature of the package system is independence on the order of package definitions and inclusions and tolerance to cycles in package dependencies.</p><p>Despite that the package system prevents name clashes in a such complex environment it is easy to understand. A package is just a dictionary of definitions, where a defintion is a function, macros, variable, primitive, etc. The namespace of each package is flat, i.e., all definitions have simple unqualified names, e.g., <code>malloc</code>, <code>foo</code>, <code>*bar*</code>. The namespace of the packages names is also flat, e.g., <code>posix</code>, <code>core</code>, <code>primus</code>. To access a definition <code>&lt;def&gt;</code> in a package <code>&lt;pkg&gt;</code> use <code>&lt;pkg&gt;:&lt;foo&gt;</code>, e.g., <code>posix:malloc</code>, <code>core:*bar*</code>. When a name is missing a package designator, e.g., <code>foo</code> the parser automatically adds the name of the <i>current</i> package. The current package defaults to <code>user</code> and is set with the <code>in-package</code> form, e.g., <code>(in-package posix)</code> sets the current package to <code>posix</code> and all unqualified names read after it and until the end of the file (or another <code>in-package</code> stanza) will be qualified with the <code>posix</code> package. Therefore, it is important to understand that every identifier in Primus Lisp, be it a variable, a function or a macro name, a symbol, and so on, is having a package, even though most of the time it left implicit and we commonly use unqualified names.</p><p>The <code>(use-package foo)</code> makes all definitions from the package <code>foo</code> available in the current package. Since Primus Lisp enables multiple definitions of the same name, no special considerations to prevent shadowing and the definitions are simply added to the current package. It also doesn't matter whether the <code>use-package</code> stanza occurs before, in between, or after the definitions of <code>foo</code> are loaded as well as it doesn't matter whether it occurs with respect to the defintions of the current package. The mental model is that <code>(use-package foo)</code> establishes a relation <i>uses</i> between the current package and the package <code>foo</code> and all definitions from <code>foo</code> are copied to the current package no matter whether they were lexically made before or after this relation was discovered. Since the definitions from <code>foo</code> are now in the current package, they are also copied to all packages that use the current package and so on, in the transitive closure of the uses relation.</p><p>The <code>use-package</code> stanza is pretty low-level and it is better to use <code>defpackage</code> to define a package, ideally, once. The <code>defpackage</code> form takes the name of the package and a list of packages that it uses as well as the documentation that describes the package purpose. E.g.,</p><pre>          (defpackage riscv
            (:use target program)
            (:documentation &quot;general riscv instruction semantics&quot;))</pre><p>In the example above we specified that the <code>riscv</code> package imports definitions from the <code>target</code> and <code>program</code> packages.</p><p>In Primus Lisp it is not required that the package should be defined before it is used but it is still a good idea to define the package beforehand and, ideally, keep the definition in a single place. With that said, it is possible to have multiple definitions (or no definitios) of a package spread across multiple files. Therefore, it is possible to extend the set of packages that some package uses with all pitfalls and perils. We highly advice to refrain from touching the use-list of packages that you do not control.</p><p>Primus Lisp comes with a set of predefined packages and all of them are used by the <code>user</code> package, which is the default package (so their definitions could be used unqualified by default):</p><ul><li><code>core</code> - the core of the Primus Lisp language;</li><li><code>primus</code> - the Primus Lisp runtime;</li><li><code>program</code> - the binary program runtime;</li><li><code>target</code> - the target CPU environment;</li><li><code>posix</code> - the definitions of the posix runtime.</li></ul><p>In addition to these packages, each target (architecture) known to bap (see <code>bap list targets</code>) forms a package that is prefilled with the registers of that target, e.g., <code>i86:SP</code>, <code>amd64:RSP</code>, and so on (the target package name is formed from the unqualified name of the target name itself). This gives an additional way to refer to registers, with the other option is to use the <code>target</code> package in which CPU registers of the currently analyzed binary are added.</p><p>Another important packages to consider is the <code>external</code> package where all externally visible definitions are put, see more about it in the <code>external</code> attribute description.</p><h4 id="name-visibility"><a href="#name-visibility" class="anchor"></a>Name Visibility</h4><p>By default all names defined in a package are public and are exported to all packages that use this package. It is, possible to control the visibility of a name using the visibility attribute. See attributes below for more information.</p><h3 id="type-system"><a href="#type-system" class="anchor"></a>Type System</h3><p>Primus Lisp has a gradual type system. A type defines all possible values of an expression. In Primus Lisp, expression values can be only scalar, i.e., machine words of different widths. The width is always specified in the number of bits. We denote a type of an expression with a decimal number, e.g., <code>(exp : 16)</code> means that an expression ranges over all 16-bit-wide words.</p><p>An expression can have a polymorphic type <code>any</code> that means that there are no static guarantees about the term type. Branching expressions in Primus Lisp are relaxed from typing (so the type of the <code>if</code> form depends on the condition). In other words, the type of a branching expression is always <code>any</code>.</p><h3 id="functions-and-expressions"><a href="#functions-and-expressions" class="anchor"></a>Functions and expressions</h3><p>Functions are named abstractions of code, where a code is a sequence of expressions. Since a value of an expression is a machine word, functions are not first-class values in Primus Lisp. However, functions and types can be manipulated on the meta-programming level.</p><p>A function is defined with the <code>defun</code> form, that has the following syntax:</p><pre><code class="ml">(defun &lt;name&gt; (&lt;arg&gt; ...) &lt;exp&gt; ...)</code></pre><p>A list of arguments (that can be empty) defines function arity. Functions in Primus Lisp has fixed arity, unlike macros.</p><p>A function definition may optionally contain a documentation strings and a declaration section. For example,</p><pre>         (defun strlen (p)
           &quot;returns a length of the null-terminated string pointed by P&quot;
           (declare (external &quot;strlen&quot;))
           (msg &quot;strlen was called with $p&quot;)
           (let ((len 0))
             (while (not (points-to-null p))
               (incr len p))
             len))</pre><p>A function can be called (applied) using the function application form:</p><pre>(&lt;name&gt; &lt;exp&gt; ...)</pre><p>The first element of the function application form is not an expression and must be an identified. The rest arguments are expressions, that are evaluated from left to right. All arguments are passed by value.</p><p>The body of a function is a sequence of expressions, that is evaluated in the lexical order (i.e., from left to right). A value of the last expression is the result of the function evaluation. An expression is either a function application or or a special form. Primus Lisp defines only 5 special forms, the rest of the syntax is defined using the macro system.</p><h4 id="conditionals"><a href="#conditionals" class="anchor"></a>Conditionals</h4><p>The <b>(if &lt;test-expr&gt; &lt;then-expr&gt; &lt;else-expr&gt; ...)</b> form is a basic control flow structure. If <b>&lt;test-expr&gt;</b> evaluates to a non-zero word then the result of the <b>&lt;if&gt;</b> form is the result of evaluation of the <b>&lt;then-expr&gt;</b>, otherwise a sequence of <b>&lt;else-expr&gt;</b> ... is evaluated and the result of the form evaluation would be a result of the last expression in a form</p><p>For example,</p><pre>        (if (&lt; 4 3)
            (msg &quot;shouldn't happen&quot;)
          (msg &quot;that's right&quot;)
          (- 4 3))</pre><p>Note that the the <b>&lt;else-expr&gt;</b> sequence maybe empty.</p><p>Several derived forms are defined as macros, e.g.,</p><pre>          (when &lt;cond&gt; &lt;expr&gt; ...)
          (or &lt;expr&gt; ...)
          (and &lt;expr&gt; ...)</pre><h4 id="loops"><a href="#loops" class="anchor"></a>Loops</h4><p>Iterations can be implemented either using recursion or with the <code>while</code> special form. Since the interpreter doesn't provide the tail-call optimization it is better to use the latter (although the interpreter itself is using a constant stack size, as it uses the host language heap memory to represent the Primus Lisp call stack).</p><p>The <b>(while &lt;cond&gt; &lt;expr&gt; ...)</b> form, will evaluate the &lt;cond&gt; expression first, and if it is a non-zero value, then the sequence of expressions <b>&lt;expr&gt; ...</b> is evaluated, and the value of the last expression becomes the value of the <code>while</code> form. If the value of the <b>&lt;cond&gt;</b> expression is a false value, then this value becomes the value of the <code>while</code> form.</p><h4 id="variables"><a href="#variables" class="anchor"></a>Variables</h4><p>The <code>let</code> form binds values to names in the lexical scope.</p><pre>         (let (&lt;binding&gt; ...)  &lt;body-expr&gt; ...)
         binding ::= (&lt;var&gt; &lt;expr&gt;)</pre><p>Evaluates each <b>&lt;binding&gt;</b> in order binding the <b>&lt;var&gt;</b> identifier to a result of <b>&lt;expr&gt;</b>. The newly created binding is available in consequent bindings and in the &lt;body-expr&gt;, but is not visible outside of the scope of the let-form.</p><p>Example,</p><pre>        (let ((x 4)
              (y (+ x 2)))
          (+ x 3))</pre><p>The value of the <code>let</code> form is the value of the last expression <b>&lt;sN&gt;</b>.</p><h4 id="sequencing"><a href="#sequencing" class="anchor"></a>Sequencing</h4><p>The <b>(prog &lt;expr&gt; ...)</b> form combines a sequence of expressions into one expression, and is useful in the contexts where an expression is required. The expressions are evaluated from left to right, and the value of the <code>prog</code> form is the value of the last expression.</p><h4 id="messaging"><a href="#messaging" class="anchor"></a>Messaging</h4><p>The <b>(msg &lt;fmt&gt; &lt;expr&gt; ...)</b> form constructs logging/debugging messages using an embedded formatting language. The formed message will be sent to the logging facility, that was set up during the Primus Lisp library initialization.</p><p>The format language interprets all symbols literally, unless they start with the dollar sign ($).</p><p>A pair of characters of the form <b>$&lt;n&gt;</b>, where <b>&lt;n&gt;</b> is a decimal digit, will be substituted with the value of the n'th expression (counting from zero).</p><p>Example,</p><pre>(msg &quot;hello, $0 $0 world, (+ 7 8) = $1&quot; &quot;cruel&quot; (+ 7 8))</pre><p>will be rendered to a message:</p><pre>&quot;hello, cruel cruel world, (+ 7 8) = 15&quot;</pre><h3 id="metaprogramming"><a href="#metaprogramming" class="anchor"></a>Metaprogramming</h3><p>Ordinary Primus Lisp expressions are evaluated at the runtime in the Primus emulator, and are quite limited as they need to be evaluated directly on the CPU model. To mitigate this limitation, Primus Lisp provides a powerful metaprogramming system. The metaprogram is evaluated when the Primus Lisp program is read. A metaprogram generates a program, that will be evaluated by the CPU. The metaprogram itself is Turing complete, thus any transformation can be applied to a program. The Primus Lisp metaprogramming system use term-rewriting as a computational model, with Lisp code fragments as terms. Primus Lisp provides three facilities for metaprogramming:</p><ul><li>syntactic constants;</li><li>syntactic substitutions;</li><li>macro definitions.</li></ul><h4 id="constants"><a href="#constants" class="anchor"></a>Constants</h4><p>The syntactic constants is the simplest syntactic substitution, it just substitutes atoms for atoms. Constants are introduced with the <code>defconstant</code> form, that has the following syntax:</p><pre>         (defconstant &lt;name&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;docstring&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;declarations&gt; &lt;atom&gt;)
         (defconstant &lt;name&gt; &lt;docstring&gt; &lt;declarations&gt; &lt;atom&gt;)</pre><p>For example,</p><pre>(defconstant main-address 0xDEAD)</pre><p>During the program parsing, each occurrence of the <b>&lt;name&gt;</b> term will be rewritten with the <b>&lt;value&gt;</b> term, that should be an atom.</p><h4 id="substitutions"><a href="#substitutions" class="anchor"></a>Substitutions</h4><p>The syntactic substitution is a generalization of syntactic constant, and has quite a similar syntax:</p><pre>          | (defsubst &lt;name&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; &lt;declarations&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; :&lt;syntax&gt; &lt;value&gt; ...)
          | (defsubst &lt;name&gt; &lt;declarations&gt; :&lt;syntax&gt; &lt;value&gt; ...)</pre><p>During parsing, every occurrence of the term <b>&lt;name&gt;</b> (that should be an atom), will be rewritten with a sequence of values </p><pre><code class="ml">{&lt;value&gt;} </code></pre><p>.</p><p>Example,</p><pre>(defsubst ten-digits 0 1 2 3 4 5 6 7 8 9)</pre><p>A process of applying of the substitutions is called &quot;expansion&quot;. Since the expansion transforms an atom to a list of atoms, it can be applied only inside the macro or function application. For example,</p><pre>(+ ten-digits)</pre><p>will be expanded to</p><pre>(+ 0 1 2 3 4 5 6 7 8 9 )</pre><h5 id="special-syntax"><a href="#special-syntax" class="anchor"></a>Special syntax</h5><p>Expansions also provide a support for extensible value specification syntax, that enables domain-specific data specification languages. Currently, we support only two syntaxes: <code>:ascii</code> and <code>:hex</code>.</p><p>In the <code>:ascii</code> syntax the values should be atoms, possibly delimited with double quotes. Each character of each atom will be expanded to its corresponding ASCII code. Strings can contain special characters prefixed with a backslash. The special character can be one of the well-known ASCII special character, e.g., <code>\n</code>, <code>\r</code>, etc, or it can be a decimal or a hexadecimal code of a character.</p><p>Example, given the following substitution:</p><pre>(defsubst hello-cruel-world :ascii &quot;hello, cruel world\n\000&quot;)</pre><p>the following application:</p><pre>(write-block SP hello-cruel-world</pre><p>will be expanded with</p><pre><code class="ml">(write-block SP
   0x68 0x65 0x6c 0x6c 0x6f 0x2c 0x20 0x63
   0x72 0x75 0x65 0x6c 0x20 0x77 0x6f 0x72
   0x6c 0x64 0x0a 0x00)</code></pre><p>In the <code>:hex</code> syntax the sequence of atoms is split into two-characters subsequences each treated as a hex value. This syntax is useful for encoding memory dumps in a format that is close to the hexdump (without offsets). E.g., given the following substitution rule</p><pre><code class="ml">(defsubt example :hex 68656c 6c 6f2c2063)</code></pre><p>an application</p><pre><code class="ml">(write-block SP example)</code></pre><p>will be expanded into</p><pre><code class="ml">(write-block SP 0x68 0x65 0x6c 0x6c 0x6f 0x2c 0x20 0x63)</code></pre><h4 id="macro"><a href="#macro" class="anchor"></a>Macro</h4><p>The macros provide the most versatile and powerful way to specify arbitrary code transformations. The macro definitions introduce abstractions on the meta-programming level. I.e., it allows a programmer to write a function that operates on code terms, making the code a first class value.</p><p>The macro definition has the following syntax:</p><pre>          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;docstring&gt; &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;declarations&gt; &lt;value&gt;)
          (defmacro &lt;name&gt; (&lt;param&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;value&gt;)</pre><p>A macro definition adds a term rewriting rule, that rewrites each occurrence of <b>(&lt;name&gt; &lt;arg&gt; ...)</b>, where the number of arguments <code>N</code> is greater or equal then the number of parameters <code>M</code>, with the <b>&lt;value&gt;</b> in which occurrences of the <code>i</code>th parameter is substituted with the term <code>i</code>th argument. If <code>N</code> is bigger than <code>M</code>, then the last parameter is bound with the sequence of arguments <b>&lt;argM&gt;...&lt;argN&gt;</b>.</p><p>The macro subsystem doesn't provide any specific looping or control-flow facilities, however, the macro-overloading mechanism along with the recursion make it possible to encode arbitrary meta-transformations.</p><p>Other than a standard context-based ad-hoc overloading mechanism, the macro application uses the arity-based resolution. As it was described above, if a number of arguments is greater than the number of parameters, then the last parameter is bound to the rest of the arguments. When several macro definitions matches, then a definition that has fewer unmatched arguments is chosen. For example, suppose we have the following definitions:</p><pre>          (defmacro list-length (x) 1)
          (defmacro list-length (x xs) (+ 1 (list-length xs)))</pre><p>The the following term</p><pre>(list-length 1 2 3)</pre><p>will be normalized (after a series of transformations) with the following:</p><pre>(+ 1 (+ 1 1))</pre><pre>          1: (list-length 1 2 3) =&gt; (+ 1 (list-length 2 3))
          2: (+ 1 (list-length 2 3)) =&gt; (+ 1 (+ 1 (list-length 3)))
          3: (+ 1 (+ 1 (list-length 3))) =&gt; (+ 1 (+ 1 1))</pre><p>In the first step, both definition match. In the first definition <code>x</code> is bound to <code>1 2 3</code>, while in the second <code>x</code> is bound to <code>1</code> and <code>xs</code> is bound to <code>2 3</code>. Since the last parameter is bound to fewer arguments, the second definition is chosen as the most certain. In the second step the second definition is still more concrete. Finally at the last step, the second definition doesn't match at all, as it has more parameters than arguments.</p><p>A slightly more complex example, is a fold iterator, that applies a function to a sequence of arguments of arbitrary length, e.g.,</p><pre>          (defmacro fold (f a x) (f a x))
          (defmacro fold (f a x xs) (fold f (f a x) xs))</pre><p>Using this definition we can define a sum function (although it is not needed as the <code>+</code> function defined in the Primus Lisp standard library, already accepts arbitrary number of arguments), as:</p><pre>(defmacro sum (xs) (fold + 0 xs))</pre><p>The <b>(sum 1 2 3)</b> will be rewritten as follows:</p><pre>          1: (sum 1 2 3) =&gt; (fold + 0 1 2 3)
          2: (fold + 0 1 2 3) =&gt; (fold + (+ 0 1) 2 3)
          3: (fold + (+ 0 1) 2 3) =&gt; (fold + (+ (+ 0 1) 2) 3)
          4: (fold + (+ (+ 0 1) 2) 3) =&gt; (+ (+ (+ 0 1) 2) 3)</pre><p>A more real example is the <code>write-block</code> macro, that takes a sequence of bytes, and writes them starting from the given address:</p><pre>          (defmacro write-block (addr bytes)
             (fold memory-write addr bytes))</pre><p>The definition uses the <code>memory-write</code> primitive, that writes a byte at the given address and returns an address of the next byte.</p><h3 id="polymorphism"><a href="#polymorphism" class="anchor"></a>Polymorphism</h3><p>Primus Lisp provides both kinds of polymorphism: parametric and ad hoc.</p><p>Expressions in Primus Lisp have types, that are denoted with natural numbers starting with one. Each type defines a set of values that can be represented with the given number of bits. Values with different widths are different, even if they represent the same number. Expressions can be polymorphic, e.g., function</p><pre>(defun square (x) ( * x x))</pre><p>has type `forall n. n -&gt; n -&gt; n`. Thus it can be applied to values of different types, e.g., <code>(square 4:4)</code>, that will be evaluated to the <code>0:4</code> value, or <code>(square 4:8)</code>, that will be evaluated to <code>16:8</code>, etc. The parametric polymorphism doesn't require any special annotations or type specifications so we will not stop on it anymore.</p><p>The ad hoc polymorphism provides a facilities for overloading definitions. That is, the same entity may have multiple definitions, and depending on a context, only one definition should be chosen. Not only functions can have multiple definitions, but also macros, constants, and substitutions. Since the latter three entities operate on the syntactic level, the syntax of Primus Lisp itself is context-dependent.</p><h4 id="context"><a href="#context" class="anchor"></a>Context</h4><p>A context (from the perspective of the type system) is a set of type class instances. The context is fixed when a program is parsed. A Primus Lisp program may not change the context; neither in runtime, nor it the parse time, thus a program is parsed and evaluated at the specific context. However, a definition may declare that it makes sense only in some context. If more than one definition make sense under the given context, then the most specific one is chosen. If no definition is more specific than another, then an error occurs.</p><p>A type class defines a type as a set of features. The subset relation induces a subtyping relation over types - a type <code>t'</code> is a subtype of a type <code>t</code> if <code>t' &lt;= t</code> (i.e., if <code>t'</code> is a subset of <code>t</code>). Each feature is a textual tag, called a feature constructor.</p><p>The context declaration limits an associated definition to the specified type class(es), and has the following syntax:</p><pre>          (declare (context (&lt;type-class&gt; &lt;feature&gt; ...) ...))</pre><p>Let's use the following two definitions for a concrete example,</p><pre>          (defmacro get-arg-0 ()
             (declare (context (arch arm gnueabi)))
             R0)

          (defmacro get-arg-0 ()
             (declare (context (arch x86 cdecl)))
             (read-word word-width (+ SP (sizeof word-width))))</pre><p>We have two definitions of the same macro <code>get-arg-0</code>, that are applicable to different contexts. The first definition, is only applicable in the context of the ARM architecture and the gnueabi ABI. The second is applicable in the context of the x86 architecture and the cdecl ABI. More formally, a definition is considered only if its context is a subtype of the current type context.</p><h3 id="attributes"><a href="#attributes" class="anchor"></a>Attributes</h3><p>Each Primus Lisp definition has a set of attributes that defines its various properties. The set of attributes is extensible and language users can define their own and attach arbitrary meaning to them. In that sense attributes is the language extension mechanism. There is, however, a set of core attributes that have predefined meaning and that are described above.</p><p>Attributes are declared using the <code>declare</code> stanza, e.g., <code>(declare (context (target riscv)))</code>. Attributes can be defined on the top level, in that case, they will be attached to each definition in this feature, alternatively, the can be attached to a definition, e.g.,</p><pre>         (defun malloc (n)
           &quot;allocates a memory region of size N&quot;
           (declare (external &quot;malloc&quot;))
           ...)</pre><p>The set of attributes of a definition is the union of attributes attached to it and global to the feature attributes.</p><h4 id="the-external-attribute"><a href="#the-external-attribute" class="anchor"></a>The external attribute</h4><p>This attributes instructs the Primus Lisp program loader that the definition has external linkage and must be linked instead of the corresponding definition in the binary program. E.g., adding <code>(external &quot;malloc&quot;)</code> will link the current definition instead of the <code>malloc</code> function defined in the binary.</p><p>When the program is linked, the linker will scan all definitions and for each definition that has <code>(external &lt;n1&gt; &lt;n2&gt; ...)</code> will be copied to the <code>external</code> package under names <code>&lt;n1&gt;</code>, <code>&lt;n2&gt;</code>, and so on. Next, when the binary program is linked, for each function in the binary the linker will search the <code>external</code> package for the matching definition.</p><p>Note, is is possible to use directly the <code>external</code> package to make your definitions externally available.</p><h4 id="the-context-attribute"><a href="#the-context-attribute" class="anchor"></a>The context attribute</h4><p>This attribute defines the context in which the definition is applicable. See the <code>Context</code> chapter for more details on it.</p><h4 id="name-visibility"><a href="#name-visibility" class="anchor"></a>Name Visibility</h4><p>The <code>visibility</code> attribute controls whether the definition will be exported to the packages that use the package where it is defined. There are two kinds of visibilities - <code>:public</code> and <code>:private</code>. By default, all definitions have the <code>:public</code> visibility. To make a definition private (so that it won't be accessible in other packages even if they use your package) add the visibility declaration to it, e.g.,</p><pre>          (defun conditional-jump (cmp off)
            (declare (visibility :private))
            (let ((pc (get-program-counter)))
              (when cmp
                (exec-addr (+ pc off)))))</pre><p>It is also possible to make all definitions in a feature private by default using a global visibility declaration, e.g.,</p><pre>        (declare (visibility :private))</pre><p>and make some definitions public by adding corresponding public declarations.</p><h4 id="global-and-static-definitions"><a href="#global-and-static-definitions" class="anchor"></a>Global and Static definitions</h4><p>The <code>global</code> and <code>static</code> definitions create variables (with, correspondingly public and private visibility), e.g.,</p><p><code>(global errno-location)</code></p><p>Creates an <code>errno-location</code> variable in the Primus Lisp runtime state. The names are read in the current package namespace.</p><h4 id="advice-mechanism"><a href="#advice-mechanism" class="anchor"></a>Advice mechanism</h4><p>Primus Lisp also provides a mechanism for non-intrusive extending existing Primus Lisp function definitions. A definition maybe advised with another definition. A piece of advice maybe added to a function that will be called either before or after the evaluation of an advised function, e.g.,</p><pre>          (defun memory-written (a x)
            (declare (advice :before core:memory-write))
            (msg &quot;write $x to $a&quot;))</pre><p>This definition not only defines a new function called <code>memory-written</code>, but also proclaims it as an advice function to the <code>memory-write</code> function that should before it is called.</p><p>If an advisor is attached before the advised function then the advisor will be called with the same arguments as the advised function. The return value of the advisor is ignored. The advisor function will be called as a normal Lisp function, with all expected overloading and name resolving. So it is possible to provide context specific advice. If there are several advice to the same function, then they will be called in the unspecified order.</p><p>An advisor that is attached after the advised function will be called with one extra argument - the result of evaluation of the advised function. The value returned by the advisor will override the result of the advised function. If there are several advisors attached after the same function, then they will be called in an unspecified order.</p><p>All names in the <code>advice</code> declaration are parsed with the current package set to <code>external</code> to enable seamless advising of the function stubs.</p><h3 id="signaling-mechanims"><a href="#signaling-mechanims" class="anchor"></a>Signaling Mechanims</h3><p>The Primus Observation system is reflected onto the Primus Lisp Machine Signals. Every time a reflected observation occurs the Lisp Machine receives a signal that is dispatched to handlers. A handler can be declared defined with the <code>defmethod</code> form, e.g.,</p><pre>        (defmethod call (name arg)
          (when (= name 'malloc)
            (msg &quot;malloc($0) was called&quot; arg)))</pre><p>The <code>defmethod</code> form follows the general definition template, i.e., it can contain a docstring and declaration section, and selection and resolution rules are applicable to methods. Methods of the same signal are invoked in an unspecified order.</p><h3 id="formal-syntax"><a href="#formal-syntax" class="anchor"></a>Formal syntax</h3><p>Each entity is an s-expression with the grammar, specified below.We use BNF-like syntax with the following conventions. Metavariables are denoted like <code>&lt;this&gt;</code>. The <code>&lt;this&gt; ...</code> stands of any number of <code>&lt;this&gt;</code> (possibly zero). Ordinary parentheses do not bear any notation, and should be read literally. Note, since the grammar is not context free, and is extensible, the following is an approximation of the language grammar. Grammar extension points are defined with the '?extensible?'comment in a production definition.</p><pre>module ::= &lt;entity&gt; ...

entity ::=
  | &lt;feature-request&gt;
  | &lt;declarations&gt;
  | &lt;constant-definition&gt;
  | &lt;substitution-definition&gt;
  | &lt;parameter-definition&gt;
  | &lt;macro-definition&gt;
  | &lt;function-definition&gt;
  | &lt;method-definition&gt;

feature-request ::= (require &lt;ident&gt;)

declarations ::= (declare &lt;attribute&gt; ...)

constant-definition ::=
  | (defconstant &lt;ident&gt; &lt;atom&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;docstring&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt;)
  | (defconstant &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt; &lt;docstring&gt;)

parameter-definition ::=
  | (defparameter &lt;ident&gt; &lt;atom&gt;)
  | (defparameter &lt;ident&gt; &lt;atom&gt; &lt;docstring&gt;)
  | (defparameter &lt;ident&gt; &lt;atom&gt; &lt;declarations&gt; &lt;docstring&gt;)

substitution-definition ::=
  | (defsubst &lt;ident&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; &lt;declarations&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; :&lt;syntax&gt; &lt;atom&gt; ...)
  | (defsubst &lt;ident&gt; &lt;declarations&gt; :&lt;syntax&gt; &lt;atom&gt; ...)

macro-definition ::=
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;docstring&gt; &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;declarations&gt; &lt;exp&gt;)
  | (defmacro &lt;ident&gt; (&lt;ident&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt;)

function-definition ::=
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;declarations&gt; &lt;exp&gt; ...)
  | (defun &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt; ...)

method-definition ::=
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;declarations&gt; &lt;exp&gt; ...)
  | (defmethod &lt;ident&gt; (&lt;var&gt; ...) &lt;docstring&gt; &lt;declarations&gt; &lt;exp&gt; ...)


exp ::=
  | ()
  | &lt;var&gt;
  | &lt;word&gt;
  | &lt;sym&gt;
  | (if &lt;exp&gt; &lt;exp&gt; &lt;exp&gt; ...)
  | (let (&lt;binding&gt; ...) &lt;exp&gt; ...)
  | (set &lt;var&gt; &lt;exp&gt;)
  | (while &lt;exp&gt; &lt;exp&gt; &lt;exp&gt; ...)
  | (prog &lt;exp&gt; ...)
  | (msg &lt;format&gt; &lt;exp&gt; ...)
  | (&lt;ident&gt; &lt;exp&gt; ...)

binding ::= (&lt;var&gt; &lt;exp&gt;)

var ::= &lt;ident&gt; | &lt;ident&gt;:&lt;size&gt;

attribute ::=
  | (external &lt;ident&gt; ...)
  | (context (&lt;ident&gt; &lt;ident&gt; ...) ...)
  | (global &lt;ident&gt; ...)
  | (static &lt;ident&gt; ...)
  | (advice &lt;cmethod&gt; &lt;ident&gt; ...)
  | (visibility &lt;visibility&gt;)
  | (&lt;ident&gt; ?ident-specific-format?)
  | &lt;ident&gt;

cmethod ::= :before | :after

visibility ::= :public | :private

docstring ::= &lt;text&gt;

syntax ::= :hex | :ascii | ...

atom  ::= &lt;word&gt; | &lt;text&gt;

word  ::= ?ascii-char? | &lt;int&gt; | &lt;int&gt;:&lt;size&gt;

sym   ::= '&lt;atom&gt;

int   ::= ?decimal-octal-hex-or-bin format?

size  ::= ?decimal?

ident ::= &lt;package&gt;:&lt;name&gt;

name ::= text

package ::= text

text ::= ?any atom that is not recognized as a &lt;word&gt;?</pre></header><dl><dt class="spec type" id="type-program"><a href="#type-program" class="anchor"></a><code><span class="keyword">type</span> program</code></dt><dd><p>an abstract type representing a lisp program</p></dd></dl><dl><dt class="spec type" id="type-message"><a href="#type-message" class="anchor"></a><code><span class="keyword">type</span> message</code></dt><dd><p>an abstract type that represents messages send with the <code>msg</code> form.</p></dd></dl><dl><dt class="spec module" id="module-Load"><a href="#module-Load" class="anchor"></a><code><span class="keyword">module</span> <a href="Load/index.html">Load</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Primus Lisp program loader</p></dd></dl><div class="spec module" id="module-Doc"><a href="#module-Doc" class="anchor"></a><code><span class="keyword">module</span> <a href="Doc/index.html">Doc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span class="keyword">module</span> <a href="Type/index.html">Type</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Lisp Type System.</p></dd></dl><dl><dt class="spec module" id="module-Semantics"><a href="#module-Semantics" class="anchor"></a><code><span class="keyword">module</span> <a href="Semantics/index.html">Semantics</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The static semantics of Primus Lisp program.</p></dd></dl><dl><dt class="spec module" id="module-Unit"><a href="#module-Unit" class="anchor"></a><code><span class="keyword">module</span> <a href="Unit/index.html">Unit</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A Primus Lisp module.</p></dd></dl><dl><dt class="spec module" id="module-Attribute"><a href="#module-Attribute" class="anchor"></a><code><span class="keyword">module</span> <a href="Attribute/index.html">Attribute</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Primus Lisp Attributes.</p></dd></dl><dl><dt class="spec module" id="module-Message"><a href="#module-Message" class="anchor"></a><code><span class="keyword">module</span> <a href="Message/index.html">Message</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Lisp Machine Message interface.</p></dd></dl><dl><dt class="spec module" id="module-Closure"><a href="#module-Closure" class="anchor"></a><code><span class="keyword">module</span> <a href="Closure/index.html">Closure</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Machine independent closure.</p></dd></dl><div class="spec module-type" id="module-type-Closure"><a href="#module-type-Closure" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Closure/index.html">Closure</a> = <a href="Closure/index.html#module-type-S">Closure.S</a></code></div><dl><dt class="spec value" id="val-primitive"><a href="#val-primitive" class="anchor"></a><code><span class="keyword">val</span> primitive : <span><span>(string * <span><a href="../index.html#type-value">value</a> list</span>)</span> <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>(lisp-primitive &lt;name&gt; &lt;arg1&gt; ... &lt;argM&gt; &lt;rval&gt;)</code> is posted when the Lisp primitive with the given &lt;name&gt; is called with the list of arguments <code>(&lt;arg1&gt; .... &lt;argM&gt;)</code> and evaluates to the <code>&lt;rval&gt;</code> value.</p><dl><dt>since</dt><dd>2.1.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-closure"><a href="#type-closure" class="anchor"></a><code><span class="keyword">type</span> closure</code><code> = <a href="Closure/index.html#type-t">Closure.t</a></code></dt><dd><p>a closure packed as an OCaml value</p></dd></dl><div class="spec module" id="module-Primitive"><a href="#module-Primitive" class="anchor"></a><code><span class="keyword">module</span> <a href="Primitive/index.html">Primitive</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-Primitives"><a href="#module-type-Primitives" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Primitives/index.html">Primitives</a> = <span class="keyword">functor</span> (<a href="module-type-Primitives/argument-1-Machine/index.html">Machine</a> : <a href="../Machine/index.html#module-type-S">Machine.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-primitives"><a href="#type-primitives" class="anchor"></a><code><span class="keyword">type</span> primitives</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-Primitives/index.html">Primitives</a>)</span></code></dt><dd><p>a list of primitives.</p></dd></dl><dl><dt class="spec extension"><code><span class="keyword">type</span> <a href="../index.html#type-exn">exn</a> += </code><code><span class="extension">Runtime_error</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-message"><a href="#val-message" class="anchor"></a><code><span class="keyword">val</span> message : <span><a href="index.html#type-message">message</a> <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>message</code> observation occurs every time a message is sent from the Primus Machine.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Machine/index.html">Machine</a> : <a href="../Machine/index.html#module-type-S">Machine.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Make(Machine) creates a Lisp machine embedded into the Primus <code>Machine</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>?&#8288;log:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> <span>?&#8288;paths:<span>string list</span></span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>