<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>System (bap-primus.Bap_primus.Std.Primus.System)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">bap-primus</a> &#x00BB; <a href="../../../index.html">Bap_primus</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Primus</a> &#x00BB; System</nav><h1>Module <code>Primus.System</code></h1><nav class="toc"><ul><li><a href="#an-instance-of-the-primus-machine">An instance of the Primus Machine</a><ul><li><a href="#system's-timeline">System's timeline</a><ul><li><a href="#the-initialization-phase">The initialization phase</a></li><li><a href="#the-post-init-phase">The post-init phase</a></li><li><a href="#the-running-phase">The running phase</a></li><li><a href="#the-post-running-phase">The post-running phase</a></li><li><a href="#the-stopped-phase">The stopped phase</a></li></ul></li><li><a href="#non-determinism-and-machine-stopping">Non-determinism and machine stopping</a></li></ul></li></ul></nav></header><section><header><h2 id="an-instance-of-the-primus-machine"><a href="#an-instance-of-the-primus-machine" class="anchor"></a>An instance of the Primus Machine</h2><p>A collection of components defines a runnable instance of Primus Machine. Systems could be defined programmatically, using this interface, or in system description files.</p><p>The system definition holds enough information to initialize and run the system.</p></header><section><header><h3 id="system's-timeline"><a href="#system's-timeline" class="anchor"></a>System's timeline</h3><p>A system consequently passes through the following main phases of its life:</p><ul><li>initialization (booting);</li><li>post-init;</li><li>running;</li><li>post-running;</li><li>stopped.</li></ul></header><section><header><h4 id="the-initialization-phase"><a href="#the-initialization-phase" class="anchor"></a>The initialization phase</h4><p>During the initialization phase, the <code>init</code> method of all components is run. The observations and non-determism are blocked in this phase and other components might be unitialized in this phase (components are initialized in an unspecified order). Components should subscribe to other observations and register their Lisp primitives in this phase.</p><p>Components should minimize the side-effects on the Primus machine and do not use Interpreter, Linker, and/or any observable operations. In this phase the Primus Machine operates in the deterministic mode and fork/switch operators are disabled.</p><p>Once this phase is complete, the <code>init</code> observation is posted and the system enters the post-init phase.</p></header></section><section><header><h4 id="the-post-init-phase"><a href="#the-post-init-phase" class="anchor"></a>The post-init phase</h4><p>The post-init phase starts after the <code>init</code> observation is posted. During this phase observation and non-determinism are enabled. This phase is used by the components that would like to change the initial state of the Machine (i.e., initialize variables, possibly non-deterministically, link code, etc).</p><p>Components that need this kind of initialization shall subscribe to the <code>init</code> observation and perform the necessary post-initialization in the handler.</p><p>This stage is used to prepare the Machine for the execution. Once it is finished the <code>start</code> observation is posted.</p><p>Any exception that is thrown in this phase will prevent machine from running and terminate the computation immediately.</p></header></section><section><header><h4 id="the-running-phase"><a href="#the-running-phase" class="anchor"></a>The running phase</h4><p>The <code>start</code> observation designates the start of the execution and the code that is attached to this observation denotes the main function of the system. It is possible that there is more than one component attach their behavior to the <code>start</code> event, in that case all the components will be run in an unspecified order.</p><p>It is not strictly required that a system should have components that are executed in the running phase, as when a system is run it is possible to provide the code that is run, during the start phase (as well as the code that is run during, the post-init phase), see <a href="index.html#val-run"><code>System.run</code></a> below.</p></header></section><section><header><h4 id="the-post-running-phase"><a href="#the-post-running-phase" class="anchor"></a>The post-running phase</h4><p>After the code attached to the start phase terminates, either normally or via the Primus exception, the <code>fini</code> observation is posted and the system enters the post-running phase. This is a non-deterministic phase and components of the system might resume running by switching the computation to another fork, therefore, the system can enter this phase multiple times (but exit only once).</p><p>Once the post-running phase is finally finished, the machine enters the final <code>stopped</code> phases.</p></header></section><section><header><h4 id="the-stopped-phase"><a href="#the-stopped-phase" class="anchor"></a>The stopped phase</h4><p>This is the final phase and, like the initial phase, observations and non-determinism are disabled. This phase could be used to summarize the information that was obtained during the system run.</p><p>When the system enters the stopped state it is no longer possible to restart it and all computations that are run during this phase will not be observable.</p></header></section></section><section><header><h3 id="non-determinism-and-machine-stopping"><a href="#non-determinism-and-machine-stopping" class="anchor"></a>Non-determinism and machine stopping</h3><p>Since Primus Machine is non-deterministic, for the given system we can observe more than one finalizations of computations. Usually, schedulers use the <code>fini</code> observation to kill the finished machine and switch to another machine.</p><p>When a machine is killed the <code>killed</code> observation is posted that could be used to summarize the machine. After the <code>killed</code> observation is posted, the machine (not the system) enters the machine stopped phase in which observations and non-determinism are blocked (it is only possible to update the project data structure or record the information in the knowledge base).</p><dl><dt>since</dt><dd>2.1.0</dd></dl></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <a href="../index.html#type-system">system</a></code></dt><dd><p>the system definition</p></dd></dl><dl><dt class="spec type" id="type-component_specification"><a href="#type-component_specification" class="anchor"></a><code><span class="keyword">type</span> component_specification</code></dt><dd><p>designates some component</p></dd></dl><dl><dt class="spec type" id="type-system_specification"><a href="#type-system_specification" class="anchor"></a><code><span class="keyword">type</span> system_specification</code></dt><dd><p>designates a system</p></dd></dl><dl><dt class="spec value" id="val-define"><a href="#val-define" class="anchor"></a><code><span class="keyword">val</span> define : <span>?&#8288;desc:string</span> <span>&#45;&gt;</span> <span>?&#8288;depends_on:<span><a href="index.html#type-system_specification">system_specification</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;components:<span><a href="index.html#type-component_specification">component_specification</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>define name</code> defines a new system.</p><p>The system designator is built from <code>package</code> and <code>name</code> and could be used to reference this system from the user interface. The designator is not required to be unique and is not registered anywhere in the library.</p><dl><dt>parameter desc</dt><dd><p>a human-readable description of the system, its task and purposes</p></dd></dl><dl><dt>parameter components</dt><dd><p>a list of component specifications that this system includes.</p></dd></dl><dl><dt>parameter depends_on</dt><dd><p>a list of system specifications on which this system depends.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_component"><a href="#val-add_component" class="anchor"></a><code><span class="keyword">val</span> add_component : <span>?&#8288;package:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_component ?package system name</code> adds a component to the system.</p><p>Adds the component designated by the given package and name to the <code>system</code>.</p></dd></dl><dl><dt class="spec value" id="val-add_dependency"><a href="#val-add_dependency" class="anchor"></a><code><span class="keyword">val</span> add_dependency : <span>?&#8288;package:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>add_dependency ?package system name</code> adds the designated system to the list of the <code>system</code> depenencies.</p><p>Essentially, all components of the dependency are added to the dependent system.</p></dd></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span>?&#8288;envp:<span>string array</span></span> <span>&#45;&gt;</span> <span>?&#8288;args:<span>string array</span></span> <span>&#45;&gt;</span> <span>?&#8288;init:<span>unit <a href="../Machine/Make/index.html#type-t">Machine.Make(Bap_knowledge.Knowledge).t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;fini:<span>unit <a href="../Machine/Make/index.html#type-t">Machine.Make(Bap_knowledge.Knowledge).t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;start:<span>unit <a href="../Machine/Make/index.html#type-t">Machine.Make(Bap_knowledge.Knowledge).t</a></span></span> <span>&#45;&gt;</span> <a href="../index.html#type-system">system</a> <span>&#45;&gt;</span> <a href="../../../../../bap/Bap/Std/index.html#type-project">Bap.Std.project</a> <span>&#45;&gt;</span> <a href="../../../../../bap-knowledge/Bap_knowledge/Knowledge/index.html#type-state">Bap_knowledge.Knowledge.state</a> <span>&#45;&gt;</span> <span><span>(<a href="../index.html#type-exit_status">exit_status</a> * <a href="../../../../../bap/Bap/Std/index.html#type-project">Bap.Std.project</a> * <a href="../../../../../bap-knowledge/Bap_knowledge/Knowledge/index.html#type-state">Bap_knowledge.Knowledge.state</a>,Â <a href="../../../../../bap-knowledge/Bap_knowledge/Knowledge/index.html#type-conflict">Bap_knowledge.Knowledge.conflict</a>)</span> <a href="../../../../../core_kernel/Core_kernel/index.html#type-result">Core_kernel.result</a></span></code></dt><dd><p><code>run system project state</code> runs the analysis defined by <code>system</code>.</p><p>Initializes all components and triggers the <code>init</code> observation after that. Once the observation is processed runs the <code>fini</code> event.</p><p>The components that comprise the <code>system</code> must schedule their evaluation on one of the observations.</p><p>The <code>project</code> and <code>state</code> are passed as the initial static representation of the program and the initial knowledge. The result of the analysis is either a failure that indicates a conflicting knowledge or a success that includes an updated program representation, computation exit status, and possibly extend knowledge.</p><p>See the <code>Job.run</code> function if you want to run Primus instances in a batch mode.</p><dl><dt>parameter envp</dt><dd><p>an array of environment variables that are passed to the program.</p></dd></dl><dl><dt>parameter args</dt><dd><p>an array of program parameters, with the first element of array being the program name.</p></dd></dl><dl><dt>parameter init</dt><dd><p>is called after all components are initialized but before the <code>init</code> observations is made.</p></dd></dl><dl><dt>parameter start</dt><dd><p>is called after the the system is started (after the <code>system-start</code> observation is made).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>unit <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>init ()</code> is posted when all components finished their initializations. It is not posted if components failed to initialize the system.</p></dd></dl><dl><dt class="spec value" id="val-start"><a href="#val-start" class="anchor"></a><code><span class="keyword">val</span> start : <span>string <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>start sys</code> occurs after the system <code>sys</code> starts.</p></dd></dl><dl><dt class="spec value" id="val-fini"><a href="#val-fini" class="anchor"></a><code><span class="keyword">val</span> fini : <span>unit <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>fini ()</code> is posted when all computations are finished. This observation is posted only if <code>init</code> was posted and successfully evaluated all observers.</p><p>I.e., if the system wasn't initialized then neither <code>init</code> nor <code>fini</code> will happen.</p></dd></dl><dl><dt class="spec value" id="val-stop"><a href="#val-stop" class="anchor"></a><code><span class="keyword">val</span> stop : <span>string <a href="../index.html#type-observation">observation</a></span></code></dt><dd><p><code>stop sys</code> occurs when the system stops. The observation handlers are called in the restricted mode (with non-determinism and observations disabled).</p><p>This observation could be used to summarize the run of the system.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <a href="../index.html#type-system">system</a> <span>&#45;&gt;</span> <a href="../../../../../bap-knowledge/Bap_knowledge/Knowledge/Name/index.html#type-t">Bap_knowledge.Knowledge.Name.t</a></code></dt><dd><p><code>name system</code> is the system designator.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="../index.html#type-system">system</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>prints the system definition.</p></dd></dl><dl><dt class="spec value" id="val-component"><a href="#val-component" class="anchor"></a><code><span class="keyword">val</span> component : <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-component_specification">component_specification</a></code></dt><dd><p><code>component ?package name</code> specifies the component with the given designator.</p><dl><dt>parameter package</dt><dd><p>defaults to <code>user</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-depends_on"><a href="#val-depends_on" class="anchor"></a><code><span class="keyword">val</span> depends_on : <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-system_specification">system_specification</a></code></dt><dd><p><code>depends_on ?package name</code> specifies a dependency on a system with the given designator.</p></dd></dl><dl><dt class="spec type" id="type-parse_error"><a href="#type-parse_error" class="anchor"></a><code><span class="keyword">type</span> parse_error</code></dt><dd><p>a parsing error description</p></dd></dl><dl><dt class="spec value" id="val-from_file"><a href="#val-from_file" class="anchor"></a><code><span class="keyword">val</span> from_file : string <span>&#45;&gt;</span> <span><span>(<span><a href="../index.html#type-system">system</a> list</span>,Â <a href="index.html#type-parse_error">parse_error</a>)</span> <a href="../../../../../core_kernel/Core_kernel/index.html#type-result">Core_kernel.result</a></span></code></dt><dd><p><code>from_file name</code> parses a list of system descriptions from the file with the given <code>name</code>.</p><p>The file should have the following format (closely follows Common Lisp's asdf format)</p><pre>             systems ::= &lt;system-definition&gt; ...
             system-definition ::= (defsystem &lt;ident&gt; &lt;option&gt; ...)
             option ::=
               | :description &lt;string&gt;
               | :components (&lt;ident&gt; ...)
               | :depends-on (&lt;ident&gt; ...)</pre><p>The <code>primus-systems</code> plugin will search and load system definition files, see <code>bap --primus-systems-help</code> for more information.</p></dd></dl><dl><dt class="spec value" id="val-pp_parse_error"><a href="#val-pp_parse_error" class="anchor"></a><code><span class="keyword">val</span> pp_parse_error : <a href="../../../../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-parse_error">parse_error</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>prints the parse error</p></dd></dl><dl><dt class="spec module" id="module-Generic"><a href="#module-Generic" class="anchor"></a><code><span class="keyword">module</span> <a href="Generic/index.html">Generic</a> : <span class="keyword">functor</span> (<a href="Generic/argument-1-Machine/index.html">Machine</a> : <a href="../Machine/index.html#module-type-S">Machine.S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Repository"><a href="#module-Repository" class="anchor"></a><code><span class="keyword">module</span> <a href="Repository/index.html">Repository</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The systems repository.</p></dd></dl></section></section></div></body></html>