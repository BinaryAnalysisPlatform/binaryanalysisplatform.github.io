<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (bap-primus.Bap_primus.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap-primus</a> &#x00BB; <a href="../index.html">Bap_primus</a> &#x00BB; Std</nav><h1>Module <code>Bap_primus.Std</code></h1><nav class="toc"><ul><li><a href="#the-primus-framework">The Primus Framework</a><ul><li><a href="#overview">Overview</a></li><li><a href="#observations">Observations</a></li><li><a href="#non-determinism">Non-determinism</a></li><li><a href="#components-and-systems">Components and Systems</a></li><li><a href="#running-the-machine">Running the Machine</a></li></ul></li></ul></nav></header><section><header><h2 id="the-primus-framework"><a href="#the-primus-framework" class="anchor"></a>The Primus Framework</h2></header><section><header><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>Primus is a microexecution framework that can be used to implement CPU and full system emulators, symbolic executors, static fuzzers, policy checkers, tracers, quickcheck-like test suites, and other analyses that rely on program evaluation.</p><p>The core of Primus is the <a href="Primus/Machine/Make/index.html"><span>Primus Machine</span></a> monad transformer that implements the observable non-deterministic computation. The core functionality is extended by libraries and components. A Primus library doesn't change the behavior of the Primus Machine, but it extends the set of operations available to components and other libraries. The core libraries are:</p><ul><li><a href="Primus/Env/index.html"><code>Primus.Env</code></a> - provides a mapping from variables to values</li><li><a href="Primus/Memory/index.html"><code>Primus.Memory</code></a> - provides a mapping from memory locations to values;</li><li><a href="Primus/Linker/index.html"><code>Primus.Linker</code></a> - provides a mapping from program labels to code;</li><li><a href="Primus/Interpreter/index.html"><code>Primus.Interpreter</code></a> - interprets programs in BAP IR;</li><li><a href="Primus/Lisp/index.html"><code>Primus.Lisp</code></a> - provides the Primus Lisp interpreter.</li></ul><p>The behavior of the Primus Machine is defined by the components that comprise that machine. A particular build of the Machine is called a <i>system</i>. A system could be seen as an Primus application and as an application it could be run.</p><p>To summarize, components use libraries to implement analysis, that is as a system and could be run to obtain the results of the analysis or to observe its side-effects.</p><p>The next few sections will elaborate on certain features of the Primus framework.</p></header></section><section><header><h3 id="observations"><a href="#observations" class="anchor"></a>Observations</h3><p>An important part of the Primus Machine computational model is that it is extensible through the user callbacks. The callbacks are inserted at predefined extension points, called <i>observations</i>. Observations are made during a computation, e.g., when an Interperter evaluates a binary operation it posts an observation, that includes the operation operands and the computed value. All parties interested in this observation are invoked and they then can change the state of the machine using other machine operations, post their own observations, and, in general can do anything that the Primus Machine allows, since an observer callback is a Primus Machine computation.</p><p>To list all known observations use the <code>bap primus-observations</code> command or use the <a href="Primus/Observation/index.html#val-list"><code>Primus.Observation.list</code></a> function.</p></header></section><section><header><h3 id="non-determinism"><a href="#non-determinism" class="anchor"></a>Non-determinism</h3><p>Primus implements a non-deterministic computaion model (here non-deterministic is used in a sense of the non-deterministic Turning Machine, when on each step of execution the computation can have more than one outcome). Non-determinism in Primus is implemented by forking the Machine on each non-deterministic computation, so that each machine observes the world deterministically.</p><p>Two non-deterministic operations are provided: <a href="Primus/Machine/Make/index.html#val-fork"><span>fork</span></a> that creates a clone of the current machine and its state but with different identifier and <a href="Primus/Machine/Make/index.html#val-switch"><span>switch</span></a> that switches between machines.</p><p>At any point of time there could be many forks of the machine, but only one will be active. A component that is responsible for selecting a machine fork that is currently active is called <i>scheduler</i>. Since there are few different scheduling strategies avaiable, there are also a few schedulers.</p></header></section><section><header><h3 id="components-and-systems"><a href="#components-and-systems" class="anchor"></a>Components and Systems</h3><p>Components are the main building blocks of the Primus machine. Components subscribe to the observations provided by Primus libraries and other components. The attached callbacks changes the behavior of the Machine thusaffecting its semantics. A particular composition of components is called a <i>system</i>. Therefore a system is a Primus application that could be run. The Primus Framework provides an extenisble repository of Primus systems and components, that could be queried using <code>bap primus-systems</code> and <code>bap primus-components</code> commmands.</p><p>A new system could be easily defined in a file with the <code>.asd</code> extension using a simple system definition language (inspired by the Common Lisp ASDF language). When that file is put in the system search directory (or in the current working directory of the process that runs the Primus Framework) it will be added automatically to the systems repository. It is also possible to define and register a system programmatically, using the <a href="Primus/System/index.html"><code>Primus.System</code></a> interface.</p><p>A new component could be added to the components repository using <a href="Primus/Components/index.html#val-register"><code>Primus.Components.register</code></a> or <a href="Primus/Components/index.html#val-register_generic"><code>Primus.Components.register_generic</code></a>. The main difference between regular components (also called <i>analyses</i>) and generic components is that the latter work with any instantiation of the Primus Monad Transofmer (recall that Primus Machine is not a monad, but a monad transformer, i.e., it is a monad constructor that creates infinitely many Primus Machine monads) and the former works only with the <a href="Primus/Analysis/index.html"><code>Primus.Analysis</code></a> monad, which is a concrete instance of the Primus Machine monad parameterized with the Knowledge monad, i.e., <code>Primus.Machine.Make(Knowledge)</code>. A regular component is a Primus computation that also has full access to the <a href="../../../bap-knowledge/Bap_knowledge/Knowledge/index.html"><span>knowledge base</span></a>. A generic component is a functor that creates a computation, which can only access Primus Machine operations.</p><p>The legacy <a href="Primus/Machine/index.html#val-add_component"><code>Primus.Machine.add_component</code></a> interface is also provided to enable backward compatibility with the old way of defining the Primus machine in which there was only one system, <a href="Primus/Machine/Main/index.html"><code>Primus.Machine.Main</code></a> that was built using the <code>add_component</code> function and the system composition was defined by the command line parameters. This old style is fully supported (but deprecated) and the old main system is available under the <code>bap:legacy-main</code> name.</p></header></section><section><header><h3 id="running-the-machine"><a href="#running-the-machine" class="anchor"></a>Running the Machine</h3><p>To run the specified system, either use <a href="Primus/System/index.html#val-run"><code>Primus.System.run</code></a> to run it in the Knowledge monad or use <a href="Primus/System/Generic/index.html#val-run"><code>Primus.System.Generic.run</code></a> to run the Machine in the monad some other monad.</p><p>It is also possible to create a <a href="Primus/Job/index.html"><code>Primus.Job</code></a> and enqueue it in the Primus Jobs queue with the <a href="Primus/Jobs/index.html#val-enqueue"><code>Primus.Jobs.enqueue</code></a> function. This queue could be run either directly with <a href="Primus/Jobs/index.html#val-run"><code>Primus.Jobs.run</code></a> or using the <code>run</code> plugin.</p></header><dl><dt class="spec module" id="module-Primus"><a href="#module-Primus" class="anchor"></a><code><span class="keyword">module</span> <a href="Primus/index.html">Primus</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Primus Framework inteface.</p></dd></dl></section></section></div></body></html>