<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unbuffered (angstrom.Angstrom.Unbuffered)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">angstrom</a> &#x00BB; <a href="../index.html">Angstrom</a> &#x00BB; Unbuffered</nav><h1>Module <code>Angstrom.Unbuffered</code></h1><p>Unbuffered parsing interface.</p><p>Use this module for total control over memory allocation and copying. Parsers run through this module perform no internal buffering. Instead, the user is responsible for managing a buffer containing the entirety of the input that has yet to be consumed by the parser. The <a href="index.html#type-state.Partial"><code>Unbuffered.state.Partial</code></a> parser state reports to the user how much input the parser consumed during its last run, via the <a href="index.html#type-partial.committed"><code>Unbuffered.partial.committed</code></a> field. This area of input must be discarded before parsing can resume. Once additional input has been collected, the unconsumed input as well as new input must be passed to the parser state via the <a href="index.html#type-partial.continue"><code>Unbuffered.partial.continue</code></a> function, together with an indication of whether there is <a href="index.html#type-more"><code>Unbuffered.more</code></a> input to come.</p><p>The logic that must be implemented in order to make proper use of this module is intricate and tied to your OS environment. It's advisable to use the <a href="../Buffered/index.html"><code>Buffered</code></a> module when initially developing and testing your parsers. For production use-cases, consider the Async and Lwt support that this library includes before attempting to use this module directly.</p></header><dl><dt class="spec type" id="type-more"><a href="#type-more" class="anchor"></a><code><span class="keyword">type</span> more</code><code> = </code><table class="variant"><tr id="type-more.Complete" class="anchored"><td class="def constructor"><a href="#type-more.Complete" class="anchor"></a><code>| </code><code><span class="constructor">Complete</span></code></td></tr><tr id="type-more.Incomplete" class="anchored"><td class="def constructor"><a href="#type-more.Incomplete" class="anchor"></a><code>| </code><code><span class="constructor">Incomplete</span></code></td></tr></table></dt><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> <span>'a state</span></code><code> = </code><table class="variant"><tr id="type-state.Partial" class="anchored"><td class="def constructor"><a href="#type-state.Partial" class="anchor"></a><code>| </code><code><span class="constructor">Partial</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-partial">partial</a></span></code></td><td class="doc"><p>The parser requires more input.</p></td></tr><tr id="type-state.Done" class="anchored"><td class="def constructor"><a href="#type-state.Done" class="anchor"></a><code>| </code><code><span class="constructor">Done</span> <span class="keyword">of</span> int * <span class="type-var">'a</span></code></td><td class="doc"><p>The parser succeeded, consuming specified bytes.</p></td></tr><tr id="type-state.Fail" class="anchored"><td class="def constructor"><a href="#type-state.Fail" class="anchor"></a><code>| </code><code><span class="constructor">Fail</span> <span class="keyword">of</span> int * <span>string list</span> * string</code></td><td class="doc"><p>The parser failed, consuming specified bytes.</p></td></tr></table></dt><dt class="spec type" id="type-partial"><a href="#type-partial" class="anchor"></a><code><span class="keyword">and</span> <span>'a partial</span></code><code> = </code><code>{</code><table class="record"><tr id="type-partial.committed" class="anchored"><td class="def field"><a href="#type-partial.committed" class="anchor"></a><code>committed : int;</code></td><td class="doc"><p>The number of bytes committed during the last input feeding. Callers must drop this number of bytes from the beginning of the input on subsequent calls. See <a href="../index.html#val-commit"><code>commit</code></a> for additional details.</p></td></tr><tr id="type-partial.continue" class="anchored"><td class="def field"><a href="#type-partial.continue" class="anchor"></a><code>continue : <a href="../index.html#type-bigstring">bigstring</a> <span>&#45;&gt;</span> <span>off:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-more">more</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-state">state</a></span>;</code></td><td class="doc"><p>A continuation of a parse that requires additional input. The input should include all uncommitted input (as reported by previous partial states) in addition to any new input that has become available, as well as an indication of whether there is <a href="index.html#type-more"><code>more</code></a> input to come.</p></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-state">state</a></span></code></dt><dd><p><code>parse t</code> runs <code>t</code> and await input if needed.</p></dd></dl><dl><dt class="spec value" id="val-state_to_option"><a href="#val-state_to_option" class="anchor"></a><code><span class="keyword">val</span> state_to_option : <span><span class="type-var">'a</span> <a href="index.html#type-state">state</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt></dl><aside><p><code>state_to_option state</code> returns <code>Some v</code> if the parser is in the <code>Done (bs, v)</code> state and <code>None</code> otherwise. This function has no effect on the current state of the parser.</p></aside><dl><dt class="spec value" id="val-state_to_result"><a href="#val-state_to_result" class="anchor"></a><code><span class="keyword">val</span> state_to_result : <span><span class="type-var">'a</span> <a href="index.html#type-state">state</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, string)</span> <a href="../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></code></dt><dd><p><code>state_to_result state</code> returns <code>Ok v</code> if the parser is in the <code>Done (bs, v)</code> state and <code>Error msg</code> if it is in the <code>Fail</code> or <code>Partial</code> state.</p><p>This function has no effect on the current state of the parser.</p></dd></dl></div></body></html>