<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base__Binary_search (base.Base__Binary_search)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">base</a> &#x00BB; Base__Binary_search</nav><h1>Module <code>Base__Binary_search</code></h1><p>General functions for performing binary searches over ordered sequences given <code>length</code> and <code>get</code> functions.</p><p>These functions can be specialized and added to a data structure using the functors supplied in <a href="../Base/Binary_searchable/index.html"><span><code>Binary_searchable</code></span></a> and described in <span class="xref-unresolved" title="unresolved reference to &quot;Base.Binary_searchable_intf&quot;"><span><code>Binary_searchable_intf</code></span></span>.</p><h3 id="examples"><a href="#examples" class="anchor"></a>Examples</h3><p>Below we assume that the functions <code>get</code>, <code>length</code> and <code>compare</code> are in scope:</p><pre><code class="ml">(* Find the index of an element [e] in [t] *)
binary_search t ~get ~length ~compare `First_equal_to e;

(* Find the index where an element [e] should be inserted *)
binary_search t ~get ~length ~compare `First_greater_than_or_equal_to e;

(* Find the index in [t] where all elements to the left are less than [e] *)
binary_search_segmented t ~get ~length ~segment_of:(fun e' -&gt;
  if compare e' e &lt;= 0 then `Left else `Right) `First_on_right</code></pre></header><dl><dt class="spec value" id="val-binary_search"><a href="#val-binary_search" class="anchor"></a><code><span class="keyword">val</span> binary_search : <span>?&#8288;pos:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> <span>length:<span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>get:<span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'elt</span>)</span></span> <span>&#45;&gt;</span> <span>compare:<span>(<span class="type-var">'elt</span> <span>&#45;&gt;</span> <span class="type-var">'key</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>[ `Last_strictly_less_than <span>| `Last_less_than_or_equal_to</span> <span>| `Last_equal_to</span> <span>| `First_equal_to</span> <span>| `First_greater_than_or_equal_to</span> <span>| `First_strictly_greater_than</span> ]</span> <span>&#45;&gt;</span> <span class="type-var">'key</span> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>binary_search ?pos ?len t ~length ~get ~compare which elt</code> takes <code>t</code> that is sorted in increasing order according to <code>compare</code>, where <code>compare</code> and <code>elt</code> divide <code>t</code> into three (possibly empty) segments:</p><pre>      |  &lt; elt  |  = elt  |  &gt; elt  |</pre><p><code>binary_search</code> returns the index in <code>t</code> of an element on the boundary of segments as specified by <code>which</code>. See the diagram below next to the <code>which</code> variants.</p><p>By default, <code>binary_search</code> searches the entire <code>t</code>. One can supply <code>?pos</code> or <code>?len</code> to search a slice of <code>t</code>.</p><p><code>binary_search</code> does not check that <code>compare</code> orders <code>t</code>, and behavior is unspecified if <code>compare</code> doesn't order <code>t</code>. Behavior is also unspecified if <code>compare</code> mutates <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-binary_search_segmented"><a href="#val-binary_search_segmented" class="anchor"></a><code><span class="keyword">val</span> binary_search_segmented : <span>?&#8288;pos:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> <span>length:<span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>get:<span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'elt</span>)</span></span> <span>&#45;&gt;</span> <span>segment_of:<span>(<span class="type-var">'elt</span> <span>&#45;&gt;</span> <span>[ `Left <span>| `Right</span> ]</span>)</span></span> <span>&#45;&gt;</span> <span>[ `Last_on_left <span>| `First_on_right</span> ]</span> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>binary_search_segmented ?pos ?len t ~length ~get ~segment_of which</code> takes a <code>segment_of</code> function that divides <code>t</code> into two (possibly empty) segments:</p><pre>      | segment_of elt = `Left | segment_of elt = `Right |</pre><p><code>binary_search_segmented</code> returns the index of the element on the boundary of the segments as specified by <code>which</code>: <code>`Last_on_left</code> yields the index of the last element of the left segment, while <code>`First_on_right</code> yields the index of the first element of the right segment. It returns <code>None</code> if the segment is empty.</p><p>By default, <code>binary_search</code> searches the entire <code>t</code>. One can supply <code>?pos</code> or <code>?len</code> to search a slice of <code>t</code>.</p><p><code>binary_search_segmented</code> does not check that <code>segment_of</code> segments <code>t</code> as in the diagram, and behavior is unspecified if <code>segment_of</code> doesn't segment <code>t</code>. Behavior is also unspecified if <code>segment_of</code> mutates <code>t</code>.</p></dd></dl></div></body></html>