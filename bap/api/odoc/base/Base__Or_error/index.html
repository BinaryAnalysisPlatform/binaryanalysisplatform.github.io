<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Base__Or_error (base.Base__Or_error)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">base</a> &#x00BB; Base__Or_error</nav><h1>Module <code>Base__Or_error</code></h1><p>Type for tracking errors in an <code>Error.t</code>. This is a specialization of the <code>Result</code> type, where the <code>Error</code> constructor carries an <code>Error.t</code>.</p><p>A common idiom is to wrap a function that is not implemented on all platforms, e.g.,</p><pre><code class="ml">val do_something_linux_specific : (unit -&gt; unit) Or_error.t</code></pre></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span>(<span class="type-var">'a</span>, <a href="../Base/Error/index.html#type-t">Base.Error.t</a>)</span> <a href="../Base/Result/index.html#type-t">Base.Result.t</a></span></code></dt><dd><p>Serialization and comparison of an <code>Error</code> force the error's lazy message.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-hash_fold_t"><a href="#val-hash_fold_t" class="anchor"></a><code><span class="keyword">val</span> hash_fold_t : <span>(<a href="../Base/Hash/index.html#type-state">Base.Hash.state</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Base/Hash/index.html#type-state">Base.Hash.state</a>)</span> <span>&#45;&gt;</span> <a href="../Base/Hash/index.html#type-state">Base.Hash.state</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Base/Hash/index.html#type-state">Base.Hash.state</a></code></dt><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val</span> t_of_sexp : <span>(<a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><p><code>Applicative</code> functions don't have quite the same semantics as <code>Applicative.of_Monad(Or_error)</code> would give -- <code>apply (Error e1) (Error e2)</code> returns the combination of <code>e1</code> and <code>e2</code>, whereas it would only return <code>e1</code> if it were defined using <code>bind</code>.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Base/Applicative/index.html#module-type-S">Base.Applicative.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base/Applicative/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">val</span> map3 : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val</span> all_ignore : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-both"><a href="#val-both" class="anchor"></a><code><span class="keyword">val</span> both : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt></dl><div class="spec module" id="module-Applicative_infix"><a href="#module-Applicative_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Applicative_infix/index.html">Applicative_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="index.html#module-Applicative_infix">Applicative_infix</a></code></span></summary><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>same as <code>apply</code></p></dd></dl><dl><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-(*&gt;)"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span>unit <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt></dl></details></div></div></div></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Base/Invariant/index.html#module-type-S1">Base.Invariant.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base/Invariant/module-type-S1/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-invariant"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <span><span class="type-var">'a</span> <a href="../Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="../Base__/Invariant_intf/index.html#type-inv">Base__.Invariant_intf.inv</a></span></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Base/Monad/index.html#module-type-S">Base.Monad.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base/Monad/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Base__/Monad_intf/index.html#module-type-S_without_syntax">Base__.Monad_intf.S_without_syntax</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base__/Monad_intf/module-type-S_without_syntax/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Base__/Monad_intf/index.html#module-type-Infix">Base__.Monad_intf.Infix</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base__/Monad_intf/module-type-Infix/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;|)"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></dd></dl></details></div></div></div><div class="spec module" id="module-Monad_infix"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <a href="../Base__/Monad_intf/index.html#module-type-Infix">Base__.Monad_intf.Infix</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base__/Monad_intf/module-type-Infix/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><dl><dt class="spec value" id="val-bind"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return v</code> returns the (trivial) computation that returns v.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map t ~f</code> is t &gt;&gt;| f.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></dd></dl><dl><dt class="spec value" id="val-ignore_m"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Pervasives.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all_unit"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-all_ignore"><a href="#val-all_ignore" class="anchor"></a><code><span class="keyword">val</span> all_ignore : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../Base__/Monad_intf/index.html#module-type-Syntax">Base__.Monad_intf.Syntax</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base__/Monad_intf/module-type-Syntax/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><div class="spec module" id="module-Let_syntax"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div></details></div></div></div><div class="spec module" id="module-Ok"><a href="#module-Ok" class="anchor"></a><code><span class="keyword">module</span> <a href="Ok/index.html">Ok</a> : <a href="../Base/Container/index.html#module-type-S1">Base.Container.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../Base/Container/module-type-S1/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><dl><dt class="spec value" id="val-is_ok"><a href="#val-is_ok" class="anchor"></a><code><span class="keyword">val</span> is_ok : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_error"><a href="#val-is_error" class="anchor"></a><code><span class="keyword">val</span> is_error : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-ignore"><a href="#val-ignore" class="anchor"></a><code><span class="keyword">val</span> ignore : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-try_with"><a href="#val-try_with" class="anchor"></a><code><span class="keyword">val</span> try_with : <span>?&#8288;backtrace:bool</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>try_with f</code> catches exceptions thrown by <code>f</code> and returns them in the <code>Result.t</code> as an <code>Error.t</code>. <code>try_with_join</code> is like <code>try_with</code>, except that <code>f</code> can throw exceptions or return an <code>Error</code> directly, without ending up with a nested error; it is equivalent to <code>Result.join (try_with f)</code>.</p></dd></dl><dl><dt class="spec value" id="val-try_with_join"><a href="#val-try_with_join" class="anchor"></a><code><span class="keyword">val</span> try_with_join : <span>?&#8288;backtrace:bool</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-ok"><a href="#val-ok" class="anchor"></a><code><span class="keyword">val</span> ok : <span><span class="type-var">'ok</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'ok</span> option</span></code></dt><dd><p><code>ok t</code> returns <code>None</code> if <code>t</code> is an <code>Error</code>, and otherwise returns the contents of the <code>Ok</code> constructor.</p></dd></dl><dl><dt class="spec value" id="val-ok_exn"><a href="#val-ok_exn" class="anchor"></a><code><span class="keyword">val</span> ok_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>ok_exn t</code> throws an exception if <code>t</code> is an <code>Error</code>, and otherwise returns the contents of the <code>Ok</code> constructor.</p></dd></dl><dl><dt class="spec value" id="val-of_exn"><a href="#val-of_exn" class="anchor"></a><code><span class="keyword">val</span> of_exn : <span>?&#8288;backtrace:<span>[ `Get <span><span>| `This</span> of string</span> ]</span></span> <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_exn exn</code> is <code>Error (Error.of_exn exn)</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_exn_result"><a href="#val-of_exn_result" class="anchor"></a><code><span class="keyword">val</span> of_exn_result : <span><span>(<span class="type-var">'a</span>, exn)</span> <a href="../Base/Result/index.html#type-t">Base.Result.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_exn_result (Ok a) = Ok a</code>, <code>of_exn_result (Error exn) = of_exn exn</code></p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">val</span> error : <span>?&#8288;strict:unit</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>error</code> is a wrapper around <code>Error.create</code>:</p><pre><code class="ml">error ?strict message a sexp_of_a
= Error (Error.create ?strict message a sexp_of_a)</code></pre><p>As with <code>Error.create</code>, <code>sexp_of_a a</code> is lazily computed when the info is converted to a sexp. So, if <code>a</code> is mutated in the time between the call to <code>create</code> and the sexp conversion, those mutations will be reflected in the sexp. Use <code>~strict:()</code> to force <code>sexp_of_a a</code> to be computed immediately.</p></dd></dl><dl><dt class="spec value" id="val-error_s"><a href="#val-error_s" class="anchor"></a><code><span class="keyword">val</span> error_s : <a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-error_string"><a href="#val-error_string" class="anchor"></a><code><span class="keyword">val</span> error_string : string <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>error_string message</code> is <code>Error (Error.of_string message)</code>.</p></dd></dl><dl><dt class="spec value" id="val-errorf"><a href="#val-errorf" class="anchor"></a><code><span class="keyword">val</span> errorf : <span><span>(<span class="type-var">'a</span>, unit, string, <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span>)</span> <a href="../../ocaml/Stdlib/index.html#type-format4">Stdlib.format4</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>errorf format arg1 arg2 ...</code> is <code>Error (sprintf format arg1 arg2 ...)</code>. Note that it calculates the string eagerly, so when performance matters you may want to use <code>error</code> instead.</p></dd></dl><dl><dt class="spec value" id="val-tag"><a href="#val-tag" class="anchor"></a><code><span class="keyword">val</span> tag : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>tag:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>tag t ~tag</code> is <code>Result.map_error t ~f:(Error.tag ~tag)</code>. <code>tag_arg</code> is similar.</p></dd></dl><dl><dt class="spec value" id="val-tag_arg"><a href="#val-tag_arg" class="anchor"></a><code><span class="keyword">val</span> tag_arg : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <a href="../Base/Sexp/index.html#type-t">Base.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-unimplemented"><a href="#val-unimplemented" class="anchor"></a><code><span class="keyword">val</span> unimplemented : string <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>For marking a given value as unimplemented. Typically combined with conditional compilation, where on some platforms the function is defined normally, and on some platforms it is defined as unimplemented. The supplied string should be the name of the function that is unimplemented.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter_error"><a href="#val-iter_error" class="anchor"></a><code><span class="keyword">val</span> iter_error : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<a href="../Base/Error/index.html#type-t">Base.Error.t</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-combine_errors"><a href="#val-combine_errors" class="anchor"></a><code><span class="keyword">val</span> combine_errors : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>combine_errors ts</code> returns <code>Ok</code> if every element in <code>ts</code> is <code>Ok</code>, else it returns <code>Error</code> with all the errors in <code>ts</code>. More precisely:</p><ul><li><code>combine_errors [Ok a1; ...; Ok an] = Ok [a1; ...; an]</code></li><li><pre><code class="ml">combine_errors [...; Error e1; ...; Error en; ...]
= Error (Error.of_list [e1; ...; en]) </code></pre></li></ul></dd></dl><dl><dt class="spec value" id="val-combine_errors_unit"><a href="#val-combine_errors_unit" class="anchor"></a><code><span class="keyword">val</span> combine_errors_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>combine_errors_unit ts</code> returns <code>Ok</code> if every element in <code>ts</code> is <code>Ok ()</code>, else it returns <code>Error</code> with all the errors in <code>ts</code>, like <code>combine_errors</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter_ok_at_least_one"><a href="#val-filter_ok_at_least_one" class="anchor"></a><code><span class="keyword">val</span> filter_ok_at_least_one : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_ok_at_least_one ts</code> returns all values in <code>ts</code> that are <code>Ok</code> if there is at least one, otherwise it returns the same error as <code>combine_errors ts</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_ok"><a href="#val-find_ok" class="anchor"></a><code><span class="keyword">val</span> find_ok : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>find_ok ts</code> returns the first value in <code>ts</code> that is <code>Ok</code>, otherwise it returns the same error as <code>combine_errors ts</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_map_ok"><a href="#val-find_map_ok" class="anchor"></a><code><span class="keyword">val</span> find_map_ok : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>find_map_ok l ~f</code> returns the first value in <code>l</code> for which <code>f</code> returns <code>Ok</code>, otherwise it returns the same error as <code>combine_errors (List.map l ~f)</code>.</p></dd></dl></div></body></html>