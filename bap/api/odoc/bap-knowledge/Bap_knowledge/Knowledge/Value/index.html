<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Value (bap-knowledge.Bap_knowledge.Knowledge.Value)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap-knowledge</a> &#x00BB; <a href="../../index.html">Bap_knowledge</a> &#x00BB; <a href="../index.html">Knowledge</a> &#x00BB; Value</nav><h1>Module <code>Knowledge.Value</code></h1><p>Knowledge Values.</p><p>A value is a concrete representation of knowledge. It is a snapshot of all properties associated with some object, i.e., an ordered tuple of slots. The value has no identity and that differs it from the object, as the value is essentially a property of an object - not an object itself.</p><p>From another perspective, a value is an extensible record, with fields reified into first-class slots, the record type into the <code>cls</code> values, and an additional constraint that all field types must be an instance of the domain type class (i.e., have a default and an ordering).</p><p>Each value has a class. The class value itself is indexed with the class and sort indices. The first index denotes the set of properties that could be associated with the value. The second index further partitions values of that class into subsets, to so that domain specific relations between values could be expressed explicitly with the host language type system.</p><p>The value sort is an arbitrary value, which can also be used to store additional static information about the value, i.e., the information that is common to all instances of the sort.</p><h4 id="total-ordering-and-age"><a href="#total-ordering-and-age" class="anchor"></a>Total ordering and age</h4><p>In addition to be partially ordered by their information content, values are also totally ordered, so that they could be organized into finite sets and maps.</p><p>The total order is induced from the information order, so that if a value <code>x</code> is ordered before <code>y</code> in the information order, then it will be also ordered before <code>y</code> in the total order. And if <code>x</code> and <code>y</code> have the same information content, then they are considered equal. Values with non-comparable information content are ordered by their time-stamp.</p><p>Every time a new value created it is assigned a time-stamp. A new value is created by all functions that has <code>'a value</code> return type, except the <code>refine</code> function. Each time-stamp is unique and no two values could have the same time-stamps unless they are physically the same, or are de-serializations of the same value, or are refinements of the same value. In other words, values with equal time-stamps are guaranteed to bear the same information.</p><p>Time-stamp values correlate with the order of evaluation. A value that was evaluated more recently will have a higher time-stamp. Therefore time-stamps define an age of a value. A value which has a smaller time-stamp is younger than a value that has a larger time-stamp.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span></code></dt><dt class="spec type" id="type-ord"><a href="#type-ord" class="anchor"></a><code><span class="keyword">type</span> <span>'a ord</span></code></dt><dd><p>a witness of the ordering</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Core_kernel.Type_equal.Injective <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../index.html#module-Value">Value</a>.t</span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec value" id="val-strip"><a href="#val-strip" class="anchor"></a><code><span class="keyword">val</span> strip : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>, <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> Core_kernel.Type_equal.equal</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> Core_kernel.Type_equal.equal</span></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-cls">cls</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span></code></dt><dd><p><code>empty cls</code> the empty value of class <code>cls</code>.</p><p>The empty value has the least information content, i.e., all slots are empty.</p></dd></dl><dl><dt class="spec value" id="val-order"><a href="#val-order" class="anchor"></a><code><span class="keyword">val</span> order : <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <a href="../Order/index.html#type-partial">Order.partial</a></code></dt><dd><p><code>order x y</code> orders <code>x</code> and <code>y</code> by their information content.</p></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span>, <a href="../index.html#type-conflict">conflict</a>)</span> Core_kernel.result</span></code></dt><dd><p><code>join x y</code> joins pairwise all slots of <code>x</code> and <code>y</code>.</p><p>Each slot of <code>x</code> and <code>y</code> are joined using the <code>Domain.join</code> function. The result is either a pairwise join or a conflict if any of the joins ended up with a conflict.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span>?&#8288;on_conflict:<span>[ `drop_old <span>| `drop_new</span> <span>| `drop_right</span> <span>| `drop_left</span> ]</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span></code></dt><dd><p><code>merge x y</code> joins <code>x</code> and <code>y</code> and resolves conflicts.</p><p>Performs a pairwise join of <code>x</code> and <code>y</code> and in case if any of the joins yields a conflict uses the provided strategy to resolve it.</p><dl><dt>parameter on_conflict</dt><dd><p>specifies the conflict resolution strategy (see below). Defaults to <code>`drop_old</code></p><p>Conflict resolution strategies</p><p>The following conflict resolution strategies are currently supported (more strategies could be added later):</p><ul><li><code>`drop_old</code> a conflicting property of an older object is ignored (an object is older if its time-stamp is less than or equal the time-stamp of other object);</li><li><code>`drop_new</code> a conflicting property of the newer object is ignored (an object is newer if its time-stamp is greater than or equal the time-stamp of other object);</li><li><code>`drop_right</code> a conflicting property of <code>y</code> is ignored;</li><li><code>`drop_left</code> a conflicting property of <code>x</code> is ignored.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-cls"><a href="#val-cls" class="anchor"></a><code><span class="keyword">val</span> cls : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span></code></dt><dd><p><code>cls x</code> is the class of <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <span><span>(<span class="type-var">'k</span>, <span class="type-var">'p</span>)</span> <a href="../index.html#type-slot">slot</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span class="type-var">'p</span></code></dt><dd><p><code>get p v</code> gets a value of the property <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-put"><a href="#val-put" class="anchor"></a><code><span class="keyword">val</span> put : <span><span>(<span class="type-var">'k</span>, <span class="type-var">'p</span>)</span> <a href="../index.html#type-slot">slot</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span class="type-var">'p</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span></code></dt><dd><p><code>put p v x</code> sets a value of the property <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-refine"><a href="#val-refine" class="anchor"></a><code><span class="keyword">val</span> refine : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="../index.html#type-value">value</a></span></code></dt><dd><p><code>refine v s</code> refines the sort of <code>v</code> to <code>s</code>.</p><p>Since, this function doesn't change the information stored in the value, the time-stamp of the returned value is the same, therefore <code>v = refine v s</code>.</p></dd></dl><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-derive"><a href="#val-derive" class="anchor"></a><code><span class="keyword">val</span> derive : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-type-S">S</a>.comparator_witness = <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="index.html#type-ord">ord</a></span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> = <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'s</span>)</span> <a href="../index.html#type-cls">cls</a></span> <a href="index.html#type-t">t</a></span>)</span></code></dt><dd><p><code>derive cls</code> derives the implementation of the <code>S</code> structure.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp ppf v</code> outputs <code>v</code> to the formatter <code>ppf</code>.</p><p>Prints all slots of the value <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-pp_slots"><a href="#val-pp_slots" class="anchor"></a><code><span class="keyword">val</span> pp_slots : <span>string list</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-value">value</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_slots slots ppf v</code> prints the specified set of slots.</p><p>Prints only slots that has a name in <code>slots</code>.</p></dd></dl></div></body></html>