<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rule (bap-knowledge.Bap_knowledge.Knowledge.Rule)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap-knowledge</a> &#x00BB; <a href="../../index.html">Bap_knowledge</a> &#x00BB; <a href="../index.html">Knowledge</a> &#x00BB; Rule</nav><h1>Module <code>Knowledge.Rule</code></h1><h4 id="rules"><a href="#rules" class="anchor"></a>Rules</h4><p>Rules are used for introspection and documentation. A rule is a specification of a promise and consists of the following parts</p><ul><li>a unique rule name,</li><li>an optional sequence of external dependencies,</li><li>an optional sequence of inputs,</li><li>the output,</li><li>the documentation string.</li></ul><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><p>Suppose, we have a system that describes personal information,</p><pre><code class="ml">type person
type address

val first_name : (person, string option) slot
val last_name : (person, string option) slot
val full_name : (person, string option) slot

val address : (person, address option) slot
val phone : (person, phone option) slot</code></pre><p>The simplest and obvious rule would a derivation of the full name from the first and last names. This derivation could be encoded as a promise. To make this promise visible and known to the users of the knowledge system we advertise it as a rule,</p><pre><code class="ml">Rule.(declare &quot;full-name&quot; |&gt;
      require first_name  |&gt;
      require last_name   |&gt;
      provide full_name   |&gt;
      comment &quot;full = first last&quot;);
promise full_name @@ fun person -&gt;
collect first_name &gt;&gt;=? fun first -&gt;
collect last_name &gt;&gt;|? fun last -&gt;
first ^ &quot; &quot; ^ last</code></pre><p>The rule above is a closed term, since it doesn't reference any language variables, i.e., it derives its output directly from the knowledge base. Such rules are called static as they are always available. Contrary, dynamic rules are provide external information to the knowledge system. For example, the following rule extracts the phone number of a person from the online database,</p><pre><code class="ml">let provide_phone_base =
  Rule.(declare &quot;lookup-phone-number&quot; |&gt;
        dynamic [&quot;phone-base&quot;] |&gt;
        require full_name |&gt;
        provide phone |&gt;
        comment &quot;lookups phone in the public database&quot;);
  fun base -&gt;
    promise phone @@ fun person -&gt;
    collect full_name &gt;&gt;| fun name -&gt;
    Phonebase.lookup base phone</code></pre><p>The <code>dynamic</code> operator of the specification accepts a list of formal parameters of the rule. In theory, this list could be empty. In that case, the rule will still be treated as dynamic.</p><p>Note, that in the example above, the rule declaration is not parametrized with the base. Otherwise, it will be only declared after the base is available. Moreover, each new application will create a new rule, which will end up in a runtime failure, since the rule name should be unique.</p><p>This module defines an domain-specific language for specifying rules. The <code>Documentation</code> and <code>Documentation.Rule</code> modules could be used to introspect all available rules.</p><dl><dt>since</dt><dd>2.2.0</dd></dl></header><dl><dt class="spec type" id="type-def"><a href="#type-def" class="anchor"></a><code><span class="keyword">type</span> def</code></dt><dd><p>a term of type <code>def</code> expects either</p><ul><li><code>|&gt; require &lt;slot&gt;</code>, or</li><li><code>|&gt; provide &lt;slot&gt;</code>.</li></ul></dd></dl><dl><dt class="spec type" id="type-doc"><a href="#type-doc" class="anchor"></a><code><span class="keyword">type</span> doc</code></dt><dd><p>a term of type <code>doc</code> expects <code>|&gt; comment &lt;doc&gt;</code>. This is the only way to finish a rule definition.</p></dd></dl><dl><dt class="spec value" id="val-declare"><a href="#val-declare" class="anchor"></a><code><span class="keyword">val</span> declare : <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-def">def</a></code></dt><dd><p><code>declare ?package name</code> starts a rule definition.</p><p>The rule definition should be followed by zero or more dependencies,</p><ul><li><code>|&gt; require &lt;slot&gt;</code>, zero or more dynamic parameters specifications,</li><li><code>|&gt; dynamic &lt;parameters&gt;</code>, exactly one output specification,</li><li><code>|&gt; provide &lt;slot&gt;</code>, and exactly one documentation string,</li><li><code>|&gt; comment &lt;comment&gt;</code></li></ul><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">declare &quot;rule-name&quot;   |&gt;
dynamic [&quot;parameter&quot;] |&gt;
require slot1         |&gt;
require slot2         |&gt;
provide slot3         |&gt;
comment &quot;example rule&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-dynamic"><a href="#val-dynamic" class="anchor"></a><code><span class="keyword">val</span> dynamic : <span>string list</span> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a></code></dt><dd><p><code>dynamic ps</code> declares that a rule is dynamic and lists formal parameters.</p></dd></dl><dl><dt class="spec value" id="val-require"><a href="#val-require" class="anchor"></a><code><span class="keyword">val</span> require : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-slot">slot</a></span> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a></code></dt><dd><p><code>require p</code> declares a dependency on the property <code>p</code>.</p><p>Note: This function enables introspection of the rules that are registered in the knowledge base. It doesn't affect the semantics in any way.</p></dd></dl><dl><dt class="spec value" id="val-provide"><a href="#val-provide" class="anchor"></a><code><span class="keyword">val</span> provide : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-slot">slot</a></span> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>provide p</code> declares that a rule computes the property <code>p</code></p></dd></dl><dl><dt class="spec value" id="val-comment"><a href="#val-comment" class="anchor"></a><code><span class="keyword">val</span> comment : string <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>comment text</code> provides a documentation for a rule.</p></dd></dl></div></body></html>