<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Symbol (bap-knowledge.Bap_knowledge.Knowledge.Symbol)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap-knowledge</a> &#x00BB; <a href="../../index.html">Bap_knowledge</a> &#x00BB; <a href="../index.html">Knowledge</a> &#x00BB; Symbol</nav><h1>Module <code>Knowledge.Symbol</code></h1><p>A symbol is an object with a unique name.</p><p>Sometimes it is necessary to refer to an object by name, so that a chosen name will always identify the same object. Finding or creating an object by name is called &quot;interning&quot; it. A symbol that has a name is called an &quot;interned symbol&quot;. However we stretch the boundaries of the symbol idea, by treating all other objects as &quot;uninterned symbols&quot;. So that any object could be treated as a symbol.</p><p>To prevent name clashing, that introduces unwanted equalities, we employ the system of packages, where each symbol belongs to a package, called its home package. The large system design is leveraged due to the mechanism of symbol importing, where the same symbol could be referenced from different packages (see <code>import</code> and <code>in_package</code> functions, for more information).</p><h4 id="symbol-syntax"><a href="#symbol-syntax" class="anchor"></a>Symbol syntax</h4><p>The <code>read</code> function enables translation of the symbol textual representation to an object. The symbol syntax is designed to be verstatile so it can allow arbitrary sets of characters, to enable support for modeling different knowledge domains. Only two characters has the special meaning for the symbol reader, the <code>:</code> character acts as a separator between the package and the name constituent, and the <code>\] symbol escapes any special
      treatment of a symbol that follows it (including the [\]
      itself). When a symbol is read, an absence of the package is
      treated the same as if the [package] parameter of the [create]
      function wasn't set, e.g.,
      [read c &quot;x&quot;] is the same as [create c &quot;x&quot;], while an empty package
      denotes the [keyword] package, e.g.,
      [read c &quot;:x&quot;] is the same as [create ~package:keyword c &quot;x&quot;].

      {3 Name equality}
      The equality of two names is defined by equality of their
      byte representation. Hence, symbols which differ in register
      will be treated differently, e.g., [Foo &lt;&gt; foo].
  </code></p></header><dl><dt class="spec value" id="val-intern"><a href="#val-intern" class="anchor"></a><code><span class="keyword">val</span> intern : <span>?&#8288;public:bool</span> <span>&#45;&gt;</span> <span>?&#8288;desc:string</span> <span>&#45;&gt;</span> <span>?&#8288;package:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="../index.html#type-cls">cls</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-obj">obj</a></span> <a href="../../index.html#type-knowledge">knowledge</a></span></code></dt><dd><p><code>intern ?public ?desc ?package name cls</code> interns a symbol in a package.</p><p>If a symbol with the given name is already interned in a package, then returns its value, otherwise creates a new object.</p><p>If symbol is <code>public</code> then it might be advertised and be accessible during the introspection. It is recommeneded to provide a description string if a symbol is public. Note, a non-public symbol still could be obtained by anyone who knows the name.</p><p>If the function is called in the scope of one or more <code>in_package pkg&lt;N&gt;</code>, then the <code>package</code> parameter defaults to <code>pkg</code>, otherwise it defaults to <code>&quot;user&quot;</code>. See also the <code>keyword</code> package for the special package that holds constants and keywords.</p><p>The <code>desc</code>, <code>package</code>, and <code>name</code> parameters could be arbitrary strings (including empty). Any occurence of the package separator symbol (<code>:</code>) will be escaped and won't be treated as a package/name separator.</p></dd></dl><dl><dt class="spec value" id="val-keyword"><a href="#val-keyword" class="anchor"></a><code><span class="keyword">val</span> keyword : string</code></dt><dd><p><code>keyword = &quot;keyword&quot;</code> is the special name for the package that contains keywords. Basically, keywords are special kinds of symbols whose meaning is defined by their names and nothing else.</p></dd></dl><dl><dt class="spec value" id="val-in_package"><a href="#val-in_package" class="anchor"></a><code><span class="keyword">val</span> in_package : string <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../index.html#type-knowledge">knowledge</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../index.html#type-knowledge">knowledge</a></span></code></dt><dd><p><code>in_package pkg f</code> makes <code>pkg</code> the default package in <code>f</code>.</p><p>Every reference to an unqualified symbol in the scope of the <code>f</code> function will be treated as it is qualified with the package <code>pkg</code>. This function will affect both the reader and the pretty printer, thus <code>in_package &quot;pkg&quot; @@ Obj.repr buf</code> will yield something like <code>#&lt;buf 123&gt;</code>, instead of <code>#&lt;pkg:buf 123&gt;</code>.</p></dd></dl><dl><dt class="spec value" id="val-import"><a href="#val-import" class="anchor"></a><code><span class="keyword">val</span> import : <span>?&#8288;strict:bool</span> <span>&#45;&gt;</span> <span>?&#8288;package:string</span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span>unit <a href="../../index.html#type-knowledge">knowledge</a></span></code></dt><dd><p><code>import ?strict ?package:p names</code> imports all <code>names</code> into <code>p</code>.</p><p>The <code>names</code> elements could be either package names or qualified names. If an element is a package, then all public names from this package are imported into the package <code>p</code>. If an element is a qualified symbol then it is imported into <code>p</code>, even if it is not public in the package from which it is being imported.</p><p>If any of the elements of the <code>names</code> list doesn't represent a known package or known symbol, then a conflict is raised, either <code>Not_a_package</code> or <code>Not_a_symbol</code>.</p><p>If <code>strict</code> is <code>true</code> then no name can change its value during the import. Otherwise, if the name is alredy in present in package <code>p</code> with a different value, then it will be overwritten with the new value, i.e., shadowed.</p><p>All names are processed in order, so names imported from packages that are in the beginning of the list could be shadowed by the names that are in the end of the list (unless <code>strict</code> is <code>true</code>, of course). Thus,</p><pre><code class="ml">import [x] &gt;&gt;= fun () -&gt;
import [y]</code></pre><p>is the same as <code>import [x;y]</code>.</p><p>Note, all imported names are added as not public.</p><p>If the <code>package</code> parameter is not specified, then names are imported into the current package, as set by the <code>in_package</code> function.</p></dd></dl></div></body></html>