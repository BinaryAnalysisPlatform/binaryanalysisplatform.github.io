<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Text_tags (text-tags.Text_tags)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">text-tags</a> &#x00BB; Text_tags</nav><h1>Module <code>Text_tags</code></h1><p>Controls tags in format strings.</p><p>This module provides facilities to control tags in the format strings. For simplicity and readability we're using sexp to define tags with attributes. See below for more information.</p><p>The default behavior is to ignore tags. You can switch between modes using <code>install</code> and <code>with_mode</code> function (the last one will restore previous state of the formatter).</p><p>Tags allows to literally tag pieces of text in format strings, the format of tagging can be explained with the following example:</p><p><code>&quot;@{&lt;html&gt; @{&lt;head&gt; @{&lt;title&gt; Tags!@}@}@{&lt;body&gt; Hello!@}@}&quot;</code></p><p>In html mode, this will produce a valid <code>HTML</code> document:</p><pre>      &lt;html&gt;
       &lt;head&gt;
        &lt;title&gt;
          Tags!
        &lt;/title&gt;
       &lt;/head&gt;
       &lt;body&gt;
         Hello!
       &lt;/body&gt;
      &lt;/html&gt;</pre><h3 id="none-mode"><a href="#none-mode" class="anchor"></a>none mode</h3><p>In this mode (the default one) the tags will be ignored, and they will have no effect on the final output.</p><h3 id="html-mode"><a href="#html-mode" class="anchor"></a>html mode</h3><p>If tag has attributes, then they should be passed as S-expressions, with the following grammar (EBNF):</p><pre>    tag = name | &quot;(&quot;, name, {arg}, &quot;)&quot;;
    arg = &quot;(&quot;, name, value, &quot;)&quot;.</pre><p>Where <code>name</code> is arbitrary html valid name without <code>&gt;</code> in it. The same is true for <code>value</code> with an addition of double quotes. If <code>value</code> start with double quotes it will be stored as is, otherwise it will be properly escaped and double quoted.</p><h4 id="implementation-details"><a href="#implementation-details" class="anchor"></a>Implementation details</h4><p>Tags in <code>Format</code> module are stringly typed, so we will use a trick, and encode them using s-expressions. Not very typesafe, but better than arbitrary string.</p><p>Example: <code>(a (href #) (id x))</code> will be converted to <code>&lt;a
    href=&quot;#&quot; id=&quot;x&quot;&gt;</code>. Note, that quotes will be inserted automatically, and special symbols will be escaped. If attribute value is quoted by itself, then it will be taken as is. If tag doesn't contain attributes, then it can be provided as an atom, e.g. <code>html</code>, but more verbose <code>(html)</code> is still accepted</p><h3 id="attr-mode"><a href="#attr-mode" class="anchor"></a>Attr mode</h3><p>In this mode the tag has the following syntax:</p><pre>tag = &quot;.&quot;, name, value, &quot;\n&quot;</pre><p>where name is a strings that must not contain whitespaces. (Usually we use dashes to separate words), and value is an arbitrary sequence of chars that must not contain the newline character.</p><p>The attributes will be printed as is, if the mode is enabled, and a name of the attribute is marked to be shown with <a href="Attr/index.html#val-show"><code>Attr.show</code></a> function (by default no attributes will be shown).</p><h4 id="colors"><a href="#colors" class="anchor"></a>Ansi color submode</h4><p>When <a href="Attr/index.html#val-print_colors"><code>Attr.print_colors</code></a> is set to <code>true</code>, the <code>foreground</code> and <code>background</code> attributes will be handled specially. The attribute value, that must be a valid ansi color escape sequence, will switch the foreground and background colors of the text, if the terminal allows it (otherwise ugly things will happen, that's why the attribute is ignored when color submode is disabled).</p><h3 id="blocks-mode"><a href="#blocks-mode" class="anchor"></a>Blocks mode</h3><p>The blocks mode grammar is very similar to html mode, as it also uses sexp syntax.</p><pre>tag := &quot;(&quot;, &quot;id&quot;, value, &quot;)&quot; | &quot;(&quot;, &quot;title&quot;, value, &quot;)&quot;</pre><p>Where <code>value</code> is a string, delimited with quotes if it contains whitespaces.</p><p>The tag will be rendered as begin/end block, with the body indented by one space. E.g.,</p><p>Will be rendered as:</p><pre>      begin(main)
       r0 := r1 + r2
       r1 := r2 + r2
       return lr
      end(main)</pre><p>If both <code>id</code> and <code>title</code> is specified, then only title will be outputted. Otherwise, <code>id</code> and <code>title</code> has the same behavior.</p></header><dl><dt class="spec type" id="type-mode"><a href="#type-mode" class="anchor"></a><code><span class="keyword">type</span> mode</code><code> = string</code></dt><dd><p>A name of mode, by default the following modes ares supported <code>html</code>, <code>blocks</code>, <code>attr</code> and <code>none</code></p></dd></dl><dl><dt class="spec exception" id="exception-Unknown_mode"><a href="#exception-Unknown_mode" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Unknown_mode</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-install"><a href="#val-install" class="anchor"></a><code><span class="keyword">val</span> install : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-mode">mode</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>install ppf mode</code> switch formatter <code>ppf</code> into a <code>mode</code>. In a default <code>mode</code> (named <code>none</code>), the semantics tags are ignored. Once a <code>mode</code> is installed, all tags will be rendered according to the mode.</p></dd></dl><dl><dt class="spec value" id="val-with_mode"><a href="#val-with_mode" class="anchor"></a><code><span class="keyword">val</span> with_mode : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-mode">mode</a> <span>&#45;&gt;</span> <span>f:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_mode ppf mode f</code> installs <code>mode</code>, calls <code>f</code>, and then reinstalls the previous mode.</p></dd></dl><dl><dt class="spec value" id="val-register_mode"><a href="#val-register_mode" class="anchor"></a><code><span class="keyword">val</span> register_mode : <a href="index.html#type-mode">mode</a> <span>&#45;&gt;</span> <span>(<a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>register_mode mode init</code> installs new mode. The <code>init</code> function must install all mode hooks using <code>Format</code> interface.</p></dd></dl><dl><dt class="spec value" id="val-available_modes"><a href="#val-available_modes" class="anchor"></a><code><span class="keyword">val</span> available_modes : unit <span>&#45;&gt;</span> <span><a href="index.html#type-mode">mode</a> list</span></code></dt><dd><p><code>available_modes ()</code> lists all currently installed modes.</p></dd></dl><dl><dt class="spec module" id="module-Attr"><a href="#module-Attr" class="anchor"></a><code><span class="keyword">module</span> <a href="Attr/index.html">Attr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Attributes mode.</p></dd></dl></div></body></html>