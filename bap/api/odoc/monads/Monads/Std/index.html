<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (monads.Monads.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">monads</a> &#x00BB; <a href="../index.html">Monads</a> &#x00BB; Std</nav><h1>Module <code>Monads.Std</code></h1><p>Monad Transformer Library.</p><h3 id="abstract"><a href="#abstract" class="anchor"></a>Abstract</h3><p>A monad is an abstraction that can be used to parametrize code with the way how computations are sequenced. A monad can also be seen as design pattern, that sometimes makes your code more readable (and, more often, less readable). A monad transformer of a monad <code>M</code> is a functor that takes another monad <code>M'</code> and enriches <code>M</code> with the behavior of <code>M'</code>. In other terms a transformer is a monad composition operator. This library provides the monad abstraction and implementations of commonly known monads. Each implementation provides the transformer as well.</p><h3 id="table-of-contents"><a href="#table-of-contents" class="anchor"></a>Table of Contents</h3><ul><li><a href="../index.html#abstract"><span>Abstract</span></a></li><li><a href="../index.html#intro"><span>Introduction</span></a></li><li><a href="../index.html#conv"><span>Conventions</span></a></li><li><a href="Monoid/index.html"><span>Monoid</span></a> a set with an associative operation</li><li><p><a href="Monad/index.html"><span>Monad</span></a> a basic monad interface</p><ul><li><p>Monad Interfaces</p><ul><li><a href="Monad/module-type-S/index.html"><span>Monad.S</span></a> the unary monad</li><li><a href="Monad/module-type-S2/index.html"><span>Monad.S2</span></a> the binary monad</li><li><a href="Monad/module-type-Minimal/index.html"><span>Monad.Minimal</span></a> the minimal interface</li><li><a href="Monad/module-type-Minimal/index.html"><span>Monad.Minimal2</span></a> the minimal interface</li><li><a href="Monad/module-type-Core/index.html"><span>Monad.Core</span></a> the core interface</li><li><a href="Monad/module-type-Core/index.html"><span>Monad.Core2</span></a> the core interface</li><li><a href="Monad/Plus/index.html"><span>Monad.Plus</span></a> a monad over a monoid interface</li><li><a href="Monad/Fail/index.html"><span>Monad.Fail</span></a> a failure monad interface</li><li><a href="Monad/Choice/index.html"><span>Monad.Choice</span></a> a choice monad interface</li><li><a href="Monad/Trans/index.html"><span>Monad.Trans</span></a> a monad transformer interface</li></ul></li><li><a href="Monad/Collection/index.html"><span>Monad.Collection</span></a> a container of monads</li><li><a href="Monad/Syntax/index.html"><span>Monad.Syntax</span></a> monad operators</li><li><p>Monad Constructors</p><ul><li><a href="Monad/Make/index.html"><span>Make</span></a></li><li><a href="Monad/Make2/index.html"><span>Make2</span></a></li><li><a href="Monad/module-type-Core/index.html"><span>Core</span></a></li><li><a href="Monad/module-type-Core2/index.html"><span>Core2</span></a></li><li><a href="Monad/module-type-Minimal/index.html"><span>Minimal</span></a></li><li><a href="Monad/module-type-Minimal2/index.html"><span>Minimal2</span></a></li></ul></li><li><a href="Monad/Ident/index.html"><span>Monad.Ident</span></a> the do-nothing monad</li><li><a href="Monad/Option/index.html"><span>Monad.Option</span></a> a non-total monad</li><li><a href="Monad/Result/index.html"><span>Monad.Result</span></a> a non-total monad</li><li><a href="Monad/Result/index.html#type-result.Error"><span>Monad.Result.Error</span></a> a non-total monad</li><li><a href="Monad/Result/Exception/index.html"><span>Monad.Result.Exception</span></a> a non-total monad</li><li><a href="Monad/List/index.html"><span>Monad.List</span></a> a non-deterministic monad</li><li><a href="Monad/Seq/index.html"><span>Monad.Seq</span></a> a non-deterministic monad</li><li><a href="Monad/Writer/index.html"><span>Monad.Writer</span></a> a computation with a writable state</li><li><a href="Monad/Reader/index.html"><span>Monad.Reader</span></a> a computation with a readable state</li><li><a href="Monad/State/index.html"><span>Monad.State</span></a> a computation with a state</li><li><a href="Monad/State/index.html"><span>Monad.State.Multi</span></a> a computation with a non-deterministic state</li><li><a href="Monad/Cont/index.html"><span>Monad.Cont</span></a> a call/cc monad</li></ul></li></ul><h3 id="intro"><a href="#intro" class="anchor"></a>Introduction</h3><p>In this section we will provide a small introduction into the Monad Concept. If you feel yourself comfortable with the idea of Monad you may skip to the next section.</p><p>Monad by itself is a concept or an abstraction. Abstractions come into play when there is a need to write a generic implementation of some algorithm. There are different mechanisms for parametrization an algorithm, but all of them require defining some kind of abstraction, that are usually denoted in a programming language with a type or a module type. In simple cases, an algorithm is parametrized by scalar, e.g.,</p><pre>      algorithm a b ::=
         x := f a;
         y := f b;
         return (x + y);</pre><p>In a more general case, we may parametrize an algorithm with transformations, i.e., with functions:</p><pre>      algorithm ((_ + _), (f _)) a b ::=
         x := f a;
         y := f b;
         return (x + y);</pre><p>However, we have one more generalization opportunity. The semicolon is a sequencing operator that has semantics that is usually defined by a programming language, and, typically, in regular deterministic languages <code>x := f a; y := f b</code> means: first compute <code>f a</code> and assign the result to <code>x</code>, then compute <code>f b</code> and assign the result to <code>y</code>. However, what if we would like to parametrize our algorithm with a behavior of the semicolon and operators:</p><pre>      algorithm ((return _), (_ := _ ; _)) ((_ + _), (f _)) a b ::=
         x := f a;
         y := f b;
         return (x + y);</pre><p>A pair of operators <code>(return _)</code> and <code>(_ := _ ; _)</code> form the monad signature. Since a host language no longer defines semantics of the assignment and semicolon, the monad actually operates with computations rather than with values. I.e., it is the monad implementation that now defines how computations produce values, the order of evaluation, etc. The <code>return x</code> lifts a value into the computation, i.e., it constructs a trivial computation from a constant. The <code>v := y; z</code> operator, also called <code>bind</code>, gives the general semantics of a program, i.e., how the result of computation <code>y</code> is propagated to the computation <code>z</code> (if propagated), it also defines the semantics of the semicolon, i.e., whether <code>z</code> is performed after <code>y</code>, etc. In general, the semantics may be arbitrary, but let's show few examples.</p><p>1. Partiality: a computation may diverge into a bottom value, i.e., if <code>y</code> diverges, then <code>z</code> is not called and the bottom value becomes the result of the whole computation. <a href="Monad/Option/index.html"><span>Monad.Option</span></a> and <a href="Monad/Result/index.html"><span>Monad.Result</span></a> provide a notion of partial computation with different representations of the bottom value.</p><p>2. Nondeterminism: a computation may produce more than one value, in that case <code>v</code> will be bound several times, and <code>z</code> will be called for each possible value of <code>v</code>. <a href="Monad/List/index.html"><span>Monad.List</span></a> and <a href="Monad/Seq/index.html"><span>Monad.Seq</span></a> provide implementations of the nondeterministic monad with different representations of a sequence of values.</p><p>3. Side-effects: <code>x</code> may produce an effect that changes the computation environment. We can subdivide effectful computation into more precise categories:</p><ul><li>effect only -- computations do depend on the effects produced by other computations, see <a href="Monad/Writer/index.html"><span>Monad.Writer</span></a>;</li><li>coeffect only -- computations can't produce effects, though they depend on the computation environment, see <a href="Monad/Reader/index.html"><span>Monad.Reader</span></a>;</li><li>full effect -- computations may change the environment and may depend on effects produced by other computations, see see <a href="Monad/State/index.html"><span>Monad.State</span></a>. The effect itself may also be non-deterministic, e.g., <code>z</code> is computed for each possible effect produced by <code>y</code>, see <a href="Monad/State/Multi/index.html"><span>Monad.State.Multi</span></a></li></ul><p>4. Continuation: <code>x</code> defines a continuation of <code>z</code>, i.e., akin to the effect notion, in which a program state is passed from one computation to another, the continuation notion reifes the control flow of a computation and passes it to the consequent continuation as a state. See <a href="Monad/Cont/index.html"><span>Monad.Cont</span></a>.</p><h4 id="the-ocaml-representation-of-the-monad-signature"><a href="#the-ocaml-representation-of-the-monad-signature" class="anchor"></a>The OCaml representation of the monad signature</h4><p>The monad signature <code>(return _), (_ := _ ; _)</code> is represented with the following OCaml signature:</p><pre><code class="ml">module type Monad = sig
  type 'a t
  val return : 'a -&gt; 'a t
  val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t
end</code></pre><p>We also use <code>&gt;&gt;=</code> operator as an alias to the <code>bind</code> function. Thus <code>v := x; z</code> is represented in OCaml as <code>x &gt;&gt;= fun v -&gt; z</code>. We use functors to parametrize algorithms with signatures, e.g.,</p><pre><code class="ml">module Algorithm(M : Monad) = struct
  open R open M

  let run a b =
    f a &gt;&gt;= fun x -&gt;
    f b &gt;&gt;= fun y -&gt;
    return (x + y)
end</code></pre><p>Basically, whenever you see <code>c1 &gt;&gt;= fun v -&gt; c2</code> you should understand it as <code>v := c1; c2</code> with a parametrized semicolon, and when you see <code>c1 &gt;&gt;= fun () -&gt; c2</code> you should understand it as <code>c1;
    c2</code>. Once you will develop a habit of using monadic semicolon it will become much easier to you to understand the monadic code. Alternatively, you may try one of the syntax preprocessors that will introduce the so called do-notation, with the actual semicolon being overloaded.</p><h3 id="conv"><a href="#conv" class="anchor"></a>Conventions</h3><p>To use the library add <code>open Monads.Std</code> to your program. It will bring <code>Monoid</code> and <code>Monad</code> modules to your scope. A conventional way of writing a computation in a monad <code>M</code>, is to open its syntax with <code>open M.Syntax</code>.</p><p>Given that monad is a concept that goes beyond OCaml language, i.e., it is more a design pattern rather than just a module type signature, we follow few conventions to make it easier to work with different monads.</p><p>First of all we have two monad signatures, <code>S</code> and <code>S2</code>. The <code>S</code> signature defines monad interface for an unary type constructor <code>'a
    t</code> and <code>S2</code> defines the monad interface for a type parametrized with two type parameters, i.e., <code>('a,'b) t</code>. Correspondingly, functors named <code>Make</code> generate modules of type <code>S</code> and modules named <code>Make2</code> produce modules of type <code>S2</code>.</p><p>Every monad <code>M</code> provides two transformers <code>M.Make</code> and <code>M.Make2</code> that transforms <code>M</code> into another monad. The <code>M</code> itself provides an implementation of <code>M.S</code> or <code>M.S2</code> (depending on a particular kind of monad).</p><p>If a monad type is parametrized by two parameters, then the first parameter holds the type of a value, and the second type holds the type of an extra information (usually the type of the context).</p><p>Each monad transformer creates a module that has functions <code>lift</code> and <code>run</code>. The <code>lift</code> function lifts original computation into the transformed one, and <code>run</code> will run the computation.</p></header><dl><dt class="spec module" id="module-Monoid"><a href="#module-Monoid" class="anchor"></a><code><span class="keyword">module</span> <a href="Monoid/index.html">Monoid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A monoid set.</p></dd></dl><dl><dt class="spec module" id="module-Monad"><a href="#module-Monad" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad/index.html">Monad</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The Monad module.</p></dd></dl></div></body></html>