<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type (bap-main.Bap_main.Extension.Type)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap-main</a> &#x00BB; <a href="../../index.html">Bap_main</a> &#x00BB; <a href="../index.html">Extension</a> &#x00BB; Type</nav><header class="odoc-preamble"><h1>Module <code><span>Extension.Type</span></code></h1><p>Data types for parameters.</p><p>A data type defines the validation, parsing, and textual representation of data used for command and configuration parameters.</p><p>Data types are not declarative, but structural, i.e., they define a set of rules which describe the set of possible values and mapping of those values to their OCaml representation.</p><p>Given that the textual representation of data could be non structural itself, e.g., filenames do not define themselves but act as a reference to some other data, it is also important to correctly define the equality operator. We use the digest function, that computes an md5 hash of the datum that describes how it should be compared to other data of the same type. This digests are approximations, which guarantee, that data with equal digests are equal (modulo probability of md5 hash collision), but not always the vice verse (since it is not always possible or feasible to compute the complete digest, cf., digest of the <code>/dev</code> folder).</p></header><nav class="odoc-toc"><ul><li><a href="#predefined-data-types">Predefined data types</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../index.html#type-typ">typ</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-define"><a href="#val-define" class="anchor"></a><code><span><span class="keyword">val</span> define : 
  <span>?name:string <span class="arrow">&#45;&gt;</span></span>
  <span>?digest:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>parse:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>print:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>define ~parse ~print default</code> defines a data type.</p><p>The <code>print x</code> is the textual representation of the value <code>x</code>. For all <code>x</code> in the defined type, <code>x = parse (print x)</code>.</p><p>The <code>parse</code> function may raise the <code>Invalid_arg</code> exception to indicate that the provided datum doesn't represent a valid element of the type. It may raise any other exception to indicate other possible errors. In any case, any exception raised by the <code>parse</code>, <code>print</code>, or <code>digest</code> functions will be caught and propagated to the <code>Bap_main.init</code> abnormal termination with a corresponding error condition.</p><p>@parameter digest if provided then <code>digest x</code>, should evaluate to an md5 hash of <code>x</code> such that if for all <code>y</code>, if <code>digest x = digest y mod md5</code> then <code>x = y</code>. I.e., if digests are equal (modulo md5 collision) then the <code>x</code> and <code>y</code> are also equal. The opposite is not guaranteed, but most of the data types usually provide this guarantee.</p><p>@parameter name is the variable name which is used to reference to elements of the type <code>t</code>. (defaults to <code>&quot;VAL&quot;</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-refine"><a href="#val-refine" class="anchor"></a><code><span><span class="keyword">val</span> refine : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>refine t valid</code> narrows the set of <code>t</code>, to those that <code>valid</code>. The <code>valid</code> function shall raise the <code>Invalid_arg</code> exception, for all values that are not members of the newly defined data type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rename"><a href="#val-rename" class="anchor"></a><code><span><span class="keyword">val</span> rename : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>renam t var</code> denotes elements of <code>t</code> with the new <code>var</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-digest"><a href="#val-digest" class="anchor"></a><code><span><span class="keyword">val</span> digest : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>digest t x</code> is the digest of <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(=?)"><a href="#val-(=?)" class="anchor"></a><code><span><span class="keyword">val</span> (=?) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t =? x</code> defines a new type with different default.</p><p>The new type has the same definition as <code>t</code> except the default value is <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(|=)"><a href="#val-(|=)" class="anchor"></a><code><span><span class="keyword">val</span> (|=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t |? guard</code> is <code>refine t guard</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(%:)"><a href="#val-(%:)" class="anchor"></a><code><span><span class="keyword">val</span> (%:) : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>name %: t</code> is <code>rename t name</code>.</p><p>Note, operators <code>(=?)</code>, <code>|?</code>, and <code>(%:)</code> are designed to be used together for easy definitions of new types, e.g.,</p><pre class="language-ocaml"><code>let arch = Type.(&quot;code&quot; %: arch_t =? `x86 |= only_x86)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>print t x</code> is the textual representation of <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>parse t s</code> is the OCaml value representing <code>s</code>.</p><p>Of those <code>s</code> which are not valid, raises the <code>Invalid_arg</code> exception.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-name"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>name t</code> is the name of the var that ranges of <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-default"><a href="#val-default" class="anchor"></a><code><span><span class="keyword">val</span> default : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>default t</code> is the default value of <code>t</code>.</p></div></div><h4 id="predefined-data-types"><a href="#predefined-data-types" class="anchor"></a>Predefined data types</h4><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bool</code> is <code>&quot;true&quot; | &quot;false&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-char"><a href="#val-char" class="anchor"></a><code><span><span class="keyword">val</span> char : <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>char</code> is a single character.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int</code> is a sequence of digits.</p><p>Common OCaml syntax is supported, with binary, decimal, and hexadecimal literals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nativeint"><a href="#val-nativeint" class="anchor"></a><code><span><span class="keyword">val</span> nativeint : <span>nativeint <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>nativeint</code> is a sequence of digit.</p><p>This type uses processor-native integer as OCaml representation so it is one bit wider than the <code>int</code> type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int32</code> is a sequence of digits.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <span>int64 <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int64</code> is a sequence of digits.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>float</code> is a floating point number.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>string</code> is a sequence of bytes.</p><p>When the sequence contains whitespaces, delimit the whole sequence with double or single quotes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-some"><a href="#val-some" class="anchor"></a><code><span><span class="keyword">val</span> some : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>some t</code> extends <code>t</code> with an empty string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span><span class="keyword">val</span> enum : <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>enum repr</code> defines a type from the given representation.</p><p>Defines a type with such <code>print</code> and <code>parse</code>, that for each pair <code>(s,v)</code> in <code>repr</code>, <code>print v = s</code> and <code>parse s = v</code>.</p><p>It is a configuration error, when <code>repr</code> is empty.</p><p>If <code>repr</code> has repretitive keys, i.e., for the same textual representation there are different values, then the result is undefined.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path"><a href="#val-path" class="anchor"></a><code><span><span class="keyword">val</span> path : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>path</code> denotes a file path.</p><p>The path is suitable for denoting output paths and its digest is the digest of the characters, which constitute the path.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-file"><a href="#val-file" class="anchor"></a><code><span><span class="keyword">val</span> file : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>file</code> the name of an input file or directory.</p><p>The file denoted by the name must exist and must be accessible.</p><p>Digesting paths</p><p>The following rules describe how the digest of the path is computed. It is assumed that the <code>file</code> type denotes the input file, therefore the contents that is referenced by the path is approximately digested. For the output destinations the <code>path</code> type is more suitable.</p><p>1. If the name is a symbolic link then the digest of the link destination is computed.</p><p>2. If the name references to a regular file then the <code>digest</code> of the file is the digest of its contents and the name itself doesn't affect the digest value.</p><p>3. If the name referenced to a directory, then a recursive digest is computed, such that:</p><ul><li>if the directory contains a small number of regular files and directories (less than 4k), then a cummulative digest of its content built from all constituting path names and modification times is computed;</li><li>otherwise (if the directory is too large or contains non regular files, e.g., sockets, fifo, devices), then a fresh new random digest is created from the directory name and the current time.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dir"><a href="#val-dir" class="anchor"></a><code><span><span class="keyword">val</span> dir : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>dir</code> denotes a file which must be a directory.</p><p>The directory denoted by the name must exist. See the <code>file</code> type for more information about computing the digest.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-non_dir_file"><a href="#val-non_dir_file" class="anchor"></a><code><span><span class="keyword">val</span> non_dir_file : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>dir</code> denotes a file which must not be a directory.</p><p>The directory denoted by the name must exist. See the <code>file</code> type for more information about computing the digest.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span>?sep:char <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>list ~sep t</code> is a list of <code>t</code> elements, separated with <code>sep</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-array"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span>?sep:char <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>array ~sep t</code> is an array of <code>t</code> elements, separated with <code>sep</code>. @parameter sep defaults to <code>','</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span>?sep:char <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pair ~sep t1 t2</code> is a pair <code>t1</code> and <code>t2</code>, separated with <code>sep</code>.</p><p>@parameter sep defaults to <code>','</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t2"><a href="#val-t2" class="anchor"></a><code><span><span class="keyword">val</span> t2 : <span>?sep:char <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t2 ~sep t1 t2</code> is a pair <code>t1</code> and <code>t2</code>, separated with <code>sep</code>.</p><p>@parameter sep defaults to <code>','</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t3"><a href="#val-t3" class="anchor"></a><code><span><span class="keyword">val</span> t3 : <span>?sep:char <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t3 ~sep t1 t2 t3</code> is (<code>t1</code>,<code>t2</code>,<code>t3</code>), separated with <code>sep</code>. @parameter sep defaults to <code>','</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t4"><a href="#val-t4" class="anchor"></a><code><span><span class="keyword">val</span> t4 : <span>?sep:char <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>t4 ~sep t1 t2 t3 t4</code> is (<code>t1</code>,<code>t2</code>,<code>t3</code>,<code>t4), separated with [sep].
        @parameter sep defaults to [',']. </code></p></div></div></div></body></html>