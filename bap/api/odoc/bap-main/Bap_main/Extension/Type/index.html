<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type (bap-main.Bap_main.Extension.Type)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">bap-main</a> &#x00BB; <a href="../../index.html">Bap_main</a> &#x00BB; <a href="../index.html">Extension</a> &#x00BB; Type</nav><h1>Module <code>Extension.Type</code></h1><p>Data types for parameters.</p><p>A data type defines the validation, parsing, and textual representation of data used for command and configuration parameters.</p><p>Data types are not declarative, but structural, i.e., they define a set of rules which describe the set of possible values and mapping of those values to their OCaml representation.</p><p>Given that the textual representation of data could be non structural itself, e.g., filenames do not define themselves but act as a reference to some other data, it is also important to correctly define the equality operator. We use the digest function, that computes an md5 hash of the datum that describes how it should be compared to other data of the same type. This digests are approximations, which guarantee, that data with equal digests are equal (modulo probability of md5 hash collision), but not always the vice verse (since it is not always possible or feasible to compute the complete digest, cf., digest of the <code>/dev</code> folder).</p><nav class="toc"><ul><li><a href="#predefined-data-types">Predefined data types</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-typ">typ</a></span></code></dt></dl><dl><dt class="spec value" id="val-define"><a href="#val-define" class="anchor"></a><code><span class="keyword">val</span> define : <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span>?&#8288;digest:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>parse:<span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>print:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>define ~parse ~print default</code> defines a data type.</p><p>The <code>print x</code> is the textual representation of the value <code>x</code>. For all <code>x</code> in the defined type, <code>x = parse (print x)</code>.</p><p>The <code>parse</code> function may raise the <code>Invalid_arg</code> exception to indicate that the provided datum doesn't represent a valid element of the type. It may raise any other exception to indicate other possible errors. In any case, any exception raised by the <code>parse</code>, <code>print</code>, or <code>digest</code> functions will be caught and propagated to the <code>Bap_main.init</code> abnormal termination with a corresponding error condition.</p><p>@parameter digest if provided then <code>digest x</code>, should evaluate to an md5 hash of <code>x</code> such that if for all <code>y</code>, if <code>digest x = digest y mod md5</code> then <code>x = y</code>. I.e., if digests are equal (modulo md5 collision) then the <code>x</code> and <code>y</code> are also equal. The opposite is not guaranteed, but most of the data types usually provide this guarantee.</p><p>@parameter name is the variable name which is used to reference to elements of the type <code>t</code>. (defaults to <code>&quot;VAL&quot;</code>).</p></dd></dl><dl><dt class="spec value" id="val-refine"><a href="#val-refine" class="anchor"></a><code><span class="keyword">val</span> refine : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>refine t valid</code> narrows the set of <code>t</code>, to those that <code>valid</code>. The <code>valid</code> function shall raise the <code>Invalid_arg</code> exception, for all values that are not members of the newly defined data type.</p></dd></dl><dl><dt class="spec value" id="val-rename"><a href="#val-rename" class="anchor"></a><code><span class="keyword">val</span> rename : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>renam t var</code> denotes elements of <code>t</code> with the new <code>var</code>.</p></dd></dl><dl><dt class="spec value" id="val-digest"><a href="#val-digest" class="anchor"></a><code><span class="keyword">val</span> digest : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>digest t x</code> is the digest of <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-(=?)"><a href="#val-(=?)" class="anchor"></a><code><span class="keyword">val</span> (=?) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t =? x</code> defines a new type with different default.</p><p>The new type has the same definition as <code>t</code> except the default value is <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-(|=)"><a href="#val-(|=)" class="anchor"></a><code><span class="keyword">val</span> (|=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t |? guard</code> is <code>refine t guard</code></p></dd></dl><dl><dt class="spec value" id="val-(%:)"><a href="#val-(%:)" class="anchor"></a><code><span class="keyword">val</span> (%:) : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>name %: t</code> is <code>rename t name</code>.</p><p>Note, operators <code>(=?)</code>, <code>|?</code>, and <code>(%:)</code> are designed to be used together for easy definitions of new types, e.g.,</p><pre><code class="ml">let arch = Type.(&quot;code&quot; %: arch_t =? `x86 |= only_x86)</code></pre></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>print t x</code> is the textual representation of <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>parse t s</code> is the OCaml value representing <code>s</code>.</p><p>Of those <code>s</code> which are not valid, raises the <code>Invalid_arg</code> exception.</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>name t</code> is the name of the var that ranges of <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-default"><a href="#val-default" class="anchor"></a><code><span class="keyword">val</span> default : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>default t</code> is the default value of <code>t</code>.</p></dd></dl><section><header><h4 id="predefined-data-types"><a href="#predefined-data-types" class="anchor"></a>Predefined data types</h4></header><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bool</code> is <code>&quot;true&quot; | &quot;false&quot;</code></p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>char</code> is a single character.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int</code> is a sequence of digits.</p><p>Common OCaml syntax is supported, with binary, decimal, and hexadecimal literals.</p></dd></dl><dl><dt class="spec value" id="val-nativeint"><a href="#val-nativeint" class="anchor"></a><code><span class="keyword">val</span> nativeint : <span>nativeint <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>nativeint</code> is a sequence of digit.</p><p>This type uses processor-native integer as OCaml representation so it is one bit wider than the <code>int</code> type.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : <span>int32 <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int32</code> is a sequence of digits.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : <span>int64 <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int64</code> is a sequence of digits.</p></dd></dl><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : <span>float <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>float</code> is a floating point number.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>string</code> is a sequence of bytes.</p><p>When the sequence contains whitespaces, delimit the whole sequence with double or single quotes.</p></dd></dl><dl><dt class="spec value" id="val-some"><a href="#val-some" class="anchor"></a><code><span class="keyword">val</span> some : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>some t</code> extends <code>t</code> with an empty string.</p></dd></dl><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : <span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>enum repr</code> defines a type from the given representation.</p><p>Defines a type with such <code>print</code> and <code>parse</code>, that for each pair <code>(s,v)</code> in <code>repr</code>, <code>print v = s</code> and <code>parse s = v</code>.</p><p>It is a configuration error, when <code>repr</code> is empty.</p><p>If <code>repr</code> has repretitive keys, i.e., for the same textual representation there are different values, then the result is undefined.</p></dd></dl><dl><dt class="spec value" id="val-path"><a href="#val-path" class="anchor"></a><code><span class="keyword">val</span> path : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>path</code> denotes a file path.</p><p>The path is suitable for denoting output paths and its digest is the digest of the characters, which constitute the path.</p></dd></dl><dl><dt class="spec value" id="val-file"><a href="#val-file" class="anchor"></a><code><span class="keyword">val</span> file : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>file</code> the name of an input file or directory.</p><p>The file denoted by the name must exist and must be accessible.</p><h4 id="digesting-paths"><a href="#digesting-paths" class="anchor"></a>Digesting paths</h4><p>The following rules describe how the digest of the path is computed. It is assumed that the <code>file</code> type denotes the input file, therefore the contents that is referenced by the path is approximately digested. For the output destinations the <code>path</code> type is more suitable.</p><p>1. If the name is a symbolic link then the digest of the link destination is computed.</p><p>2. If the name references to a regular file then the <code>digest</code> of the file is the digest of its contents and the name itself doesn't affect the digest value.</p><p>3. If the name referenced to a directory, then a recursive digest is computed, such that:</p><ul><li>if the directory contains a small number of regular files and directories (less than 4k), then a cummulative digest of its content built from all constituting path names and modification times is computed;</li><li>otherwise (if the directory is too large or contains non regular files, e.g., sockets, fifo, devices), then a fresh new random digest is created from the directory name and the current time.</li></ul></dd></dl><dl><dt class="spec value" id="val-dir"><a href="#val-dir" class="anchor"></a><code><span class="keyword">val</span> dir : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>dir</code> denotes a file which must be a directory.</p><p>The directory denoted by the name must exist. See the <code>file</code> type for more information about computing the digest.</p></dd></dl><dl><dt class="spec value" id="val-non_dir_file"><a href="#val-non_dir_file" class="anchor"></a><code><span class="keyword">val</span> non_dir_file : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>dir</code> denotes a file which must not be a directory.</p><p>The directory denoted by the name must exist. See the <code>file</code> type for more information about computing the digest.</p></dd></dl><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <span>?&#8288;sep:char</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list ~sep t</code> is a list of <code>t</code> elements, separated with <code>sep</code>.</p></dd></dl><dl><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val</span> array : <span>?&#8288;sep:char</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> array</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>array ~sep t</code> is an array of <code>t</code> elements, separated with <code>sep</code>. @parameter sep defaults to <code>','</code>.</p></dd></dl><dl><dt class="spec value" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span class="keyword">val</span> pair : <span>?&#8288;sep:char</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>pair ~sep t1 t2</code> is a pair <code>t1</code> and <code>t2</code>, separated with <code>sep</code>.</p><p>@parameter sep defaults to <code>','</code>.</p></dd></dl><dl><dt class="spec value" id="val-t2"><a href="#val-t2" class="anchor"></a><code><span class="keyword">val</span> t2 : <span>?&#8288;sep:char</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t2 ~sep t1 t2</code> is a pair <code>t1</code> and <code>t2</code>, separated with <code>sep</code>.</p><p>@parameter sep defaults to <code>','</code>.</p></dd></dl><dl><dt class="spec value" id="val-t3"><a href="#val-t3" class="anchor"></a><code><span class="keyword">val</span> t3 : <span>?&#8288;sep:char</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t3 ~sep t1 t2 t3</code> is (<code>t1</code>,<code>t2</code>,<code>t3</code>), separated with <code>sep</code>. @parameter sep defaults to <code>','</code>.</p></dd></dl><dl><dt class="spec value" id="val-t4"><a href="#val-t4" class="anchor"></a><code><span class="keyword">val</span> t4 : <span>?&#8288;sep:char</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>t4 ~sep t1 t2 t3 t4</code> is (<code>t1</code>,<code>t2</code>,<code>t3</code>,<code>t4), separated with [sep].
        @parameter sep defaults to [',']. </code></p></dd></dl></section></div></body></html>