<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Command (bap-main.Bap_main.Extension.Command)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap-main</a> &#x00BB; <a href="../../index.html">Bap_main</a> &#x00BB; <a href="../index.html">Extension</a> &#x00BB; Command</nav><h1>Module <code>Extension.Command</code></h1><p>Interface for specifying commands.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('f, 'r) t</span></code></dt><dd><p>description of the command line syntax.</p><p>The <code>'f</code> parameter is the type of function that is evaluated when the command is selected.</p><p>The <code>'r</code> is the value returned by <code>'f</code> (and so <code>'r</code> is always included in <code>'f</code>.</p><p>For example,</p><pre><code class="ml">type s =
  (int -&gt; ctxt -&gt; (unit,error) result,
   ctxt -&gt; (unit,error) result) t</code></pre><p>is a type of a function that takes two input arguments of type <code>int</code> and <code>ctxt</code> respectively, and must evaluate to a value of type <code>unit,error</code> result</p></dd></dl><dl><dt class="spec type" id="type-param"><a href="#type-param" class="anchor"></a><code><span class="keyword">type</span> <span>'a param</span></code></dt><dd><p><code>'a param</code> command line parameter represented with the OCaml value of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-declare"><a href="#val-declare" class="anchor"></a><code><span class="keyword">val</span> declare : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span>?&#8288;requires:<span>string list</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'f</span>, <a href="../../index.html#type-ctxt">ctxt</a> <span>&#45;&gt;</span> <span><span>(unit, <a href="../../index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'f</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>declare grammar name command</code> declares a <code>command</code>.</p><p>Declares to BAP that a command with the given <code>name</code> should be invoked when a user specifies the <code>name</code> or <code>:name</code> as the first argument in the command line. The <code>grammar</code> defines the command line grammar of this command.</p><p>where <code>&lt;command1&gt;</code> ... <code>&lt;commandN&gt;</code> are the names of declared commands, <code>grammar1</code> ... <code>grammarN</code> are corresponding grammars for each command, and <code>G'</code> is the global</p><p>When the command is selected and command line arguments are parsed successfully, the <code>command</code> function is applied to the specified command line arguments. The result of evaluation of the <code>command</code> will become the result of the <code>Bap_main.init
        ()</code> expression in the host program.</p><p>If the function with the given <code>name</code> is already registered, then the command is not registered and BAP initialization will terminate abnormally with the configuration error condition.</p><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><p>Note, the examples below assume the following preamble:</p><pre><code class="ml">open Core_kernel
open Bap_main.Extension</code></pre><p>1) Declare a command with no arguments:</p><pre><code class="ml">let () =
  Command.(declare &quot;hello&quot; args) @@
  fun ctxt -&gt;
  printf &quot;the `hello' command is called\n&quot;;
  Ok ()</code></pre><p>2) Declaring a command with one positional argument</p><pre><code class="ml">let input = Command.argument Type.int
let () =
  Command.(declare &quot;hello&quot; (args $input)) @@
  fun input ctxt -&gt;
  printf &quot;called as `hello %d'\n&quot; input</code></pre><p>3) Declaring a command with an optional named parameter, and many positional arguments.</p><pre><code class="ml">let inputs = Command.arguments Type.string
let output = Command.parameter Type.string &quot;output&quot;
let () =
  Command.(declare &quot;copy&quot; (args $output $inputs)) @@
  fun output inputs -&gt;
  printf &quot;copying %s inputs to %s\n&quot;
    (String.concat ~sep:&quot; &quot; inputs) output</code></pre><p>@parameter doc defines the documentation for the declared command, it could be as simple one-line description or a full featured manual in the markdown syntax. See the corresponding parameter in the <a href="../../index.html#val-init"><code>Bap_main.init</code></a> function for the description of the accepted.</p><p>@parameter requires defines the set of features that are required by the implementation of this command. It defaults to the set of all possible features. The context value passed to the <code>command</code> function will be refined to the context of extensions which are providing the specified features, i.e., between different invocations of BAP it will not change if the configuration parameters of extensions on which the command depends didn't change.</p></dd></dl><dl><dt class="spec value" id="val-args"><a href="#val-args" class="anchor"></a><code><span class="keyword">val</span> args : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>args</code> is the empty grammar. Useful to define commands that do not take arguments or as the initial grammar which is later extended with parameters using the <code>$</code> operator (see below).</p></dd></dl><dl><dt class="spec value" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val</span> ($) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-param">param</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>args t $ t'</code> extends the grammar specification <code>t</code> with <code>t'</code>.</p></dd></dl><dl><dt class="spec value" id="val-argument"><a href="#val-argument" class="anchor"></a><code><span class="keyword">val</span> argument : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-typ">typ</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>argument t</code> declares a positional argument of type <code>t</code>.</p><p>The grammar of <code>args $ term $ argument t</code>:</p><pre>          G = term, [t] | [t], term</pre></dd></dl><dl><dt class="spec value" id="val-arguments"><a href="#val-arguments" class="anchor"></a><code><span class="keyword">val</span> arguments : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-typ">typ</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>arguments t</code> declares an infinite number of positional arguments of type <code>t</code>.</p><p>The grammar of <code>args $ term $ arguments t</code>:</p><pre>          G = term, {t} | {t}, term</pre><p>Note, no positional arguments could be appended to the command line specification after this one, e.g., the following is not well formed:</p><pre><code class="ml">(* Warning! Ill-formed code *)

let inputs = Command.arguments Type.string
let output = Command.parameter Type.string &quot;output&quot;
let () =
  Command.(declare &quot;copy&quot; (args $inputs $output)) @@
  fun output inputs -&gt;
  printf &quot;copying %s inputs to %s\n&quot;
    (String.concat ~sep:&quot; &quot; inputs) output</code></pre></dd></dl><dl><dt class="spec value" id="val-switch"><a href="#val-switch" class="anchor"></a><code><span class="keyword">val</span> switch : <span>?&#8288;doc:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>string list</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>switch values name</code> declares a switch-type parameter.</p><p>The grammar of <code>args $ term $ switch values name</code>:</p><pre>          G  = term, G' | G', term
          G' = [&quot;--&lt;name v0&gt;&quot; | .. | &quot;--&lt;name vN&gt;&quot;]</pre><p>where <code>&lt;name vK&gt;</code> is the result of application of the <code>name</code> function to the <code>K</code>th element of the <code>values</code> list.</p><p>The switch-type parameters enables a selection from a list of choices. If <code>--&lt;name vK&gt;</code> is specified on the command line, then <code>Some vK</code> will be passed to the command, otherwise, the <code>None</code> value will be passed.</p><p>The <code>name</code> function could be non-injective, so that several names can correspond to the same value in the choice list.</p><p>The <code>name</code> function shall return syntactically valid command line keys, i.e., non-empty strings that do not contain whitespaces.</p></dd></dl><dl><dt class="spec value" id="val-switches"><a href="#val-switches" class="anchor"></a><code><span class="keyword">val</span> switches : <span>?&#8288;doc:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>string list</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>switches values name</code> is multiple choice switch-type parameter.</p><p>The grammar of <code>args $ term $ switches values name</code> is</p><pre>          G  = term, G' | G', term
          G' = {&quot;--&lt;name v0&gt;&quot; | .. | &quot;--&lt;name vN&gt;&quot;}</pre><p>where <code>v1</code> .. <code>vN</code> are elements of <code>values</code>, and <code>&lt;name vK&gt;</code> is the result of application of the <code>name</code> function to the <code>K</code>th element of the <code>values</code> list.</p><p>The switch-type parameters enables a selection from a list of choices, however unlike it <code>switch</code> counterpart, the selector can occur more than once on the command line. For every occurrence <code>--&lt;name vK&gt;</code> on the command line, the corresponding <code>vK</code> value will be added to the list that will be passed as an argument to the command. The order of elements in the list will match with the order of selectors on the command line.</p><p>The <code>name</code> function could be non-injective, so that several names can correspond to the same value in the choice list.</p><p>The <code>name</code> function shall return syntactically valid command line keys, i.e., non-empty strings that do not contain whitespaces.</p></dd></dl><dl><dt class="spec value" id="val-dictionary"><a href="#val-dictionary" class="anchor"></a><code><span class="keyword">val</span> dictionary : <span>?&#8288;doc:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>?&#8288;as_flag:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span>string list</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'k</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'d</span> <a href="../index.html#type-typ">typ</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'k</span> * <span class="type-var">'d</span>)</span> list</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>dictionary keys t name</code> declares a dictionary-style parameter.</p><p>The grammar of <code>args $ term $ dictionary keys t name</code> is</p><pre>          G  = term, G' | G', term
          G' = [&quot;--&lt;name k0&gt;&quot; [=] t] | .. | [&quot;--&lt;name kN&gt;&quot; [=] t]</pre><p>where <code>k0</code> .. <code>kN</code> are elements of the <code>keys</code> list and <code>&lt;name
        kN&gt;</code> is the result of application of the <code>name</code> function to the <code>kN</code> element of the <code>keys</code> list.</p><p>For each occurrence of <code>--&lt;name k&gt; [=] v</code> on the specified command line a binding <code>(k,v)</code> will be added to the dictionary, which is passed as an argument to the command.</p><p>Each key-value pair can occur at most once on the command line. If a key-value pair is omitted, then the <code>default t</code> will be added to the dictionary for that key. The length of the passed dictionary is the same as the length of the <code>keys</code> list.</p><p>The <code>name</code> function could be non-injective, so that several names can correspond to the same value in the choice list.</p><p>The <code>name</code> function shall return syntactically valid command line keys, i.e., non-empty strings that do not contain whitespaces.</p><h4 id="keys-as-flags"><a href="#keys-as-flags" class="anchor"></a>Keys as flags</h4><p>When the <code>as_flag</code> option is specified makes the value part of the grammar becomes optional, thus the grammar of <code>args $ term $ dictionary ~as_flag:s keys t name</code> becomes</p><pre>          G  = term, G' | G', term
          G' = [&quot;--&lt;name k0&gt;&quot; [[=] t]] | .. | [&quot;--&lt;name kN&gt;&quot; [[=] t]]</pre><p>If the value is omitted on the command line, by the key <code>k</code> is specified, then the <code>(k,s)</code> will be added to the dictionary.</p><p>@parameter as_flag enables the &quot;Keys as flags&quot; mode.</p><p>@parameter docv is the name that will be used to reference values in the documentation string.</p><p>@parameter doc if specified then <code>doc k</code> will be the documentation string for the <code>--&lt;key k&gt;</code> parameter.</p></dd></dl><dl><dt class="spec value" id="val-parameter"><a href="#val-parameter" class="anchor"></a><code><span class="keyword">val</span> parameter : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span>?&#8288;as_flag:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>string list</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-typ">typ</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>parameter t name</code> declares a generic command line parameter.</p><p>The grammar of <code>args $ term $ parameter t name</code></p><pre>          G  = term, G' | G', term
          G' = [&quot;--&lt;name&gt;&quot; [=] t]</pre><p>If <code>--&lt;name&gt;=v</code> is specified, then <code>v</code> will be passed to the command, otherwise the <code>default t</code> value will be passed.</p><h4 id="parameters-as-flags"><a href="#parameters-as-flags" class="anchor"></a>Parameters as flags</h4><p>When the <code>as_flag</code> option specified, then the value part of becomes optional and the parameter could be specified without it, as a flag, e.g., <code>--&lt;name&gt;</code>, in that case the value passed to the <code>as_flag</code> parameter will be passed as an argument to the command.</p><h4 id="short-keys"><a href="#short-keys" class="anchor"></a>Short keys</h4><p>The <code>aliases</code> parameter may additionally contain one-character-long names, which will be interpreted as short keys, that should be specified with only one dash character, i.e.,</p><p>The grammar of <code>args $ term $ parameter ~aliases:[&quot;&lt;k&gt;&quot;] t name</code></p><pre>          G  = term, G' | G', term
          G' = [&quot;--&lt;name&gt;&quot; [=] t | &quot;-&lt;k&gt;&quot; [=] t]</pre><p>where <code>&lt;k&gt;</code> is a single character.</p><p>@parameter as_flag enables the &quot;Parameters as flags&quot; mode.</p><p>@parameter doc is the documentation string.</p><p>@parameter docv is the name used to reference the parameter value in its documentation.</p><p>@parameter aliases is a list of additional aliases of the parameter.</p></dd></dl><dl><dt class="spec value" id="val-parameters"><a href="#val-parameters" class="anchor"></a><code><span class="keyword">val</span> parameters : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span>?&#8288;as_flag:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>string list</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-typ">typ</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>parameters</code> declares a generic command line parameter.</p><p>The grammar of <code>args $ term $ parameters t name</code></p><pre>          G  = term, G' | G', term
          G' = {&quot;--&lt;name&gt;&quot; [=] t}</pre><p>This command line parameter behaves the same as its <code>parameter</code> counterpart, but it could be specified more than once on the command line. For each occurrence of <code>--&lt;name&gt;=v</code>, <code>v</code> will be added to the list (in the order of occurrence), which will be passed as an argument to the command.</p><p>See the <a href="index.html#val-parameter"><code>parameter</code></a> function for more details.</p></dd></dl><dl><dt class="spec value" id="val-flag"><a href="#val-flag" class="anchor"></a><code><span class="keyword">val</span> flag : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>string list</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>bool <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>flag name</code> declares a flag-style parameter.</p><p>The flag-style parameter is like a normal <code>parameter</code>, except that it is not possible to specify its value.</p><p>The grammar of <code>args $ term $ flag name</code> is</p><pre>          G  = term, G' | G', term
          G' = [&quot;--&lt;name&gt;&quot;]</pre><p>The flag could be specified at most once on the command line, and if specified then the <code>true</code> value will be passed to the command.</p><p>The rest of parameters of the <code>flag</code> function have the same meaning as described in the <a href="index.html#val-parameter"><code>parameter</code></a> function.</p></dd></dl><dl><dt class="spec value" id="val-flags"><a href="#val-flags" class="anchor"></a><code><span class="keyword">val</span> flags : <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span>?&#8288;aliases:<span>string list</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>int <a href="index.html#type-param">param</a></span></code></dt><dd><p><code>flags</code> declares a muti-occurring flag-style parameter.</p><p>The grammar of <code>args $ term $ flag name</code> is</p><pre>          G  = term, G' | G', term
          G' = {&quot;--&lt;name&gt;&quot;}</pre><p>Unlike it <a href="index.html#val-flag"><code>flag</code></a> counterparts parameters declared as <code>flags</code> make occur more than once on the command line. The number of occurrences will be passed to the command.</p></dd></dl></div></body></html>