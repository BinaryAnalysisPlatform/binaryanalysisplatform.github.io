<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bap_main (bap-main.Bap_main)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bap-main</a> &#x00BB; Bap_main</nav><h1>Module <code>Bap_main</code></h1><p>The entry point to BAP.</p><p>This module is an entry point to BAP and serves the two goals:</p><ul><li>embedding BAP in other applications;</li><li>extending BAP with the user code.</li></ul><h3 id="embedding-bap"><a href="#embedding-bap" class="anchor"></a>Embedding BAP</h3><p>BAP is designed to be friendly and act as a library, so that it can be seamlessly embedded into user applications, in cases when the main frontend of BAP, the <code>bap</code> utility, couldn't suffice the user requirements. Being a guest, BAP will act respectfully to its host and won't interfere with system utilities, unless allowed to, e.g., it won't terminate the program, hijack the control flow, spam into channels and, in general, will keep quiet and minimize possible side-effects.</p><p>Embedding is achieved by a simple call to the <code>Bap_main.init ()</code> procedure which takes a few optional arguments. By default it will just initialize plugins, peeking configuration from the predefined locations and environment variables (which in turn, could be also specified). If command line arguments are passed, the <code>init</code> procedure will evaluate them. See the <code>bap</code> utility for the description of the command line interface and semantics of command line arguments.</p><h4 id="warning"><a href="#warning" class="anchor"></a>Warning</h4><p>Sine BAP is relying on dynamic loading, for correct behavior the host program shall provide information to the dynamic loader about the units that are linked into the host program. Failure to do so may result in an undefined behavior with the segmentation fault being the most favorable outcome.</p><p>This requirement could be achieved by using the <code>ocamlfind</code> tool to build the host program and specifying <code>-package findlib.dynload</code> in the linking command <code>1</code>.</p><p>Alternatively, if <code>dune</code> is used, then adding <code>findlib.dynload</code> to the libraries dependencies of the host application (e.g., <code>(libraries findlib.dynload)</code> should also work) <code>2</code>.</p><p>Finally, if neither of approaches suffice, the dependencies could be manually set using the <code>Findlib.record_package</code> function.</p><p><code>1</code>: http://projects.camlcity.org/projects/dl/findlib-1.5.6/doc/ref-html/lib/Fl_dynload.html <code>2</code>: https://jbuilder.readthedocs.io/en/latest/advanced-topics.html#dynamic-loading-of-packages</p><h3 id="extending-bap"><a href="#extending-bap" class="anchor"></a>Extending BAP</h3><p>It is much more common and recommended to use the <code>bap</code> utility to initialize and run BAP. The user code could be injected in predefined extension points, and will be called by the system with all the necessary input parameters. This approach minimizes the amount of the boilerplate that has to be written and lets an analyst to inject its analysis in the right place of a pipeline.</p><p>There are plenty of extension points in BAP, too many to mention here, but writing a disassembling pass would be a good example. Using the <code>Project.register_pass</code> function an analyst can get straight to the point and apply its analysis as a transformation to the <code>project</code> data structure without being obligated to create this structure on the first hand, thus relinquishing to the BAP framework the responsibility of parsing the command line arguments, selecting proper loaders and disassembler parameters.</p><p>This approach also establishes a unified interface to BAP making the whole system easier to use and understand.</p><h4 id="plugins"><a href="#plugins" class="anchor"></a>Plugins</h4><p>A plugin is compiled and packed code that could be loaded in runtime. A plugin is a bundle that in addition to the machine and byte code of the extension itself, contains the meta information that describes plugin properties, requirements, and provided features. It may also optionally contain the code for dependencies, which leverages plugin portability, so that it can be loaded when the development environment is no longer available. (Note, by default all dependencies except the bap library itself and core_kernel) are packed into the plugin.</p><p>The <code>bapbuild</code> tool is used to build plugins from OCaml source code. The <code>bapbundle</code> tool could be used to deploy the plugin into a place where it will be automatically loaded by the framework. In short, to build and deploy a plugin with OCaml code located in a file named <code>example.ml</code> execute the following two commands:</p><p>1. <code>bapbuild example.plugin</code> 2. <code>bapbundle install example.plugin</code></p><p>The <code>bapbuild</code> tool will scan the dependencies of the <code>example.ml</code> file and build them automatically if they are present in the current directory, e.g., if <code>example.ml</code> references the <code>Analysis</code> module and <code>analysis.ml</code> is present in the current folder, then it will be automatically built and linked into the final product. A dependency on an external package could be specified using the <code>-pkg</code> and <code>-pkgs</code> option (the latter accepts a comma separated list of dependencies). Underneath the hood, <code>bapbuild</code> is the standard OCaml <code>ocamlbuild</code> tool extended with a few rules that are necessary to build and pack plugins.</p><p>The <code>bapbuild</code> tool has its limitations, for example, only one plugin per folder could be built. When the source base grows very big it is becoming hard to manage it with <code>bapbuild</code>, so using some configuration system is advised, e.g., OASIS or dune. A plugin, then, could be built as a normal OCaml library and later packed with <code>bapbuild</code>.</p><h4 id="extensions"><a href="#extensions" class="anchor"></a>Extensions</h4><p>After the plugin is deployed to the place where it could be found by BAP, it will be loaded every time the <code>Bap_main.init</code> function is called. All toplevel expressions of all modules constituting the plugin will be evaluated, however, a well-behaving plugin shall not evaluate any side-effectful expressions except those that are provided by the <code>Extension</code> module.</p><p>The <code>Extension</code> module let the extension to</p><p>1) declare configuration parameters; 2) declare command line arguments; 3) declare an extension; 4) declare a command; 5) specify meta attributes such as documentation, features, and requirements.</p><p>When an extension is enabled by the framework (see the <a href="index.html#features"><span>Features</span></a> section which describes the process of selection), it will be evaluated with the context, capturing the computation environment, passed to it as function argument.</p><h4 id="commands"><a href="#commands" class="anchor"></a>Commands</h4><p>Commands are special kinds of extensions which stand aside because the play the role of the <code>main</code> function in BAP, i.e., a command is an OCaml function which will be evaluated as the main function, when BAP is run.</p><p>Commands can have their own command line arguments, which are then reified into OCaml values and passed to the specified function as arguments.</p><h3 id="features-and-requirements"><a href="#features-and-requirements" class="anchor"></a>Features and Requirements</h3><p>BAP employs a system of simple semantic tags to denote required and provided capabilities of its various components. This system facilitates fine granular selection of components that are required for an application to satisfy it needs.</p><h4 id="features"><a href="#features" class="anchor"></a>Features</h4><p>Both the main system and its extensions may explicitly state the set of features that they provide or expect, as well as the set of requirements that they require or implement.</p><p>Both, features and requirements are intentionally denoted with string tags with no specific requirements.</p><p>A feature is a high-level description of an application and its environment. It is used to describe to the extensions what the application is doing and what should be expected by an extension.</p><p>Features are specified by the application via the <code>init</code> function. An extension may define a specific set of features that it expects to be present and won't be loaded by application which do not specify the expected features.</p><p>Some general examples of features are <code>user-interface</code>, <code>interactive</code>, <code>toplevel</code>.</p><p>Another common use case of features is denoting an tag that is specific to the given application or an organization, e.g., <code>my-verification-framework</code> or <code>cmu.edu</code>, and specify them in plugins to ensure that they are loaded only in the specified environments, but not in more general.</p><p>The more features an application specifies the more general it is, i.e., more extensions will be available for it. The more features an extension specifies, the less general it is, i.e., it could be used in fewer applications.</p><p>The list of features known to the <code>bap</code> utility, could be obtained by using the <code>bap list features</code> command.</p><h4 id="requirements"><a href="#requirements" class="anchor"></a>Requirements</h4><p>The requirements are more fine granular descriptions of system capabilities that are used to define system dependencies without relying on concrete implementations. For example, if an application needs to parse ELF files it may explicitly define this dependency by adding the <code>elf</code> tag to the list of its requirements.</p><p>By using requirements in this manner it is possible to build an application that loads some minimal set of dependencies.</p><h4 id="caching"><a href="#caching" class="anchor"></a>Caching</h4><p>Requirements are also playing an important role in the caching subsystem and in general leverage reproducibility of BAP applications by enabling pure functional relationships between BAP components.</p><p>Every BAP extension is evaluated in the context, which is captured by a value of type <code>ctxt</code> that is passed to each extension function. The context is an immutable value that fully describes the set of configuration parameters, command line arguments, and other descriptors of the environment in which the BAP subsystem is evaluating.</p><p>It is possible to reduce the context into its cryptographic digest, which, in turn, could be used as key in some persistent storage, which, useful for implementing caching. However, computing a digest of the whole context could be overconservative, since it may also capture variables that are irrelevant to a given computation. For that reason, we provide a mechanism to refine the context by specifying a set of tags that relate the computation to the environment.</p><p>For example, the disassembler command, provided by the <code>disassemble.plugin</code> depends on a predefined set of features provided by different plugins, namely, <code>disassembler</code>, <code>lifter</code>, <code>symbolizer</code>, <code>rooter</code>, <code>reconstructor</code>, <code>brancher</code>, and <code>loader</code><code>^1</code>. Therefore, it depends on extensions that provide those features, and when parameters of those extensions change, it is reflected by the context refinement that the disassemble plugin is using to compute the key for storing the disassembled program in the cache storage.</p><p>In other words, it is important to specify explicitly features of your extensions, to ensure that any change in their configuration is reflected and propagated to the components that may depend on your extension.</p><p>Use the <code>bap list tags</code> command to list all semantics tags and plugins that provide them.</p><p><code>^1</code>: The list is not definitive and may change, consult the plugin documentation for the exhaustive and up-to-date list.</p><h3 id="the-command-line-interface"><a href="#the-command-line-interface" class="anchor"></a>The Command Line Interface</h3><p>The <code>Bap_main</code> library provides a few functions that could be used to create composable command line interfaces. The final grammar specification is build from pieces and is having the following EBNF definition:</p><pre>    G =
      | &quot;bap&quot;, common-options
      | &quot;bap&quot; &quot;&lt;command1&gt;&quot;, command1-grammar, common-options
      ..
      | &quot;bap&quot; &quot;&lt;commandN&gt;&quot;, commandN-grammar, common-options

    common-options =
      | &quot;&quot;
      | {&quot;-L&quot;, [=], string}
      | {&quot;--load-path&quot;, [=], string}
      | {&quot;--plugin-path&quot;, [=], string}
      | [&quot;--log-dir&quot;, [=], string | &quot;--log-dir&quot;, [=], string]
      | &quot;--recipe&quot;, recipe-grammar
      | &quot;--version&quot;
      | &quot;--help&quot;, [[=], help-format]
      | &quot;--help-&lt;plugin1&gt;&quot;, [[=], help-format]
      ...
      | &quot;--help-&lt;pluginN&gt;&quot;, [[=], help-format]
      | &quot;--&lt;plugin1&gt;&quot;
      ...
      | &quot;--&lt;pluginN&gt;&quot;
      | &quot;--no-&lt;plugin1&gt;&quot;
      ...
      | &quot;--no-&lt;pluginN&gt;&quot;
      | plugin1-grammar
      ...
      | pluginN-grammar</pre><p>Each command can define its own syntax and use the full power of the command line (including positional arguments and short keys) as long as it doesn't introduce conflicts with the <code>common-options</code> grammar.</p><p>The <code>common-options</code> grammar defines the syntax that is used to specify plugin configuration parameters. Each plugin can register its own parameters, but in a restricted way, e.g., no positional arguments, all parameter names must be long and will be automatically prefixed with the plugin name. Plugins configuration parameters form the configuration context for each invocation of BAP. These parameters also do not need an access to the command line, and could be specified via configuration files, environment, etc.</p><p>A couple of predefined rules are added to the <code>common-options</code> grammar. First of all, for each registered <code>&lt;plugin&gt;</code> the <code>&quot;--no-&lt;plugin&gt;&quot;</code> option is added, which if specified, will disable the plugin. A disabled plugin will still contribute to the command line grammar, but the extensions which are registered with it will not be loaded. Unless the extension is the command itself, which will be still evaluated if selected on the command line.</p><p>Also, for each registered <code>&lt;plugin&gt;</code> an option <code>--&lt;plugin&gt;</code> will be added to enable the backward compatibility with the old style of specifying passes.</p><p>Another rule which is added on per plugin basis, is the <code>--help-&lt;plugin&gt;</code> rule which will render a manual page for the given <code>&lt;plugin&gt;</code>.</p><p>The <code>-L</code> and <code>--logdir</code> options are preparsed on the command line and are used to specify the plugins search path (which obviously should be specified before we can load plugins) and the logging destination which we would like to know as soon as possible.</p><p>The <code>--recipe</code> option is very special, as it changes the command line itself. Every occurrence of the <code>--recipe</code> option will parse the provided recipe, which will be evaluated to the list of arguments which will be substituted instead of the specified <code>--recipe</code> option. See <code>bap recipes</code> for more information about the recipes.</p><p>Finally, the common <code>--version</code> and <code>--help</code> options are added with an expected semantics.</p><p>For the detailed description of the command line interface read the manual page generated with <code>bap --help</code>.</p><p>Note, the actual parser is less strict than the grammar and may accepts inputs that are not recognized by the grammar.</p></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code><code> = </code><code>..</code></dt><dd><p>describes an error condition.</p></dd></dl><dl><dt class="spec type" id="type-ctxt"><a href="#type-ctxt" class="anchor"></a><code><span class="keyword">type</span> ctxt</code></dt><dd><p>captures the evaluation context.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>?&#8288;features:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;requires:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;library:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;argv:<span>string array</span></span> <span>&#45;&gt;</span> <span>?&#8288;env:<span>(string <span>&#45;&gt;</span> <span>string option</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;log:<span>[ <span>`Formatter of <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a></span> <span><span>| `Dir</span> of string</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;out:<a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a></span> <span>&#45;&gt;</span> <span>?&#8288;err:<a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a></span> <span>&#45;&gt;</span> <span>?&#8288;man:string</span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span>?&#8288;version:string</span> <span>&#45;&gt;</span> <span>?&#8288;default:<span>(<a href="index.html#type-ctxt">ctxt</a> <span>&#45;&gt;</span> <span><span>(unit,Â <a href="index.html#type-error">error</a>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;default_command:string</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(unit,Â <a href="index.html#type-error">error</a>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></code></dt><dd><p><code>init ()</code> initializes the BAP framework.</p><p>Attention: function is only needed when BAP framework is embedded in another application. It shall not be called in BAP plugins. If you're not sure whether you need to call it, then don't call it.</p><p>The <code>init ()</code> expression evaluates to <code>Ok ()</code> if the system initialization terminated normally and is fully complete. It returns <code>Error condition</code> in case if the evaluation terminated abnormally with the <code>condition</code> value that describes the reasons and consequences of this abnormal termination (note, despite the name, it is not always an error, e.g., a user may have requested the help message, using the --help command).</p><p>If <code>init ()</code> terminates with any value other that <code>Ok ()</code> the BAP framework is considered to be unitialized and shouldn't be used.</p><p>The initialization procedure uses the provided parameters to evaluate command line and environment arguments, loads the requested plugins and dispatches commands if any are requested through the command line.</p><p>This function could be invoked only once per lifetime of a process, and consecutive</p><p>@parameter features, if specified, denotes a set of features of an application that extensions can expect. Extensions that require a feature which is not in the <code>features</code> provided by the application will not be evaluated.</p><p>@parameter requires if specified then only those extensions that provide at least one feature in <code>requires</code> will be evaluated.</p><p>@parameter library specifies a list of folders that will be prepended to the plugins search paths list (which already contains some precompiled location and the value of the BAP_PLUGIN_PATH environment variable, which in turn could also be a list).</p><p>@parameter argv is the array of command line arguments, with the first value being the program name. If not specified, then it defaults to <code>[|Sys.progname|]</code>, i.e., no command line arguments will be evaluated. If you want to let <code>init</code> process the command line passed to the process, use the <code>Sys.argv</code> variable.</p><p>@parameter env, if specified, then this function will be used to access environment variables. Otherwise, the environment variables are looked up using the <code>Sys.getenv</code> function.</p><p>@parameter log, if specified, then the specified location will be used for logging. If <code>`Formatter ppf</code> is passed then all log messages will be printed into <code>ppf</code> (every message is flushed). If <code>`Dir path</code> is passed, then all log messages will be printed in the <code>Filename.concat path &quot;log&quot;</code> file. If such file exists, then it will be renamed to &quot;log~1&quot;, if &quot;log~1&quot;, in turn, exists, it will will be renamed to &quot;log~2&quot; and so on, until &quot;log~99&quot; is reached, which will be discarded. If the <code>log</code> parameter is not specified, then the logging will be performed in a directory which name is obtained either from the command line (via the <code>--logdir</code> parameter) or from the environment (using the <code>BAP_LOG_DIR</code> variable). If neither is present then the logging will be performed into a directory prescribed by the XDG standard for the application - i.e., to the `$XDG_STATE_HOME/bap`, where the environment variable <code>XDG_STATE_HOME</code> defaults to <code>$HOME/.local/state</code>. If, for some reason, it wasn't possible to create a log file, then logging will fallback to the <code>stderr</code> channel. Note, a usual log rotating routine will be applied in the log directory, as described above.</p><p>@parameter out if specified, then this channel will be used to report help and other informational messages, if such are requested through command line.</p><p>@parameter err if specified, then this channel will be used to report error and other diagnostic messages in case of configuration problems. Nothing will be printed in this channel if the initialization procedure went normally (and evaluated to <code>Ok ()</code>).</p><p>@parameter man is the manual describing the purposes and basic usage of the utility in which bap is embedded. It is useful if the host program is going to use BAP command line parsing facilities, so it will be rendered when the <code>--help</code> option is specified. A simple markdown syntax is understood, i.e., paragraphs, section headers, itemized lists, and verbatim code sections.</p><p>@parameter name is used as the name of the process. If not specified, then <code>Sys.progname</code> is used.</p><p>@parameter version defaults to the BAP Framework version.</p><p>@parameter default, if specified, then this function will be invoked when no command line arguments were provided.</p><p>@parameter default_command, if specified, then this command will be used when command line arguments are provided but do not specify a command. </p><dl><dt>since</dt><dd>2.1.0.</dd></dl></dd></dl><dl><dt class="spec module" id="module-Extension"><a href="#module-Extension" class="anchor"></a><code><span class="keyword">module</span> <a href="Extension/index.html">Extension</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Writing and declaring BAP extensions.</p></dd></dl></div></body></html>