<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Std (bap-future.Bap_future.Std)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap-future</a> &#x00BB; <a href="../index.html">Bap_future</a> &#x00BB; Std</nav><header class="odoc-preamble"><h1>Module <code><span>Bap_future.Std</span></code></h1><p>Future library.</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#notion-of-time">Notion of time</a></li><li><a href="#main-loop">Main-loop</a></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>The purpose of the library is to provide mechanisms for reasoning about state based dynamic system. Due to a separation of concerns, the library allows to reason about such system purely mathematically, without any dependency on the actual representation of the state, or how the dynamism is handled. Putting it more simple, the library allows to reason about mathematical objects, whose value changes with time. Such objects, are usually model some complex systems with a hidden state, that can be only observed. This kind of systems is hard and practically impossible to describe using inductive types. We reify such systems with coinduction. The library defines two main coinductive types: <code>future</code> and <code>stream</code>. The <code>future</code> type is dual of the option type (a co-option), and <code>stream</code> is a dual of the list (co-list).</p><p>A value of type <code>future</code> is an object, with some observable state, that is not yet defined. We know, that it might happen, but it is not guaranteed. The <code>future</code> can be defined only once. Once it is defined, it cannot be changed. Basically, the time line of the <code>future</code> object is separated into two phases: on a first phase the value of the object is undefined, and on the second it is defined and fixed. Both phases can be empty, i.e., an object can be brought into life with a defined value, and an undefined future, might be never defined.</p><p>A value of type <code>stream</code> is an infinite sequence of finite values. More precisely, a stream can be viewed as an object, whose value varies in time.</p><p>The library can be also seen as a common denominator between different async libraries and methods, e.g., lwt, async, threads, forthcoming effective programming in multicore OCaml, etc. For example, the <code>future</code> are quite similar to the <code>Lwt.t</code> in <code>Lwt</code> library and to the <code>Deferred.t</code> of the <code>Async</code> library. There are few differences, however. The <code>future</code> library tries to separate concerns, so unlike <code>Lwt</code> or <code>Async</code> libraries, future can't fail. In other words, if a computation that computes the <code>future</code> fails, that just means, that this particular future has never occurred. If a user wants to represent a future value, that can fail or succeed, that he is welcome to use sum types, e.g., <code>('a,'b) Result.t future</code>. The same is true for the async library.</p><h2 id="notion-of-time"><a href="#notion-of-time" class="anchor"></a>Notion of time</h2><p>The future library handles time in a special way. The notion of physical time is replaced with the notion of order. We consider only the precedence of events. There is no notion of simultaneity built into the model of the library. Every event occurs in its own separate time slot, i.e., all events are serialized in the time.</p><p>That is not to say, that simultaneous events are not representable. The library just allows a user, to engineer its own timescale and define, what is simultaneous and what is not. For example, a clock timer can be represented as a stream of seconds, and everything that occurs after the start of the <code>n</code>'th second, but before the start of the <code>n+1</code>'th second, is simultaneous.</p><h2 id="main-loop"><a href="#main-loop" class="anchor"></a>Main-loop</h2><p>Since the internal state of the dynamic system is usually impossible to represent, it is modeled by a notion of primitive signals and promises. When a future is created a corresponding promise is made. The system, that models the dynamic system is responsible to fulfill the promise. A signal is akin to the promise, with only difference, that it can (and should) be fulfilled, or signaled, more than once.</p><p>The use of promises and signals is totally under a user control and is separated from the rest of the library. They can be signaled from event loops, such as Lwt or Async main loops, or from a window system event loop. The only requirement, is that this calls should be serialized, if it is possible that they are made from different threads.</p><p>A common way to bind <code>Lwt</code> thread with <code>Future</code> is to use <code>on_success</code> function (or <code>upon</code> function for <code>Async</code>'s <code>Deferred</code>):</p><pre><code>let future_of_thread t =
  let future,promise = Future.create () in
  Lwt.on_success t (Promise.fulfill promise);
  future</code></pre><div class="odoc-spec"><div class="spec type" id="type-future" class="anchored"><a href="#type-future" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a future</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-promise" class="anchored"><a href="#type-promise" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a promise</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-stream" class="anchored"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a stream</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-signal" class="anchored"><a href="#type-signal" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a signal</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Applicable" class="anchored"><a href="#module-Applicable" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Applicable/index.html">Applicable</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Variadic" class="anchored"><a href="#module-Variadic" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Variadic/index.html">Variadic</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Variadic arguments.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Future" class="anchored"><a href="#module-Future" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Future/index.html">Future</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Future is an object whose value will be decided somewhere in the future, if that future has occurred.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Promise" class="anchored"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An promise to provide a value in a future.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Stream" class="anchored"><a href="#module-Stream" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Stream/index.html">Stream</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A stream of elements.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Signal" class="anchored"><a href="#module-Signal" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Signal/index.html">Signal</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A handler to produce elements in streams.</p></div></div></div></body></html>