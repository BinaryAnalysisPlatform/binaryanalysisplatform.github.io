<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Variadic (bap-future.Bap_future.Std.Variadic)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap-future</a> &#x00BB; <a href="../../index.html">Bap_future</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Variadic</nav><h1>Module <code>Std.Variadic</code></h1><p>Variadic arguments.</p><p><code>Variadic</code>, abstracts a common idiom of a function applied to a variable number of arguments. A common examples of such function would be OCaml's standard <code>printf</code> and <code>scanf</code> functions. A more general examples, are monadic parsers, such as <code>MParser</code>, command line parsers such as <code>Cmdliner</code> and <code>Core</code>'s <code>Command</code>. They all are using the same trick to collect arguments of different type and pass it to a function, s.t. the function type actually defines the type of collected arguments. Both <code>Cmdliner</code> and <code>Command</code> relies on <code>Applicative</code> functor defined in <code>1</code>. However, it requires a <code>return</code> function, that is not possible to provide in general for co-inductive types, that can only be observed or mapped. It is still possible to implement a variadic interface using the restricted <code>Applicable</code> interface given only one restriction: it is not possible to create an empty variadic list of arguments (that can be considered as a benefit).</p><p>Here are some examples, that highlights common use cases of the variadic structure. Suppose, we have several future values of different types, that we would like to merge with some function <code>f</code>, to be concrete let's assume, that we're waiting for:</p><p><code>arch : arch future</code> - program architecture to be defined; <code>lang : lang future</code> - a programming language; <code>abi  : abi future</code> - an ABI; <code>api  : api future</code> - an api specification</p><p>And we have a function <code>typecheck</code> of type</p><pre><code class="ml">arch -&gt; lang -&gt; abi -&gt; api -&gt; pass future</code></pre><p>,</p><p>that will typecheck a binary program, according to the typing rules of the specified programming <code>lang</code>uage, binary interface, and type environment <code>api</code>. Given the <code>Variadic</code> interface we can write it as</p><p><code>Future.Variadic.(apply (args arch $lang $abi $api) ~f:typecheck</code></p><p>Note, since future implements a more powerful Monad interface, it is still possible to apply a <code>typecheck</code> function without using the variadic interface, e.g.,</p><pre><code class="ml">arch &gt;&gt;= fun arch -&gt;
lang &gt;&gt;= fun lang -&gt;
abi &gt;&gt;= fun abi -&gt;
api &gt;&gt;= fun api -&gt;
typecheck arch lang abi api</code></pre><p>However, this is less general, as it specifies a concrete order of argument bindings, it is also requires a much less general monad interface with bind and return operations, that are in general not available for coinductive types, for example for <code>stream</code> type. If we substitute <code>future</code> type constructor in the above example with a <code>stream</code> constructor we will no be able to implement the latter solution, as we lack the monad interface.</p><p>Using a stream for this particular example, makes sense, since, the specified properties, can be defined on a module level, so they can be defined multiple times for each project. In that case function typecheck will be applied for each quartet of the arguments.</p><p>When used with collections, such as list, sequences, sets, etc, the pattern can be used to generalize cartesian product from a function taking a pair of arguments, to a function taking arbitrary amount of arguments.</p><p>For collection, the Variadic can be used to generalize cartesian product to <code>N</code> arguments:</p><pre><code class="ml">module AList = struct
  include List
  let apply fs xs =
    cartesian_product fs xs &gt;&gt;| fun (f,x) -&gt; f x
end
module Varags = Variadic.Make(AList)

let cartesian_product = Varags.apply</code></pre><p>For option and error monad, with the following definition of <code>apply</code>,</p><pre><code class="ml">let apply f x = match f,x with
          | Some f, Some x -&gt; Some (f x)
          | None -&gt; None</code></pre><p>The produced <code>Varargs.apply</code> will be a generalization of <code>Option.merge</code>, i.e., it will apply function <code>f</code> to <code>N</code> arguments of different types, if all of them are not zero (i.e., <code>None</code>, <code>Error</code>.</p><dl><dt>see <a href="http://staff.city.ac.uk/~ross/papers/Applicative.pdf">http://staff.city.ac.uk/~ross/papers/Applicative.pdf</a></dt><dd><pre>      [1]: Applicative Programming with Effects.
           Conor McBride and Ross Paterson.
           Journal of Functional Programming 18:1 (2008), pages 1-13.</pre></dd></dl></header><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Variadic argument list.</p></dd></dl><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-T/index.html">T</a> : <a href="../Applicable/index.html#module-type-S">Applicable.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="Make/index.html#type-arg">arg</a> = <span class="type-var">'a</span> <a href="Make/argument-1-T/index.html#type-t">T.t</a></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="index.html#module-type-S">S</a>.arg = <span class="type-var">'a</span></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> ('f, 'r) t</code></dt><dd><p><code>('f,'r) t</code> is a list of arguments, where <code>'f</code> defines the arrow type of the arguments, and <code>'r</code> is the return type. C.f., <code>'f</code> and <code>'r</code> with the first and last parameter of the <code>format</code> type constuctor.</p></dd></dl><dl><dt class="spec type" id="type-arg"><a href="#type-arg" class="anchor"></a><code><span class="keyword">type</span> 'a arg</code><code> = <span class="type-var">'a</span></code></dt></dl><dl><dt class="spec value" id="val-args"><a href="#val-args" class="anchor"></a><code><span class="keyword">val</span> args : <span class="type-var">'a</span> <a href="index.html#type-arg">arg</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>, <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>args x</code> creates a singleton list of arguments that can be applied to a function that takes <code>x</code> argument, and returns a value of type <code>'b</code>.</p></dd></dl><dl><dt class="spec value" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val</span> ($) : (<span class="type-var">'a</span>, <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-arg">arg</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>args $x</code> appends argument <code>x</code> to a list of arguments <code>args</code>.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : f:<span class="type-var">'f</span> <span>&#45;&gt;</span> (<span class="type-var">'f</span>, <span class="type-var">'r</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'r</span> <a href="index.html#type-arg">arg</a></code></dt><dd><p><code>apply args ~f</code> applies function <code>f</code> to arguments <code>args</code>.</p></dd></dl></details></div></div></div></div></body></html>