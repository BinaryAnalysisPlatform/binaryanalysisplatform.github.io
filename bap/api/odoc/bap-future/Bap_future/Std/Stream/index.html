<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (bap-future.Bap_future.Std.Stream)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">bap-future</a> &#x00BB; <a href="../../index.html">Bap_future</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Stream</nav><header class="odoc-preamble"><h1>Module <code><span>Std.Stream</span></code></h1><p>A stream of elements.</p><p>A stream is an infinite sequence of elements. Since the stream is defined coinductively it can be processed only corecursively. That means that in general, one cannot aggregate a stream into normal (inductive) data. But it is still possible to get an aggregate snapshot of some intermediate state in the form of futures.</p><p>Streams can be observed and combined. There is no built in notion of the end of stream and all streams are considered infinite. It is still possible to simulate an end of stream, by using futures, that designates the end of stream condition.</p><p>Streams can be made lazy in the sense that if no one is watching a stream, then no work should be performed to feed the stream. This requires some cooperation from the feeder, as it should use <code>on_subscribe</code> and <code>on_unsubscribe</code> functions, to react on user's subsriptions. The <code>has_subscribers</code> is also useful.</p><p>Streams also provide some mechanism for a pushback, that allows a cooperative sink to limit his rate. The pushback interface consists of two functions:</p><ul><li><code>wait</code> that should be called by a consumer, when it wants to ask a producer to wait for a moment;</li></ul><ul><li><code>on_wait</code> that is called when any consumer requested for a pause.</li></ul><p>The pushback interface is not mandatory.</p></header><nav class="odoc-toc"><ul><li><a href="#subscriber-interface">Subscriber interface</a></li><li><a href="#publisher-interface">Publisher interface</a></li><li><a href="#combinators">Combinators</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../index.html#type-stream">stream</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-id" class="anchored"><a href="#type-id" class="anchor"></a><code><span><span class="keyword">type</span> id</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Variadic" class="anchored"><a href="#module-Variadic" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Variadic/index.html">Variadic</a></span><span> : <a href="../Variadic/module-type-S/index.html">Variadic.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../Variadic/module-type-S/index.html#type-arg">arg</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></div><div class="spec-doc"><p>Applying function to multiple streams.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="../index.html#type-signal">signal</a></span></span></code></div><div class="spec-doc"><p><code>create ()</code> returns a stream and a signal handler that is used to feed the stream. Every time a value is signaled, it will occur in the stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from" class="anchored"><a href="#val-from" class="anchor"></a><code><span><span class="keyword">val</span> from : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span></span></code></div><div class="spec-doc"><p><code>from f</code> returns a stream that is generated from successive applications of a function <code>f</code>. A new value is produced by a stream, every time it is signaled with associated signal handler.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span></span></code></div><div class="spec-doc"><p><code>unfold ~init ~f</code> a more general than <code>from</code> way of building a stream, that allows to pass state between consecutive invocations of the generator function. A new value is produced by a stream, every time it is signaled with an associated signal handler.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold_until" class="anchored"><a href="#val-unfold_until" class="anchor"></a><code><span><span class="keyword">val</span> unfold_until : <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span> * <span>unit <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>unfold_until ~init ~f</code> returns <code>(stream,signal,future)</code> is the same as <code>unfold</code>, except that function <code>f</code> is called until it returns a <code>None</code> value. Once this happens, the <code>future</code> becomes determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold'" class="anchored"><a href="#val-unfold'" class="anchor"></a><code><span><span class="keyword">val</span> unfold' : <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Queue.t</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span></span></code></div><div class="spec-doc"><p><code>unfold' ~init ~f</code> is a batched version of the <code>unfold</code> function. A new value is produced by a stream, every time it is signaled with associated signal handler.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span></span></code></div><div class="spec-doc"><p><code>repeat x</code> returns a stream <code>xs</code> and a signal <code>s</code>. Every time <code>s</code> is signaled stream <code>xs</code> will produce a value <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span> * <span>unit <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>of_list xs</code> returns a stream <code>ss</code>, a signal <code>s</code> and a future <code>es</code>. Stream will produce consequently elements of <code>xs</code> every time the signal <code>s</code> is sent. Once all elements are produced the future <code>es</code> will occur signifying the end of the underlying sequence. All consecutive signals from <code>es</code> are ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array" class="anchored"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span> * <span>unit <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>of_array xs</code> returns a stream <code>ss</code>, a signal <code>s</code> and a future <code>es</code>. Stream will produce consequently elements of <code>xs</code> every time the signal <code>s</code> is sent. Once all elements are produced the future <code>es</code> will occur signifying the end of the underlying sequence. All consecutive signals from <code>es</code> are ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_sequence" class="anchored"><a href="#val-of_sequence" class="anchor"></a><code><span><span class="keyword">val</span> of_sequence : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span>unit <a href="../index.html#type-signal">signal</a></span> * <span>unit <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>of_seq xs</code> returns a stream <code>ss</code>, a signal <code>s</code> and a future <code>es</code>. Stream will produce consequently elements of <code>xs</code> every time the signal <code>s</code> is sent. Once all elements are produced the future <code>es</code> will occur signifying the end of the underlying sequence. All consecutive signals from <code>es</code> are ignored.</p></div></div><h3 id="subscriber-interface"><a href="#subscriber-interface" class="anchor"></a>Subscriber interface</h3><p>In order to start to monitor a stream, a user should subscribe to the stream using one of the subscription functions: <code>watch</code>, <code>observe</code>, <code>subscribe</code>.</p><p>The subscription can be canceled by using an <code>unsubscribe</code> function, or by throwing an exception from the callback function. The latter plays well with `with_return` function.</p><div class="odoc-spec"><div class="spec value" id="val-watch" class="anchored"><a href="#val-watch" class="anchor"></a><code><span><span class="keyword">val</span> watch : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>watch s f</code> watches a stream <code>s</code> with a function <code>f</code>. A subscription identifier is passed to the function, so it can be used to unsubscribe from the stream directly from the function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-observe" class="anchored"><a href="#val-observe" class="anchor"></a><code><span><span class="keyword">val</span> observe : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>observe s f</code> is like <code>watch</code> but a subscription identifier is not passed to the function <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-subscribe" class="anchored"><a href="#val-subscribe" class="anchor"></a><code><span><span class="keyword">val</span> subscribe : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-id">id</a></span></code></div><div class="spec-doc"><p><code>subscribe s f</code> subscribe to a stream <code>s</code> with a function <code>f</code>. A subscription identifier is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsubscribe" class="anchored"><a href="#val-unsubscribe" class="anchor"></a><code><span><span class="keyword">val</span> unsubscribe : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unsubscribe s id</code> stop calling a function that was has a provided identifier <code>id</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-wait" class="anchored"><a href="#val-wait" class="anchor"></a><code><span><span class="keyword">val</span> wait : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>wait xs</code> a polite way to notify a producer to slow down. Note: producer is not required to obey.</p></div></div><h3 id="publisher-interface"><a href="#publisher-interface" class="anchor"></a>Publisher interface</h3><div class="odoc-spec"><div class="spec value" id="val-has_subscribers" class="anchored"><a href="#val-has_subscribers" class="anchor"></a><code><span><span class="keyword">val</span> has_subscribers : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_subscribers s</code> is true if someone is watching for the stream</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_subscribe" class="anchored"><a href="#val-on_subscribe" class="anchor"></a><code><span><span class="keyword">val</span> on_subscribe : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>on_subscribe s f</code> will call a function <code>f</code> every time someone is subscribed to a stream <code>s</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_unsubscribe" class="anchored"><a href="#val-on_unsubscribe" class="anchor"></a><code><span><span class="keyword">val</span> on_unsubscribe : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>on_unsubscribe s f</code> will call a function <code>f</code> every time someone has canceled subscription to a stream <code>s</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_wait" class="anchored"><a href="#val-on_wait" class="anchor"></a><code><span><span class="keyword">val</span> on_wait : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>on_wait s f</code> will be called every time someone, watching a stream <code>s</code>, will call <code>wait s</code> to ask a producer to slow down.</p></div></div><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3><div class="odoc-spec"><div class="spec value" id="val-map'" class="anchored"><a href="#val-map'" class="anchor"></a><code><span><span class="keyword">val</span> map' : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Core_kernel</span>.Queue.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>s' = map' s ~f</code> apply function <code>f</code> for each value of a stream <code>s</code> and push values from a resulting queue into the stream <code>s'</code>. Example:</p><pre><code>let q,p = of_list ['a','b','c', '.']
let q' = map q ~f:(function
    | 'a'..'z' as c -&gt;
      Queue.of_list Char.[uppercase c; lowercase c]
    | c -&gt; Queue.singleton c</code></pre><p>Will produce:</p><p><code>&lt;A; a; B; b; C; c; .&gt;</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map ss ~f</code> returns new stream, that is build by application of a function <code>f</code> to each element of the stream <code>ss</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map s ~f</code> for each value <code>x</code> in stream <code>s</code>, produce <code>y</code> if <code>f x</code> is <code>Some y</code>, otherwise ignore <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter s f</code> produce a stream that contains the elements of stream <code>s</code>, for which <code>f</code> evaluates to true.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-either" class="anchored"><a href="#val-either" class="anchor"></a><code><span><span class="keyword">val</span> either : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Core_kernel</span>.Either.t</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>either xs ys</code> is a discriminated union of two streams.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>merge xs ys f</code> merges streams <code>xs</code> and <code>ys</code> using function <code>f</code>. To merge an arbitrary number of streams use the <a href="Variadic/index.html"><code>Variadic</code></a> interface.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply" class="anchored"><a href="#val-apply" class="anchor"></a><code><span><span class="keyword">val</span> apply : <span><span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>apply fs xs</code> apply stream of functions <code>fs</code> to a stream of values xs, producing a stream of results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>concat ss</code> returns a stream that will produce elements from the input list of streams <code>ss</code>. The ordering of the elements of different streams is unspecified, though it is guaranteed that elements of the same stream will preserve their ordering.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_merge" class="anchored"><a href="#val-concat_merge" class="anchor"></a><code><span><span class="keyword">val</span> concat_merge : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>concat_merge xs ~f</code> builds a stream, that will produce elements from the input list and applies <code>f</code> to all consecutive elements. The ordering of the input list does not mandate the ordering of elements in the output stream, and is undefined. See <code>concat</code> for more information.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split xs ~f</code> returns a pair of streams, where the first stream contains <code>fst (f x)</code> for each <code>x</code> in <code>xs</code> and the second stream contains <code>snd (f x)</code> for each <code>x</code> in <code>xs</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip" class="anchored"><a href="#val-zip" class="anchor"></a><code><span><span class="keyword">val</span> zip : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zip xs ys</code> creates a steam that will produce an element <code>(x,y)</code> every time both <code>xs</code> and <code>ys</code> produce elements <code>x</code> and <code>y</code> respectively</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip" class="anchored"><a href="#val-unzip" class="anchor"></a><code><span><span class="keyword">val</span> unzip : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unzip xs</code> creates a pair of streams, where the first stream contains <code>fst x</code> for each <code>x</code> in <code>xs</code> and the second stream contains <code>snd x</code> for each <code>x</code> in <code>xs</code>. Essentially, the same as <code>split ~f:ident</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-once" class="anchored"><a href="#val-once" class="anchor"></a><code><span><span class="keyword">val</span> once : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>once xs</code> creates a stream that will at most contain the next value produced by <code>xs</code> and nothing more.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-parse" class="anchored"><a href="#val-parse" class="anchor"></a><code><span><span class="keyword">val</span> parse : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>parse ss ~init ~f</code> parses stream <code>ss</code> and builds new stream <code>ss'</code>. Function <code>f</code> is applied to each consecutive element of the stream <code>ss</code> with a state <code>s</code>. If function <code>f</code> returns <code>None,s'</code>, then no value is produced in the output state and state <code>s'</code> is passed to the next invocation of function <code>f</code>. If it returns <code>Some x, s'</code>, then value <code>x</code> is produced by the output stream and state <code>s'</code> is passed to a consecutive invocation of <code>f</code>. If it state type <code>'b</code> is an instance of a list type, then parse will be a push down automaton. With arbitrary type of state it is possible to build automatons that falls between PDA and Turing Machine (not including the latter).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldw" class="anchored"><a href="#val-foldw" class="anchor"></a><code><span><span class="keyword">val</span> foldw : <span>?stride:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>foldw ss n ~init ~f</code> performs a windowed fold of the stream. A function <code>f</code> is folded over <code>n</code> consecutive elements of <code>ss</code>, then the result is produced into the output stream, the window is shifted by <code>stride</code> (defaults to one) and function <code>f</code> applied to the next <code>n</code> elements. For example, if stream <code>ss</code> produced the following sequence of elements:</p><pre><code>1,2,3,4,5,6,7,8</code></pre><p>and windows length <code>n</code> is equal to <code>3</code>, then the function <code>f</code> will be applied to a sequences:</p><pre><code>[1,2,3], [2,3,4], [3,4,5], [4,5,6], [5,6,7], [6,7,8]</code></pre><p>.</p><p>Example, a moving average filter implemented with <code>foldw</code>:</p><pre><code>let moving_average ss n =
  Float.(foldw ss n ~init:zero ~f:(+) &gt;&gt;| fun s / of_int n)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-frame" class="anchored"><a href="#val-frame" class="anchor"></a><code><span><span class="keyword">val</span> frame : <span>clk:<span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>frame ~clk s ~init ~f</code> will gather elements of <code>s</code> into frames, where the start of the new frame is signaled by a stream <code>clk</code>. The function is very similar to <code>foldw</code> except, that the window is determined dynamically by a <code>clk</code> stream. This function is useful to build custom time scales.</p><p>The semantics of the function can be clarified with the following description: 1. Every time a stream <code>s</code> produces a value it is buffered 2. Every time a stream <code>clk</code> produces a value, a function <code>f</code> is folded over all buffered value, and the result is put into the output stream. The internal buffer is cleared afterwards.</p><p>Example -------</p><p>Consider the following timing diagram, where each row represents a stream, and columns represent time. Elements of the <code>clk</code> stream are depicted with a <code>T</code> symbol.</p><pre>          clk:    T         T        T  T      T     T
           ss: 123 56 123 12  1234 4      1234  1</pre><p>will be framed in the following way:</p><p><code>[123], [5612312], [12344], [], [1234], [1]</code></p><p>Note: since all streams should be serialized it is impossible, that two events occur at the same time. So at the same column of the timing diagram there can be only one event.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sample" class="anchored"><a href="#val-sample" class="anchor"></a><code><span><span class="keyword">val</span> sample : <span>clk:<span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sample ~clk ss</code> is semantically the same as <code>frame ~clk ss &gt;&gt;| fst</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-hd" class="anchored"><a href="#val-hd" class="anchor"></a><code><span><span class="keyword">val</span> hd : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>hd s</code> returns a <code>future</code> that will occur as soon, as stream <code>s</code> will produce a value. Note: if <code>hd</code> is called on a stream, that already produced some values, the returned future will still be fulfilled on the first value, that will be put into the stream after the future is created.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tl" class="anchored"><a href="#val-tl" class="anchor"></a><code><span><span class="keyword">val</span> tl : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>tl s</code> ignores the next occurrence in the stream <code>s</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>find xs f</code> returns a future that will be fulfilled with a first value for which a function <code>f</code> is <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>find_map xs f</code> returns a future that will be fulfilled by a result of a first invocation of <code>f</code> to an element of the stream, that evaluated to <code>Some</code> value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>take xs n</code> returns a future that will evaluate to <code>n</code> values of the stream <code>xs</code> that has occurred after the future was created.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>nth xs n</code> returns <code>n</code>'th element of the stream <code>xs</code>. The element is <code>n</code>'th with respect to the future <code>f</code>, if was <code>n</code>'th element of the stream after the creation of the stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-upon" class="anchored"><a href="#val-upon" class="anchor"></a><code><span><span class="keyword">val</span> upon : <span><span>unit <a href="../index.html#type-future">future</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>upon e xs</code> returns a future that will be fulfilled with a last value of a stream <code>xs</code> before an event <code>e</code> has occurred. If at the time when the event <code>e</code> occurs, the stream <code>xs</code> didn't produce any elements, then the future will not be fulfilled.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-before" class="anchored"><a href="#val-before" class="anchor"></a><code><span><span class="keyword">val</span> before : <span><span>unit <a href="../index.html#type-future">future</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>before e xs</code> returns a list that contains elements of the stream <code>xs</code> that occurred before the event <code>e</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-last_before" class="anchored"><a href="#val-last_before" class="anchor"></a><code><span><span class="keyword">val</span> last_before : <span><span>unit <a href="../index.html#type-future">future</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="../index.html#type-future">future</a></span></span></code></div><div class="spec-doc"><p><code>last_before e xs n</code> returns a list of length up to <code>n</code>, that contains last elements of the stream <code>xs</code> that occurred before the event <code>e</code></p></div></div></div></body></html>