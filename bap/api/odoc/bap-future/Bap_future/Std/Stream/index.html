<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (bap-future.Bap_future.Std.Stream)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">bap-future</a> &#x00BB; <a href="../../index.html">Bap_future</a> &#x00BB; <a href="../index.html">Std</a> &#x00BB; Stream</nav><h1>Module <code>Std.Stream</code></h1><p>A stream of elements.</p><p>A stream is an infinite sequence of elements. Since the stream is defined coinductively it can be processed only corecursively. That means that in general, one cannot aggregate a stream into normal (inductive) data. But it is still possible to get an aggregate snapshot of some intermediate state in the form of futures.</p><p>Streams can be observed and combined. There is no built in notion of the end of stream and all streams are considered infinite. It is still possible to simulate an end of stream, by using futures, that designates the end of stream condition.</p><p>Streams can be made lazy in the sense that if no one is watching a stream, then no work should be performed to feed the stream. This requires some cooperation from the feeder, as it should use <code>on_subscribe</code> and <code>on_unsubscribe</code> functions, to react on user's subsriptions. The <code>has_subscribers</code> is also useful.</p><p>Streams also provide some mechanism for a pushback, that allows a cooperative sink to limit his rate. The pushback interface consists of two functions:</p><ul><li><code>wait</code> that should be called by a consumer, when it wants to ask a producer to wait for a moment;</li></ul><ul><li><code>on_wait</code> that is called when any consumer requested for a pause.</li></ul><p>The pushback interface is not mandatory.</p><nav class="toc"><ul><li><a href="#subscriber-interface">Subscriber interface</a></li><li><a href="#publisher-interface">Publisher interface</a></li><li><a href="#combinators">Combinators</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> 'a t</code><code> = <span class="type-var">'a</span> <a href="../index.html#type-stream">stream</a></code></dt><dt class="spec type" id="type-id"><a href="#type-id" class="anchor"></a><code><span class="keyword">type</span> id</code></dt></dl><div class="spec module" id="module-Variadic"><a href="#module-Variadic" class="anchor"></a><code><span class="keyword">module</span> <a href="Variadic/index.html">Variadic</a> : <a href="../Variadic/index.html#module-type-S">Variadic.S</a> <span class="keyword">with</span> <span class="keyword">type</span> 'a <a href="../Variadic/module-type-S/index.html#type-arg">arg</a> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'a</span> <a href="../index.html#type-signal">signal</a></code></dt><dd><p><code>create ()</code> retuns a stream and a signal handler that is used to feed the stream. Every time a value is signaled, it will occur in the stream.</p></dd></dl><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a></code></dt><dd><p><code>from f</code> returns a stream that is generated from successive applications of a function <code>f</code>. A new value is produced by a stream, every time it is signaled with associated signal handler.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a></code></dt><dd><p><code>unfold ~init ~f</code> a more general than <code>from</code> way of building a stream, that allows to pass state between consecutive invocations of the generator function. A new value is produced by a stream, every time it is signaled with an associated signal handler.</p></dd></dl><dl><dt class="spec value" id="val-unfold_until"><a href="#val-unfold_until" class="anchor"></a><code><span class="keyword">val</span> unfold_until : init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a> * unit <a href="../index.html#type-future">future</a></code></dt><dd><p><code>unfold_until ~init ~f</code> returns <code>(stream,signal,future)</code> is the same as <code>unfold</code>, except that function <code>f</code> is called until it returns a <code>None</code> value. Once this happens, the <code>future</code> becomes determined.</p></dd></dl><dl><dt class="spec value" id="val-unfold'"><a href="#val-unfold'" class="anchor"></a><code><span class="keyword">val</span> unfold' : init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a></code></dt><dd><p><code>unfold' ~init ~f</code> is a batched version of the <code>unfold</code> function. A new value is produced by a stream, every time it is signaled with associated signal handler.</p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a></code></dt><dd><p><code>repeat x</code> returns a stream <code>xs</code> and a signal <code>s</code>. Every time <code>s</code> is signaled stream <code>xs</code> will produce a value <code>x</code></p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a> * unit <a href="../index.html#type-future">future</a></code></dt><dd><p><code>of_list xs</code> returns a stream <code>ss</code>, a signal <code>s</code> and a future <code>es</code>. Stream will produce consequently elements of <code>xs</code> every time the signal <code>s</code> is sent. Once all elements are produced the future <code>es</code> will occur signifying the end of the underlying sequence. All consecutive signals from <code>es</code> are ignored.</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a> * unit <a href="../index.html#type-future">future</a></code></dt><dd><p><code>of_array xs</code> returns a stream <code>ss</code>, a signal <code>s</code> and a future <code>es</code>. Stream will produce consequently elements of <code>xs</code> every time the signal <code>s</code> is sent. Once all elements are produced the future <code>es</code> will occur signifying the end of the underlying sequence. All consecutive signals from <code>es</code> are ignored.</p></dd></dl><dl><dt class="spec value" id="val-of_sequence"><a href="#val-of_sequence" class="anchor"></a><code><span class="keyword">val</span> of_sequence : <span class="type-var">'a</span> <a href="../../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * unit <a href="../index.html#type-signal">signal</a> * unit <a href="../index.html#type-future">future</a></code></dt><dd><p><code>of_seq xs</code> returns a stream <code>ss</code>, a signal <code>s</code> and a future <code>es</code>. Stream will produce consequently elements of <code>xs</code> every time the signal <code>s</code> is sent. Once all elements are produced the future <code>es</code> will occur signifying the end of the underlying sequence. All consecutive signals from <code>es</code> are ignored.</p></dd></dl><section><header><h3 id="subscriber-interface"><a href="#subscriber-interface" class="anchor"></a>Subscriber interface</h3><p>In order to start to monitor a stream, a user should subscribe to the stream using one of the subscription functions: <code>watch</code>, <code>observe</code>, <code>subscribe</code>.</p><p>The subscription can be canceled by using an <code>unsubscribe</code> function, or by throwing an exception from the callback function. The latter plays well with `with_return` function.</p></header><dl><dt class="spec value" id="val-watch"><a href="#val-watch" class="anchor"></a><code><span class="keyword">val</span> watch : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>watch s f</code> watches a stream <code>s</code> with a function <code>f</code>. A subscription identifier is passed to the function, so it can be used to unsubscribe from the stream directly from the function.</p></dd></dl><dl><dt class="spec value" id="val-observe"><a href="#val-observe" class="anchor"></a><code><span class="keyword">val</span> observe : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>observe s f</code> is like <code>watch</code> but a subscription identifier is not passed to the function <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-subscribe"><a href="#val-subscribe" class="anchor"></a><code><span class="keyword">val</span> subscribe : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-id">id</a></code></dt><dd><p><code>subscribe s f</code> subscribe to a stream <code>s</code> with a function <code>f</code>. A subscription identifier is returned.</p></dd></dl><dl><dt class="spec value" id="val-unsubscribe"><a href="#val-unsubscribe" class="anchor"></a><code><span class="keyword">val</span> unsubscribe : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-id">id</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>unsubscribe s id</code> stop calling a function that was has a provided identifier <code>id</code></p></dd></dl><dl><dt class="spec value" id="val-wait"><a href="#val-wait" class="anchor"></a><code><span class="keyword">val</span> wait : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>wait xs</code> a polite way to notify a producer to slow down. Note: producer is not required to obey.</p></dd></dl></section><section><header><h3 id="publisher-interface"><a href="#publisher-interface" class="anchor"></a>Publisher interface</h3></header><dl><dt class="spec value" id="val-has_subscribers"><a href="#val-has_subscribers" class="anchor"></a><code><span class="keyword">val</span> has_subscribers : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_subscribers s</code> is true if someone is watching for the stream</p></dd></dl><dl><dt class="spec value" id="val-on_subscribe"><a href="#val-on_subscribe" class="anchor"></a><code><span class="keyword">val</span> on_subscribe : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>on_subscribe s f</code> will call a function <code>f</code> every time someone is subscribed to a stream <code>s</code></p></dd></dl><dl><dt class="spec value" id="val-on_unsubscribe"><a href="#val-on_unsubscribe" class="anchor"></a><code><span class="keyword">val</span> on_unsubscribe : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-id">id</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>on_unsubscribe s f</code> will call a function <code>f</code> every time someone has canceled subscription to a stream <code>s</code></p></dd></dl><dl><dt class="spec value" id="val-on_wait"><a href="#val-on_wait" class="anchor"></a><code><span class="keyword">val</span> on_wait : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p><code>on_wait s f</code> will be called every time someone, watching a stream <code>s</code>, will call <code>wait s</code> to ask a producer to slow down.</p></dd></dl></section><section><header><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3></header><dl><dt class="spec value" id="val-map'"><a href="#val-map'" class="anchor"></a><code><span class="keyword">val</span> map' : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>s' = map' s ~f</code> apply function <code>f</code> for each value of a stream <code>s</code> and push values from a resulting queue into the stream <code>s'</code>. Example:</p><pre><code class="ml">let q,p = of_list ['a','b','c', '.']
let q' = map q ~f:(function
    | 'a'..'z' as c -&gt;
      Queue.of_list Char.[uppercase c; lowercase c]
    | c -&gt; Queue.singleton c</code></pre><p>Will produce:</p><p><code>&lt;A; a; B; b; C; c; .&gt;</code></p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map ss ~f</code> returns new stream, that is build by application of a function <code>f</code> to each element of the stream <code>ss</code></p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_map s ~f</code> for each value <code>x</code> in stream <code>s</code>, produce <code>y</code> if <code>f x</code> is <code>Some y</code>, otherwise ignore <code>x</code></p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter s f</code> produce a stream that contains the elements of stream <code>s</code>, for which <code>f</code> evaluates to true.</p></dd></dl><dl><dt class="spec value" id="val-either"><a href="#val-either" class="anchor"></a><code><span class="keyword">val</span> either : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="../../../../core_kernel/Core_kernel/Either/index.html#type-t">Core_kernel.Either.t</a> <a href="index.html#type-t">t</a></code></dt><dd><p><code>either xs ys</code> is a discriminated union of two streams.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>merge xs ys f</code> merges streams <code>xs</code> and <code>ys</code> using function <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">val</span> apply : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>apply fs xs</code> apply stream of functions <code>fs</code> to a stream of values xs, producing a stream of results.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat ss</code> returns a stream that will produce elements from the input list of streams <code>ss</code>. The ordering of the elements of different streams is unspecified, though it is guaranteed that elements of the same stream will preserve their ordering.</p></dd></dl><dl><dt class="spec value" id="val-concat_merge"><a href="#val-concat_merge" class="anchor"></a><code><span class="keyword">val</span> concat_merge : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>concat_merge xs ~f</code> builds a stream, that will produce elements from the input list and applies <code>f</code> to all consecutive elements. The ordering of the input list does not mandate the ordering of elemenets in the output stream, and is undefined. See <code>concat</code> for more information.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> * <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> * <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>split xs ~f</code> returns a pair of streams, where the first stream contains <code>fst (f x)</code> for each <code>x</code> in <code>xs</code> and the second stream contains <code>snd (f x)</code> for each <code>x</code> in <code>xs</code>.</p></dd></dl><dl><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">val</span> zip : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>zip xs ys</code> creates a steam that will produce an element <code>(x,y)</code> every time both <code>xs</code> and <code>ys</code> produce elements <code>x</code> and <code>y</code> respectively</p></dd></dl><dl><dt class="spec value" id="val-unzip"><a href="#val-unzip" class="anchor"></a><code><span class="keyword">val</span> unzip : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> * <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unzip xs</code> creates a pair of streams, where the first stream contains <code>fst x</code> for each <code>x</code> in <code>xs</code> and the second stream contains <code>snd x</code> for each <code>x</code> in <code>xs</code>. Essentially, the same as <code>split ~f:ident</code></p></dd></dl><dl><dt class="spec value" id="val-once"><a href="#val-once" class="anchor"></a><code><span class="keyword">val</span> once : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>once xs</code> creates a stream that will at most contain the next value produced by <code>xs</code> and nothing more.</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> option * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>parse ss ~init ~f</code> parses stream <code>ss</code> and builds new stream <code>ss'</code>. Function <code>f</code> is applied to each consecutive element of the stream <code>ss</code> with a state <code>s</code>. If function <code>f</code> returns <code>None,s'</code>, then no value is produced in the output state and state <code>s'</code> is passed to the next invocation of function <code>f</code>. If it returns <code>Some x, s'</code>, then value <code>x</code> is produced by the output stream and state <code>s'</code> is passed to a consecutive invocation of <code>f</code>. If it state type <code>'b</code> is an instance of a list type, then parse will be a push down automaton. With arbitrary type of state it is possible to build automatons that falls between PDA and Turing Machine (not including the latter).</p></dd></dl><dl><dt class="spec value" id="val-foldw"><a href="#val-foldw" class="anchor"></a><code><span class="keyword">val</span> foldw : ?&#8288;stride:int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>foldw ss n ~init ~f</code> performs a windowed fold of the stream. A function <code>f</code> is folded over <code>n</code> consecutive elements of <code>ss</code>, then the result is produced into the output stream, the window is shifted by <code>stride</code> (defaults to one) and function <code>f</code> applied to the next <code>n</code> elements. For example, if stream <code>ss</code> produced the following sequence of elements:</p><pre><code class="ml">1,2,3,4,5,6,7,8</code></pre><p>and windows length <code>n</code> is equal to <code>3</code>, then the function <code>f</code> will be applied to a sequences:</p><pre><code class="ml">[1,2,3], [2,3,4], [3,4,5], [4,5,6], [5,6,7], [6,7,8]</code></pre><p>.</p><p>Example, a moving average filter implemented with <code>foldw</code>:</p><pre><code class="ml">let moving_average ss n =
  Float.(foldw ss n ~init:zero ~f:(+) &gt;&gt;| fun s / of_int n)</code></pre></dd></dl><dl><dt class="spec value" id="val-frame"><a href="#val-frame" class="anchor"></a><code><span class="keyword">val</span> frame : clk:unit <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> init:<span class="type-var">'b</span> <span>&#45;&gt;</span> f:(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>frame ~clk s ~init ~f</code> will gather elements of <code>s</code> into frames, where the start of the new frame is signaled by a stream <code>clk</code>. The function is very similar to <code>foldw</code> except, that the window is determined dynamically by a <code>clk</code> stream. This function is useful to build custom time scales.</p><p>The semantics of the function can be clarified with the following description: 1. Every time a stream <code>s</code> produces a value it is buffered 2. Every time a stream <code>clk</code> produces a value, a function <code>f</code> is folded over all buffered value, and the result is put into the output stream. The internal buffer is cleared afterwards.</p><p>Example -------</p><p>Consider the following timing diagram, where each row represents a stream, and columns represent time. Elements of the <code>clk</code> stream are depicted with a <code>T</code> symbol.</p><pre>          clk:    T         T        T  T      T     T
           ss: 123 56 123 12  1234 4      1234  1</pre><p>will be framed in the following way:</p><p><code>[123], [5612312], [12344], [], [1234], [1]</code></p><p>Note: since all streams should be serialized it is impossible, that two events occur at the same time. So at the same column of the timing diagram there can be only one event.</p></dd></dl><dl><dt class="spec value" id="val-sample"><a href="#val-sample" class="anchor"></a><code><span class="keyword">val</span> sample : clk:unit <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a></code></dt><dd><p><code>sample ~clk ss</code> is semantically the same as <code>frame ~clk ss &gt;&gt;| fst</code></p></dd></dl><dl><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../index.html#type-future">future</a></code></dt><dd><p><code>hd s</code> returns a <code>future</code> that will occur as soon, as stream <code>s</code> will produce a value. Note: if <code>hd</code> is called on a stream, that already produced some values, the returned future will still be fulfilled on the first value, that will be put into the stream after the future is created.</p></dd></dl><dl><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>tl s</code> ignores the next occurrence in the stream <code>s</code></p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../index.html#type-future">future</a></code></dt><dd><p><code>find xs f</code> returns a future that will be fulfilled with a first value for which a function <code>f</code> is <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="../index.html#type-future">future</a></code></dt><dd><p><code>find_map xs f</code> returns a future that will be fulfilled by a result of a first invocation of <code>f</code> to an element of the stream, that evaluated to <code>Some</code> value</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../index.html#type-future">future</a></code></dt><dd><p><code>take xs n</code> returns a future that will evaluate to <code>n</code> values of the stream <code>xs</code> that has occurred after the future was created.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../index.html#type-future">future</a></code></dt><dd><p><code>nth xs n</code> returns <code>n</code>'th element of the stream <code>xs</code>. The element is <code>n</code>'th with respect to the future <code>f</code>, if was <code>n</code>'th element of the stream after the creation of the stream.</p></dd></dl><dl><dt class="spec value" id="val-upon"><a href="#val-upon" class="anchor"></a><code><span class="keyword">val</span> upon : unit <a href="../index.html#type-future">future</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="../index.html#type-future">future</a></code></dt><dd><p><code>upon e xs</code> returns a future that will be fulfilled with a last value of a stream <code>xs</code> before an event <code>e</code> has occurred. If at the time when the event <code>e</code> occurs, the stream <code>xs</code> didn't produce any elements, then the future will not be fulfilled.</p></dd></dl><dl><dt class="spec value" id="val-before"><a href="#val-before" class="anchor"></a><code><span class="keyword">val</span> before : unit <a href="../index.html#type-future">future</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../index.html#type-future">future</a></code></dt><dd><p><code>before e xs</code> returns a list that contains elements of the stream <code>xs</code> that occurred before the event <code>e</code></p></dd></dl><dl><dt class="spec value" id="val-last_before"><a href="#val-last_before" class="anchor"></a><code><span class="keyword">val</span> last_before : unit <a href="../index.html#type-future">future</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="../index.html#type-future">future</a></code></dt><dd><p><code>last_before e xs n</code> returns a list of length up to <code>n</code>, that contains last elements of the stream <code>xs</code> that occurred before the event <code>e</code></p></dd></dl></section></div></body></html>