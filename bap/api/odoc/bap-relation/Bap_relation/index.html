<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bap_relation (bap-relation.Bap_relation)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">bap-relation</a> &#x00BB; Bap_relation</nav><header class="odoc-preamble"><h1>Module <code><span>Bap_relation</span></code></h1><p>A representation of relations between two sets.</p><p>A relation between two sets is a set of pairs made from the elements of these sets. The precise mathematical defition is given below. This module implements a bidirectional mapping between two sets and computes their matching that defines bijections between the sets.</p></header><nav class="odoc-toc"><ul><li><a href="#formal-definition-and-notation">Formal Definition and Notation</a></li><li><a href="#bijections-and-matching">Bijections and matching</a></li></ul></nav><div class="odoc-content"><h3 id="formal-definition-and-notation"><a href="#formal-definition-and-notation" class="anchor"></a>Formal Definition and Notation</h3><p>Given two sets <code>K</code> and <code>S</code>, with meta-variables <code>x,y,z</code> ranging over <code>K</code> and meta-variables <code>r,s,t</code> ranging over <code>S</code> we will denote a finitary relation <code>R</code> as a subset of the cartesian product <code>K x S</code>, which is a set of pairs <code>(x,r), ..., (z,t)</code>, which we represent as a bipartite graph <code>G = (K,S,R)</code>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('k, 's) t</span></span></code></div><div class="spec-doc"><p>the type for relation between <code>'k</code> and <code>'s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span>(<span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>empty compare_k compare_s</code> the empty relation between two sets.</p><ul><li><code>compare_k</code> is the function that defines order of the elements of the set <code>K</code>.</li></ul><ul><li><code>compare_s</code> is the function that defines order of the elements of the set <code>S</code>.</li></ul><p>Example</p><pre class="language-ocaml"><code>let empty = Bap_relation.empty
    Int.compare
    String.compare</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty rel</code> is true if the relation <code>rel</code> is an empty set.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add relation x s</code> establishes a relation between <code>x</code> and <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem rel x s</code> is <code>true</code> if <code>(k,s)</code> is in the relation <code>rel</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-findl"><a href="#val-findl" class="anchor"></a><code><span><span class="keyword">val</span> findl : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> list</span></span></code></div><div class="spec-doc"><p><code>findl rel x</code> finds all pairs in <code>rel</code> that have <code>x</code> on the left.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-findr"><a href="#val-findr" class="anchor"></a><code><span><span class="keyword">val</span> findr : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> list</span></span></code></div><div class="spec-doc"><p><code>findr rel s</code> finds all pairs in <code>rel</code> that have <code>s</code> on the right.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>init:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold rel init f</code> folds over all pairs in the relation <code>rel</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>(<span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter rel f</code> iterates over all pairs in the relation <code>rel</code>.</p></div></div><h3 id="bijections-and-matching"><a href="#bijections-and-matching" class="anchor"></a>Bijections and matching</h3><p>The set of independent edges <code>M</code> (the matching) of the graph <code>G</code> forms a finite bijection between <code>K</code> and <code>S</code>. It is guaranteed that for each pair <code>(x,s)</code> in <code>M</code> there is no other pair in <code>M</code>, that will include <code>x</code> or <code>s</code>.</p><p>Edges <code>R</code> that are not in the matching <code>M</code> represent a subset of <code>R</code> that do not match because of one the two anomalies:</p><ul><li>A non-injective forward mapping occurs when the same value from the set <code>S</code> is in relation with more than one value from the set <code>K</code>, e.g., <code>(x,s), (y,s)</code> is encoded as <code>Non_injective_fwd ([x,y],s)</code>;</li></ul><ul><li>A non-injective backward mapping occurs when the same value from the set <code>K</code> is in relation with more than one value from the set <code>S</code>, e.g., <code>(x,r), (x,s)</code> is encoded as <code>Non_injective_bwd ([r;s],x);
</code></li></ul><div class="odoc-spec"><div class="spec type anchored" id="type-non_injective"><a href="#type-non_injective" class="anchor"></a><code><span><span class="keyword">type</span> <span>('k, 's) non_injective</span></span><span> = </span></code><ol><li id="type-non_injective.Non_injective_fwd" class="def variant constructor anchored"><a href="#type-non_injective.Non_injective_fwd" class="anchor"></a><code><span>| </span><span><span class="constructor">Non_injective_fwd</span> <span class="keyword">of</span> <span><span class="type-var">'k</span> list</span> * <span class="type-var">'s</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Non-injective forward mapping.</p><span class="comment-delim">*)</span></div></li><li id="type-non_injective.Non_injective_bwd" class="def variant constructor anchored"><a href="#type-non_injective.Non_injective_bwd" class="anchor"></a><code><span>| </span><span><span class="constructor">Non_injective_bwd</span> <span class="keyword">of</span> <span><span class="type-var">'s</span> list</span> * <span class="type-var">'k</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Non-injective backward mapping.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>the reason why the pair was left unmatched</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matching"><a href="#val-matching" class="anchor"></a><code><span><span class="keyword">val</span> matching : 
  <span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?saturated:<span>(<span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?unmatched:<span>(<span><span><span>(<span class="type-var">'k</span>, <span class="type-var">'s</span>)</span> <a href="#type-non_injective">non_injective</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>matching relation data</code> computes the matching for the given <code>relation</code>.</p><p>Calls <code>saturated x s data</code> for each <code>(x,s)</code> in the matching <code>M</code> (see the module description) and <code>unmatched z reason d</code> for each <code>(z,t)</code> in the relation that are not matched, the reason is one of the:</p><ul><li><code>Non_injective_fwd (xs,s)</code> if the mapping <code>K -&gt; S</code> that is induced by the <code>relation</code> is non-injective, because the set of values <code>xs</code> from <code>K</code> are mapped to the same value <code>s</code> in <code>S</code>.</li></ul><ul><li><code>Non_injective_bwd (ss,x)</code> if the mapping <code>S -&gt; K</code> that is induced by the <code>relation</code> is non-injective, because the set of values <code>ss</code> from <code>S</code> are mapped to the same value <code>x</code> in <code>K</code>.</li></ul></div></div></div></body></html>