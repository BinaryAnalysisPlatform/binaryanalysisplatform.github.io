<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unsafe (regular.Regular.Std.Bytes.Unsafe)</title><link rel="stylesheet" href="../../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">regular</a> &#x00BB; <a href="../../../index.html">Regular</a> &#x00BB; <a href="../../index.html">Std</a> &#x00BB; <a href="../index.html">Bytes</a> &#x00BB; Unsafe</nav><header class="odoc-preamble"><h1>Module <code><span>Bytes.Unsafe</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#unsafe-conversions-(for-advanced-users)">Unsafe conversions (for advanced users)</a></li></ul></nav><div class="odoc-content"><h5 id="unsafe-conversions-(for-advanced-users)"><a href="#unsafe-conversions-(for-advanced-users)" class="anchor"></a>Unsafe conversions (for advanced users)</h5><p>This section describes unsafe, low-level conversion functions between <code>bytes</code> and <code>string</code>. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the <code>-safe-string</code> option. They are available for expert library authors, but for most purposes you should use the always-correct <a href="../index.html#val-to_string"><code>Bytes.to_string</code></a> and <a href="../index.html#val-of_string"><code>Bytes.of_string</code></a> instead.</p><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="../index.html#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string b</code> - unsafely converts a byte sequence into a string.</p><p>To reason about the use of <code>to_string</code>, it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:</p><ul><li>Unique ownership: the data may be accessed and mutated</li><li>Shared ownership: the data has several owners, that may only access it, not mutate it.</li></ul><p>Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.</p><p><code>to_string s</code> can only be used when the caller owns the byte sequence <code>s</code> -- either uniquely or as shared immutable data. The caller gives up ownership of <code>s</code>, and gains ownership of the returned string.</p><p>There are two valid use-cases that respect this ownership discipline:</p><p>1. Creating a string by initializing and mutating a byte sequence that is never changed after initialization is performed.</p><pre><code>let string_init len f : string =
  let s = Bytes.create len in
  for i = 0 to len - 1 do Bytes.set s i (f i) done;
  Bytes.Unsafe.to_string s</code></pre><p>This function is safe because the byte sequence <code>s</code> will never be accessed or mutated after <code>to_string</code> is called. The <code>string_init</code> code gives up ownership of <code>s</code>, and returns the ownership of the resulting string to its caller.</p><p>Note that it would be unsafe if <code>s</code> was passed as an additional parameter to the function <code>f</code> as it could escape this way and be mutated in the future -- <code>string_init</code> would give up ownership of <code>s</code> to pass it to <code>f</code>, and could not call <code>to_string</code> safely.</p><p>We have provided the <code>String</code>.init, <code>String</code>.map and <code>String</code>.mapi functions to cover most cases of building new strings. You should prefer those over <code>to_string</code> or <code>to_string</code> whenever applicable.</p><p>2. Temporarily giving ownership of a byte sequence to a function that expects a uniquely owned string and returns ownership back, so that we can mutate the sequence again after the call ended.</p><pre><code>let bytes_length (s : bytes) =
  String.length (Bytes.Unsafe.to_string s)</code></pre><p>In this use-case, we do not promise that <code>s</code> will never be mutated after the call to <code>bytes_length s</code>. The <code>String</code>.length function temporarily borrows unique ownership of the byte sequence (and sees it as a <code>string</code>), but returns this ownership back to the caller, which may assume that <code>s</code> is still a valid byte sequence after the call. Note that this is only correct because we know that <code>String</code>.length does not capture its argument -- it could escape by a side-channel such as a memoization combinator.</p><p>The caller may not mutate <code>s</code> while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if <code>String.length</code> returned a closure to be called later, <code>s</code> should not be mutated until this closure is fully applied and returns ownership.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_string s</code> - unsafely converts a shared string to a byte sequence that should not be mutated.</p><p>The same ownership discipline that makes <code>to_string</code> correct applies to <code>of_string</code>: you may use it if you were the owner of the <code>string</code> value, and you will own the return <code>bytes</code> in the same mode.</p><p>In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.</p><p>For example, string literals are implicitly shared by the compiler, so you never uniquely own them.</p><pre><code>let incorrect = Bytes.Unsafe.of_string &quot;hello&quot;
let s = Bytes.of_string &quot;hello&quot;</code></pre><p>The first declaration is incorrect, because the string literal <code>&quot;hello&quot;</code> could be shared by the compiler with other parts of the program, and mutating <code>incorrect</code> is a bug. You must always use the second version, which performs a copy and is thus correct.</p><p>Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating <code>of_string (&quot;foo&quot; ^ s)</code> could mutate the shared string <code>&quot;foo&quot;</code> -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of <code>of_string</code>.</p><p>The only case we have reasonable confidence is safe is if the produced <code>bytes</code> is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example <code>Marshal</code>.from_bytes) and previously used the <code>string</code> type for this purpose.</p></div></div></div></body></html>