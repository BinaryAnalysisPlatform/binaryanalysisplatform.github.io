<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>base (bap-c.Bap_c_size.base)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">bap-c</a> &#x00BB; <a href="../index.html">Bap_c_size</a> &#x00BB; base</nav><h1>Class <code>Bap_c_size.base</code></h1><p>Base class for computing size of C data types. The algorithm is implemented as a class to allow a particular implementation to fine tune the calculation. We need here an open recursion, since type is inherently recursive.</p><p>The entry method is the <code>bits</code> method.</p></header><dl><dt class="spec method" id="method-bits"><a href="#method-bits" class="anchor"></a><code><span class="keyword">method</span> bits : <a href="../../Bap_c_type/index.html#type-t">Bap_c_type.t</a> <span>&#45;&gt;</span> <span><a href="../index.html#type-bits">bits</a> option</span></code></dt><dd><p>returns a size of the data type representation if type definition is complete. Otherwise <code>None</code> is returned. The size is computed with respect to padding and alignment restructions.</p></dd></dl><dl><dt class="spec method" id="method-alignment"><a href="#method-alignment" class="anchor"></a><code><span class="keyword">method</span> alignment : <a href="../../Bap_c_type/index.html#type-t">Bap_c_type.t</a> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt><dd><p><code>alignment t</code> calculates an alignment restriction for data type <code>t</code>. The default alignment rules are the following:</p><ul><li>if type is scalar then the alignment is <code>sizeof(t)</code>;</li><li>if type is <code>elt[]</code> then the alignment is <code>sizeof(elt)</code>;</li><li>if type is structure or union, the the alignment of is the maximum alignment of a field;</li><li>if type is function, then alignment is equal to sizeof pointer</li><li>if type is void then alignment is 8 bits.</li></ul></dd></dl><dl><dt class="spec method" id="method-padding"><a href="#method-padding" class="anchor"></a><code><span class="keyword">method</span> padding : <a href="../../Bap_c_type/index.html#type-t">Bap_c_type.t</a> <span>&#45;&gt;</span> <a href="../index.html#type-bits">bits</a> <span>&#45;&gt;</span> <span><a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a> option</span></code></dt><dd><p><code>padding t off</code> computes a required padding at given offset that should be inserted before value of type <code>t</code> to satisfy the alignment restriction for <code>t</code>, as determined by the <code>alignment</code> method.</p></dd></dl><dl><dt class="spec method" id="method-array"><a href="#method-array" class="anchor"></a><code><span class="keyword">method</span> array : <span><span>(<span><a href="../../Bap_c_type/index.html#type-cvr">Bap_c_type.cvr</a> <a href="../../Bap_c_type/index.html#type-qualifier">Bap_c_type.qualifier</a></span>, <a href="../../Bap_c_type/index.html#type-array">Bap_c_type.array</a>)</span> <a href="../../Bap_c_type/index.html#type-spec">Bap_c_type.spec</a></span> <span>&#45;&gt;</span> <span><a href="../index.html#type-bits">bits</a> option</span></code></dt><dd><p><code>array spec</code> if array <code>spec</code> is complete, then returns a product of the bitwidth of array size and array's element type, otherwise returns <code>None</code></p></dd></dl><dl><dt class="spec method" id="method-union"><a href="#method-union" class="anchor"></a><code><span class="keyword">method</span> union : <span><span>(<a href="../../Bap_c_type/index.html#type-no_qualifier">Bap_c_type.no_qualifier</a>, <a href="../../Bap_c_type/index.html#type-compound">Bap_c_type.compound</a>)</span> <a href="../../Bap_c_type/index.html#type-spec">Bap_c_type.spec</a></span> <span>&#45;&gt;</span> <span><a href="../index.html#type-bits">bits</a> option</span></code></dt><dd><p>if spec is complete then returns a size of the biggest element, including padding</p></dd></dl><dl><dt class="spec method" id="method-structure"><a href="#method-structure" class="anchor"></a><code><span class="keyword">method</span> structure : <span><span>(<a href="../../Bap_c_type/index.html#type-no_qualifier">Bap_c_type.no_qualifier</a>, <a href="../../Bap_c_type/index.html#type-compound">Bap_c_type.compound</a>)</span> <a href="../../Bap_c_type/index.html#type-spec">Bap_c_type.spec</a></span> <span>&#45;&gt;</span> <span><a href="../index.html#type-bits">bits</a> option</span></code></dt><dd><p>if spec is complete then returns a total size of the structure, including padding.</p></dd></dl><dl><dt class="spec method" id="method-integer"><a href="#method-integer" class="anchor"></a><code><span class="keyword">method</span> integer : <a href="../../Bap_c_type/index.html#type-integer">Bap_c_type.integer</a> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt><dt class="spec method" id="method-pointer"><a href="#method-pointer" class="anchor"></a><code><span class="keyword">method</span> pointer : <a href="../../../bap/Bap/Std/index.html#type-addr_size">Bap.Std.addr_size</a></code></dt><dt class="spec method" id="method-enum"><a href="#method-enum" class="anchor"></a><code><span class="keyword">method</span> enum : <span><span>(string * <span>int64 option</span>)</span> list</span> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt><dt class="spec method" id="method-real"><a href="#method-real" class="anchor"></a><code><span class="keyword">method</span> real : <a href="../../Bap_c_type/index.html#type-real">Bap_c_type.real</a> <span>&#45;&gt;</span> <span>[ `r32 <span>| `r64</span> <span>| `r128</span> ]</span></code></dt><dt class="spec method" id="method-complex"><a href="#method-complex" class="anchor"></a><code><span class="keyword">method</span> complex : <a href="../../Bap_c_type/index.html#type-complex">Bap_c_type.complex</a> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt><dt class="spec method" id="method-floating"><a href="#method-floating" class="anchor"></a><code><span class="keyword">method</span> floating : <a href="../../Bap_c_type/index.html#type-floating">Bap_c_type.floating</a> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt><dt class="spec method" id="method-basic"><a href="#method-basic" class="anchor"></a><code><span class="keyword">method</span> basic : <a href="../../Bap_c_type/index.html#type-basic">Bap_c_type.basic</a> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt><dt class="spec method" id="method-scalar"><a href="#method-scalar" class="anchor"></a><code><span class="keyword">method</span> scalar : <a href="../../Bap_c_type/index.html#type-scalar">Bap_c_type.scalar</a> <span>&#45;&gt;</span> <a href="../../../bap/Bap/Std/index.html#type-size">Bap.Std.size</a></code></dt></dl></div></body></html>