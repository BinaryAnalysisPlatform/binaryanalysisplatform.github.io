<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Arg (bap-c.Bap_c_abi.Arg)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bap-c</a> &#x00BB; <a href="../index.html">Bap_c_abi</a> &#x00BB; Arg</nav><header class="odoc-preamble"><h1>Module <code><span>Bap_c_abi.Arg</span></code></h1><p>A monadic eDSL for argument passing semantics specification.</p><p>This DSL helps in defining the abi processor's <code>insert_args</code> function. The DSL describes the semantics of argument passing that is then reified to the <code>args</code> structure. The <code>DSL</code> is a choice monad that enables describing the argument passing grammar using backtracking when the chosen strategy doesn't fit. The <code>reject ()</code> operator will reject the current computation up until the nearest choice prompt, e.g., in the following example, computations <code>e1</code>, <code>e2</code>, and <code>e3</code> are rejected and any side-effects that they might had are ignored and, instead the <code>option2</code> computation is tried as if the previous sequence had never happend.</p><pre><code>choice [
  sequence [e1; e2; e3; reject ()];
  option2;
]</code></pre><p>Since the purpose of this DSL is to describe how the passed arguments are read in terms of BIL expressions, the generated specification could be seen as a grammar and the DSL itself as a parser combinator, specialized for describing ABI.</p></header><nav class="odoc-toc"><ul><li><a href="#example">Example</a></li></ul></nav><div class="odoc-content"><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>Below we define the semantics of <code>riscv32</code> and <code>riscv64</code> targets. Both targets have fully specified register files with properly assigned roles and the register order matches with register names ordering, so we can use the simplified Arena creating functions. We have four independent arenas, two for passing in and out integer arguments, and two corresponding arenas for floating-point arguments.</p><p>We start with defining the integer calling convention by first determining how many register are needed to pass an argument. If the size of the argument couldn't be determined we reject the computation. Otherwise, if it fits into one register we try to pass it via a register fallback to memory if there are no registers available. If it requires two registers we first try to pass it as an aligned register pair (with the first part going through the nearest available even register). If we don't have enough aligned registers, we then split it in two parts and pass the first part in a register and the second part in the memory. Finally, if the size is greater than two words we pass it as an implicit reference.</p><p>The floating-point calling convention assumes the presence of the hardware floating-point registers but the specification is general enough to handle the soft floats convention, as any attempt to pass an argument via the hardware floating-point registers will be rejected since the corresponding arena will be empty.</p><p>The convention tries to pass a floating-point argument via the corresponding register file if it fits into a register otherwise it falls back to the integer registers. When an argument fits into the floating-point register we first try passing it through the floating-point file and if it is out of registers we use available integer registers (in riscv with hardware floating-point registers it is possible to pass 16 floating-point arguments all in registers) and finally use the last resort option of using the memory.</p><pre><code>module Arg = C.Abi.Arg
open Arg.Let
open Arg.Syntax

let is_floating = function
  | `Basic {C.Type.Spec.t=#C.Type.real} -&gt; true
  | _ -&gt; false

let data_model t =
  let bits = Theory.Target.bits t in
  new C.Size.base (if bits = 32 then `ILP32 else `LP64)

let define t =
  let model = data_model t in
  C.Abi.define t model @@ fun _ {C.Type.Proto.return=r; args} -&gt;
  let* iargs = Arg.Arena.iargs t in
  let* irets = Arg.Arena.irets t in
  let* fargs = Arg.Arena.fargs t in
  let* frets = Arg.Arena.frets t in

  (* integer calling convention *)
  let integer regs t =
    Arg.count regs t &gt;&gt;= function
    | None -&gt; Arg.reject ()
    | Some 1 -&gt; Arg.choice [
        Arg.register regs t;
        Arg.memory t;
      ]
    | Some 2 -&gt; Arg.choice [
        Arg.sequence [
          Arg.align_even regs;
          Arg.registers ~limit:2 regs t;
        ];
        Arg.split_with_memory regs t;
        Arg.memory t;
      ]
    | Some _ -&gt; Arg.reference regs t in

  (* floating-point calling convention *)
  let float iregs fregs t =
    Arg.count fregs t &gt;&gt;= function
    | Some 1 -&gt; Arg.choice [
        Arg.register fregs t;
        Arg.register iregs t;
        Arg.memory t;
      ]
    | _ -&gt; integer iregs t in

  let arg iregs fregs r =
    if is_floating r
    then float iregs fregs r
    else integer iregs r in

  Arg.define ?return:(match r with
      | `Void -&gt; None
      | r -&gt; Some (arg irets frets r))
    (Arg.List.iter args ~f:(fun (_,t) -&gt;
         arg iargs fargs t));

  let () = List.iter ~f:define Bap_risv_target.[riscv32; riscv64]</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.3.0</li></ul><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-arena" class="anchored"><a href="#type-arena" class="anchor"></a><code><span><span class="keyword">type</span> arena</span></code></div><div class="spec-doc"><p>an ordered expendable collection of registers</p></div></div><div class="odoc-spec"><div class="spec type" id="type-semantics" class="anchored"><a href="#type-semantics" class="anchor"></a><code><span><span class="keyword">type</span> semantics</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-ctype" class="anchored"><a href="#type-ctype" class="anchor"></a><code><span><span class="keyword">type</span> ctype</span><span> = <a href="../../Bap_c_type/index.html#type-t">Bap_c_type.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-define" class="anchored"><a href="#val-define" class="anchor"></a><code><span><span class="keyword">val</span> define : <span>?return:<span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-semantics">semantics</a> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>define ?return args</code> the toplevel function for defining argument passing semantics.</p><p>The function has two entries, the optional <code>return</code> entry describes the semantics of passing of the return value, and the second section describes the semantics of passing the list of arguments.</p><p>The semantics is defined as a sequence of these two rules, with the return rule evaluated first. Therefore, if <code>return</code> is rejected the whole semantics will be rejected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-register" class="anchored"><a href="#val-register" class="anchor"></a><code><span><span class="keyword">val</span> register : <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>register arena t</code> passes the argument of type <code>t</code> using the next available register in <code>arena</code>.</p><p>The computation is rejected if no registers are available; if <code>t</code> doesn't fit into a register in <code>arena</code>; or if size of <code>t</code> can't be determined.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-registers" class="anchored"><a href="#val-registers" class="anchor"></a><code><span><span class="keyword">val</span> registers : <span>?limit:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>registers arena t</code> passes the argument in consecutive registers from <code>arena</code>.</p><p>Rejects the computation if <code>arena</code> doesn't have the necessary number of registers; the number of required registers is greater than <code>limit</code>; or if the size of <code>t</code> is unknown.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-align_even" class="anchored"><a href="#val-align_even" class="anchor"></a><code><span><span class="keyword">val</span> align_even : <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>align_even arena</code> ensures that the first available register in <code>arena</code> has even number.</p><p>Registers in an arena are enumerated from zero in the order of their appearence in the arena specification. This function removes, when necessary, a register form the arena, so that the next available register has an even number.</p><p>The computation is rejected if there are no more even registers in <code>arena</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-deplet" class="anchored"><a href="#val-deplet" class="anchor"></a><code><span><span class="keyword">val</span> deplet : <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>deplet arena</code> unconditionally consumes all registers in arena.</p><p>The computation is never rejected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reference" class="anchored"><a href="#val-reference" class="anchor"></a><code><span><span class="keyword">val</span> reference : <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>reference arena t</code> passes the argument of type <code>t</code> as a pointer to <code>t</code> via the first available register in <code>arena</code>.</p><p>Rejects the computation if there are no available registers in <code>arena</code> or if the target doesn't have a register with the stack pointer role. The size of <code>t</code> is not required.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-memory" class="anchored"><a href="#val-memory" class="anchor"></a><code><span><span class="keyword">val</span> memory : <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>memory t</code> passes the argument of type <code>t</code> in the next available stack slot.</p><p>Rejects the computation if the size of <code>t</code> is not known or if the target doesn't have a register with the stack pointer role.</p><p>The address of the slot is aligned corresponding to the alignment requirements of <code>t</code> but no less than the minimal data alignment requirements of the architecture or the natural alignment of the stack pointer.</p><p>Note, passing a number arguments via a descending stack using <code>memory</code> will pass the arguments in the right-to-left (RTL aka C) order, i.e., the first passed argument will end up at the bottom (will have the minimal address). Use <code>push</code> if you want the left-to-right order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_with_memory" class="anchored"><a href="#val-split_with_memory" class="anchor"></a><code><span><span class="keyword">val</span> split_with_memory : <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split_with_memory arena t</code> passes the low order part of the value in a register (if available) and the rest in the memory.</p><p>The size of the part that is passed via the registers is equal to the size of the register. The part that is passed via the stack is aligned to the stack boundary.</p><p>Rejects the computation if the size of <code>t</code> is not known; if <code>arena</code> is empty; or if some other argument is already passed via memory.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-push" class="anchored"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>push t</code> pushes the argument of type <code>t</code> via stack.</p><p>Rejects the computation if the size of <code>t</code> is not known.</p><p>The address of the slot is aligned corresponding to the alignment requirements of <code>t</code> but no less than the minimal data alignment requirements of the architecture or the natural alignment of the stack pointer.</p><p>When passing a number of arguments via a descending stack, the last pushed argument will be at the bottom of the stack, i.e., will have the minimal address. This corresponds to the LTR aka Pascal ordering.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span><a href="#type-arena">arena</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ctype">ctype</a> <span class="arrow">&#45;&gt;</span></span> <span><span>int option</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>count arena t</code> counts the number of registers need to pass a value of type <code>t</code>.</p><p>Returns <code>None</code> if the size of <code>t</code> is not known or if the <code>arena</code> size is empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-either" class="anchored"><a href="#val-either" class="anchor"></a><code><span><span class="keyword">val</span> either : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>either option1 option2</code> tries to pass using <code>option1</code> and if it is rejected uses <code>option2</code>.</p><p>For example, <code>either (register x) (memory x)</code> tries to pass <code>x</code> via a register and if it is not possible (either because <code>x</code> doesn't fit into a register or there are no registers available) tries to pass it via memory.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-choice" class="anchored"><a href="#val-choice" class="anchor"></a><code><span><span class="keyword">val</span> choice : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>choice [o1 o2 ... oN]</code> tries options in order until the first one that is not rejected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reify" class="anchored"><a href="#val-reify" class="anchor"></a><code><span><span class="keyword">val</span> reify : 
  <span><a href="../../../bap-core-theory/Bap_core_theory/Theory/Target/index.html#type-t">Bap_core_theory.Theory.Target.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Bap_c_size/class-base/index.html">Bap_c_size.base</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-semantics">semantics</a> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-args">args</a> option</span></span></code></div><div class="spec-doc"><p><code>reify t size args</code> compiles the argument passing specification.</p><p>If the spec is not rejected the returned structure will contain the reification of the argument passing semantics.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../monads/Monads/Std/Monad/module-type-S/index.html">Monads.Std.Monad.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-void" class="anchored"><a href="#val-void" class="anchor"></a><code><span><span class="keyword">val</span> void : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>void m</code> computes <code>m</code> and discrards the result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sequence" class="anchored"><a href="#val-sequence" class="anchor"></a><code><span><span class="keyword">val</span> sequence : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sequence xs</code> computes a sequence of computations <code>xs</code> in the left to right order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-forever" class="anchored"><a href="#val-forever" class="anchor"></a><code><span><span class="keyword">val</span> forever : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>forever xs</code> creates a computationt that never returns.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Fn" class="anchored"><a href="#module-Fn" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fn/index.html">Fn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Various function combinators lifted into the Kleisli category.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Pair" class="anchored"><a href="#module-Pair" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Pair/index.html">Pair</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The pair interface lifted into the monad.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Triple" class="anchored"><a href="#module-Triple" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Triple/index.html">Triple</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The triple interface lifted into a monad.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Lift" class="anchored"><a href="#module-Lift" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lift/index.html">Lift</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Lifts functions into the monad.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Exn" class="anchored"><a href="#module-Exn" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Exn/index.html">Exn</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Interacting between monads and language exceptions</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Collection" class="anchored"><a href="#module-Collection" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Collection/index.html">Collection</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Lifts collection interface into the monad.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-List" class="anchored"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> <a href="List/index.html">List</a></span><span> : <a href="Collection/module-type-S/index.html">Collection.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="Collection/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> list</span></span></span></code></div><div class="spec-doc"><p>The <span class="xref-unresolved">Monad.Collection.S</span> interface for lists</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Seq" class="anchored"><a href="#module-Seq" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Seq/index.html">Seq</a></span><span> : <a href="Collection/module-type-S/index.html">Collection.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="Collection/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <span class="xref-unresolved">Core_kernel</span>.Sequence.t</span></span></span></code></div><div class="spec-doc"><p>The <span class="xref-unresolved">Monad.Collection.S</span> interface for sequences</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html">Monads.Std.Monad.Syntax.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>m &gt;&gt;= f</code> is <code>bind m f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>m &gt;&gt;= f</code> is <code>map m ~f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;=&gt;)" class="anchored"><a href="#val-(&gt;=&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;=&gt;) : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>f &gt;=&gt; g</code> is <code>fun x -&gt; f x &gt;&gt;= g</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!!)" class="anchored"><a href="#val-(!!)" class="anchor"></a><code><span><span class="keyword">val</span> (!!) : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!!x</code> is <code>return x</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!$)" class="anchored"><a href="#val-(!$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$) : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$f</code> is <code>Lift.unary f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!$$)" class="anchored"><a href="#val-(!$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$) : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$f</code> is <code>Lift.binary f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!$$$)" class="anchored"><a href="#val-(!$$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$$) : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$$f</code> is <code>Lift.ternary f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!$$$$)" class="anchored"><a href="#val-(!$$$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$$$) : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'e</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'e</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$$$f</code> is <code>Lift.quaternary f</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-(!$$$$$)" class="anchored"><a href="#val-(!$$$$$)" class="anchor"></a><code><span><span class="keyword">val</span> (!$$$$$) : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'f</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'f</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>!$$$$$f</code> is <code>Lift.quinary f</code></p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html">Monads.Std.Monad.Syntax.Let.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-let*" class="anchored"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let* r = f x in b</code> is <code>f x &gt;&gt;= fun r -&gt; b</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-and*" class="anchored"><a href="#val-and*" class="anchor"></a><code><span><span class="keyword">val</span> and* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>monoidal product</p></div></div><div class="odoc-spec"><div class="spec value" id="val-let+" class="anchored"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let+ r = f x in b</code> is <code>f x &gt;&gt;| fun r -&gt; b</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-and+" class="anchored"><a href="#val-and+" class="anchor"></a><code><span><span class="keyword">val</span> and+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>monoidal product</p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Core_kernel</span>.Monad.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <span class="xref-unresolved">t</span></span> := <span><span class="type-var">'a</span> <span class="xref-unresolved">t</span></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;|) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span><span class="keyword">val</span> bind : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span><span class="keyword">val</span> ignore_m : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span><span class="keyword">val</span> all_unit : <span><span><span>unit <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-Let" class="anchored"><a href="#module-Let" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Let/index.html">Let</a></span><span> : <a href="../../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html">Monads.Std.Monad.Syntax.Let.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/Syntax/Let/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></div><div class="spec-doc"><p>Monadic operators, see <span class="xref-unresolved">Monad.Syntax.S</span> for more.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Syntax" class="anchored"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a></span><span> : <a href="../../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html">Monads.Std.Monad.Syntax.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/Syntax/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></div><div class="spec-doc"><p>Monadic operators, see <span class="xref-unresolved">Monad.Syntax.S</span> for more.</p></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../monads/Monads/Std/Monad/Choice/module-type-S/index.html">Monads.Std.Monad.Choice.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/Choice/module-type-S/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../monads/Monads/Std/Monad/Choice/module-type-Basic/index.html">Monads.Std.Monad.Choice.Basic</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../monads/Monads/Std/Monad/Choice/module-type-Basic/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-pure" class="anchored"><a href="#val-pure" class="anchor"></a><code><span><span class="keyword">val</span> pure : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pure x</code> creates a computation that results in <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zero" class="anchored"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zero ()</code> creates a computation that has no result.</p></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-accept" class="anchored"><a href="#val-accept" class="anchor"></a><code><span><span class="keyword">val</span> accept : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>accept x</code> accepts <code>x</code> as a result of computation. (Same as <code>pure x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reject" class="anchored"><a href="#val-reject" class="anchor"></a><code><span><span class="keyword">val</span> reject : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>reject ()</code> rejects the rest of computation sequence, and terminate the computation with the <code>zero</code> result (Same as <code>zero ()</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-guard" class="anchored"><a href="#val-guard" class="anchor"></a><code><span><span class="keyword">val</span> guard : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>guard cond</code> ensures <code>cond</code> is <code>true</code> in the rest of computation. Otherwise the rest of the computation is rejected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on" class="anchored"><a href="#val-on" class="anchor"></a><code><span><span class="keyword">val</span> on : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>on cond x</code> computes <code>x</code> only iff <code>cond</code> is <code>true</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-unless" class="anchored"><a href="#val-unless" class="anchor"></a><code><span><span class="keyword">val</span> unless : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unless cond x</code> computes <code>x</code> unless <code>cond</code> is <code>true</code>.</p></div></div></details></div><div class="odoc-spec"><div class="spec module" id="module-Arena" class="anchored"><a href="#module-Arena" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Arena/index.html">Arena</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An ordered collection of registers.</p></div></div></div></body></html>