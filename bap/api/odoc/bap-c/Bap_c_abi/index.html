<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bap_c_abi (bap-c.Bap_c_abi)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bap-c</a> &#x00BB; Bap_c_abi</nav><h1>Module <code>Bap_c_abi</code></h1><p>C language ABI.</p><p>This module provides a common interface for building ABI support modules for C language.</p></header><dl><dt class="spec type" id="type-param"><a href="#type-param" class="anchor"></a><code><span class="keyword">type</span> param</code><code> = <a href="../Bap_c_data/index.html#type-t">Bap_c_data.t</a> * <a href="../../bap/Bap/Std/index.html#type-exp">Bap.Std.exp</a></code></dt><dd><p>Function formal parameter is represented as a pair of an abstraction of data, that is passed via the parameter, and a BIL expression, that denotes the parameter.</p></dd></dl><dl><dt class="spec type" id="type-args"><a href="#type-args" class="anchor"></a><code><span class="keyword">type</span> args</code><code> = </code><code>{</code><table class="record"><tr id="type-args.return" class="anchored"><td class="def field"><a href="#type-args.return" class="anchor"></a><code>return : <span><a href="index.html#type-param">param</a> option</span>;</code></td></tr><tr id="type-args.hidden" class="anchored"><td class="def field"><a href="#type-args.hidden" class="anchor"></a><code>hidden : <span><span>(<a href="../Bap_c_type/index.html#type-t">Bap_c_type.t</a> * <a href="index.html#type-param">param</a>)</span> list</span>;</code></td></tr><tr id="type-args.params" class="anchored"><td class="def field"><a href="#type-args.params" class="anchor"></a><code>params : <span><a href="index.html#type-param">param</a> list</span>;</code></td></tr></table><code>}</code></dt><dd><p>subroutine argument list is split into three parts: <code>return</code> is the return arguments, that is optional; <code>params</code> are regular positional parameters, the length of the <code>params</code> list must equal to the amount of the formals in the function prototype; <code>hidden</code> are hidden parameters, that are inserted by abi to pass special arguments, like <code>this</code> pointer or a pointer to a structural value, for example.</p><p>The api processor, created by this module, will insert arg terms into sub in the following way:</p><ul><li>nth positional argument corresponds to nth arg term (counting from 0).</li><li>the last arg term corresponds to the return argument, if any;</li><li>all hidden arguments are put between the last positional and the return argument.</li></ul></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.insert_args" class="anchored"><td class="def field"><a href="#type-t.insert_args" class="anchor"></a><code>insert_args : <span><a href="../../bap/Bap/Std/index.html#type-sub">Bap.Std.sub</a> <a href="../../bap/Bap/Std/index.html#type-term">Bap.Std.term</a></span> <span>&#45;&gt;</span> <span><a href="../Bap_c_type/index.html#type-attr">Bap_c_type.attr</a> list</span> <span>&#45;&gt;</span> <a href="../Bap_c_type/index.html#type-proto">Bap_c_type.proto</a> <span>&#45;&gt;</span> <span><a href="index.html#type-args">args</a> option</span>;</code></td></tr><tr id="type-t.apply_attrs" class="anchored"><td class="def field"><a href="#type-t.apply_attrs" class="anchor"></a><code>apply_attrs : <span><a href="../Bap_c_type/index.html#type-attr">Bap_c_type.attr</a> list</span> <span>&#45;&gt;</span> <span><a href="../../bap/Bap/Std/index.html#type-sub">Bap.Std.sub</a> <a href="../../bap/Bap/Std/index.html#type-term">Bap.Std.term</a></span> <span>&#45;&gt;</span> <span><a href="../../bap/Bap/Std/index.html#type-sub">Bap.Std.sub</a> <a href="../../bap/Bap/Std/index.html#type-term">Bap.Std.term</a></span>;</code></td></tr></table><code>}</code></dt><dd><p>an abi processor. Each architecture registers its own abi processor, that is responsible for dispatching the processed subroutine between architecture specific abi processors.</p></dd></dl><dl><dt class="spec value" id="val-create_api_processor"><a href="#val-create_api_processor" class="anchor"></a><code><span class="keyword">val</span> create_api_processor : <a href="../Bap_c_size/index.html">Bap_c_size</a>.#base <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../bap-api/Bap_api/index.html#type-t">Bap_api.t</a></code></dt><dd><p><code>create_api_processor size t</code> packs an api processor. The processor will insert arg terms into each recognized subroutine, propagate some known C attributes into corresponding BIR attributes, annotate each inserted arg term with its corresponding C type and datum model, and annotate each regognized subroutine with its C prototype.</p><p>The api processor relies on an availability of a front end parser for C language.</p></dd></dl><dl><dt class="spec value" id="val-data"><a href="#val-data" class="anchor"></a><code><span class="keyword">val</span> data : <a href="../Bap_c_size/index.html">Bap_c_size</a>.#base <span>&#45;&gt;</span> <a href="../Bap_c_type/index.html#type-t">Bap_c_type.t</a> <span>&#45;&gt;</span> <a href="../Bap_c_data/index.html#type-t">Bap_c_data.t</a></code></dt><dd><p><code>data size t</code> creates an abstraction of data that is represented by type <code>t</code>. The <code>size</code> parameter defines a data model, e.g., sizes of primitive types, padding and alignment restrictions, etc.</p></dd></dl><dl><dt class="spec value" id="val-arg_intent"><a href="#val-arg_intent" class="anchor"></a><code><span class="keyword">val</span> arg_intent : <a href="../Bap_c_type/index.html#type-t">Bap_c_type.t</a> <span>&#45;&gt;</span> <a href="../../bap/Bap/Std/index.html#type-intent">Bap.Std.intent</a></code></dt><dd><p><code>arg_intent t</code> infers argument intention based on its C type. If an argument is passed by value, i.e., it is a c basic type, then it is an input argument. If an argument is a reference, but not a function, then it is input/output if any value, referenced by the argument is non-const. A reference to function always has the input intent. If an argyment is a structure or union, then it is input/output if any of its fields is input/output.</p></dd></dl><dl><dt class="spec module" id="module-Stack"><a href="#module-Stack" class="anchor"></a><code><span class="keyword">module</span> <a href="Stack/index.html">Stack</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An abstraction of a stack, commonly used in C compilers.</p></dd></dl></div></body></html>